[
  {
    "function_name": "cleanup_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "2349-2358",
    "snippet": "void\ncleanup_exit(int i)\n{\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\tleave_non_blocking();\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\tssh_kill_proxy_command();\n\t_exit(i);\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "extern int muxserver_sock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "i"
          ],
          "line": 2357
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "2349-2358",
          "snippet": "void\ncleanup_exit(int i)\n{\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\tleave_non_blocking();\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\tssh_kill_proxy_command();\n\t_exit(i);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ssh_kill_proxy_command",
          "args": [],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_kill_proxy_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "256-265",
          "snippet": "void\nssh_kill_proxy_command(void)\n{\n\t/*\n\t * Send SIGHUP to proxy command if used. We don't wait() in\n\t * case it hangs and instead rely on init to reap the child\n\t */\n\tif (proxy_command_pid > 1)\n\t\tkill(proxy_command_pid, SIGHUP);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static pid_t proxy_command_pid = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic pid_t proxy_command_pid = 0;\n\nvoid\nssh_kill_proxy_command(void)\n{\n\t/*\n\t * Send SIGHUP to proxy command if used. We don't wait() in\n\t * case it hangs and instead rely on init to reap the child\n\t */\n\tif (proxy_command_pid > 1)\n\t\tkill(proxy_command_pid, SIGHUP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "options.control_path"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leave_non_blocking",
          "args": [],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "leave_non_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "195-202",
          "snippet": "static void\nleave_non_blocking(void)\n{\n\tif (in_non_blocking_mode) {\n\t\tunset_nonblock(fileno(stdin));\n\t\tin_non_blocking_mode = 0;\n\t}\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int in_non_blocking_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int in_non_blocking_mode = 0;\n\nstatic void\nleave_non_blocking(void)\n{\n\tif (in_non_blocking_mode) {\n\t\tunset_nonblock(fileno(stdin));\n\t\tin_non_blocking_mode = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "leave_raw_mode",
          "args": [
            "options.request_tty == REQUEST_TTY_FORCE"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "leave_raw_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshtty.c",
          "lines": "56-66",
          "snippet": "void\nleave_raw_mode(int quiet)\n{\n\tif (!_in_raw_mode)\n\t\treturn;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 0;\n}",
          "includes": [
            "#include \"sshpty.h\"",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios _saved_tio;",
            "static int _in_raw_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sshpty.h\"\n#include <pwd.h>\n#include <termios.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct termios _saved_tio;\nstatic int _in_raw_mode = 0;\n\nvoid\nleave_raw_mode(int quiet)\n{\n\tif (!_in_raw_mode)\n\t\treturn;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nextern int muxserver_sock;\n\nvoid\ncleanup_exit(int i)\n{\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\tleave_non_blocking();\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\tssh_kill_proxy_command();\n\t_exit(i);\n}"
  },
  {
    "function_name": "client_stop_mux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "2333-2346",
    "snippet": "void\nclient_stop_mux(void)\n{\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\t/*\n\t * If we are in persist mode, or don't have a shell, signal that we\n\t * should close when all active channels are closed.\n\t */\n\tif (options.control_persist || no_shell_flag) {\n\t\tsession_closed = 1;\n\t\tsetproctitle(\"[stopped mux]\");\n\t}\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "extern int no_shell_flag;",
      "extern int muxserver_sock;",
      "static int session_closed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "setproctitle",
          "args": [
            "\"[stopped mux]\""
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "setproctitle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/setproctitle.c",
          "lines": "122-167",
          "snippet": "void\nsetproctitle(const char *fmt, ...)\n{\n#if SPT_TYPE != SPT_NONE\n\tva_list ap;\n\tchar buf[1024], ptitle[1024];\n\tsize_t len = 0;\n\tint r;\n\textern char *__progname;\n#if SPT_TYPE == SPT_PSTAT\n\tunion pstun pst;\n#endif\n\n#if SPT_TYPE == SPT_REUSEARGV\n\tif (argv_env_len <= 0)\n\t\treturn;\n#endif\n\n\tstrlcpy(buf, __progname, sizeof(buf));\n\n\tr = -1;\n\tva_start(ap, fmt);\n\tif (fmt != NULL) {\n\t\tlen = strlcat(buf, \": \", sizeof(buf));\n\t\tif (len < sizeof(buf))\n\t\t\tr = vsnprintf(buf + len, sizeof(buf) - len , fmt, ap);\n\t}\n\tva_end(ap);\n\tif (r == -1 || (size_t)r >= sizeof(buf) - len)\n\t\treturn;\n\tstrnvis(ptitle, buf, sizeof(ptitle),\n\t    VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL);\n\n#if SPT_TYPE == SPT_PSTAT\n\tpst.pst_command = ptitle;\n\tpstat(PSTAT_SETCMD, pst, strlen(ptitle), 0, 0);\n#elif SPT_TYPE == SPT_REUSEARGV\n/*\tdebug(\"setproctitle: copy \\\"%s\\\" into len %d\",\n\t    buf, argv_env_len); */\n\tlen = strlcpy(argv_start, ptitle, argv_env_len);\n\tfor(; len < argv_env_len; len++)\n\t\targv_start[len] = SPT_PADCHAR;\n#endif\n\n#endif /* SPT_NONE */\n}",
          "includes": [
            "#include <vis.h>",
            "#include <string.h>",
            "#include <sys/pstat.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SPT_REUSEARGV\t2\t/* cover argv with title information */",
            "#define SPT_PSTAT\t1\t/* use pstat(PSTAT_SETCMD, ...) */",
            "#define SPT_NONE\t0\t/* don't use it at all */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vis.h>\n#include <string.h>\n#include <sys/pstat.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\n#define SPT_REUSEARGV\t2\t/* cover argv with title information */\n#define SPT_PSTAT\t1\t/* use pstat(PSTAT_SETCMD, ...) */\n#define SPT_NONE\t0\t/* don't use it at all */\n\nvoid\nsetproctitle(const char *fmt, ...)\n{\n#if SPT_TYPE != SPT_NONE\n\tva_list ap;\n\tchar buf[1024], ptitle[1024];\n\tsize_t len = 0;\n\tint r;\n\textern char *__progname;\n#if SPT_TYPE == SPT_PSTAT\n\tunion pstun pst;\n#endif\n\n#if SPT_TYPE == SPT_REUSEARGV\n\tif (argv_env_len <= 0)\n\t\treturn;\n#endif\n\n\tstrlcpy(buf, __progname, sizeof(buf));\n\n\tr = -1;\n\tva_start(ap, fmt);\n\tif (fmt != NULL) {\n\t\tlen = strlcat(buf, \": \", sizeof(buf));\n\t\tif (len < sizeof(buf))\n\t\t\tr = vsnprintf(buf + len, sizeof(buf) - len , fmt, ap);\n\t}\n\tva_end(ap);\n\tif (r == -1 || (size_t)r >= sizeof(buf) - len)\n\t\treturn;\n\tstrnvis(ptitle, buf, sizeof(ptitle),\n\t    VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL);\n\n#if SPT_TYPE == SPT_PSTAT\n\tpst.pst_command = ptitle;\n\tpstat(PSTAT_SETCMD, pst, strlen(ptitle), 0, 0);\n#elif SPT_TYPE == SPT_REUSEARGV\n/*\tdebug(\"setproctitle: copy \\\"%s\\\" into len %d\",\n\t    buf, argv_env_len); */\n\tlen = strlcpy(argv_start, ptitle, argv_env_len);\n\tfor(; len < argv_env_len; len++)\n\t\targv_start[len] = SPT_PADCHAR;\n#endif\n\n#endif /* SPT_NONE */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "options.control_path"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nextern int no_shell_flag;\nextern int muxserver_sock;\nstatic int session_closed;\n\nvoid\nclient_stop_mux(void)\n{\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\t/*\n\t * If we are in persist mode, or don't have a shell, signal that we\n\t * should close when all active channels are closed.\n\t */\n\tif (options.control_persist || no_shell_flag) {\n\t\tsession_closed = 1;\n\t\tsetproctitle(\"[stopped mux]\");\n\t}\n}"
  },
  {
    "function_name": "client_init_dispatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "2307-2331",
    "snippet": "static void\nclient_init_dispatch(void)\n{\n\tdispatch_init(&dispatch_protocol_error);\n\n\tdispatch_set(SSH2_MSG_CHANNEL_CLOSE, &channel_input_oclose);\n\tdispatch_set(SSH2_MSG_CHANNEL_DATA, &channel_input_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_EOF, &channel_input_ieof);\n\tdispatch_set(SSH2_MSG_CHANNEL_EXTENDED_DATA, &channel_input_extended_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN, &client_input_channel_open);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, &channel_input_open_confirmation);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_FAILURE, &channel_input_open_failure);\n\tdispatch_set(SSH2_MSG_CHANNEL_REQUEST, &client_input_channel_req);\n\tdispatch_set(SSH2_MSG_CHANNEL_WINDOW_ADJUST, &channel_input_window_adjust);\n\tdispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &channel_input_status_confirm);\n\tdispatch_set(SSH2_MSG_CHANNEL_FAILURE, &channel_input_status_confirm);\n\tdispatch_set(SSH2_MSG_GLOBAL_REQUEST, &client_input_global_request);\n\n\t/* rekeying */\n\tdispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);\n\n\t/* global request reply messages */\n\tdispatch_set(SSH2_MSG_REQUEST_FAILURE, &client_global_request_reply);\n\tdispatch_set(SSH2_MSG_REQUEST_SUCCESS, &client_global_request_reply);\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void client_init_dispatch(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_REQUEST_SUCCESS",
            "&client_global_request_reply"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_REQUEST_FAILURE",
            "&client_global_request_reply"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_KEXINIT",
            "&kex_input_kexinit"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_GLOBAL_REQUEST",
            "&client_input_global_request"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_FAILURE",
            "&channel_input_status_confirm"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_SUCCESS",
            "&channel_input_status_confirm"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_WINDOW_ADJUST",
            "&channel_input_window_adjust"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_REQUEST",
            "&client_input_channel_req"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_OPEN_FAILURE",
            "&channel_input_open_failure"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_OPEN_CONFIRMATION",
            "&channel_input_open_confirmation"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_OPEN",
            "&client_input_channel_open"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_EXTENDED_DATA",
            "&channel_input_extended_data"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_EOF",
            "&channel_input_ieof"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_DATA",
            "&channel_input_data"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_set",
          "args": [
            "SSH2_MSG_CHANNEL_CLOSE",
            "&channel_input_oclose"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_init",
          "args": [
            "&dispatch_protocol_error"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void client_init_dispatch(void);\n\nstatic void\nclient_init_dispatch(void)\n{\n\tdispatch_init(&dispatch_protocol_error);\n\n\tdispatch_set(SSH2_MSG_CHANNEL_CLOSE, &channel_input_oclose);\n\tdispatch_set(SSH2_MSG_CHANNEL_DATA, &channel_input_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_EOF, &channel_input_ieof);\n\tdispatch_set(SSH2_MSG_CHANNEL_EXTENDED_DATA, &channel_input_extended_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN, &client_input_channel_open);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, &channel_input_open_confirmation);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_FAILURE, &channel_input_open_failure);\n\tdispatch_set(SSH2_MSG_CHANNEL_REQUEST, &client_input_channel_req);\n\tdispatch_set(SSH2_MSG_CHANNEL_WINDOW_ADJUST, &channel_input_window_adjust);\n\tdispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &channel_input_status_confirm);\n\tdispatch_set(SSH2_MSG_CHANNEL_FAILURE, &channel_input_status_confirm);\n\tdispatch_set(SSH2_MSG_GLOBAL_REQUEST, &client_input_global_request);\n\n\t/* rekeying */\n\tdispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);\n\n\t/* global request reply messages */\n\tdispatch_set(SSH2_MSG_REQUEST_FAILURE, &client_global_request_reply);\n\tdispatch_set(SSH2_MSG_REQUEST_SUCCESS, &client_global_request_reply);\n}"
  },
  {
    "function_name": "client_session2_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "2193-2305",
    "snippet": "void\nclient_session2_setup(struct ssh *ssh, int id, int want_tty, int want_subsystem,\n    const char *term, struct termios *tiop, int in_fd, struct sshbuf *cmd,\n    char **env)\n{\n\tint i, j, matched, len;\n\tchar *name, *val;\n\tChannel *c = NULL;\n\n\tdebug2(\"%s: id %d\", __func__, id);\n\n\tif ((c = channel_lookup(ssh, id)) == NULL)\n\t\tfatal(\"%s: channel %d: unknown channel\", __func__, id);\n\n\tpacket_set_interactive(want_tty,\n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\n\tif (want_tty) {\n\t\tstruct winsize ws;\n\n\t\t/* Store window size in the packet. */\n\t\tif (ioctl(in_fd, TIOCGWINSZ, &ws) < 0)\n\t\t\tmemset(&ws, 0, sizeof(ws));\n\n\t\tchannel_request_start(ssh, id, \"pty-req\", 1);\n\t\tclient_expect_confirm(ssh, id, \"PTY allocation\", CONFIRM_TTY);\n\t\tpacket_put_cstring(term != NULL ? term : \"\");\n\t\tpacket_put_int((u_int)ws.ws_col);\n\t\tpacket_put_int((u_int)ws.ws_row);\n\t\tpacket_put_int((u_int)ws.ws_xpixel);\n\t\tpacket_put_int((u_int)ws.ws_ypixel);\n\t\tif (tiop == NULL)\n\t\t\ttiop = get_saved_tio();\n\t\tssh_tty_make_modes(ssh, -1, tiop);\n\t\tpacket_send();\n\t\t/* XXX wait for reply */\n\t\tc->client_tty = 1;\n\t}\n\n\t/* Transfer any environment variables from client to server */\n\tif (options.num_send_env != 0 && env != NULL) {\n\t\tdebug(\"Sending environment.\");\n\t\tfor (i = 0; env[i] != NULL; i++) {\n\t\t\t/* Split */\n\t\t\tname = xstrdup(env[i]);\n\t\t\tif ((val = strchr(name, '=')) == NULL) {\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*val++ = '\\0';\n\n\t\t\tmatched = 0;\n\t\t\tfor (j = 0; j < options.num_send_env; j++) {\n\t\t\t\tif (match_pattern(name, options.send_env[j])) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!matched) {\n\t\t\t\tdebug3(\"Ignored env %s\", name);\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdebug(\"Sending env %s = %s\", name, val);\n\t\t\tchannel_request_start(ssh, id, \"env\", 0);\n\t\t\tpacket_put_cstring(name);\n\t\t\tpacket_put_cstring(val);\n\t\t\tpacket_send();\n\t\t\tfree(name);\n\t\t}\n\t}\n\tfor (i = 0; i < options.num_setenv; i++) {\n\t\t/* Split */\n\t\tname = xstrdup(options.setenv[i]);\n\t\tif ((val = strchr(name, '=')) == NULL) {\n\t\t\tfree(name);\n\t\t\tcontinue;\n\t\t}\n\t\t*val++ = '\\0';\n\n\t\tdebug(\"Setting env %s = %s\", name, val);\n\t\tchannel_request_start(ssh, id, \"env\", 0);\n\t\tpacket_put_cstring(name);\n\t\tpacket_put_cstring(val);\n\t\tpacket_send();\n\t\tfree(name);\n\t}\n\n\tlen = sshbuf_len(cmd);\n\tif (len > 0) {\n\t\tif (len > 900)\n\t\t\tlen = 900;\n\t\tif (want_subsystem) {\n\t\t\tdebug(\"Sending subsystem: %.*s\",\n\t\t\t    len, (const u_char*)sshbuf_ptr(cmd));\n\t\t\tchannel_request_start(ssh, id, \"subsystem\", 1);\n\t\t\tclient_expect_confirm(ssh, id, \"subsystem\",\n\t\t\t    CONFIRM_CLOSE);\n\t\t} else {\n\t\t\tdebug(\"Sending command: %.*s\",\n\t\t\t    len, (const u_char*)sshbuf_ptr(cmd));\n\t\t\tchannel_request_start(ssh, id, \"exec\", 1);\n\t\t\tclient_expect_confirm(ssh, id, \"exec\", CONFIRM_CLOSE);\n\t\t}\n\t\tpacket_put_string(sshbuf_ptr(cmd), sshbuf_len(cmd));\n\t\tpacket_send();\n\t} else {\n\t\tchannel_request_start(ssh, id, \"shell\", 1);\n\t\tclient_expect_confirm(ssh, id, \"shell\", CONFIRM_CLOSE);\n\t\tpacket_send();\n\t}\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "void ssh_process_session2_setup(int, int, int, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client_expect_confirm",
          "args": [
            "ssh",
            "id",
            "\"shell\"",
            "CONFIRM_CLOSE"
          ],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "client_expect_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "734-745",
          "snippet": "void\nclient_expect_confirm(struct ssh *ssh, int id, const char *request,\n    enum confirm_action action)\n{\n\tstruct channel_reply_ctx *cr = xcalloc(1, sizeof(*cr));\n\n\tcr->request_type = request;\n\tcr->action = action;\n\n\tchannel_register_status_confirm(ssh, id, client_status_confirm,\n\t    client_abandon_status_confirm, cr);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclient_expect_confirm(struct ssh *ssh, int id, const char *request,\n    enum confirm_action action)\n{\n\tstruct channel_reply_ctx *cr = xcalloc(1, sizeof(*cr));\n\n\tcr->request_type = request;\n\tcr->action = action;\n\n\tchannel_register_status_confirm(ssh, id, client_status_confirm,\n\t    client_abandon_status_confirm, cr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_request_start",
          "args": [
            "ssh",
            "id",
            "\"shell\"",
            "1"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "channel_request_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "932-952",
          "snippet": "void\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: unknown channel id\", __func__, id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: unknown channel id\", __func__, id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_string",
          "args": [
            "sshbuf_ptr(cmd)",
            "sshbuf_len(cmd)"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "cmd"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "cmd"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Sending command: %.*s\"",
            "len",
            "(const u_char*)sshbuf_ptr(cmd)"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "val"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "name"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name",
            "'='"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "options.setenv[i]"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "val"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "name"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_pattern",
          "args": [
            "name",
            "options.send_env[j]"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "56-112",
          "snippet": "int\nmatch_pattern(const char *s, const char *pattern)\n{\n\tfor (;;) {\n\t\t/* If at end of pattern, accept if also at end of string. */\n\t\tif (!*pattern)\n\t\t\treturn !*s;\n\n\t\tif (*pattern == '*') {\n\t\t\t/* Skip the asterisk. */\n\t\t\tpattern++;\n\n\t\t\t/* If at end of pattern, accept immediately. */\n\t\t\tif (!*pattern)\n\t\t\t\treturn 1;\n\n\t\t\t/* If next character in pattern is known, optimize. */\n\t\t\tif (*pattern != '?' && *pattern != '*') {\n\t\t\t\t/*\n\t\t\t\t * Look instances of the next character in\n\t\t\t\t * pattern, and try to match starting from\n\t\t\t\t * those.\n\t\t\t\t */\n\t\t\t\tfor (; *s; s++)\n\t\t\t\t\tif (*s == *pattern &&\n\t\t\t\t\t    match_pattern(s + 1, pattern + 1))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t/* Failed. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Move ahead one character at a time and try to\n\t\t\t * match at each position.\n\t\t\t */\n\t\t\tfor (; *s; s++)\n\t\t\t\tif (match_pattern(s, pattern))\n\t\t\t\t\treturn 1;\n\t\t\t/* Failed. */\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * There must be at least one more character in the string.\n\t\t * If we are at the end, fail.\n\t\t */\n\t\tif (!*s)\n\t\t\treturn 0;\n\n\t\t/* Check if the next character of the string is acceptable. */\n\t\tif (*pattern != '?' && *pattern != *s)\n\t\t\treturn 0;\n\n\t\t/* Move to the next character, both in string and in pattern. */\n\t\ts++;\n\t\tpattern++;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern(const char *s, const char *pattern)\n{\n\tfor (;;) {\n\t\t/* If at end of pattern, accept if also at end of string. */\n\t\tif (!*pattern)\n\t\t\treturn !*s;\n\n\t\tif (*pattern == '*') {\n\t\t\t/* Skip the asterisk. */\n\t\t\tpattern++;\n\n\t\t\t/* If at end of pattern, accept immediately. */\n\t\t\tif (!*pattern)\n\t\t\t\treturn 1;\n\n\t\t\t/* If next character in pattern is known, optimize. */\n\t\t\tif (*pattern != '?' && *pattern != '*') {\n\t\t\t\t/*\n\t\t\t\t * Look instances of the next character in\n\t\t\t\t * pattern, and try to match starting from\n\t\t\t\t * those.\n\t\t\t\t */\n\t\t\t\tfor (; *s; s++)\n\t\t\t\t\tif (*s == *pattern &&\n\t\t\t\t\t    match_pattern(s + 1, pattern + 1))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t/* Failed. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Move ahead one character at a time and try to\n\t\t\t * match at each position.\n\t\t\t */\n\t\t\tfor (; *s; s++)\n\t\t\t\tif (match_pattern(s, pattern))\n\t\t\t\t\treturn 1;\n\t\t\t/* Failed. */\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * There must be at least one more character in the string.\n\t\t * If we are at the end, fail.\n\t\t */\n\t\tif (!*s)\n\t\t\treturn 0;\n\n\t\t/* Check if the next character of the string is acceptable. */\n\t\tif (*pattern != '?' && *pattern != *s)\n\t\t\treturn 0;\n\n\t\t/* Move to the next character, both in string and in pattern. */\n\t\ts++;\n\t\tpattern++;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_tty_make_modes",
          "args": [
            "ssh",
            "-1",
            "tiop"
          ],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_tty_make_modes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ttymodes.c",
          "lines": "278-336",
          "snippet": "void\nssh_tty_make_modes(struct ssh *ssh, int fd, struct termios *tiop)\n{\n\tstruct termios tio;\n\tstruct sshbuf *buf;\n\tint r, ibaud, obaud;\n\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tif (tiop == NULL) {\n\t\tif (fd == -1) {\n\t\t\tdebug(\"%s: no fd or tio\", __func__);\n\t\t\tgoto end;\n\t\t}\n\t\tif (tcgetattr(fd, &tio) == -1) {\n\t\t\tlogit(\"tcgetattr: %.100s\", strerror(errno));\n\t\t\tgoto end;\n\t\t}\n\t} else\n\t\ttio = *tiop;\n\n\t/* Store input and output baud rates. */\n\tobaud = speed_to_baud(cfgetospeed(&tio));\n\tibaud = speed_to_baud(cfgetispeed(&tio));\n\tif ((r = sshbuf_put_u8(buf, TTY_OP_OSPEED)) != 0 ||\n\t    (r = sshbuf_put_u32(buf, obaud)) != 0 ||\n\t    (r = sshbuf_put_u8(buf, TTY_OP_ISPEED)) != 0 ||\n\t    (r = sshbuf_put_u32(buf, ibaud)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t/* Store values of mode flags. */\n#define TTYCHAR(NAME, OP) \\\n\tif ((r = sshbuf_put_u8(buf, OP)) != 0 || \\\n\t    (r = sshbuf_put_u32(buf, \\\n\t    special_char_encode(tio.c_cc[NAME]))) != 0) \\\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r)); \\\n\n#define SSH_TTYMODE_IUTF8 42  /* for SSH_BUG_UTF8TTYMODE */\n\n#define TTYMODE(NAME, FIELD, OP) \\\n\tif (OP == SSH_TTYMODE_IUTF8 && (datafellows & SSH_BUG_UTF8TTYMODE)) { \\\n\t\tdebug3(\"%s: SSH_BUG_UTF8TTYMODE\", __func__); \\\n\t} else if ((r = sshbuf_put_u8(buf, OP)) != 0 || \\\n\t    (r = sshbuf_put_u32(buf, ((tio.FIELD & NAME) != 0))) != 0) \\\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r)); \\\n\n#include \"ttymodes.h\"\n\n#undef TTYCHAR\n#undef TTYMODE\n\nend:\n\t/* Mark end of mode data. */\n\tif ((r = sshbuf_put_u8(buf, TTY_OP_END)) != 0 ||\n\t    (r = sshpkt_put_stringb(ssh, buf)) != 0)\n\t\tfatal(\"%s: packet error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(buf);\n}",
          "includes": [
            "#include \"ttymodes.h\"",
            "#include \"ttymodes.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"compat.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include <stdarg.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SSH_TTYMODE_IUTF8 42  /* for SSH_BUG_UTF8TTYMODE */",
            "#define TTY_OP_OSPEED\t129",
            "#define TTY_OP_ISPEED\t128",
            "#define TTY_OP_END\t\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ttymodes.h\"\n#include \"ttymodes.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"compat.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include <stdarg.h>\n#include <termios.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SSH_TTYMODE_IUTF8 42  /* for SSH_BUG_UTF8TTYMODE */\n#define TTY_OP_OSPEED\t129\n#define TTY_OP_ISPEED\t128\n#define TTY_OP_END\t\t0\n\nvoid\nssh_tty_make_modes(struct ssh *ssh, int fd, struct termios *tiop)\n{\n\tstruct termios tio;\n\tstruct sshbuf *buf;\n\tint r, ibaud, obaud;\n\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tif (tiop == NULL) {\n\t\tif (fd == -1) {\n\t\t\tdebug(\"%s: no fd or tio\", __func__);\n\t\t\tgoto end;\n\t\t}\n\t\tif (tcgetattr(fd, &tio) == -1) {\n\t\t\tlogit(\"tcgetattr: %.100s\", strerror(errno));\n\t\t\tgoto end;\n\t\t}\n\t} else\n\t\ttio = *tiop;\n\n\t/* Store input and output baud rates. */\n\tobaud = speed_to_baud(cfgetospeed(&tio));\n\tibaud = speed_to_baud(cfgetispeed(&tio));\n\tif ((r = sshbuf_put_u8(buf, TTY_OP_OSPEED)) != 0 ||\n\t    (r = sshbuf_put_u32(buf, obaud)) != 0 ||\n\t    (r = sshbuf_put_u8(buf, TTY_OP_ISPEED)) != 0 ||\n\t    (r = sshbuf_put_u32(buf, ibaud)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t/* Store values of mode flags. */\n#define TTYCHAR(NAME, OP) \\\n\tif ((r = sshbuf_put_u8(buf, OP)) != 0 || \\\n\t    (r = sshbuf_put_u32(buf, \\\n\t    special_char_encode(tio.c_cc[NAME]))) != 0) \\\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r)); \\\n\n#define SSH_TTYMODE_IUTF8 42  /* for SSH_BUG_UTF8TTYMODE */\n\n#define TTYMODE(NAME, FIELD, OP) \\\n\tif (OP == SSH_TTYMODE_IUTF8 && (datafellows & SSH_BUG_UTF8TTYMODE)) { \\\n\t\tdebug3(\"%s: SSH_BUG_UTF8TTYMODE\", __func__); \\\n\t} else if ((r = sshbuf_put_u8(buf, OP)) != 0 || \\\n\t    (r = sshbuf_put_u32(buf, ((tio.FIELD & NAME) != 0))) != 0) \\\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r)); \\\n\n#include \"ttymodes.h\"\n\n#undef TTYCHAR\n#undef TTYMODE\n\nend:\n\t/* Mark end of mode data. */\n\tif ((r = sshbuf_put_u8(buf, TTY_OP_END)) != 0 ||\n\t    (r = sshpkt_put_stringb(ssh, buf)) != 0)\n\t\tfatal(\"%s: packet error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_saved_tio",
          "args": [],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "get_saved_tio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshtty.c",
          "lines": "50-54",
          "snippet": "struct termios *\nget_saved_tio(void)\n{\n\treturn _in_raw_mode ? &_saved_tio : NULL;\n}",
          "includes": [
            "#include \"sshpty.h\"",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios _saved_tio;",
            "static int _in_raw_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sshpty.h\"\n#include <pwd.h>\n#include <termios.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct termios _saved_tio;\nstatic int _in_raw_mode = 0;\n\nstruct termios *\nget_saved_tio(void)\n{\n\treturn _in_raw_mode ? &_saved_tio : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "(u_int)ws.ws_ypixel"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "(u_int)ws.ws_xpixel"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "(u_int)ws.ws_row"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "(u_int)ws.ws_col"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "term != NULL ? term : \"\""
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ws",
            "0",
            "sizeof(ws)"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "in_fd",
            "TIOCGWINSZ",
            "&ws"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_set_interactive",
          "args": [
            "want_tty",
            "options.ip_qos_interactive",
            "options.ip_qos_bulk"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %d: unknown channel\"",
            "__func__",
            "id"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_lookup",
          "args": [
            "ssh",
            "id"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "channel_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "279-302",
          "snippet": "Channel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: id %d\"",
            "__func__",
            "id"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nvoid ssh_process_session2_setup(int, int, int, struct sshbuf *);\n\nvoid\nclient_session2_setup(struct ssh *ssh, int id, int want_tty, int want_subsystem,\n    const char *term, struct termios *tiop, int in_fd, struct sshbuf *cmd,\n    char **env)\n{\n\tint i, j, matched, len;\n\tchar *name, *val;\n\tChannel *c = NULL;\n\n\tdebug2(\"%s: id %d\", __func__, id);\n\n\tif ((c = channel_lookup(ssh, id)) == NULL)\n\t\tfatal(\"%s: channel %d: unknown channel\", __func__, id);\n\n\tpacket_set_interactive(want_tty,\n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\n\tif (want_tty) {\n\t\tstruct winsize ws;\n\n\t\t/* Store window size in the packet. */\n\t\tif (ioctl(in_fd, TIOCGWINSZ, &ws) < 0)\n\t\t\tmemset(&ws, 0, sizeof(ws));\n\n\t\tchannel_request_start(ssh, id, \"pty-req\", 1);\n\t\tclient_expect_confirm(ssh, id, \"PTY allocation\", CONFIRM_TTY);\n\t\tpacket_put_cstring(term != NULL ? term : \"\");\n\t\tpacket_put_int((u_int)ws.ws_col);\n\t\tpacket_put_int((u_int)ws.ws_row);\n\t\tpacket_put_int((u_int)ws.ws_xpixel);\n\t\tpacket_put_int((u_int)ws.ws_ypixel);\n\t\tif (tiop == NULL)\n\t\t\ttiop = get_saved_tio();\n\t\tssh_tty_make_modes(ssh, -1, tiop);\n\t\tpacket_send();\n\t\t/* XXX wait for reply */\n\t\tc->client_tty = 1;\n\t}\n\n\t/* Transfer any environment variables from client to server */\n\tif (options.num_send_env != 0 && env != NULL) {\n\t\tdebug(\"Sending environment.\");\n\t\tfor (i = 0; env[i] != NULL; i++) {\n\t\t\t/* Split */\n\t\t\tname = xstrdup(env[i]);\n\t\t\tif ((val = strchr(name, '=')) == NULL) {\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*val++ = '\\0';\n\n\t\t\tmatched = 0;\n\t\t\tfor (j = 0; j < options.num_send_env; j++) {\n\t\t\t\tif (match_pattern(name, options.send_env[j])) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!matched) {\n\t\t\t\tdebug3(\"Ignored env %s\", name);\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdebug(\"Sending env %s = %s\", name, val);\n\t\t\tchannel_request_start(ssh, id, \"env\", 0);\n\t\t\tpacket_put_cstring(name);\n\t\t\tpacket_put_cstring(val);\n\t\t\tpacket_send();\n\t\t\tfree(name);\n\t\t}\n\t}\n\tfor (i = 0; i < options.num_setenv; i++) {\n\t\t/* Split */\n\t\tname = xstrdup(options.setenv[i]);\n\t\tif ((val = strchr(name, '=')) == NULL) {\n\t\t\tfree(name);\n\t\t\tcontinue;\n\t\t}\n\t\t*val++ = '\\0';\n\n\t\tdebug(\"Setting env %s = %s\", name, val);\n\t\tchannel_request_start(ssh, id, \"env\", 0);\n\t\tpacket_put_cstring(name);\n\t\tpacket_put_cstring(val);\n\t\tpacket_send();\n\t\tfree(name);\n\t}\n\n\tlen = sshbuf_len(cmd);\n\tif (len > 0) {\n\t\tif (len > 900)\n\t\t\tlen = 900;\n\t\tif (want_subsystem) {\n\t\t\tdebug(\"Sending subsystem: %.*s\",\n\t\t\t    len, (const u_char*)sshbuf_ptr(cmd));\n\t\t\tchannel_request_start(ssh, id, \"subsystem\", 1);\n\t\t\tclient_expect_confirm(ssh, id, \"subsystem\",\n\t\t\t    CONFIRM_CLOSE);\n\t\t} else {\n\t\t\tdebug(\"Sending command: %.*s\",\n\t\t\t    len, (const u_char*)sshbuf_ptr(cmd));\n\t\t\tchannel_request_start(ssh, id, \"exec\", 1);\n\t\t\tclient_expect_confirm(ssh, id, \"exec\", CONFIRM_CLOSE);\n\t\t}\n\t\tpacket_put_string(sshbuf_ptr(cmd), sshbuf_len(cmd));\n\t\tpacket_send();\n\t} else {\n\t\tchannel_request_start(ssh, id, \"shell\", 1);\n\t\tclient_expect_confirm(ssh, id, \"shell\", CONFIRM_CLOSE);\n\t\tpacket_send();\n\t}\n}"
  },
  {
    "function_name": "client_input_global_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "2170-2191",
    "snippet": "static int\nclient_input_global_request(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tchar *rtype;\n\tint want_reply;\n\tint success = 0;\n\n\trtype = packet_get_cstring(NULL);\n\twant_reply = packet_get_char();\n\tdebug(\"client_input_global_request: rtype %s want_reply %d\",\n\t    rtype, want_reply);\n\tif (strcmp(rtype, \"hostkeys-00@openssh.com\") == 0)\n\t\tsuccess = client_input_hostkeys();\n\tif (want_reply) {\n\t\tpacket_start(success ?\n\t\t    SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t}\n\tfree(rtype);\n\treturn 0;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rtype"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_write_wait",
          "args": [],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "packet_write_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "271-278",
          "snippet": "void\npacket_write_wait(void)\n{\n\tint r;\n\n\tif ((r = ssh_packet_write_wait(active_state)) != 0)\n\t\tsshpkt_fatal(active_state, __func__, r);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_write_wait(void)\n{\n\tint r;\n\n\tif ((r = ssh_packet_write_wait(active_state)) != 0)\n\t\tsshpkt_fatal(active_state, __func__, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_start",
          "args": [
            "success ?\n\t\t    SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client_input_hostkeys",
          "args": [],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "client_input_hostkeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "2020-2168",
          "snippet": "static int\nclient_input_hostkeys(void)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tconst u_char *blob = NULL;\n\tsize_t i, len = 0;\n\tstruct sshbuf *buf = NULL;\n\tstruct sshkey *key = NULL, **tmp;\n\tint r;\n\tchar *fp;\n\tstatic int hostkeys_seen = 0; /* XXX use struct ssh */\n\textern struct sockaddr_storage hostaddr; /* XXX from ssh.c */\n\tstruct hostkeys_update_ctx *ctx = NULL;\n\n\tif (hostkeys_seen)\n\t\tfatal(\"%s: server already sent hostkeys\", __func__);\n\tif (options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK &&\n\t    options.batch_mode)\n\t\treturn 1; /* won't ask in batchmode, so don't even try */\n\tif (!options.update_hostkeys || options.num_user_hostfiles <= 0)\n\t\treturn 1;\n\n\tctx = xcalloc(1, sizeof(*ctx));\n\twhile (ssh_packet_remaining(ssh) > 0) {\n\t\tsshkey_free(key);\n\t\tkey = NULL;\n\t\tif ((r = sshpkt_get_string_direct(ssh, &blob, &len)) != 0) {\n\t\t\terror(\"%s: couldn't parse message: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_from_blob(blob, len, &key)) != 0) {\n\t\t\terror(\"%s: parse key: %s\", __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tfp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\tdebug3(\"%s: received %s key %s\", __func__,\n\t\t    sshkey_type(key), fp);\n\t\tfree(fp);\n\n\t\tif (!key_accepted_by_hostkeyalgs(key)) {\n\t\t\tdebug3(\"%s: %s key not permitted by HostkeyAlgorithms\",\n\t\t\t    __func__, sshkey_ssh_name(key));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Skip certs */\n\t\tif (sshkey_is_cert(key)) {\n\t\t\tdebug3(\"%s: %s key is a certificate; skipping\",\n\t\t\t    __func__, sshkey_ssh_name(key));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Ensure keys are unique */\n\t\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\t\tif (sshkey_equal(key, ctx->keys[i])) {\n\t\t\t\terror(\"%s: received duplicated %s host key\",\n\t\t\t\t    __func__, sshkey_ssh_name(key));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* Key is good, record it */\n\t\tif ((tmp = recallocarray(ctx->keys, ctx->nkeys, ctx->nkeys + 1,\n\t\t    sizeof(*ctx->keys))) == NULL)\n\t\t\tfatal(\"%s: recallocarray failed nkeys = %zu\",\n\t\t\t    __func__, ctx->nkeys);\n\t\tctx->keys = tmp;\n\t\tctx->keys[ctx->nkeys++] = key;\n\t\tkey = NULL;\n\t}\n\n\tif (ctx->nkeys == 0) {\n\t\tdebug(\"%s: server sent no hostkeys\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((ctx->keys_seen = calloc(ctx->nkeys,\n\t    sizeof(*ctx->keys_seen))) == NULL)\n\t\tfatal(\"%s: calloc failed\", __func__);\n\n\tget_hostfile_hostname_ipaddr(host,\n\t    options.check_host_ip ? (struct sockaddr *)&hostaddr : NULL,\n\t    options.port, &ctx->host_str,\n\t    options.check_host_ip ? &ctx->ip_str : NULL);\n\n\t/* Find which keys we already know about. */\n\tif ((r = hostkeys_foreach(options.user_hostfiles[0], hostkeys_find,\n\t    ctx, ctx->host_str, ctx->ip_str,\n\t    HKF_WANT_PARSE_KEY|HKF_WANT_MATCH)) != 0) {\n\t\terror(\"%s: hostkeys_foreach failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\n\t/* Figure out if we have any new keys to add */\n\tctx->nnew = 0;\n\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\tif (!ctx->keys_seen[i])\n\t\t\tctx->nnew++;\n\t}\n\n\tdebug3(\"%s: %zu keys from server: %zu new, %zu retained. %zu to remove\",\n\t    __func__, ctx->nkeys, ctx->nnew, ctx->nkeys - ctx->nnew, ctx->nold);\n\n\tif (ctx->nnew == 0 && ctx->nold != 0) {\n\t\t/* We have some keys to remove. Just do it. */\n\t\tupdate_known_hosts(ctx);\n\t} else if (ctx->nnew != 0) {\n\t\t/*\n\t\t * We have received hitherto-unseen keys from the server.\n\t\t * Ask the server to confirm ownership of the private halves.\n\t\t */\n\t\tdebug3(\"%s: asking server to prove ownership for %zu keys\",\n\t\t    __func__, ctx->nnew);\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"hostkeys-prove-00@openssh.com\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0) /* bool: want reply */\n\t\t\tfatal(\"%s: cannot prepare packet: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tif ((buf = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new\", __func__);\n\t\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\t\tif (ctx->keys_seen[i])\n\t\t\t\tcontinue;\n\t\t\tsshbuf_reset(buf);\n\t\t\tif ((r = sshkey_putb(ctx->keys[i], buf)) != 0)\n\t\t\t\tfatal(\"%s: sshkey_putb: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif ((r = sshpkt_put_stringb(ssh, buf)) != 0)\n\t\t\t\tfatal(\"%s: sshpkt_put_string: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\tif ((r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal(\"%s: sshpkt_send: %s\", __func__, ssh_err(r));\n\t\tclient_register_global_confirm(\n\t\t    client_global_hostkeys_private_confirm, ctx);\n\t\tctx = NULL;  /* will be freed in callback */\n\t}\n\n\t/* Success */\n out:\n\thostkeys_update_ctx_free(ctx);\n\tsshkey_free(key);\n\tsshbuf_free(buf);\n\t/*\n\t * NB. Return success for all cases. The server doesn't need to know\n\t * what the client does with its hosts file.\n\t */\n\treturn 1;\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "extern char *host;",
            "void ssh_process_session2_setup(int, int, int, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nextern char *host;\nvoid ssh_process_session2_setup(int, int, int, struct sshbuf *);\n\nstatic int\nclient_input_hostkeys(void)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tconst u_char *blob = NULL;\n\tsize_t i, len = 0;\n\tstruct sshbuf *buf = NULL;\n\tstruct sshkey *key = NULL, **tmp;\n\tint r;\n\tchar *fp;\n\tstatic int hostkeys_seen = 0; /* XXX use struct ssh */\n\textern struct sockaddr_storage hostaddr; /* XXX from ssh.c */\n\tstruct hostkeys_update_ctx *ctx = NULL;\n\n\tif (hostkeys_seen)\n\t\tfatal(\"%s: server already sent hostkeys\", __func__);\n\tif (options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK &&\n\t    options.batch_mode)\n\t\treturn 1; /* won't ask in batchmode, so don't even try */\n\tif (!options.update_hostkeys || options.num_user_hostfiles <= 0)\n\t\treturn 1;\n\n\tctx = xcalloc(1, sizeof(*ctx));\n\twhile (ssh_packet_remaining(ssh) > 0) {\n\t\tsshkey_free(key);\n\t\tkey = NULL;\n\t\tif ((r = sshpkt_get_string_direct(ssh, &blob, &len)) != 0) {\n\t\t\terror(\"%s: couldn't parse message: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_from_blob(blob, len, &key)) != 0) {\n\t\t\terror(\"%s: parse key: %s\", __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tfp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\tdebug3(\"%s: received %s key %s\", __func__,\n\t\t    sshkey_type(key), fp);\n\t\tfree(fp);\n\n\t\tif (!key_accepted_by_hostkeyalgs(key)) {\n\t\t\tdebug3(\"%s: %s key not permitted by HostkeyAlgorithms\",\n\t\t\t    __func__, sshkey_ssh_name(key));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Skip certs */\n\t\tif (sshkey_is_cert(key)) {\n\t\t\tdebug3(\"%s: %s key is a certificate; skipping\",\n\t\t\t    __func__, sshkey_ssh_name(key));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Ensure keys are unique */\n\t\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\t\tif (sshkey_equal(key, ctx->keys[i])) {\n\t\t\t\terror(\"%s: received duplicated %s host key\",\n\t\t\t\t    __func__, sshkey_ssh_name(key));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* Key is good, record it */\n\t\tif ((tmp = recallocarray(ctx->keys, ctx->nkeys, ctx->nkeys + 1,\n\t\t    sizeof(*ctx->keys))) == NULL)\n\t\t\tfatal(\"%s: recallocarray failed nkeys = %zu\",\n\t\t\t    __func__, ctx->nkeys);\n\t\tctx->keys = tmp;\n\t\tctx->keys[ctx->nkeys++] = key;\n\t\tkey = NULL;\n\t}\n\n\tif (ctx->nkeys == 0) {\n\t\tdebug(\"%s: server sent no hostkeys\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((ctx->keys_seen = calloc(ctx->nkeys,\n\t    sizeof(*ctx->keys_seen))) == NULL)\n\t\tfatal(\"%s: calloc failed\", __func__);\n\n\tget_hostfile_hostname_ipaddr(host,\n\t    options.check_host_ip ? (struct sockaddr *)&hostaddr : NULL,\n\t    options.port, &ctx->host_str,\n\t    options.check_host_ip ? &ctx->ip_str : NULL);\n\n\t/* Find which keys we already know about. */\n\tif ((r = hostkeys_foreach(options.user_hostfiles[0], hostkeys_find,\n\t    ctx, ctx->host_str, ctx->ip_str,\n\t    HKF_WANT_PARSE_KEY|HKF_WANT_MATCH)) != 0) {\n\t\terror(\"%s: hostkeys_foreach failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\n\t/* Figure out if we have any new keys to add */\n\tctx->nnew = 0;\n\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\tif (!ctx->keys_seen[i])\n\t\t\tctx->nnew++;\n\t}\n\n\tdebug3(\"%s: %zu keys from server: %zu new, %zu retained. %zu to remove\",\n\t    __func__, ctx->nkeys, ctx->nnew, ctx->nkeys - ctx->nnew, ctx->nold);\n\n\tif (ctx->nnew == 0 && ctx->nold != 0) {\n\t\t/* We have some keys to remove. Just do it. */\n\t\tupdate_known_hosts(ctx);\n\t} else if (ctx->nnew != 0) {\n\t\t/*\n\t\t * We have received hitherto-unseen keys from the server.\n\t\t * Ask the server to confirm ownership of the private halves.\n\t\t */\n\t\tdebug3(\"%s: asking server to prove ownership for %zu keys\",\n\t\t    __func__, ctx->nnew);\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"hostkeys-prove-00@openssh.com\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0) /* bool: want reply */\n\t\t\tfatal(\"%s: cannot prepare packet: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tif ((buf = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new\", __func__);\n\t\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\t\tif (ctx->keys_seen[i])\n\t\t\t\tcontinue;\n\t\t\tsshbuf_reset(buf);\n\t\t\tif ((r = sshkey_putb(ctx->keys[i], buf)) != 0)\n\t\t\t\tfatal(\"%s: sshkey_putb: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif ((r = sshpkt_put_stringb(ssh, buf)) != 0)\n\t\t\t\tfatal(\"%s: sshpkt_put_string: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\tif ((r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal(\"%s: sshpkt_send: %s\", __func__, ssh_err(r));\n\t\tclient_register_global_confirm(\n\t\t    client_global_hostkeys_private_confirm, ctx);\n\t\tctx = NULL;  /* will be freed in callback */\n\t}\n\n\t/* Success */\n out:\n\thostkeys_update_ctx_free(ctx);\n\tsshkey_free(key);\n\tsshbuf_free(buf);\n\t/*\n\t * NB. Return success for all cases. The server doesn't need to know\n\t * what the client does with its hosts file.\n\t */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rtype",
            "\"hostkeys-00@openssh.com\""
          ],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"client_input_global_request: rtype %s want_reply %d\"",
            "rtype",
            "want_reply"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_char",
          "args": [],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "221-225",
          "snippet": "u_int\npacket_get_char(void)\n{\n\treturn (ssh_packet_get_char(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_char(void)\n{\n\treturn (ssh_packet_get_char(active_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_cstring",
          "args": [
            "NULL"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nclient_input_global_request(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tchar *rtype;\n\tint want_reply;\n\tint success = 0;\n\n\trtype = packet_get_cstring(NULL);\n\twant_reply = packet_get_char();\n\tdebug(\"client_input_global_request: rtype %s want_reply %d\",\n\t    rtype, want_reply);\n\tif (strcmp(rtype, \"hostkeys-00@openssh.com\") == 0)\n\t\tsuccess = client_input_hostkeys();\n\tif (want_reply) {\n\t\tpacket_start(success ?\n\t\t    SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t}\n\tfree(rtype);\n\treturn 0;\n}"
  },
  {
    "function_name": "client_input_hostkeys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "2020-2168",
    "snippet": "static int\nclient_input_hostkeys(void)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tconst u_char *blob = NULL;\n\tsize_t i, len = 0;\n\tstruct sshbuf *buf = NULL;\n\tstruct sshkey *key = NULL, **tmp;\n\tint r;\n\tchar *fp;\n\tstatic int hostkeys_seen = 0; /* XXX use struct ssh */\n\textern struct sockaddr_storage hostaddr; /* XXX from ssh.c */\n\tstruct hostkeys_update_ctx *ctx = NULL;\n\n\tif (hostkeys_seen)\n\t\tfatal(\"%s: server already sent hostkeys\", __func__);\n\tif (options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK &&\n\t    options.batch_mode)\n\t\treturn 1; /* won't ask in batchmode, so don't even try */\n\tif (!options.update_hostkeys || options.num_user_hostfiles <= 0)\n\t\treturn 1;\n\n\tctx = xcalloc(1, sizeof(*ctx));\n\twhile (ssh_packet_remaining(ssh) > 0) {\n\t\tsshkey_free(key);\n\t\tkey = NULL;\n\t\tif ((r = sshpkt_get_string_direct(ssh, &blob, &len)) != 0) {\n\t\t\terror(\"%s: couldn't parse message: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_from_blob(blob, len, &key)) != 0) {\n\t\t\terror(\"%s: parse key: %s\", __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tfp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\tdebug3(\"%s: received %s key %s\", __func__,\n\t\t    sshkey_type(key), fp);\n\t\tfree(fp);\n\n\t\tif (!key_accepted_by_hostkeyalgs(key)) {\n\t\t\tdebug3(\"%s: %s key not permitted by HostkeyAlgorithms\",\n\t\t\t    __func__, sshkey_ssh_name(key));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Skip certs */\n\t\tif (sshkey_is_cert(key)) {\n\t\t\tdebug3(\"%s: %s key is a certificate; skipping\",\n\t\t\t    __func__, sshkey_ssh_name(key));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Ensure keys are unique */\n\t\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\t\tif (sshkey_equal(key, ctx->keys[i])) {\n\t\t\t\terror(\"%s: received duplicated %s host key\",\n\t\t\t\t    __func__, sshkey_ssh_name(key));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* Key is good, record it */\n\t\tif ((tmp = recallocarray(ctx->keys, ctx->nkeys, ctx->nkeys + 1,\n\t\t    sizeof(*ctx->keys))) == NULL)\n\t\t\tfatal(\"%s: recallocarray failed nkeys = %zu\",\n\t\t\t    __func__, ctx->nkeys);\n\t\tctx->keys = tmp;\n\t\tctx->keys[ctx->nkeys++] = key;\n\t\tkey = NULL;\n\t}\n\n\tif (ctx->nkeys == 0) {\n\t\tdebug(\"%s: server sent no hostkeys\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((ctx->keys_seen = calloc(ctx->nkeys,\n\t    sizeof(*ctx->keys_seen))) == NULL)\n\t\tfatal(\"%s: calloc failed\", __func__);\n\n\tget_hostfile_hostname_ipaddr(host,\n\t    options.check_host_ip ? (struct sockaddr *)&hostaddr : NULL,\n\t    options.port, &ctx->host_str,\n\t    options.check_host_ip ? &ctx->ip_str : NULL);\n\n\t/* Find which keys we already know about. */\n\tif ((r = hostkeys_foreach(options.user_hostfiles[0], hostkeys_find,\n\t    ctx, ctx->host_str, ctx->ip_str,\n\t    HKF_WANT_PARSE_KEY|HKF_WANT_MATCH)) != 0) {\n\t\terror(\"%s: hostkeys_foreach failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\n\t/* Figure out if we have any new keys to add */\n\tctx->nnew = 0;\n\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\tif (!ctx->keys_seen[i])\n\t\t\tctx->nnew++;\n\t}\n\n\tdebug3(\"%s: %zu keys from server: %zu new, %zu retained. %zu to remove\",\n\t    __func__, ctx->nkeys, ctx->nnew, ctx->nkeys - ctx->nnew, ctx->nold);\n\n\tif (ctx->nnew == 0 && ctx->nold != 0) {\n\t\t/* We have some keys to remove. Just do it. */\n\t\tupdate_known_hosts(ctx);\n\t} else if (ctx->nnew != 0) {\n\t\t/*\n\t\t * We have received hitherto-unseen keys from the server.\n\t\t * Ask the server to confirm ownership of the private halves.\n\t\t */\n\t\tdebug3(\"%s: asking server to prove ownership for %zu keys\",\n\t\t    __func__, ctx->nnew);\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"hostkeys-prove-00@openssh.com\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0) /* bool: want reply */\n\t\t\tfatal(\"%s: cannot prepare packet: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tif ((buf = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new\", __func__);\n\t\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\t\tif (ctx->keys_seen[i])\n\t\t\t\tcontinue;\n\t\t\tsshbuf_reset(buf);\n\t\t\tif ((r = sshkey_putb(ctx->keys[i], buf)) != 0)\n\t\t\t\tfatal(\"%s: sshkey_putb: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif ((r = sshpkt_put_stringb(ssh, buf)) != 0)\n\t\t\t\tfatal(\"%s: sshpkt_put_string: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\tif ((r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal(\"%s: sshpkt_send: %s\", __func__, ssh_err(r));\n\t\tclient_register_global_confirm(\n\t\t    client_global_hostkeys_private_confirm, ctx);\n\t\tctx = NULL;  /* will be freed in callback */\n\t}\n\n\t/* Success */\n out:\n\thostkeys_update_ctx_free(ctx);\n\tsshkey_free(key);\n\tsshbuf_free(buf);\n\t/*\n\t * NB. Return success for all cases. The server doesn't need to know\n\t * what the client does with its hosts file.\n\t */\n\treturn 1;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "extern char *host;",
      "void ssh_process_session2_setup(int, int, int, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "buf"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "key"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hostkeys_update_ctx_free",
          "args": [
            "ctx"
          ],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_register_global_confirm",
          "args": [
            "client_global_hostkeys_private_confirm",
            "ctx"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "client_register_global_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "747-766",
          "snippet": "void\nclient_register_global_confirm(global_confirm_cb *cb, void *ctx)\n{\n\tstruct global_confirm *gc, *last_gc;\n\n\t/* Coalesce identical callbacks */\n\tlast_gc = TAILQ_LAST(&global_confirms, global_confirms);\n\tif (last_gc && last_gc->cb == cb && last_gc->ctx == ctx) {\n\t\tif (++last_gc->ref_count >= INT_MAX)\n\t\t\tfatal(\"%s: last_gc->ref_count = %d\",\n\t\t\t    __func__, last_gc->ref_count);\n\t\treturn;\n\t}\n\n\tgc = xcalloc(1, sizeof(*gc));\n\tgc->cb = cb;\n\tgc->ctx = ctx;\n\tgc->ref_count = 1;\n\tTAILQ_INSERT_TAIL(&global_confirms, gc, entry);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct global_confirms global_confirms =\n    TAILQ_HEAD_INITIALIZER(global_confirms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct global_confirms global_confirms =\n    TAILQ_HEAD_INITIALIZER(global_confirms);\n\nvoid\nclient_register_global_confirm(global_confirm_cb *cb, void *ctx)\n{\n\tstruct global_confirm *gc, *last_gc;\n\n\t/* Coalesce identical callbacks */\n\tlast_gc = TAILQ_LAST(&global_confirms, global_confirms);\n\tif (last_gc && last_gc->cb == cb && last_gc->ctx == ctx) {\n\t\tif (++last_gc->ref_count >= INT_MAX)\n\t\t\tfatal(\"%s: last_gc->ref_count = %d\",\n\t\t\t    __func__, last_gc->ref_count);\n\t\treturn;\n\t}\n\n\tgc = xcalloc(1, sizeof(*gc));\n\tgc->cb = cb;\n\tgc->ctx = ctx;\n\tgc->ref_count = 1;\n\tTAILQ_INSERT_TAIL(&global_confirms, gc, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshpkt_send: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_stringb",
          "args": [
            "ssh",
            "buf"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2465-2469",
          "snippet": "int\nsshpkt_put_stringb(struct ssh *ssh, const struct sshbuf *v)\n{\n\treturn sshbuf_put_stringb(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_stringb(struct ssh *ssh, const struct sshbuf *v)\n{\n\treturn sshbuf_put_stringb(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_putb",
          "args": [
            "ctx->keys[i]",
            "buf"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_putb_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "842-846",
          "snippet": "int\nsshkey_putb_plain(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn to_blob_buf(key, b, 1, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_putb_plain(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn to_blob_buf(key, b, 1, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "buf"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new\"",
            "__func__"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u8",
          "args": [
            "ssh",
            "1"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2435-2439",
          "snippet": "int\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "\"hostkeys-prove-00@openssh.com\""
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_GLOBAL_REQUEST"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: asking server to prove ownership for %zu keys\"",
            "__func__",
            "ctx->nnew"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_known_hosts",
          "args": [
            "ctx"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "update_known_hosts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1848-1915",
          "snippet": "static void\nupdate_known_hosts(struct hostkeys_update_ctx *ctx)\n{\n\tint r, was_raw = 0;\n\tint loglevel = options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK ?\n\t    SYSLOG_LEVEL_INFO : SYSLOG_LEVEL_VERBOSE;\n\tchar *fp, *response;\n\tsize_t i;\n\n\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\tif (ctx->keys_seen[i] != 2)\n\t\t\tcontinue;\n\t\tif ((fp = sshkey_fingerprint(ctx->keys[i],\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tdo_log2(loglevel, \"Learned new hostkey: %s %s\",\n\t\t    sshkey_type(ctx->keys[i]), fp);\n\t\tfree(fp);\n\t}\n\tfor (i = 0; i < ctx->nold; i++) {\n\t\tif ((fp = sshkey_fingerprint(ctx->old_keys[i],\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tdo_log2(loglevel, \"Deprecating obsolete hostkey: %s %s\",\n\t\t    sshkey_type(ctx->old_keys[i]), fp);\n\t\tfree(fp);\n\t}\n\tif (options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK) {\n\t\tif (get_saved_tio() != NULL) {\n\t\t\tleave_raw_mode(1);\n\t\t\twas_raw = 1;\n\t\t}\n\t\tresponse = NULL;\n\t\tfor (i = 0; !quit_pending && i < 3; i++) {\n\t\t\tfree(response);\n\t\t\tresponse = read_passphrase(\"Accept updated hostkeys? \"\n\t\t\t    \"(yes/no): \", RP_ECHO);\n\t\t\tif (strcasecmp(response, \"yes\") == 0)\n\t\t\t\tbreak;\n\t\t\telse if (quit_pending || response == NULL ||\n\t\t\t    strcasecmp(response, \"no\") == 0) {\n\t\t\t\toptions.update_hostkeys = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdo_log2(loglevel, \"Please enter \"\n\t\t\t\t    \"\\\"yes\\\" or \\\"no\\\"\");\n\t\t\t}\n\t\t}\n\t\tif (quit_pending || i >= 3 || response == NULL)\n\t\t\toptions.update_hostkeys = 0;\n\t\tfree(response);\n\t\tif (was_raw)\n\t\t\tenter_raw_mode(1);\n\t}\n\n\t/*\n\t * Now that all the keys are verified, we can go ahead and replace\n\t * them in known_hosts (assuming SSH_UPDATE_HOSTKEYS_ASK didn't\n\t * cancel the operation).\n\t */\n\tif (options.update_hostkeys != 0 &&\n\t    (r = hostfile_replace_entries(options.user_hostfiles[0],\n\t    ctx->host_str, ctx->ip_str, ctx->keys, ctx->nkeys,\n\t    options.hash_known_hosts, 0,\n\t    options.fingerprint_hash)) != 0)\n\t\terror(\"%s: hostfile_replace_entries failed: %s\",\n\t\t    __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "volatile sig_atomic_t quit_pending;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nvolatile sig_atomic_t quit_pending;\n\nstatic void\nupdate_known_hosts(struct hostkeys_update_ctx *ctx)\n{\n\tint r, was_raw = 0;\n\tint loglevel = options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK ?\n\t    SYSLOG_LEVEL_INFO : SYSLOG_LEVEL_VERBOSE;\n\tchar *fp, *response;\n\tsize_t i;\n\n\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\tif (ctx->keys_seen[i] != 2)\n\t\t\tcontinue;\n\t\tif ((fp = sshkey_fingerprint(ctx->keys[i],\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tdo_log2(loglevel, \"Learned new hostkey: %s %s\",\n\t\t    sshkey_type(ctx->keys[i]), fp);\n\t\tfree(fp);\n\t}\n\tfor (i = 0; i < ctx->nold; i++) {\n\t\tif ((fp = sshkey_fingerprint(ctx->old_keys[i],\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tdo_log2(loglevel, \"Deprecating obsolete hostkey: %s %s\",\n\t\t    sshkey_type(ctx->old_keys[i]), fp);\n\t\tfree(fp);\n\t}\n\tif (options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK) {\n\t\tif (get_saved_tio() != NULL) {\n\t\t\tleave_raw_mode(1);\n\t\t\twas_raw = 1;\n\t\t}\n\t\tresponse = NULL;\n\t\tfor (i = 0; !quit_pending && i < 3; i++) {\n\t\t\tfree(response);\n\t\t\tresponse = read_passphrase(\"Accept updated hostkeys? \"\n\t\t\t    \"(yes/no): \", RP_ECHO);\n\t\t\tif (strcasecmp(response, \"yes\") == 0)\n\t\t\t\tbreak;\n\t\t\telse if (quit_pending || response == NULL ||\n\t\t\t    strcasecmp(response, \"no\") == 0) {\n\t\t\t\toptions.update_hostkeys = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdo_log2(loglevel, \"Please enter \"\n\t\t\t\t    \"\\\"yes\\\" or \\\"no\\\"\");\n\t\t\t}\n\t\t}\n\t\tif (quit_pending || i >= 3 || response == NULL)\n\t\t\toptions.update_hostkeys = 0;\n\t\tfree(response);\n\t\tif (was_raw)\n\t\t\tenter_raw_mode(1);\n\t}\n\n\t/*\n\t * Now that all the keys are verified, we can go ahead and replace\n\t * them in known_hosts (assuming SSH_UPDATE_HOSTKEYS_ASK didn't\n\t * cancel the operation).\n\t */\n\tif (options.update_hostkeys != 0 &&\n\t    (r = hostfile_replace_entries(options.user_hostfiles[0],\n\t    ctx->host_str, ctx->ip_str, ctx->keys, ctx->nkeys,\n\t    options.hash_known_hosts, 0,\n\t    options.fingerprint_hash)) != 0)\n\t\terror(\"%s: hostfile_replace_entries failed: %s\",\n\t\t    __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: hostkeys_foreach failed: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hostkeys_foreach",
          "args": [
            "options.user_hostfiles[0]",
            "hostkeys_find",
            "ctx",
            "ctx->host_str",
            "ctx->ip_str",
            "HKF_WANT_PARSE_KEY|HKF_WANT_MATCH"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_foreach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "661-834",
          "snippet": "int\nhostkeys_foreach(const char *path, hostkeys_foreach_fn *callback, void *ctx,\n    const char *host, const char *ip, u_int options)\n{\n\tFILE *f;\n\tchar *line = NULL, ktype[128];\n\tu_long linenum = 0;\n\tchar *cp, *cp2;\n\tu_int kbits;\n\tint hashed;\n\tint s, r = 0;\n\tstruct hostkey_foreach_line lineinfo;\n\tsize_t linesize = 0, l;\n\n\tmemset(&lineinfo, 0, sizeof(lineinfo));\n\tif (host == NULL && (options & HKF_WANT_MATCH) != 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((f = fopen(path, \"r\")) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\tdebug3(\"%s: reading file \\\"%s\\\"\", __func__, path);\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\tline[strcspn(line, \"\\n\")] = '\\0';\n\n\t\tfree(lineinfo.line);\n\t\tsshkey_free(lineinfo.key);\n\t\tmemset(&lineinfo, 0, sizeof(lineinfo));\n\t\tlineinfo.path = path;\n\t\tlineinfo.linenum = linenum;\n\t\tlineinfo.line = xstrdup(line);\n\t\tlineinfo.marker = MRK_NONE;\n\t\tlineinfo.status = HKF_STATUS_OK;\n\t\tlineinfo.keytype = KEY_UNSPEC;\n\n\t\t/* Skip any leading whitespace, comments and empty lines. */\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (!*cp || *cp == '#' || *cp == '\\n') {\n\t\t\tif ((options & HKF_WANT_MATCH) == 0) {\n\t\t\t\tlineinfo.status = HKF_STATUS_COMMENT;\n\t\t\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((lineinfo.marker = check_markers(&cp)) == MRK_ERROR) {\n\t\t\tverbose(\"%s: invalid marker at %s:%lu\",\n\t\t\t    __func__, path, linenum);\n\t\t\tif ((options & HKF_WANT_MATCH) == 0)\n\t\t\t\tgoto bad;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Find the end of the host name portion. */\n\t\tfor (cp2 = cp; *cp2 && *cp2 != ' ' && *cp2 != '\\t'; cp2++)\n\t\t\t;\n\t\tlineinfo.hosts = cp;\n\t\t*cp2++ = '\\0';\n\n\t\t/* Check if the host name matches. */\n\t\tif (host != NULL) {\n\t\t\tif ((s = match_maybe_hashed(host, lineinfo.hosts,\n\t\t\t    &hashed)) == -1) {\n\t\t\t\tdebug2(\"%s: %s:%ld: bad host hash \\\"%.32s\\\"\",\n\t\t\t\t    __func__, path, linenum, lineinfo.hosts);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (s == 1) {\n\t\t\t\tlineinfo.status = HKF_STATUS_MATCHED;\n\t\t\t\tlineinfo.match |= HKF_MATCH_HOST |\n\t\t\t\t    (hashed ? HKF_MATCH_HOST_HASHED : 0);\n\t\t\t}\n\t\t\t/* Try matching IP address if supplied */\n\t\t\tif (ip != NULL) {\n\t\t\t\tif ((s = match_maybe_hashed(ip, lineinfo.hosts,\n\t\t\t\t    &hashed)) == -1) {\n\t\t\t\t\tdebug2(\"%s: %s:%ld: bad ip hash \"\n\t\t\t\t\t    \"\\\"%.32s\\\"\", __func__, path,\n\t\t\t\t\t    linenum, lineinfo.hosts);\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tif (s == 1) {\n\t\t\t\t\tlineinfo.status = HKF_STATUS_MATCHED;\n\t\t\t\t\tlineinfo.match |= HKF_MATCH_IP |\n\t\t\t\t\t    (hashed ? HKF_MATCH_IP_HASHED : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * Skip this line if host matching requested and\n\t\t\t * neither host nor address matched.\n\t\t\t */\n\t\t\tif ((options & HKF_WANT_MATCH) != 0 &&\n\t\t\t    lineinfo.status != HKF_STATUS_MATCHED)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Got a match.  Skip host name and any following whitespace */\n\t\tfor (; *cp2 == ' ' || *cp2 == '\\t'; cp2++)\n\t\t\t;\n\t\tif (*cp2 == '\\0' || *cp2 == '#') {\n\t\t\tdebug2(\"%s:%ld: truncated before key type\",\n\t\t\t    path, linenum);\n\t\t\tgoto bad;\n\t\t}\n\t\tlineinfo.rawkey = cp = cp2;\n\n\t\tif ((options & HKF_WANT_PARSE_KEY) != 0) {\n\t\t\t/*\n\t\t\t * Extract the key from the line.  This will skip\n\t\t\t * any leading whitespace.  Ignore badly formatted\n\t\t\t * lines.\n\t\t\t */\n\t\t\tif ((lineinfo.key = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\t\terror(\"%s: sshkey_new failed\", __func__);\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!hostfile_read_key(&cp, &kbits, lineinfo.key)) {\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tlineinfo.keytype = lineinfo.key->type;\n\t\t\tlineinfo.comment = cp;\n\t\t} else {\n\t\t\t/* Extract and parse key type */\n\t\t\tl = strcspn(lineinfo.rawkey, \" \\t\");\n\t\t\tif (l <= 1 || l >= sizeof(ktype) ||\n\t\t\t    lineinfo.rawkey[l] == '\\0')\n\t\t\t\tgoto bad;\n\t\t\tmemcpy(ktype, lineinfo.rawkey, l);\n\t\t\tktype[l] = '\\0';\n\t\t\tlineinfo.keytype = sshkey_type_from_name(ktype);\n\n\t\t\t/*\n\t\t\t * Assume legacy RSA1 if the first component is a short\n\t\t\t * decimal number.\n\t\t\t */\n\t\t\tif (lineinfo.keytype == KEY_UNSPEC && l < 8 &&\n\t\t\t    strspn(ktype, \"0123456789\") == l)\n\t\t\t\tgoto bad;\n\n\t\t\t/*\n\t\t\t * Check that something other than whitespace follows\n\t\t\t * the key type. This won't catch all corruption, but\n\t\t\t * it does catch trivial truncation.\n\t\t\t */\n\t\t\tcp2 += l; /* Skip past key type */\n\t\t\tfor (; *cp2 == ' ' || *cp2 == '\\t'; cp2++)\n\t\t\t\t;\n\t\t\tif (*cp2 == '\\0' || *cp2 == '#') {\n\t\t\t\tdebug2(\"%s:%ld: truncated after key type\",\n\t\t\t\t    path, linenum);\n\t\t\t\tlineinfo.keytype = KEY_UNSPEC;\n\t\t\t}\n\t\t\tif (lineinfo.keytype == KEY_UNSPEC) {\n bad:\n\t\t\t\tsshkey_free(lineinfo.key);\n\t\t\t\tlineinfo.key = NULL;\n\t\t\t\tlineinfo.status = HKF_STATUS_INVALID;\n\t\t\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\tbreak;\n\t}\n\tsshkey_free(lineinfo.key);\n\tfree(lineinfo.line);\n\tfree(line);\n\tfclose(f);\n\treturn r;\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nhostkeys_foreach(const char *path, hostkeys_foreach_fn *callback, void *ctx,\n    const char *host, const char *ip, u_int options)\n{\n\tFILE *f;\n\tchar *line = NULL, ktype[128];\n\tu_long linenum = 0;\n\tchar *cp, *cp2;\n\tu_int kbits;\n\tint hashed;\n\tint s, r = 0;\n\tstruct hostkey_foreach_line lineinfo;\n\tsize_t linesize = 0, l;\n\n\tmemset(&lineinfo, 0, sizeof(lineinfo));\n\tif (host == NULL && (options & HKF_WANT_MATCH) != 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((f = fopen(path, \"r\")) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\tdebug3(\"%s: reading file \\\"%s\\\"\", __func__, path);\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\tline[strcspn(line, \"\\n\")] = '\\0';\n\n\t\tfree(lineinfo.line);\n\t\tsshkey_free(lineinfo.key);\n\t\tmemset(&lineinfo, 0, sizeof(lineinfo));\n\t\tlineinfo.path = path;\n\t\tlineinfo.linenum = linenum;\n\t\tlineinfo.line = xstrdup(line);\n\t\tlineinfo.marker = MRK_NONE;\n\t\tlineinfo.status = HKF_STATUS_OK;\n\t\tlineinfo.keytype = KEY_UNSPEC;\n\n\t\t/* Skip any leading whitespace, comments and empty lines. */\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (!*cp || *cp == '#' || *cp == '\\n') {\n\t\t\tif ((options & HKF_WANT_MATCH) == 0) {\n\t\t\t\tlineinfo.status = HKF_STATUS_COMMENT;\n\t\t\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((lineinfo.marker = check_markers(&cp)) == MRK_ERROR) {\n\t\t\tverbose(\"%s: invalid marker at %s:%lu\",\n\t\t\t    __func__, path, linenum);\n\t\t\tif ((options & HKF_WANT_MATCH) == 0)\n\t\t\t\tgoto bad;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Find the end of the host name portion. */\n\t\tfor (cp2 = cp; *cp2 && *cp2 != ' ' && *cp2 != '\\t'; cp2++)\n\t\t\t;\n\t\tlineinfo.hosts = cp;\n\t\t*cp2++ = '\\0';\n\n\t\t/* Check if the host name matches. */\n\t\tif (host != NULL) {\n\t\t\tif ((s = match_maybe_hashed(host, lineinfo.hosts,\n\t\t\t    &hashed)) == -1) {\n\t\t\t\tdebug2(\"%s: %s:%ld: bad host hash \\\"%.32s\\\"\",\n\t\t\t\t    __func__, path, linenum, lineinfo.hosts);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (s == 1) {\n\t\t\t\tlineinfo.status = HKF_STATUS_MATCHED;\n\t\t\t\tlineinfo.match |= HKF_MATCH_HOST |\n\t\t\t\t    (hashed ? HKF_MATCH_HOST_HASHED : 0);\n\t\t\t}\n\t\t\t/* Try matching IP address if supplied */\n\t\t\tif (ip != NULL) {\n\t\t\t\tif ((s = match_maybe_hashed(ip, lineinfo.hosts,\n\t\t\t\t    &hashed)) == -1) {\n\t\t\t\t\tdebug2(\"%s: %s:%ld: bad ip hash \"\n\t\t\t\t\t    \"\\\"%.32s\\\"\", __func__, path,\n\t\t\t\t\t    linenum, lineinfo.hosts);\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tif (s == 1) {\n\t\t\t\t\tlineinfo.status = HKF_STATUS_MATCHED;\n\t\t\t\t\tlineinfo.match |= HKF_MATCH_IP |\n\t\t\t\t\t    (hashed ? HKF_MATCH_IP_HASHED : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * Skip this line if host matching requested and\n\t\t\t * neither host nor address matched.\n\t\t\t */\n\t\t\tif ((options & HKF_WANT_MATCH) != 0 &&\n\t\t\t    lineinfo.status != HKF_STATUS_MATCHED)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Got a match.  Skip host name and any following whitespace */\n\t\tfor (; *cp2 == ' ' || *cp2 == '\\t'; cp2++)\n\t\t\t;\n\t\tif (*cp2 == '\\0' || *cp2 == '#') {\n\t\t\tdebug2(\"%s:%ld: truncated before key type\",\n\t\t\t    path, linenum);\n\t\t\tgoto bad;\n\t\t}\n\t\tlineinfo.rawkey = cp = cp2;\n\n\t\tif ((options & HKF_WANT_PARSE_KEY) != 0) {\n\t\t\t/*\n\t\t\t * Extract the key from the line.  This will skip\n\t\t\t * any leading whitespace.  Ignore badly formatted\n\t\t\t * lines.\n\t\t\t */\n\t\t\tif ((lineinfo.key = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\t\terror(\"%s: sshkey_new failed\", __func__);\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!hostfile_read_key(&cp, &kbits, lineinfo.key)) {\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tlineinfo.keytype = lineinfo.key->type;\n\t\t\tlineinfo.comment = cp;\n\t\t} else {\n\t\t\t/* Extract and parse key type */\n\t\t\tl = strcspn(lineinfo.rawkey, \" \\t\");\n\t\t\tif (l <= 1 || l >= sizeof(ktype) ||\n\t\t\t    lineinfo.rawkey[l] == '\\0')\n\t\t\t\tgoto bad;\n\t\t\tmemcpy(ktype, lineinfo.rawkey, l);\n\t\t\tktype[l] = '\\0';\n\t\t\tlineinfo.keytype = sshkey_type_from_name(ktype);\n\n\t\t\t/*\n\t\t\t * Assume legacy RSA1 if the first component is a short\n\t\t\t * decimal number.\n\t\t\t */\n\t\t\tif (lineinfo.keytype == KEY_UNSPEC && l < 8 &&\n\t\t\t    strspn(ktype, \"0123456789\") == l)\n\t\t\t\tgoto bad;\n\n\t\t\t/*\n\t\t\t * Check that something other than whitespace follows\n\t\t\t * the key type. This won't catch all corruption, but\n\t\t\t * it does catch trivial truncation.\n\t\t\t */\n\t\t\tcp2 += l; /* Skip past key type */\n\t\t\tfor (; *cp2 == ' ' || *cp2 == '\\t'; cp2++)\n\t\t\t\t;\n\t\t\tif (*cp2 == '\\0' || *cp2 == '#') {\n\t\t\t\tdebug2(\"%s:%ld: truncated after key type\",\n\t\t\t\t    path, linenum);\n\t\t\t\tlineinfo.keytype = KEY_UNSPEC;\n\t\t\t}\n\t\t\tif (lineinfo.keytype == KEY_UNSPEC) {\n bad:\n\t\t\t\tsshkey_free(lineinfo.key);\n\t\t\t\tlineinfo.key = NULL;\n\t\t\t\tlineinfo.status = HKF_STATUS_INVALID;\n\t\t\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\tbreak;\n\t}\n\tsshkey_free(lineinfo.key);\n\tfree(lineinfo.line);\n\tfree(line);\n\tfclose(f);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hostfile_hostname_ipaddr",
          "args": [
            "host",
            "options.check_host_ip ? (struct sockaddr *)&hostaddr : NULL",
            "options.port",
            "&ctx->host_str",
            "options.check_host_ip ? &ctx->ip_str : NULL"
          ],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "get_hostfile_hostname_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "777-829",
          "snippet": "void\nget_hostfile_hostname_ipaddr(char *hostname, struct sockaddr *hostaddr,\n    u_short port, char **hostfile_hostname, char **hostfile_ipaddr)\n{\n\tchar ntop[NI_MAXHOST];\n\tsocklen_t addrlen;\n\n\tswitch (hostaddr == NULL ? -1 : hostaddr->sa_family) {\n\tcase -1:\n\t\taddrlen = 0;\n\t\tbreak;\n\tcase AF_INET:\n\t\taddrlen = sizeof(struct sockaddr_in);\n\t\tbreak;\n\tcase AF_INET6:\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tbreak;\n\tdefault:\n\t\taddrlen = sizeof(struct sockaddr);\n\t\tbreak;\n\t}\n\n\t/*\n\t * We don't have the remote ip-address for connections\n\t * using a proxy command\n\t */\n\tif (hostfile_ipaddr != NULL) {\n\t\tif (options.proxy_command == NULL) {\n\t\t\tif (getnameinfo(hostaddr, addrlen,\n\t\t\t    ntop, sizeof(ntop), NULL, 0, NI_NUMERICHOST) != 0)\n\t\t\tfatal(\"%s: getnameinfo failed\", __func__);\n\t\t\t*hostfile_ipaddr = put_host_port(ntop, port);\n\t\t} else {\n\t\t\t*hostfile_ipaddr = xstrdup(\"<no hostip for proxy \"\n\t\t\t    \"command>\");\n\t\t}\n\t}\n\n\t/*\n\t * Allow the user to record the key under a different name or\n\t * differentiate a non-standard port.  This is useful for ssh\n\t * tunneling over forwarded connections or if you run multiple\n\t * sshd's on different ports on the same machine.\n\t */\n\tif (hostfile_hostname != NULL) {\n\t\tif (options.host_key_alias != NULL) {\n\t\t\t*hostfile_hostname = xstrdup(options.host_key_alias);\n\t\t\tdebug(\"using hostkeyalias: %s\", *hostfile_hostname);\n\t\t} else {\n\t\t\t*hostfile_hostname = put_host_port(hostname, port);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nvoid\nget_hostfile_hostname_ipaddr(char *hostname, struct sockaddr *hostaddr,\n    u_short port, char **hostfile_hostname, char **hostfile_ipaddr)\n{\n\tchar ntop[NI_MAXHOST];\n\tsocklen_t addrlen;\n\n\tswitch (hostaddr == NULL ? -1 : hostaddr->sa_family) {\n\tcase -1:\n\t\taddrlen = 0;\n\t\tbreak;\n\tcase AF_INET:\n\t\taddrlen = sizeof(struct sockaddr_in);\n\t\tbreak;\n\tcase AF_INET6:\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tbreak;\n\tdefault:\n\t\taddrlen = sizeof(struct sockaddr);\n\t\tbreak;\n\t}\n\n\t/*\n\t * We don't have the remote ip-address for connections\n\t * using a proxy command\n\t */\n\tif (hostfile_ipaddr != NULL) {\n\t\tif (options.proxy_command == NULL) {\n\t\t\tif (getnameinfo(hostaddr, addrlen,\n\t\t\t    ntop, sizeof(ntop), NULL, 0, NI_NUMERICHOST) != 0)\n\t\t\tfatal(\"%s: getnameinfo failed\", __func__);\n\t\t\t*hostfile_ipaddr = put_host_port(ntop, port);\n\t\t} else {\n\t\t\t*hostfile_ipaddr = xstrdup(\"<no hostip for proxy \"\n\t\t\t    \"command>\");\n\t\t}\n\t}\n\n\t/*\n\t * Allow the user to record the key under a different name or\n\t * differentiate a non-standard port.  This is useful for ssh\n\t * tunneling over forwarded connections or if you run multiple\n\t * sshd's on different ports on the same machine.\n\t */\n\tif (hostfile_hostname != NULL) {\n\t\tif (options.host_key_alias != NULL) {\n\t\t\t*hostfile_hostname = xstrdup(options.host_key_alias);\n\t\t\tdebug(\"using hostkeyalias: %s\", *hostfile_hostname);\n\t\t} else {\n\t\t\t*hostfile_hostname = put_host_port(hostname, port);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "ctx->nkeys",
            "sizeof(*ctx->keys_seen)"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recallocarray",
          "args": [
            "ctx->keys",
            "ctx->nkeys",
            "ctx->nkeys + 1",
            "sizeof(*ctx->keys)"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "key"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_equal",
          "args": [
            "key",
            "ctx->keys[i]"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "704-714",
          "snippet": "int\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "key"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_accepted_by_hostkeyalgs",
          "args": [
            "key"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "key_accepted_by_hostkeyalgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1999-2013",
          "snippet": "static int\nkey_accepted_by_hostkeyalgs(const struct sshkey *key)\n{\n\tconst char *ktype = sshkey_ssh_name(key);\n\tconst char *hostkeyalgs = options.hostkeyalgorithms != NULL ?\n\t    options.hostkeyalgorithms : KEX_DEFAULT_PK_ALG;\n\n\tif (key == NULL || key->type == KEY_UNSPEC)\n\t\treturn 0;\n\tif (key->type == KEY_RSA &&\n\t    (match_pattern_list(\"rsa-sha2-256\", hostkeyalgs, 0) == 1 ||\n\t    match_pattern_list(\"rsa-sha2-512\", hostkeyalgs, 0) == 1))\n\t\treturn 1;\n\treturn match_pattern_list(ktype, hostkeyalgs, 0) == 1;\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic int\nkey_accepted_by_hostkeyalgs(const struct sshkey *key)\n{\n\tconst char *ktype = sshkey_ssh_name(key);\n\tconst char *hostkeyalgs = options.hostkeyalgorithms != NULL ?\n\t    options.hostkeyalgorithms : KEX_DEFAULT_PK_ALG;\n\n\tif (key == NULL || key->type == KEY_UNSPEC)\n\t\treturn 0;\n\tif (key->type == KEY_RSA &&\n\t    (match_pattern_list(\"rsa-sha2-256\", hostkeyalgs, 0) == 1 ||\n\t    match_pattern_list(\"rsa-sha2-512\", hostkeyalgs, 0) == 1))\n\t\treturn 1;\n\treturn match_pattern_list(ktype, hostkeyalgs, 0) == 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "key"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "key",
            "options.fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_blob",
          "args": [
            "blob",
            "len",
            "&key"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2263-2274",
          "snippet": "int\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_string_direct",
          "args": [
            "ssh",
            "&blob",
            "&len"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2520-2524",
          "snippet": "int\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_remaining",
          "args": [
            "ssh"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_remaining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "1757-1761",
          "snippet": "int\nssh_packet_remaining(struct ssh *ssh)\n{\n\treturn sshbuf_len(ssh->state->incoming_packet);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_remaining(struct ssh *ssh)\n{\n\treturn sshbuf_len(ssh->state->incoming_packet);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nextern char *host;\nvoid ssh_process_session2_setup(int, int, int, struct sshbuf *);\n\nstatic int\nclient_input_hostkeys(void)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tconst u_char *blob = NULL;\n\tsize_t i, len = 0;\n\tstruct sshbuf *buf = NULL;\n\tstruct sshkey *key = NULL, **tmp;\n\tint r;\n\tchar *fp;\n\tstatic int hostkeys_seen = 0; /* XXX use struct ssh */\n\textern struct sockaddr_storage hostaddr; /* XXX from ssh.c */\n\tstruct hostkeys_update_ctx *ctx = NULL;\n\n\tif (hostkeys_seen)\n\t\tfatal(\"%s: server already sent hostkeys\", __func__);\n\tif (options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK &&\n\t    options.batch_mode)\n\t\treturn 1; /* won't ask in batchmode, so don't even try */\n\tif (!options.update_hostkeys || options.num_user_hostfiles <= 0)\n\t\treturn 1;\n\n\tctx = xcalloc(1, sizeof(*ctx));\n\twhile (ssh_packet_remaining(ssh) > 0) {\n\t\tsshkey_free(key);\n\t\tkey = NULL;\n\t\tif ((r = sshpkt_get_string_direct(ssh, &blob, &len)) != 0) {\n\t\t\terror(\"%s: couldn't parse message: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_from_blob(blob, len, &key)) != 0) {\n\t\t\terror(\"%s: parse key: %s\", __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tfp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\tdebug3(\"%s: received %s key %s\", __func__,\n\t\t    sshkey_type(key), fp);\n\t\tfree(fp);\n\n\t\tif (!key_accepted_by_hostkeyalgs(key)) {\n\t\t\tdebug3(\"%s: %s key not permitted by HostkeyAlgorithms\",\n\t\t\t    __func__, sshkey_ssh_name(key));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Skip certs */\n\t\tif (sshkey_is_cert(key)) {\n\t\t\tdebug3(\"%s: %s key is a certificate; skipping\",\n\t\t\t    __func__, sshkey_ssh_name(key));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Ensure keys are unique */\n\t\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\t\tif (sshkey_equal(key, ctx->keys[i])) {\n\t\t\t\terror(\"%s: received duplicated %s host key\",\n\t\t\t\t    __func__, sshkey_ssh_name(key));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* Key is good, record it */\n\t\tif ((tmp = recallocarray(ctx->keys, ctx->nkeys, ctx->nkeys + 1,\n\t\t    sizeof(*ctx->keys))) == NULL)\n\t\t\tfatal(\"%s: recallocarray failed nkeys = %zu\",\n\t\t\t    __func__, ctx->nkeys);\n\t\tctx->keys = tmp;\n\t\tctx->keys[ctx->nkeys++] = key;\n\t\tkey = NULL;\n\t}\n\n\tif (ctx->nkeys == 0) {\n\t\tdebug(\"%s: server sent no hostkeys\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((ctx->keys_seen = calloc(ctx->nkeys,\n\t    sizeof(*ctx->keys_seen))) == NULL)\n\t\tfatal(\"%s: calloc failed\", __func__);\n\n\tget_hostfile_hostname_ipaddr(host,\n\t    options.check_host_ip ? (struct sockaddr *)&hostaddr : NULL,\n\t    options.port, &ctx->host_str,\n\t    options.check_host_ip ? &ctx->ip_str : NULL);\n\n\t/* Find which keys we already know about. */\n\tif ((r = hostkeys_foreach(options.user_hostfiles[0], hostkeys_find,\n\t    ctx, ctx->host_str, ctx->ip_str,\n\t    HKF_WANT_PARSE_KEY|HKF_WANT_MATCH)) != 0) {\n\t\terror(\"%s: hostkeys_foreach failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\n\t/* Figure out if we have any new keys to add */\n\tctx->nnew = 0;\n\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\tif (!ctx->keys_seen[i])\n\t\t\tctx->nnew++;\n\t}\n\n\tdebug3(\"%s: %zu keys from server: %zu new, %zu retained. %zu to remove\",\n\t    __func__, ctx->nkeys, ctx->nnew, ctx->nkeys - ctx->nnew, ctx->nold);\n\n\tif (ctx->nnew == 0 && ctx->nold != 0) {\n\t\t/* We have some keys to remove. Just do it. */\n\t\tupdate_known_hosts(ctx);\n\t} else if (ctx->nnew != 0) {\n\t\t/*\n\t\t * We have received hitherto-unseen keys from the server.\n\t\t * Ask the server to confirm ownership of the private halves.\n\t\t */\n\t\tdebug3(\"%s: asking server to prove ownership for %zu keys\",\n\t\t    __func__, ctx->nnew);\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"hostkeys-prove-00@openssh.com\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0) /* bool: want reply */\n\t\t\tfatal(\"%s: cannot prepare packet: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tif ((buf = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new\", __func__);\n\t\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\t\tif (ctx->keys_seen[i])\n\t\t\t\tcontinue;\n\t\t\tsshbuf_reset(buf);\n\t\t\tif ((r = sshkey_putb(ctx->keys[i], buf)) != 0)\n\t\t\t\tfatal(\"%s: sshkey_putb: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif ((r = sshpkt_put_stringb(ssh, buf)) != 0)\n\t\t\t\tfatal(\"%s: sshpkt_put_string: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\tif ((r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal(\"%s: sshpkt_send: %s\", __func__, ssh_err(r));\n\t\tclient_register_global_confirm(\n\t\t    client_global_hostkeys_private_confirm, ctx);\n\t\tctx = NULL;  /* will be freed in callback */\n\t}\n\n\t/* Success */\n out:\n\thostkeys_update_ctx_free(ctx);\n\tsshkey_free(key);\n\tsshbuf_free(buf);\n\t/*\n\t * NB. Return success for all cases. The server doesn't need to know\n\t * what the client does with its hosts file.\n\t */\n\treturn 1;\n}"
  },
  {
    "function_name": "key_accepted_by_hostkeyalgs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "1999-2013",
    "snippet": "static int\nkey_accepted_by_hostkeyalgs(const struct sshkey *key)\n{\n\tconst char *ktype = sshkey_ssh_name(key);\n\tconst char *hostkeyalgs = options.hostkeyalgorithms != NULL ?\n\t    options.hostkeyalgorithms : KEX_DEFAULT_PK_ALG;\n\n\tif (key == NULL || key->type == KEY_UNSPEC)\n\t\treturn 0;\n\tif (key->type == KEY_RSA &&\n\t    (match_pattern_list(\"rsa-sha2-256\", hostkeyalgs, 0) == 1 ||\n\t    match_pattern_list(\"rsa-sha2-512\", hostkeyalgs, 0) == 1))\n\t\treturn 1;\n\treturn match_pattern_list(ktype, hostkeyalgs, 0) == 1;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_pattern_list",
          "args": [
            "ktype",
            "hostkeyalgs",
            "0"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "120-171",
          "snippet": "int\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "key"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic int\nkey_accepted_by_hostkeyalgs(const struct sshkey *key)\n{\n\tconst char *ktype = sshkey_ssh_name(key);\n\tconst char *hostkeyalgs = options.hostkeyalgorithms != NULL ?\n\t    options.hostkeyalgorithms : KEX_DEFAULT_PK_ALG;\n\n\tif (key == NULL || key->type == KEY_UNSPEC)\n\t\treturn 0;\n\tif (key->type == KEY_RSA &&\n\t    (match_pattern_list(\"rsa-sha2-256\", hostkeyalgs, 0) == 1 ||\n\t    match_pattern_list(\"rsa-sha2-512\", hostkeyalgs, 0) == 1))\n\t\treturn 1;\n\treturn match_pattern_list(ktype, hostkeyalgs, 0) == 1;\n}"
  },
  {
    "function_name": "client_global_hostkeys_private_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "1917-1993",
    "snippet": "static void\nclient_global_hostkeys_private_confirm(struct ssh *ssh, int type,\n    u_int32_t seq, void *_ctx)\n{\n\tstruct hostkeys_update_ctx *ctx = (struct hostkeys_update_ctx *)_ctx;\n\tsize_t i, ndone;\n\tstruct sshbuf *signdata;\n\tint r, kexsigtype, use_kexsigtype;\n\tconst u_char *sig;\n\tsize_t siglen;\n\n\tif (ctx->nnew == 0)\n\t\tfatal(\"%s: ctx->nnew == 0\", __func__); /* sanity */\n\tif (type != SSH2_MSG_REQUEST_SUCCESS) {\n\t\terror(\"Server failed to confirm ownership of \"\n\t\t    \"private host keys\");\n\t\thostkeys_update_ctx_free(ctx);\n\t\treturn;\n\t}\n\tkexsigtype = sshkey_type_plain(\n\t    sshkey_type_from_name(ssh->kex->hostkey_alg));\n\n\tif ((signdata = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t/* Don't want to accidentally accept an unbound signature */\n\tif (ssh->kex->session_id_len == 0)\n\t\tfatal(\"%s: ssh->kex->session_id_len == 0\", __func__);\n\t/*\n\t * Expect a signature for each of the ctx->nnew private keys we\n\t * haven't seen before. They will be in the same order as the\n\t * ctx->keys where the corresponding ctx->keys_seen[i] == 0.\n\t */\n\tfor (ndone = i = 0; i < ctx->nkeys; i++) {\n\t\tif (ctx->keys_seen[i])\n\t\t\tcontinue;\n\t\t/* Prepare data to be signed: session ID, unique string, key */\n\t\tsshbuf_reset(signdata);\n\t\tif ( (r = sshbuf_put_cstring(signdata,\n\t\t    \"hostkeys-prove-00@openssh.com\")) != 0 ||\n\t\t    (r = sshbuf_put_string(signdata, ssh->kex->session_id,\n\t\t    ssh->kex->session_id_len)) != 0 ||\n\t\t    (r = sshkey_puts(ctx->keys[i], signdata)) != 0)\n\t\t\tfatal(\"%s: failed to prepare signature: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t/* Extract and verify signature */\n\t\tif ((r = sshpkt_get_string_direct(ssh, &sig, &siglen)) != 0) {\n\t\t\terror(\"%s: couldn't parse message: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * For RSA keys, prefer to use the signature type negotiated\n\t\t * during KEX to the default (SHA1).\n\t\t */\n\t\tuse_kexsigtype = kexsigtype == KEY_RSA &&\n\t\t    sshkey_type_plain(ctx->keys[i]->type) == KEY_RSA;\n\t\tif ((r = sshkey_verify(ctx->keys[i], sig, siglen,\n\t\t    sshbuf_ptr(signdata), sshbuf_len(signdata),\n\t\t    use_kexsigtype ? ssh->kex->hostkey_alg : NULL, 0)) != 0) {\n\t\t\terror(\"%s: server gave bad signature for %s key %zu\",\n\t\t\t    __func__, sshkey_type(ctx->keys[i]), i);\n\t\t\tgoto out;\n\t\t}\n\t\t/* Key is good. Mark it as 'seen' */\n\t\tctx->keys_seen[i] = 2;\n\t\tndone++;\n\t}\n\tif (ndone != ctx->nnew)\n\t\tfatal(\"%s: ndone != ctx->nnew (%zu / %zu)\", __func__,\n\t\t    ndone, ctx->nnew);  /* Shouldn't happen */\n\tssh_packet_check_eom(ssh);\n\n\t/* Make the edits to known_hosts */\n\tupdate_known_hosts(ctx);\n out:\n\thostkeys_update_ctx_free(ctx);\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *host;",
      "void ssh_process_session2_setup(int, int, int, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hostkeys_update_ctx_free",
          "args": [
            "ctx"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_known_hosts",
          "args": [
            "ctx"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "update_known_hosts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1848-1915",
          "snippet": "static void\nupdate_known_hosts(struct hostkeys_update_ctx *ctx)\n{\n\tint r, was_raw = 0;\n\tint loglevel = options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK ?\n\t    SYSLOG_LEVEL_INFO : SYSLOG_LEVEL_VERBOSE;\n\tchar *fp, *response;\n\tsize_t i;\n\n\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\tif (ctx->keys_seen[i] != 2)\n\t\t\tcontinue;\n\t\tif ((fp = sshkey_fingerprint(ctx->keys[i],\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tdo_log2(loglevel, \"Learned new hostkey: %s %s\",\n\t\t    sshkey_type(ctx->keys[i]), fp);\n\t\tfree(fp);\n\t}\n\tfor (i = 0; i < ctx->nold; i++) {\n\t\tif ((fp = sshkey_fingerprint(ctx->old_keys[i],\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tdo_log2(loglevel, \"Deprecating obsolete hostkey: %s %s\",\n\t\t    sshkey_type(ctx->old_keys[i]), fp);\n\t\tfree(fp);\n\t}\n\tif (options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK) {\n\t\tif (get_saved_tio() != NULL) {\n\t\t\tleave_raw_mode(1);\n\t\t\twas_raw = 1;\n\t\t}\n\t\tresponse = NULL;\n\t\tfor (i = 0; !quit_pending && i < 3; i++) {\n\t\t\tfree(response);\n\t\t\tresponse = read_passphrase(\"Accept updated hostkeys? \"\n\t\t\t    \"(yes/no): \", RP_ECHO);\n\t\t\tif (strcasecmp(response, \"yes\") == 0)\n\t\t\t\tbreak;\n\t\t\telse if (quit_pending || response == NULL ||\n\t\t\t    strcasecmp(response, \"no\") == 0) {\n\t\t\t\toptions.update_hostkeys = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdo_log2(loglevel, \"Please enter \"\n\t\t\t\t    \"\\\"yes\\\" or \\\"no\\\"\");\n\t\t\t}\n\t\t}\n\t\tif (quit_pending || i >= 3 || response == NULL)\n\t\t\toptions.update_hostkeys = 0;\n\t\tfree(response);\n\t\tif (was_raw)\n\t\t\tenter_raw_mode(1);\n\t}\n\n\t/*\n\t * Now that all the keys are verified, we can go ahead and replace\n\t * them in known_hosts (assuming SSH_UPDATE_HOSTKEYS_ASK didn't\n\t * cancel the operation).\n\t */\n\tif (options.update_hostkeys != 0 &&\n\t    (r = hostfile_replace_entries(options.user_hostfiles[0],\n\t    ctx->host_str, ctx->ip_str, ctx->keys, ctx->nkeys,\n\t    options.hash_known_hosts, 0,\n\t    options.fingerprint_hash)) != 0)\n\t\terror(\"%s: hostfile_replace_entries failed: %s\",\n\t\t    __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "volatile sig_atomic_t quit_pending;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nvolatile sig_atomic_t quit_pending;\n\nstatic void\nupdate_known_hosts(struct hostkeys_update_ctx *ctx)\n{\n\tint r, was_raw = 0;\n\tint loglevel = options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK ?\n\t    SYSLOG_LEVEL_INFO : SYSLOG_LEVEL_VERBOSE;\n\tchar *fp, *response;\n\tsize_t i;\n\n\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\tif (ctx->keys_seen[i] != 2)\n\t\t\tcontinue;\n\t\tif ((fp = sshkey_fingerprint(ctx->keys[i],\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tdo_log2(loglevel, \"Learned new hostkey: %s %s\",\n\t\t    sshkey_type(ctx->keys[i]), fp);\n\t\tfree(fp);\n\t}\n\tfor (i = 0; i < ctx->nold; i++) {\n\t\tif ((fp = sshkey_fingerprint(ctx->old_keys[i],\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tdo_log2(loglevel, \"Deprecating obsolete hostkey: %s %s\",\n\t\t    sshkey_type(ctx->old_keys[i]), fp);\n\t\tfree(fp);\n\t}\n\tif (options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK) {\n\t\tif (get_saved_tio() != NULL) {\n\t\t\tleave_raw_mode(1);\n\t\t\twas_raw = 1;\n\t\t}\n\t\tresponse = NULL;\n\t\tfor (i = 0; !quit_pending && i < 3; i++) {\n\t\t\tfree(response);\n\t\t\tresponse = read_passphrase(\"Accept updated hostkeys? \"\n\t\t\t    \"(yes/no): \", RP_ECHO);\n\t\t\tif (strcasecmp(response, \"yes\") == 0)\n\t\t\t\tbreak;\n\t\t\telse if (quit_pending || response == NULL ||\n\t\t\t    strcasecmp(response, \"no\") == 0) {\n\t\t\t\toptions.update_hostkeys = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdo_log2(loglevel, \"Please enter \"\n\t\t\t\t    \"\\\"yes\\\" or \\\"no\\\"\");\n\t\t\t}\n\t\t}\n\t\tif (quit_pending || i >= 3 || response == NULL)\n\t\t\toptions.update_hostkeys = 0;\n\t\tfree(response);\n\t\tif (was_raw)\n\t\t\tenter_raw_mode(1);\n\t}\n\n\t/*\n\t * Now that all the keys are verified, we can go ahead and replace\n\t * them in known_hosts (assuming SSH_UPDATE_HOSTKEYS_ASK didn't\n\t * cancel the operation).\n\t */\n\tif (options.update_hostkeys != 0 &&\n\t    (r = hostfile_replace_entries(options.user_hostfiles[0],\n\t    ctx->host_str, ctx->ip_str, ctx->keys, ctx->nkeys,\n\t    options.hash_known_hosts, 0,\n\t    options.fingerprint_hash)) != 0)\n\t\terror(\"%s: hostfile_replace_entries failed: %s\",\n\t\t    __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_check_eom",
          "args": [
            "ssh"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: ndone != ctx->nnew (%zu / %zu)\"",
            "__func__",
            "ndone",
            "ctx->nnew"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: server gave bad signature for %s key %zu\"",
            "__func__",
            "sshkey_type(ctx->keys[i])",
            "i"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "ctx->keys[i]"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_verify",
          "args": [
            "ctx->keys[i]",
            "sig",
            "siglen",
            "sshbuf_ptr(signdata)",
            "sshbuf_len(signdata)",
            "use_kexsigtype ? ssh->kex->hostkey_alg : NULL",
            "0"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2427-2459",
          "snippet": "int\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat)\n{\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_verify(key, sig, siglen, data, dlen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_verify(key, sig, siglen, data, dlen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_verify(key, sig, siglen, data, dlen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat)\n{\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_verify(key, sig, siglen, data, dlen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_verify(key, sig, siglen, data, dlen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_verify(key, sig, siglen, data, dlen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "signdata"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "signdata"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_string_direct",
          "args": [
            "ssh",
            "&sig",
            "&siglen"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2520-2524",
          "snippet": "int\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_puts",
          "args": [
            "ctx->keys[i]",
            "signdata"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "836-840",
          "snippet": "int\nsshkey_puts(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_puts_opts(key, b, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_puts(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_puts_opts(key, b, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "signdata",
            "ssh->kex->session_id",
            "ssh->kex->session_id_len"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "signdata",
            "\"hostkeys-prove-00@openssh.com\""
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "signdata"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: ssh->kex->session_id_len == 0\"",
            "__func__"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_from_name",
          "args": [
            "ssh->kex->hostkey_alg"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "190-202",
          "snippet": "int\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern char *host;\nvoid ssh_process_session2_setup(int, int, int, struct sshbuf *);\n\nstatic void\nclient_global_hostkeys_private_confirm(struct ssh *ssh, int type,\n    u_int32_t seq, void *_ctx)\n{\n\tstruct hostkeys_update_ctx *ctx = (struct hostkeys_update_ctx *)_ctx;\n\tsize_t i, ndone;\n\tstruct sshbuf *signdata;\n\tint r, kexsigtype, use_kexsigtype;\n\tconst u_char *sig;\n\tsize_t siglen;\n\n\tif (ctx->nnew == 0)\n\t\tfatal(\"%s: ctx->nnew == 0\", __func__); /* sanity */\n\tif (type != SSH2_MSG_REQUEST_SUCCESS) {\n\t\terror(\"Server failed to confirm ownership of \"\n\t\t    \"private host keys\");\n\t\thostkeys_update_ctx_free(ctx);\n\t\treturn;\n\t}\n\tkexsigtype = sshkey_type_plain(\n\t    sshkey_type_from_name(ssh->kex->hostkey_alg));\n\n\tif ((signdata = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t/* Don't want to accidentally accept an unbound signature */\n\tif (ssh->kex->session_id_len == 0)\n\t\tfatal(\"%s: ssh->kex->session_id_len == 0\", __func__);\n\t/*\n\t * Expect a signature for each of the ctx->nnew private keys we\n\t * haven't seen before. They will be in the same order as the\n\t * ctx->keys where the corresponding ctx->keys_seen[i] == 0.\n\t */\n\tfor (ndone = i = 0; i < ctx->nkeys; i++) {\n\t\tif (ctx->keys_seen[i])\n\t\t\tcontinue;\n\t\t/* Prepare data to be signed: session ID, unique string, key */\n\t\tsshbuf_reset(signdata);\n\t\tif ( (r = sshbuf_put_cstring(signdata,\n\t\t    \"hostkeys-prove-00@openssh.com\")) != 0 ||\n\t\t    (r = sshbuf_put_string(signdata, ssh->kex->session_id,\n\t\t    ssh->kex->session_id_len)) != 0 ||\n\t\t    (r = sshkey_puts(ctx->keys[i], signdata)) != 0)\n\t\t\tfatal(\"%s: failed to prepare signature: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t/* Extract and verify signature */\n\t\tif ((r = sshpkt_get_string_direct(ssh, &sig, &siglen)) != 0) {\n\t\t\terror(\"%s: couldn't parse message: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * For RSA keys, prefer to use the signature type negotiated\n\t\t * during KEX to the default (SHA1).\n\t\t */\n\t\tuse_kexsigtype = kexsigtype == KEY_RSA &&\n\t\t    sshkey_type_plain(ctx->keys[i]->type) == KEY_RSA;\n\t\tif ((r = sshkey_verify(ctx->keys[i], sig, siglen,\n\t\t    sshbuf_ptr(signdata), sshbuf_len(signdata),\n\t\t    use_kexsigtype ? ssh->kex->hostkey_alg : NULL, 0)) != 0) {\n\t\t\terror(\"%s: server gave bad signature for %s key %zu\",\n\t\t\t    __func__, sshkey_type(ctx->keys[i]), i);\n\t\t\tgoto out;\n\t\t}\n\t\t/* Key is good. Mark it as 'seen' */\n\t\tctx->keys_seen[i] = 2;\n\t\tndone++;\n\t}\n\tif (ndone != ctx->nnew)\n\t\tfatal(\"%s: ndone != ctx->nnew (%zu / %zu)\", __func__,\n\t\t    ndone, ctx->nnew);  /* Shouldn't happen */\n\tssh_packet_check_eom(ssh);\n\n\t/* Make the edits to known_hosts */\n\tupdate_known_hosts(ctx);\n out:\n\thostkeys_update_ctx_free(ctx);\n}"
  },
  {
    "function_name": "update_known_hosts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "1848-1915",
    "snippet": "static void\nupdate_known_hosts(struct hostkeys_update_ctx *ctx)\n{\n\tint r, was_raw = 0;\n\tint loglevel = options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK ?\n\t    SYSLOG_LEVEL_INFO : SYSLOG_LEVEL_VERBOSE;\n\tchar *fp, *response;\n\tsize_t i;\n\n\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\tif (ctx->keys_seen[i] != 2)\n\t\t\tcontinue;\n\t\tif ((fp = sshkey_fingerprint(ctx->keys[i],\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tdo_log2(loglevel, \"Learned new hostkey: %s %s\",\n\t\t    sshkey_type(ctx->keys[i]), fp);\n\t\tfree(fp);\n\t}\n\tfor (i = 0; i < ctx->nold; i++) {\n\t\tif ((fp = sshkey_fingerprint(ctx->old_keys[i],\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tdo_log2(loglevel, \"Deprecating obsolete hostkey: %s %s\",\n\t\t    sshkey_type(ctx->old_keys[i]), fp);\n\t\tfree(fp);\n\t}\n\tif (options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK) {\n\t\tif (get_saved_tio() != NULL) {\n\t\t\tleave_raw_mode(1);\n\t\t\twas_raw = 1;\n\t\t}\n\t\tresponse = NULL;\n\t\tfor (i = 0; !quit_pending && i < 3; i++) {\n\t\t\tfree(response);\n\t\t\tresponse = read_passphrase(\"Accept updated hostkeys? \"\n\t\t\t    \"(yes/no): \", RP_ECHO);\n\t\t\tif (strcasecmp(response, \"yes\") == 0)\n\t\t\t\tbreak;\n\t\t\telse if (quit_pending || response == NULL ||\n\t\t\t    strcasecmp(response, \"no\") == 0) {\n\t\t\t\toptions.update_hostkeys = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdo_log2(loglevel, \"Please enter \"\n\t\t\t\t    \"\\\"yes\\\" or \\\"no\\\"\");\n\t\t\t}\n\t\t}\n\t\tif (quit_pending || i >= 3 || response == NULL)\n\t\t\toptions.update_hostkeys = 0;\n\t\tfree(response);\n\t\tif (was_raw)\n\t\t\tenter_raw_mode(1);\n\t}\n\n\t/*\n\t * Now that all the keys are verified, we can go ahead and replace\n\t * them in known_hosts (assuming SSH_UPDATE_HOSTKEYS_ASK didn't\n\t * cancel the operation).\n\t */\n\tif (options.update_hostkeys != 0 &&\n\t    (r = hostfile_replace_entries(options.user_hostfiles[0],\n\t    ctx->host_str, ctx->ip_str, ctx->keys, ctx->nkeys,\n\t    options.hash_known_hosts, 0,\n\t    options.fingerprint_hash)) != 0)\n\t\terror(\"%s: hostfile_replace_entries failed: %s\",\n\t\t    __func__, ssh_err(r));\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "volatile sig_atomic_t quit_pending;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: hostfile_replace_entries failed: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hostfile_replace_entries",
          "args": [
            "options.user_hostfiles[0]",
            "ctx->host_str",
            "ctx->ip_str",
            "ctx->keys",
            "ctx->nkeys",
            "options.hash_known_hosts",
            "0",
            "options.fingerprint_hash"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "hostfile_replace_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "523-641",
          "snippet": "int\nhostfile_replace_entries(const char *filename, const char *host, const char *ip,\n    struct sshkey **keys, size_t nkeys, int store_hash, int quiet, int hash_alg)\n{\n\tint r, fd, oerrno = 0;\n\tint loglevel = quiet ? SYSLOG_LEVEL_DEBUG1 : SYSLOG_LEVEL_VERBOSE;\n\tstruct host_delete_ctx ctx;\n\tchar *fp, *temp = NULL, *back = NULL;\n\tmode_t omask;\n\tsize_t i;\n\n\tomask = umask(077);\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.host = host;\n\tctx.quiet = quiet;\n\tif ((ctx.skip_keys = calloc(nkeys, sizeof(*ctx.skip_keys))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tctx.keys = keys;\n\tctx.nkeys = nkeys;\n\tctx.modified = 0;\n\n\t/*\n\t * Prepare temporary file for in-place deletion.\n\t */\n\tif ((r = asprintf(&temp, \"%s.XXXXXXXXXXX\", filename)) < 0 ||\n\t    (r = asprintf(&back, \"%s.old\", filename)) < 0) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto fail;\n\t}\n\n\tif ((fd = mkstemp(temp)) == -1) {\n\t\toerrno = errno;\n\t\terror(\"%s: mkstemp: %s\", __func__, strerror(oerrno));\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto fail;\n\t}\n\tif ((ctx.out = fdopen(fd, \"w\")) == NULL) {\n\t\toerrno = errno;\n\t\tclose(fd);\n\t\terror(\"%s: fdopen: %s\", __func__, strerror(oerrno));\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto fail;\n\t}\n\n\t/* Remove all entries for the specified host from the file */\n\tif ((r = hostkeys_foreach(filename, host_delete, &ctx, host, ip,\n\t    HKF_WANT_PARSE_KEY)) != 0) {\n\t\terror(\"%s: hostkeys_foreach failed: %s\", __func__, ssh_err(r));\n\t\tgoto fail;\n\t}\n\n\t/* Add the requested keys */\n\tfor (i = 0; i < nkeys; i++) {\n\t\tif (ctx.skip_keys[i])\n\t\t\tcontinue;\n\t\tif ((fp = sshkey_fingerprint(keys[i], hash_alg,\n\t\t    SSH_FP_DEFAULT)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tdo_log2(loglevel, \"%s%sAdding new key for %s to %s: %s %s\",\n\t\t    quiet ? __func__ : \"\", quiet ? \": \" : \"\", host, filename,\n\t\t    sshkey_ssh_name(keys[i]), fp);\n\t\tfree(fp);\n\t\tif (!write_host_entry(ctx.out, host, ip, keys[i], store_hash)) {\n\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\tgoto fail;\n\t\t}\n\t\tctx.modified = 1;\n\t}\n\tfclose(ctx.out);\n\tctx.out = NULL;\n\n\tif (ctx.modified) {\n\t\t/* Backup the original file and replace it with the temporary */\n\t\tif (unlink(back) == -1 && errno != ENOENT) {\n\t\t\toerrno = errno;\n\t\t\terror(\"%s: unlink %.100s: %s\", __func__,\n\t\t\t    back, strerror(errno));\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (link(filename, back) == -1) {\n\t\t\toerrno = errno;\n\t\t\terror(\"%s: link %.100s to %.100s: %s\", __func__,\n\t\t\t    filename, back, strerror(errno));\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (rename(temp, filename) == -1) {\n\t\t\toerrno = errno;\n\t\t\terror(\"%s: rename \\\"%s\\\" to \\\"%s\\\": %s\", __func__,\n\t\t\t    temp, filename, strerror(errno));\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\t/* No changes made; just delete the temporary file */\n\t\tif (unlink(temp) != 0)\n\t\t\terror(\"%s: unlink \\\"%s\\\": %s\", __func__,\n\t\t\t    temp, strerror(errno));\n\t}\n\n\t/* success */\n\tr = 0;\n fail:\n\tif (temp != NULL && r != 0)\n\t\tunlink(temp);\n\tfree(temp);\n\tfree(back);\n\tif (ctx.out != NULL)\n\t\tfclose(ctx.out);\n\tfree(ctx.skip_keys);\n\tumask(omask);\n\tif (r == SSH_ERR_SYSTEM_ERROR)\n\t\terrno = oerrno;\n\treturn r;\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nhostfile_replace_entries(const char *filename, const char *host, const char *ip,\n    struct sshkey **keys, size_t nkeys, int store_hash, int quiet, int hash_alg)\n{\n\tint r, fd, oerrno = 0;\n\tint loglevel = quiet ? SYSLOG_LEVEL_DEBUG1 : SYSLOG_LEVEL_VERBOSE;\n\tstruct host_delete_ctx ctx;\n\tchar *fp, *temp = NULL, *back = NULL;\n\tmode_t omask;\n\tsize_t i;\n\n\tomask = umask(077);\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.host = host;\n\tctx.quiet = quiet;\n\tif ((ctx.skip_keys = calloc(nkeys, sizeof(*ctx.skip_keys))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tctx.keys = keys;\n\tctx.nkeys = nkeys;\n\tctx.modified = 0;\n\n\t/*\n\t * Prepare temporary file for in-place deletion.\n\t */\n\tif ((r = asprintf(&temp, \"%s.XXXXXXXXXXX\", filename)) < 0 ||\n\t    (r = asprintf(&back, \"%s.old\", filename)) < 0) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto fail;\n\t}\n\n\tif ((fd = mkstemp(temp)) == -1) {\n\t\toerrno = errno;\n\t\terror(\"%s: mkstemp: %s\", __func__, strerror(oerrno));\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto fail;\n\t}\n\tif ((ctx.out = fdopen(fd, \"w\")) == NULL) {\n\t\toerrno = errno;\n\t\tclose(fd);\n\t\terror(\"%s: fdopen: %s\", __func__, strerror(oerrno));\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto fail;\n\t}\n\n\t/* Remove all entries for the specified host from the file */\n\tif ((r = hostkeys_foreach(filename, host_delete, &ctx, host, ip,\n\t    HKF_WANT_PARSE_KEY)) != 0) {\n\t\terror(\"%s: hostkeys_foreach failed: %s\", __func__, ssh_err(r));\n\t\tgoto fail;\n\t}\n\n\t/* Add the requested keys */\n\tfor (i = 0; i < nkeys; i++) {\n\t\tif (ctx.skip_keys[i])\n\t\t\tcontinue;\n\t\tif ((fp = sshkey_fingerprint(keys[i], hash_alg,\n\t\t    SSH_FP_DEFAULT)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tdo_log2(loglevel, \"%s%sAdding new key for %s to %s: %s %s\",\n\t\t    quiet ? __func__ : \"\", quiet ? \": \" : \"\", host, filename,\n\t\t    sshkey_ssh_name(keys[i]), fp);\n\t\tfree(fp);\n\t\tif (!write_host_entry(ctx.out, host, ip, keys[i], store_hash)) {\n\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\tgoto fail;\n\t\t}\n\t\tctx.modified = 1;\n\t}\n\tfclose(ctx.out);\n\tctx.out = NULL;\n\n\tif (ctx.modified) {\n\t\t/* Backup the original file and replace it with the temporary */\n\t\tif (unlink(back) == -1 && errno != ENOENT) {\n\t\t\toerrno = errno;\n\t\t\terror(\"%s: unlink %.100s: %s\", __func__,\n\t\t\t    back, strerror(errno));\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (link(filename, back) == -1) {\n\t\t\toerrno = errno;\n\t\t\terror(\"%s: link %.100s to %.100s: %s\", __func__,\n\t\t\t    filename, back, strerror(errno));\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (rename(temp, filename) == -1) {\n\t\t\toerrno = errno;\n\t\t\terror(\"%s: rename \\\"%s\\\" to \\\"%s\\\": %s\", __func__,\n\t\t\t    temp, filename, strerror(errno));\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\t/* No changes made; just delete the temporary file */\n\t\tif (unlink(temp) != 0)\n\t\t\terror(\"%s: unlink \\\"%s\\\": %s\", __func__,\n\t\t\t    temp, strerror(errno));\n\t}\n\n\t/* success */\n\tr = 0;\n fail:\n\tif (temp != NULL && r != 0)\n\t\tunlink(temp);\n\tfree(temp);\n\tfree(back);\n\tif (ctx.out != NULL)\n\t\tfclose(ctx.out);\n\tfree(ctx.skip_keys);\n\tumask(omask);\n\tif (r == SSH_ERR_SYSTEM_ERROR)\n\t\terrno = oerrno;\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enter_raw_mode",
          "args": [
            "1"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "enter_raw_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshtty.c",
          "lines": "68-96",
          "snippet": "void\nenter_raw_mode(int quiet)\n{\n\tstruct termios tio;\n\n\tif (tcgetattr(fileno(stdin), &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcgetattr\");\n\t\treturn;\n\t}\n\t_saved_tio = tio;\n\ttio.c_iflag |= IGNPAR;\n\ttio.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);\n#ifdef IUCLC\n\ttio.c_iflag &= ~IUCLC;\n#endif\n\ttio.c_lflag &= ~(ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);\n#ifdef IEXTEN\n\ttio.c_lflag &= ~IEXTEN;\n#endif\n\ttio.c_oflag &= ~OPOST;\n\ttio.c_cc[VMIN] = 1;\n\ttio.c_cc[VTIME] = 0;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 1;\n}",
          "includes": [
            "#include \"sshpty.h\"",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios _saved_tio;",
            "static int _in_raw_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sshpty.h\"\n#include <pwd.h>\n#include <termios.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct termios _saved_tio;\nstatic int _in_raw_mode = 0;\n\nvoid\nenter_raw_mode(int quiet)\n{\n\tstruct termios tio;\n\n\tif (tcgetattr(fileno(stdin), &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcgetattr\");\n\t\treturn;\n\t}\n\t_saved_tio = tio;\n\ttio.c_iflag |= IGNPAR;\n\ttio.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);\n#ifdef IUCLC\n\ttio.c_iflag &= ~IUCLC;\n#endif\n\ttio.c_lflag &= ~(ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);\n#ifdef IEXTEN\n\ttio.c_lflag &= ~IEXTEN;\n#endif\n\ttio.c_oflag &= ~OPOST;\n\ttio.c_cc[VMIN] = 1;\n\ttio.c_cc[VTIME] = 0;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "response"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_log2",
          "args": [
            "loglevel",
            "\"Please enter \"\n\t\t\t\t    \"\\\"yes\\\" or \\\"no\\\"\""
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "do_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "390-398",
          "snippet": "void\ndo_log2(LogLevel level, const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(level, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndo_log2(LogLevel level, const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(level, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "response",
            "\"no\""
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "response",
            "\"yes\""
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_passphrase",
          "args": [
            "\"Accept updated hostkeys? \"\n\t\t\t    \"(yes/no): \"",
            "RP_ECHO"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "read_passphrase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readpass.c",
          "lines": "117-166",
          "snippet": "char *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "leave_raw_mode",
          "args": [
            "1"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "leave_raw_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshtty.c",
          "lines": "56-66",
          "snippet": "void\nleave_raw_mode(int quiet)\n{\n\tif (!_in_raw_mode)\n\t\treturn;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 0;\n}",
          "includes": [
            "#include \"sshpty.h\"",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios _saved_tio;",
            "static int _in_raw_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sshpty.h\"\n#include <pwd.h>\n#include <termios.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct termios _saved_tio;\nstatic int _in_raw_mode = 0;\n\nvoid\nleave_raw_mode(int quiet)\n{\n\tif (!_in_raw_mode)\n\t\treturn;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_saved_tio",
          "args": [],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "get_saved_tio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshtty.c",
          "lines": "50-54",
          "snippet": "struct termios *\nget_saved_tio(void)\n{\n\treturn _in_raw_mode ? &_saved_tio : NULL;\n}",
          "includes": [
            "#include \"sshpty.h\"",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios _saved_tio;",
            "static int _in_raw_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sshpty.h\"\n#include <pwd.h>\n#include <termios.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct termios _saved_tio;\nstatic int _in_raw_mode = 0;\n\nstruct termios *\nget_saved_tio(void)\n{\n\treturn _in_raw_mode ? &_saved_tio : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "ctx->old_keys[i]"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshkey_fingerprint failed\"",
            "__func__"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "ctx->old_keys[i]",
            "options.fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nvolatile sig_atomic_t quit_pending;\n\nstatic void\nupdate_known_hosts(struct hostkeys_update_ctx *ctx)\n{\n\tint r, was_raw = 0;\n\tint loglevel = options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK ?\n\t    SYSLOG_LEVEL_INFO : SYSLOG_LEVEL_VERBOSE;\n\tchar *fp, *response;\n\tsize_t i;\n\n\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\tif (ctx->keys_seen[i] != 2)\n\t\t\tcontinue;\n\t\tif ((fp = sshkey_fingerprint(ctx->keys[i],\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tdo_log2(loglevel, \"Learned new hostkey: %s %s\",\n\t\t    sshkey_type(ctx->keys[i]), fp);\n\t\tfree(fp);\n\t}\n\tfor (i = 0; i < ctx->nold; i++) {\n\t\tif ((fp = sshkey_fingerprint(ctx->old_keys[i],\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tdo_log2(loglevel, \"Deprecating obsolete hostkey: %s %s\",\n\t\t    sshkey_type(ctx->old_keys[i]), fp);\n\t\tfree(fp);\n\t}\n\tif (options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK) {\n\t\tif (get_saved_tio() != NULL) {\n\t\t\tleave_raw_mode(1);\n\t\t\twas_raw = 1;\n\t\t}\n\t\tresponse = NULL;\n\t\tfor (i = 0; !quit_pending && i < 3; i++) {\n\t\t\tfree(response);\n\t\t\tresponse = read_passphrase(\"Accept updated hostkeys? \"\n\t\t\t    \"(yes/no): \", RP_ECHO);\n\t\t\tif (strcasecmp(response, \"yes\") == 0)\n\t\t\t\tbreak;\n\t\t\telse if (quit_pending || response == NULL ||\n\t\t\t    strcasecmp(response, \"no\") == 0) {\n\t\t\t\toptions.update_hostkeys = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdo_log2(loglevel, \"Please enter \"\n\t\t\t\t    \"\\\"yes\\\" or \\\"no\\\"\");\n\t\t\t}\n\t\t}\n\t\tif (quit_pending || i >= 3 || response == NULL)\n\t\t\toptions.update_hostkeys = 0;\n\t\tfree(response);\n\t\tif (was_raw)\n\t\t\tenter_raw_mode(1);\n\t}\n\n\t/*\n\t * Now that all the keys are verified, we can go ahead and replace\n\t * them in known_hosts (assuming SSH_UPDATE_HOSTKEYS_ASK didn't\n\t * cancel the operation).\n\t */\n\tif (options.update_hostkeys != 0 &&\n\t    (r = hostfile_replace_entries(options.user_hostfiles[0],\n\t    ctx->host_str, ctx->ip_str, ctx->keys, ctx->nkeys,\n\t    options.hash_known_hosts, 0,\n\t    options.fingerprint_hash)) != 0)\n\t\terror(\"%s: hostfile_replace_entries failed: %s\",\n\t\t    __func__, ssh_err(r));\n}"
  },
  {
    "function_name": "hostkeys_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "1815-1846",
    "snippet": "static int\nhostkeys_find(struct hostkey_foreach_line *l, void *_ctx)\n{\n\tstruct hostkeys_update_ctx *ctx = (struct hostkeys_update_ctx *)_ctx;\n\tsize_t i;\n\tstruct sshkey **tmp;\n\n\tif (l->status != HKF_STATUS_MATCHED || l->key == NULL)\n\t\treturn 0;\n\n\t/* Mark off keys we've already seen for this host */\n\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\tif (sshkey_equal(l->key, ctx->keys[i])) {\n\t\t\tdebug3(\"%s: found %s key at %s:%ld\", __func__,\n\t\t\t    sshkey_ssh_name(ctx->keys[i]), l->path, l->linenum);\n\t\t\tctx->keys_seen[i] = 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/* This line contained a key that not offered by the server */\n\tdebug3(\"%s: deprecated %s key at %s:%ld\", __func__,\n\t    sshkey_ssh_name(l->key), l->path, l->linenum);\n\tif ((tmp = recallocarray(ctx->old_keys, ctx->nold, ctx->nold + 1,\n\t    sizeof(*ctx->old_keys))) == NULL)\n\t\tfatal(\"%s: recallocarray failed nold = %zu\",\n\t\t    __func__, ctx->nold);\n\tctx->old_keys = tmp;\n\tctx->old_keys[ctx->nold++] = l->key;\n\tl->key = NULL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *host;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: recallocarray failed nold = %zu\"",
            "__func__",
            "ctx->nold"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recallocarray",
          "args": [
            "ctx->old_keys",
            "ctx->nold",
            "ctx->nold + 1",
            "sizeof(*ctx->old_keys)"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: deprecated %s key at %s:%ld\"",
            "__func__",
            "sshkey_ssh_name(l->key)",
            "l->path",
            "l->linenum"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "l->key"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_equal",
          "args": [
            "l->key",
            "ctx->keys[i]"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "704-714",
          "snippet": "int\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern char *host;\n\nstatic int\nhostkeys_find(struct hostkey_foreach_line *l, void *_ctx)\n{\n\tstruct hostkeys_update_ctx *ctx = (struct hostkeys_update_ctx *)_ctx;\n\tsize_t i;\n\tstruct sshkey **tmp;\n\n\tif (l->status != HKF_STATUS_MATCHED || l->key == NULL)\n\t\treturn 0;\n\n\t/* Mark off keys we've already seen for this host */\n\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\tif (sshkey_equal(l->key, ctx->keys[i])) {\n\t\t\tdebug3(\"%s: found %s key at %s:%ld\", __func__,\n\t\t\t    sshkey_ssh_name(ctx->keys[i]), l->path, l->linenum);\n\t\t\tctx->keys_seen[i] = 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/* This line contained a key that not offered by the server */\n\tdebug3(\"%s: deprecated %s key at %s:%ld\", __func__,\n\t    sshkey_ssh_name(l->key), l->path, l->linenum);\n\tif ((tmp = recallocarray(ctx->old_keys, ctx->nold, ctx->nold + 1,\n\t    sizeof(*ctx->old_keys))) == NULL)\n\t\tfatal(\"%s: recallocarray failed nold = %zu\",\n\t\t    __func__, ctx->nold);\n\tctx->old_keys = tmp;\n\tctx->old_keys[ctx->nold++] = l->key;\n\tl->key = NULL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hostkeys_update_ctx_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "1796-1813",
    "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ctx"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "ctx->old_keys[i]"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
  },
  {
    "function_name": "client_input_channel_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "1719-1771",
    "snippet": "static int\nclient_input_channel_req(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tint exitval, id, reply, success = 0;\n\tchar *rtype;\n\n\tid = packet_get_int();\n\tc = channel_lookup(ssh, id);\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\trtype = packet_get_string(NULL);\n\treply = packet_get_char();\n\n\tdebug(\"client_input_channel_req: channel %d rtype %s reply %d\",\n\t    id, rtype, reply);\n\n\tif (id == -1) {\n\t\terror(\"client_input_channel_req: request for channel -1\");\n\t} else if (c == NULL) {\n\t\terror(\"client_input_channel_req: channel %d: \"\n\t\t    \"unknown channel\", id);\n\t} else if (strcmp(rtype, \"eow@openssh.com\") == 0) {\n\t\tpacket_check_eom();\n\t\tchan_rcvd_eow(ssh, c);\n\t} else if (strcmp(rtype, \"exit-status\") == 0) {\n\t\texitval = packet_get_int();\n\t\tif (c->ctl_chan != -1) {\n\t\t\tmux_exit_message(ssh, c, exitval);\n\t\t\tsuccess = 1;\n\t\t} else if (id == session_ident) {\n\t\t\t/* Record exit value of local session */\n\t\t\tsuccess = 1;\n\t\t\texit_status = exitval;\n\t\t} else {\n\t\t\t/* Probably for a mux channel that has already closed */\n\t\t\tdebug(\"%s: no sink for exit-status on channel %d\",\n\t\t\t    __func__, id);\n\t\t}\n\t\tpacket_check_eom();\n\t}\n\tif (reply && c != NULL && !(c->flags & CHAN_CLOSE_SENT)) {\n\t\tif (!c->have_remote_id)\n\t\t\tfatal(\"%s: channel %d: no remote_id\",\n\t\t\t    __func__, c->self);\n\t\tpacket_start(success ?\n\t\t    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE);\n\t\tpacket_put_int(c->remote_id);\n\t\tpacket_send();\n\t}\n\tfree(rtype);\n\treturn 0;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int exit_status;",
      "int\tsession_ident = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rtype"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "c->remote_id"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_start",
          "args": [
            "success ?\n\t\t    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %d: no remote_id\"",
            "__func__",
            "c->self"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_check_eom",
          "args": [],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: no sink for exit-status on channel %d\"",
            "__func__",
            "id"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_exit_message",
          "args": [
            "ssh",
            "c",
            "exitval"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "mux_exit_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1228-1251",
          "snippet": "void\nmux_exit_message(struct ssh *ssh, Channel *c, int exitval)\n{\n\tstruct sshbuf *m;\n\tChannel *mux_chan;\n\tint r;\n\n\tdebug3(\"%s: channel %d: exit message, exitval %d\", __func__, c->self,\n\t    exitval);\n\n\tif ((mux_chan = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\tfatal(\"%s: channel %d missing mux channel %d\",\n\t\t    __func__, c->self, c->ctl_chan);\n\n\t/* Append exit message packet to control socket output queue */\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_S_EXIT_MESSAGE)) != 0 ||\n\t    (r = sshbuf_put_u32(m, c->self)) != 0 ||\n\t    (r = sshbuf_put_u32(m, exitval)) != 0 ||\n\t    (r = sshbuf_put_stringb(mux_chan->output, m)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\tsshbuf_free(m);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_S_EXIT_MESSAGE\t0x80000004"
          ],
          "globals_used": [
            "static void mux_session_confirm(struct ssh *, int, int, void *);",
            "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_EXIT_MESSAGE\t0x80000004\n\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nvoid\nmux_exit_message(struct ssh *ssh, Channel *c, int exitval)\n{\n\tstruct sshbuf *m;\n\tChannel *mux_chan;\n\tint r;\n\n\tdebug3(\"%s: channel %d: exit message, exitval %d\", __func__, c->self,\n\t    exitval);\n\n\tif ((mux_chan = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\tfatal(\"%s: channel %d missing mux channel %d\",\n\t\t    __func__, c->self, c->ctl_chan);\n\n\t/* Append exit message packet to control socket output queue */\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_S_EXIT_MESSAGE)) != 0 ||\n\t    (r = sshbuf_put_u32(m, c->self)) != 0 ||\n\t    (r = sshbuf_put_u32(m, exitval)) != 0 ||\n\t    (r = sshbuf_put_stringb(mux_chan->output, m)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\tsshbuf_free(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_int",
          "args": [],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "227-231",
          "snippet": "u_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rtype",
            "\"exit-status\""
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_rcvd_eow",
          "args": [
            "ssh",
            "c"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "chan_rcvd_eow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "167-177",
          "snippet": "void\nchan_rcvd_eow(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: rcvd eow\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_rcvd_eow(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: rcvd eow\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_check_eom",
          "args": [],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"client_input_channel_req: channel %d: \"\n\t\t    \"unknown channel\"",
            "id"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_char",
          "args": [],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "221-225",
          "snippet": "u_int\npacket_get_char(void)\n{\n\treturn (ssh_packet_get_char(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_char(void)\n{\n\treturn (ssh_packet_get_char(active_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "NULL"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_proxy_upstream",
          "args": [
            "c",
            "type",
            "seq",
            "ssh"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "channel_proxy_upstream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2865-2943",
          "snippet": "int\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_lookup",
          "args": [
            "ssh",
            "id"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "channel_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "279-302",
          "snippet": "Channel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int exit_status;\nint\tsession_ident = -1;\n\nstatic int\nclient_input_channel_req(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tint exitval, id, reply, success = 0;\n\tchar *rtype;\n\n\tid = packet_get_int();\n\tc = channel_lookup(ssh, id);\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\trtype = packet_get_string(NULL);\n\treply = packet_get_char();\n\n\tdebug(\"client_input_channel_req: channel %d rtype %s reply %d\",\n\t    id, rtype, reply);\n\n\tif (id == -1) {\n\t\terror(\"client_input_channel_req: request for channel -1\");\n\t} else if (c == NULL) {\n\t\terror(\"client_input_channel_req: channel %d: \"\n\t\t    \"unknown channel\", id);\n\t} else if (strcmp(rtype, \"eow@openssh.com\") == 0) {\n\t\tpacket_check_eom();\n\t\tchan_rcvd_eow(ssh, c);\n\t} else if (strcmp(rtype, \"exit-status\") == 0) {\n\t\texitval = packet_get_int();\n\t\tif (c->ctl_chan != -1) {\n\t\t\tmux_exit_message(ssh, c, exitval);\n\t\t\tsuccess = 1;\n\t\t} else if (id == session_ident) {\n\t\t\t/* Record exit value of local session */\n\t\t\tsuccess = 1;\n\t\t\texit_status = exitval;\n\t\t} else {\n\t\t\t/* Probably for a mux channel that has already closed */\n\t\t\tdebug(\"%s: no sink for exit-status on channel %d\",\n\t\t\t    __func__, id);\n\t\t}\n\t\tpacket_check_eom();\n\t}\n\tif (reply && c != NULL && !(c->flags & CHAN_CLOSE_SENT)) {\n\t\tif (!c->have_remote_id)\n\t\t\tfatal(\"%s: channel %d: no remote_id\",\n\t\t\t    __func__, c->self);\n\t\tpacket_start(success ?\n\t\t    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE);\n\t\tpacket_put_int(c->remote_id);\n\t\tpacket_send();\n\t}\n\tfree(rtype);\n\treturn 0;\n}"
  },
  {
    "function_name": "client_input_channel_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "1664-1717",
    "snippet": "static int\nclient_input_channel_open(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tchar *ctype;\n\tint rchan;\n\tu_int rmaxpack, rwindow, len;\n\n\tctype = packet_get_string(&len);\n\trchan = packet_get_int();\n\trwindow = packet_get_int();\n\trmaxpack = packet_get_int();\n\n\tdebug(\"client_input_channel_open: ctype %s rchan %d win %d max %d\",\n\t    ctype, rchan, rwindow, rmaxpack);\n\n\tif (strcmp(ctype, \"forwarded-tcpip\") == 0) {\n\t\tc = client_request_forwarded_tcpip(ssh, ctype, rchan, rwindow,\n\t\t    rmaxpack);\n\t} else if (strcmp(ctype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\tc = client_request_forwarded_streamlocal(ssh, ctype, rchan);\n\t} else if (strcmp(ctype, \"x11\") == 0) {\n\t\tc = client_request_x11(ssh, ctype, rchan);\n\t} else if (strcmp(ctype, \"auth-agent@openssh.com\") == 0) {\n\t\tc = client_request_agent(ssh, ctype, rchan);\n\t}\n\tif (c != NULL && c->type == SSH_CHANNEL_MUX_CLIENT) {\n\t\tdebug3(\"proxied to downstream: %s\", ctype);\n\t} else if (c != NULL) {\n\t\tdebug(\"confirm %s\", ctype);\n\t\tc->remote_id = rchan;\n\t\tc->have_remote_id = 1;\n\t\tc->remote_window = rwindow;\n\t\tc->remote_maxpacket = rmaxpack;\n\t\tif (c->type != SSH_CHANNEL_CONNECTING) {\n\t\t\tpacket_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);\n\t\t\tpacket_put_int(c->remote_id);\n\t\t\tpacket_put_int(c->self);\n\t\t\tpacket_put_int(c->local_window);\n\t\t\tpacket_put_int(c->local_maxpacket);\n\t\t\tpacket_send();\n\t\t}\n\t} else {\n\t\tdebug(\"failure %s\", ctype);\n\t\tpacket_start(SSH2_MSG_CHANNEL_OPEN_FAILURE);\n\t\tpacket_put_int(rchan);\n\t\tpacket_put_int(SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED);\n\t\tpacket_put_cstring(\"open failed\");\n\t\tpacket_put_cstring(\"\");\n\t\tpacket_send();\n\t}\n\tfree(ctype);\n\treturn 0;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ctype"
          ],
          "line": 1715
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "\"\""
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "\"open failed\""
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "rchan"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_start",
          "args": [
            "SSH2_MSG_CHANNEL_OPEN_FAILURE"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"failure %s\"",
            "ctype"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "c->local_maxpacket"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "c->local_window"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "c->self"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "c->remote_id"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_start",
          "args": [
            "SSH2_MSG_CHANNEL_OPEN_CONFIRMATION"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client_request_agent",
          "args": [
            "ssh",
            "ctype",
            "rchan"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "client_request_agent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1595-1619",
          "snippet": "static Channel *\nclient_request_agent(struct ssh *ssh, const char *request_type, int rchan)\n{\n\tChannel *c = NULL;\n\tint r, sock;\n\n\tif (!options.forward_agent) {\n\t\terror(\"Warning: ssh server tried agent forwarding.\");\n\t\terror(\"Warning: this is probably a break-in attempt by a \"\n\t\t    \"malicious server.\");\n\t\treturn NULL;\n\t}\n\tif ((r = ssh_get_authentication_socket(&sock)) != 0) {\n\t\tif (r != SSH_ERR_AGENT_NOT_PRESENT)\n\t\t\tdebug(\"%s: ssh_get_authentication_socket: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\treturn NULL;\n\t}\n\tc = channel_new(ssh, \"authentication agent connection\",\n\t    SSH_CHANNEL_OPEN, sock, sock, -1,\n\t    CHAN_X11_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0,\n\t    \"authentication agent connection\", 1);\n\tc->force_drain = 1;\n\treturn c;\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic Channel *\nclient_request_agent(struct ssh *ssh, const char *request_type, int rchan)\n{\n\tChannel *c = NULL;\n\tint r, sock;\n\n\tif (!options.forward_agent) {\n\t\terror(\"Warning: ssh server tried agent forwarding.\");\n\t\terror(\"Warning: this is probably a break-in attempt by a \"\n\t\t    \"malicious server.\");\n\t\treturn NULL;\n\t}\n\tif ((r = ssh_get_authentication_socket(&sock)) != 0) {\n\t\tif (r != SSH_ERR_AGENT_NOT_PRESENT)\n\t\t\tdebug(\"%s: ssh_get_authentication_socket: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\treturn NULL;\n\t}\n\tc = channel_new(ssh, \"authentication agent connection\",\n\t    SSH_CHANNEL_OPEN, sock, sock, -1,\n\t    CHAN_X11_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0,\n\t    \"authentication agent connection\", 1);\n\tc->force_drain = 1;\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ctype",
            "\"auth-agent@openssh.com\""
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_request_x11",
          "args": [
            "ssh",
            "ctype",
            "rchan"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "client_request_x11",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1559-1593",
          "snippet": "static Channel *\nclient_request_x11(struct ssh *ssh, const char *request_type, int rchan)\n{\n\tChannel *c = NULL;\n\tchar *originator;\n\tu_short originator_port;\n\tint sock;\n\n\tif (!options.forward_x11) {\n\t\terror(\"Warning: ssh server tried X11 forwarding.\");\n\t\terror(\"Warning: this is probably a break-in attempt by a \"\n\t\t    \"malicious server.\");\n\t\treturn NULL;\n\t}\n\tif (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {\n\t\tverbose(\"Rejected X11 connection after ForwardX11Timeout \"\n\t\t    \"expired\");\n\t\treturn NULL;\n\t}\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\t/* XXX check permission */\n\tdebug(\"client_request_x11: request from %s %d\", originator,\n\t    originator_port);\n\tfree(originator);\n\tsock = x11_connect_display(ssh);\n\tif (sock < 0)\n\t\treturn NULL;\n\tc = channel_new(ssh, \"x11\",\n\t    SSH_CHANNEL_X11_OPEN, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT, 0, \"x11\", 1);\n\tc->force_drain = 1;\n\treturn c;\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "static u_int x11_refuse_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic u_int x11_refuse_time;\n\nstatic Channel *\nclient_request_x11(struct ssh *ssh, const char *request_type, int rchan)\n{\n\tChannel *c = NULL;\n\tchar *originator;\n\tu_short originator_port;\n\tint sock;\n\n\tif (!options.forward_x11) {\n\t\terror(\"Warning: ssh server tried X11 forwarding.\");\n\t\terror(\"Warning: this is probably a break-in attempt by a \"\n\t\t    \"malicious server.\");\n\t\treturn NULL;\n\t}\n\tif (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {\n\t\tverbose(\"Rejected X11 connection after ForwardX11Timeout \"\n\t\t    \"expired\");\n\t\treturn NULL;\n\t}\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\t/* XXX check permission */\n\tdebug(\"client_request_x11: request from %s %d\", originator,\n\t    originator_port);\n\tfree(originator);\n\tsock = x11_connect_display(ssh);\n\tif (sock < 0)\n\t\treturn NULL;\n\tc = channel_new(ssh, \"x11\",\n\t    SSH_CHANNEL_X11_OPEN, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT, 0, \"x11\", 1);\n\tc->force_drain = 1;\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_request_forwarded_streamlocal",
          "args": [
            "ssh",
            "ctype",
            "rchan"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "client_request_forwarded_streamlocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1537-1557",
          "snippet": "static Channel *\nclient_request_forwarded_streamlocal(struct ssh *ssh,\n    const char *request_type, int rchan)\n{\n\tChannel *c = NULL;\n\tchar *listen_path;\n\n\t/* Get the remote path. */\n\tlisten_path = packet_get_string(NULL);\n\t/* XXX: Skip reserved field for now. */\n\tif (packet_get_string_ptr(NULL) == NULL)\n\t\tfatal(\"%s: packet_get_string_ptr failed\", __func__);\n\tpacket_check_eom();\n\n\tdebug(\"%s: %s\", __func__, listen_path);\n\n\tc = channel_connect_by_listen_path(ssh, listen_path,\n\t    \"forwarded-streamlocal@openssh.com\", \"forwarded-streamlocal\");\n\tfree(listen_path);\n\treturn c;\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *\nclient_request_forwarded_streamlocal(struct ssh *ssh,\n    const char *request_type, int rchan)\n{\n\tChannel *c = NULL;\n\tchar *listen_path;\n\n\t/* Get the remote path. */\n\tlisten_path = packet_get_string(NULL);\n\t/* XXX: Skip reserved field for now. */\n\tif (packet_get_string_ptr(NULL) == NULL)\n\t\tfatal(\"%s: packet_get_string_ptr failed\", __func__);\n\tpacket_check_eom();\n\n\tdebug(\"%s: %s\", __func__, listen_path);\n\n\tc = channel_connect_by_listen_path(ssh, listen_path,\n\t    \"forwarded-streamlocal@openssh.com\", \"forwarded-streamlocal\");\n\tfree(listen_path);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_request_forwarded_tcpip",
          "args": [
            "ssh",
            "ctype",
            "rchan",
            "rwindow",
            "rmaxpack"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "client_request_forwarded_tcpip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1484-1535",
          "snippet": "static Channel *\nclient_request_forwarded_tcpip(struct ssh *ssh, const char *request_type,\n    int rchan, u_int rwindow, u_int rmaxpack)\n{\n\tChannel *c = NULL;\n\tstruct sshbuf *b = NULL;\n\tchar *listen_address, *originator_address;\n\tu_short listen_port, originator_port;\n\tint r;\n\n\t/* Get rest of the packet */\n\tlisten_address = packet_get_string(NULL);\n\tlisten_port = packet_get_int();\n\toriginator_address = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"%s: listen %s port %d, originator %s port %d\", __func__,\n\t    listen_address, listen_port, originator_address, originator_port);\n\n\tc = channel_connect_by_listen_address(ssh, listen_address, listen_port,\n\t    \"forwarded-tcpip\", originator_address);\n\n\tif (c != NULL && c->type == SSH_CHANNEL_MUX_CLIENT) {\n\t\tif ((b = sshbuf_new()) == NULL) {\n\t\t\terror(\"%s: alloc reply\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\t/* reconstruct and send to muxclient */\n\t\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t\t    (r = sshbuf_put_u8(b, SSH2_MSG_CHANNEL_OPEN)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, request_type)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, rchan)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, rwindow)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, rmaxpack)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, listen_address)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, listen_port)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, originator_address)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, originator_port)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(c->output, b)) != 0) {\n\t\t\terror(\"%s: compose for muxclient %s\", __func__,\n\t\t\t    ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n out:\n\tsshbuf_free(b);\n\tfree(originator_address);\n\tfree(listen_address);\n\treturn c;\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssh_process_session2_setup(int, int, int, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid ssh_process_session2_setup(int, int, int, struct sshbuf *);\n\nstatic Channel *\nclient_request_forwarded_tcpip(struct ssh *ssh, const char *request_type,\n    int rchan, u_int rwindow, u_int rmaxpack)\n{\n\tChannel *c = NULL;\n\tstruct sshbuf *b = NULL;\n\tchar *listen_address, *originator_address;\n\tu_short listen_port, originator_port;\n\tint r;\n\n\t/* Get rest of the packet */\n\tlisten_address = packet_get_string(NULL);\n\tlisten_port = packet_get_int();\n\toriginator_address = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"%s: listen %s port %d, originator %s port %d\", __func__,\n\t    listen_address, listen_port, originator_address, originator_port);\n\n\tc = channel_connect_by_listen_address(ssh, listen_address, listen_port,\n\t    \"forwarded-tcpip\", originator_address);\n\n\tif (c != NULL && c->type == SSH_CHANNEL_MUX_CLIENT) {\n\t\tif ((b = sshbuf_new()) == NULL) {\n\t\t\terror(\"%s: alloc reply\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\t/* reconstruct and send to muxclient */\n\t\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t\t    (r = sshbuf_put_u8(b, SSH2_MSG_CHANNEL_OPEN)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, request_type)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, rchan)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, rwindow)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, rmaxpack)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, listen_address)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, listen_port)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, originator_address)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, originator_port)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(c->output, b)) != 0) {\n\t\t\terror(\"%s: compose for muxclient %s\", __func__,\n\t\t\t    ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n out:\n\tsshbuf_free(b);\n\tfree(originator_address);\n\tfree(listen_address);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_int",
          "args": [],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "227-231",
          "snippet": "u_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "&len"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nclient_input_channel_open(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tchar *ctype;\n\tint rchan;\n\tu_int rmaxpack, rwindow, len;\n\n\tctype = packet_get_string(&len);\n\trchan = packet_get_int();\n\trwindow = packet_get_int();\n\trmaxpack = packet_get_int();\n\n\tdebug(\"client_input_channel_open: ctype %s rchan %d win %d max %d\",\n\t    ctype, rchan, rwindow, rmaxpack);\n\n\tif (strcmp(ctype, \"forwarded-tcpip\") == 0) {\n\t\tc = client_request_forwarded_tcpip(ssh, ctype, rchan, rwindow,\n\t\t    rmaxpack);\n\t} else if (strcmp(ctype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\tc = client_request_forwarded_streamlocal(ssh, ctype, rchan);\n\t} else if (strcmp(ctype, \"x11\") == 0) {\n\t\tc = client_request_x11(ssh, ctype, rchan);\n\t} else if (strcmp(ctype, \"auth-agent@openssh.com\") == 0) {\n\t\tc = client_request_agent(ssh, ctype, rchan);\n\t}\n\tif (c != NULL && c->type == SSH_CHANNEL_MUX_CLIENT) {\n\t\tdebug3(\"proxied to downstream: %s\", ctype);\n\t} else if (c != NULL) {\n\t\tdebug(\"confirm %s\", ctype);\n\t\tc->remote_id = rchan;\n\t\tc->have_remote_id = 1;\n\t\tc->remote_window = rwindow;\n\t\tc->remote_maxpacket = rmaxpack;\n\t\tif (c->type != SSH_CHANNEL_CONNECTING) {\n\t\t\tpacket_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);\n\t\t\tpacket_put_int(c->remote_id);\n\t\t\tpacket_put_int(c->self);\n\t\t\tpacket_put_int(c->local_window);\n\t\t\tpacket_put_int(c->local_maxpacket);\n\t\t\tpacket_send();\n\t\t}\n\t} else {\n\t\tdebug(\"failure %s\", ctype);\n\t\tpacket_start(SSH2_MSG_CHANNEL_OPEN_FAILURE);\n\t\tpacket_put_int(rchan);\n\t\tpacket_put_int(SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED);\n\t\tpacket_put_cstring(\"open failed\");\n\t\tpacket_put_cstring(\"\");\n\t\tpacket_send();\n\t}\n\tfree(ctype);\n\treturn 0;\n}"
  },
  {
    "function_name": "client_request_tun_fwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "1621-1661",
    "snippet": "char *\nclient_request_tun_fwd(struct ssh *ssh, int tun_mode,\n    int local_tun, int remote_tun)\n{\n\tChannel *c;\n\tint fd;\n\tchar *ifname = NULL;\n\n\tif (tun_mode == SSH_TUNMODE_NO)\n\t\treturn 0;\n\n\tdebug(\"Requesting tun unit %d in mode %d\", local_tun, tun_mode);\n\n\t/* Open local tunnel device */\n\tif ((fd = tun_open(local_tun, tun_mode, &ifname)) == -1) {\n\t\terror(\"Tunnel device open failed.\");\n\t\treturn NULL;\n\t}\n\tdebug(\"Tunnel forwarding using interface %s\", ifname);\n\n\tc = channel_new(ssh, \"tun\", SSH_CHANNEL_OPENING, fd, fd, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, \"tun\", 1);\n\tc->datagram = 1;\n\n#if defined(SSH_TUN_FILTER)\n\tif (options.tun_open == SSH_TUNMODE_POINTOPOINT)\n\t\tchannel_register_filter(ssh, c->self, sys_tun_infilter,\n\t\t    sys_tun_outfilter, NULL, NULL);\n#endif\n\n\tpacket_start(SSH2_MSG_CHANNEL_OPEN);\n\tpacket_put_cstring(\"tun@openssh.com\");\n\tpacket_put_int(c->self);\n\tpacket_put_int(c->local_window_max);\n\tpacket_put_int(c->local_maxpacket);\n\tpacket_put_int(tun_mode);\n\tpacket_put_int(remote_tun);\n\tpacket_send();\n\n\treturn ifname;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "remote_tun"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "tun_mode"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "c->local_maxpacket"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "c->local_window_max"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "c->self"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "\"tun@openssh.com\""
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_start",
          "args": [
            "SSH2_MSG_CHANNEL_OPEN"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_register_filter",
          "args": [
            "ssh",
            "c->self",
            "sys_tun_infilter",
            "sys_tun_outfilter",
            "NULL",
            "NULL"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1012-1026",
          "snippet": "void\nchannel_register_filter(struct ssh *ssh, int id, channel_infilter_fn *ifn,\n    channel_outfilter_fn *ofn, channel_filter_cleanup_fn *cfn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->input_filter = ifn;\n\tc->output_filter = ofn;\n\tc->filter_ctx = ctx;\n\tc->filter_cleanup = cfn;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_filter(struct ssh *ssh, int id, channel_infilter_fn *ifn,\n    channel_outfilter_fn *ofn, channel_filter_cleanup_fn *cfn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->input_filter = ifn;\n\tc->output_filter = ofn;\n\tc->filter_ctx = ctx;\n\tc->filter_cleanup = cfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "\"tun\"",
            "SSH_CHANNEL_OPENING",
            "fd",
            "fd",
            "-1",
            "CHAN_TCP_WINDOW_DEFAULT",
            "CHAN_TCP_PACKET_DEFAULT",
            "0",
            "\"tun\"",
            "1"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Tunnel forwarding using interface %s\"",
            "ifname"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Tunnel device open failed.\""
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tun_open",
          "args": [
            "local_tun",
            "tun_mode",
            "&ifname"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "tun_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1031-1107",
          "snippet": "int\ntun_open(int tun, int mode, char **ifname)\n{\n#if defined(CUSTOM_SYS_TUN_OPEN)\n\treturn (sys_tun_open(tun, mode, ifname));\n#elif defined(SSH_TUN_OPENBSD)\n\tstruct ifreq ifr;\n\tchar name[100];\n\tint fd = -1, sock;\n\tconst char *tunbase = \"tun\";\n\n\tif (ifname != NULL)\n\t\t*ifname = NULL;\n\n\tif (mode == SSH_TUNMODE_ETHERNET)\n\t\ttunbase = \"tap\";\n\n\t/* Open the tunnel device */\n\tif (tun <= SSH_TUNID_MAX) {\n\t\tsnprintf(name, sizeof(name), \"/dev/%s%d\", tunbase, tun);\n\t\tfd = open(name, O_RDWR);\n\t} else if (tun == SSH_TUNID_ANY) {\n\t\tfor (tun = 100; tun >= 0; tun--) {\n\t\t\tsnprintf(name, sizeof(name), \"/dev/%s%d\",\n\t\t\t    tunbase, tun);\n\t\t\tif ((fd = open(name, O_RDWR)) >= 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdebug(\"%s: invalid tunnel %u\", __func__, tun);\n\t\treturn -1;\n\t}\n\n\tif (fd < 0) {\n\t\tdebug(\"%s: %s open: %s\", __func__, name, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tdebug(\"%s: %s mode %d fd %d\", __func__, name, mode, fd);\n\n\t/* Bring interface up if it is not already */\n\tsnprintf(ifr.ifr_name, sizeof(ifr.ifr_name), \"%s%d\", tunbase, tun);\n\tif ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1)\n\t\tgoto failed;\n\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1) {\n\t\tdebug(\"%s: get interface %s flags: %s\", __func__,\n\t\t    ifr.ifr_name, strerror(errno));\n\t\tgoto failed;\n\t}\n\n\tif (!(ifr.ifr_flags & IFF_UP)) {\n\t\tifr.ifr_flags |= IFF_UP;\n\t\tif (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1) {\n\t\t\tdebug(\"%s: activate interface %s: %s\", __func__,\n\t\t\t    ifr.ifr_name, strerror(errno));\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tif (ifname != NULL)\n\t\t*ifname = xstrdup(ifr.ifr_name);\n\n\tclose(sock);\n\treturn fd;\n\n failed:\n\tif (fd >= 0)\n\t\tclose(fd);\n\tif (sock >= 0)\n\t\tclose(sock);\n\treturn -1;\n#else\n\terror(\"Tunnel interfaces are not supported on this platform\");\n\treturn (-1);\n#endif\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ntun_open(int tun, int mode, char **ifname)\n{\n#if defined(CUSTOM_SYS_TUN_OPEN)\n\treturn (sys_tun_open(tun, mode, ifname));\n#elif defined(SSH_TUN_OPENBSD)\n\tstruct ifreq ifr;\n\tchar name[100];\n\tint fd = -1, sock;\n\tconst char *tunbase = \"tun\";\n\n\tif (ifname != NULL)\n\t\t*ifname = NULL;\n\n\tif (mode == SSH_TUNMODE_ETHERNET)\n\t\ttunbase = \"tap\";\n\n\t/* Open the tunnel device */\n\tif (tun <= SSH_TUNID_MAX) {\n\t\tsnprintf(name, sizeof(name), \"/dev/%s%d\", tunbase, tun);\n\t\tfd = open(name, O_RDWR);\n\t} else if (tun == SSH_TUNID_ANY) {\n\t\tfor (tun = 100; tun >= 0; tun--) {\n\t\t\tsnprintf(name, sizeof(name), \"/dev/%s%d\",\n\t\t\t    tunbase, tun);\n\t\t\tif ((fd = open(name, O_RDWR)) >= 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdebug(\"%s: invalid tunnel %u\", __func__, tun);\n\t\treturn -1;\n\t}\n\n\tif (fd < 0) {\n\t\tdebug(\"%s: %s open: %s\", __func__, name, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tdebug(\"%s: %s mode %d fd %d\", __func__, name, mode, fd);\n\n\t/* Bring interface up if it is not already */\n\tsnprintf(ifr.ifr_name, sizeof(ifr.ifr_name), \"%s%d\", tunbase, tun);\n\tif ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1)\n\t\tgoto failed;\n\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1) {\n\t\tdebug(\"%s: get interface %s flags: %s\", __func__,\n\t\t    ifr.ifr_name, strerror(errno));\n\t\tgoto failed;\n\t}\n\n\tif (!(ifr.ifr_flags & IFF_UP)) {\n\t\tifr.ifr_flags |= IFF_UP;\n\t\tif (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1) {\n\t\t\tdebug(\"%s: activate interface %s: %s\", __func__,\n\t\t\t    ifr.ifr_name, strerror(errno));\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tif (ifname != NULL)\n\t\t*ifname = xstrdup(ifr.ifr_name);\n\n\tclose(sock);\n\treturn fd;\n\n failed:\n\tif (fd >= 0)\n\t\tclose(fd);\n\tif (sock >= 0)\n\t\tclose(sock);\n\treturn -1;\n#else\n\terror(\"Tunnel interfaces are not supported on this platform\");\n\treturn (-1);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nchar *\nclient_request_tun_fwd(struct ssh *ssh, int tun_mode,\n    int local_tun, int remote_tun)\n{\n\tChannel *c;\n\tint fd;\n\tchar *ifname = NULL;\n\n\tif (tun_mode == SSH_TUNMODE_NO)\n\t\treturn 0;\n\n\tdebug(\"Requesting tun unit %d in mode %d\", local_tun, tun_mode);\n\n\t/* Open local tunnel device */\n\tif ((fd = tun_open(local_tun, tun_mode, &ifname)) == -1) {\n\t\terror(\"Tunnel device open failed.\");\n\t\treturn NULL;\n\t}\n\tdebug(\"Tunnel forwarding using interface %s\", ifname);\n\n\tc = channel_new(ssh, \"tun\", SSH_CHANNEL_OPENING, fd, fd, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, \"tun\", 1);\n\tc->datagram = 1;\n\n#if defined(SSH_TUN_FILTER)\n\tif (options.tun_open == SSH_TUNMODE_POINTOPOINT)\n\t\tchannel_register_filter(ssh, c->self, sys_tun_infilter,\n\t\t    sys_tun_outfilter, NULL, NULL);\n#endif\n\n\tpacket_start(SSH2_MSG_CHANNEL_OPEN);\n\tpacket_put_cstring(\"tun@openssh.com\");\n\tpacket_put_int(c->self);\n\tpacket_put_int(c->local_window_max);\n\tpacket_put_int(c->local_maxpacket);\n\tpacket_put_int(tun_mode);\n\tpacket_put_int(remote_tun);\n\tpacket_send();\n\n\treturn ifname;\n}"
  },
  {
    "function_name": "client_request_agent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "1595-1619",
    "snippet": "static Channel *\nclient_request_agent(struct ssh *ssh, const char *request_type, int rchan)\n{\n\tChannel *c = NULL;\n\tint r, sock;\n\n\tif (!options.forward_agent) {\n\t\terror(\"Warning: ssh server tried agent forwarding.\");\n\t\terror(\"Warning: this is probably a break-in attempt by a \"\n\t\t    \"malicious server.\");\n\t\treturn NULL;\n\t}\n\tif ((r = ssh_get_authentication_socket(&sock)) != 0) {\n\t\tif (r != SSH_ERR_AGENT_NOT_PRESENT)\n\t\t\tdebug(\"%s: ssh_get_authentication_socket: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\treturn NULL;\n\t}\n\tc = channel_new(ssh, \"authentication agent connection\",\n\t    SSH_CHANNEL_OPEN, sock, sock, -1,\n\t    CHAN_X11_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0,\n\t    \"authentication agent connection\", 1);\n\tc->force_drain = 1;\n\treturn c;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "\"authentication agent connection\"",
            "SSH_CHANNEL_OPEN",
            "sock",
            "sock",
            "-1",
            "CHAN_X11_WINDOW_DEFAULT",
            "CHAN_TCP_PACKET_DEFAULT",
            "0",
            "\"authentication agent connection\"",
            "1"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: ssh_get_authentication_socket: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_get_authentication_socket",
          "args": [
            "&sock"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_get_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "86-120",
          "snippet": "int\nssh_get_authentication_socket(int *fdp)\n{\n\tconst char *authsocket;\n\tint sock, oerrno;\n\tstruct sockaddr_un sunaddr;\n\n\tif (fdp != NULL)\n\t\t*fdp = -1;\n\n\tauthsocket = getenv(SSH_AUTHSOCKET_ENV_NAME);\n\tif (!authsocket)\n\t\treturn SSH_ERR_AGENT_NOT_PRESENT;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tstrlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));\n\n\tif ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\t/* close on exec */\n\tif (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1 ||\n\t    connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\toerrno = errno;\n\t\tclose(sock);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (fdp != NULL)\n\t\t*fdp = sock;\n\telse\n\t\tclose(sock);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_get_authentication_socket(int *fdp)\n{\n\tconst char *authsocket;\n\tint sock, oerrno;\n\tstruct sockaddr_un sunaddr;\n\n\tif (fdp != NULL)\n\t\t*fdp = -1;\n\n\tauthsocket = getenv(SSH_AUTHSOCKET_ENV_NAME);\n\tif (!authsocket)\n\t\treturn SSH_ERR_AGENT_NOT_PRESENT;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tstrlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));\n\n\tif ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\t/* close on exec */\n\tif (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1 ||\n\t    connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\toerrno = errno;\n\t\tclose(sock);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (fdp != NULL)\n\t\t*fdp = sock;\n\telse\n\t\tclose(sock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Warning: this is probably a break-in attempt by a \"\n\t\t    \"malicious server.\""
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic Channel *\nclient_request_agent(struct ssh *ssh, const char *request_type, int rchan)\n{\n\tChannel *c = NULL;\n\tint r, sock;\n\n\tif (!options.forward_agent) {\n\t\terror(\"Warning: ssh server tried agent forwarding.\");\n\t\terror(\"Warning: this is probably a break-in attempt by a \"\n\t\t    \"malicious server.\");\n\t\treturn NULL;\n\t}\n\tif ((r = ssh_get_authentication_socket(&sock)) != 0) {\n\t\tif (r != SSH_ERR_AGENT_NOT_PRESENT)\n\t\t\tdebug(\"%s: ssh_get_authentication_socket: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\treturn NULL;\n\t}\n\tc = channel_new(ssh, \"authentication agent connection\",\n\t    SSH_CHANNEL_OPEN, sock, sock, -1,\n\t    CHAN_X11_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0,\n\t    \"authentication agent connection\", 1);\n\tc->force_drain = 1;\n\treturn c;\n}"
  },
  {
    "function_name": "client_request_x11",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "1559-1593",
    "snippet": "static Channel *\nclient_request_x11(struct ssh *ssh, const char *request_type, int rchan)\n{\n\tChannel *c = NULL;\n\tchar *originator;\n\tu_short originator_port;\n\tint sock;\n\n\tif (!options.forward_x11) {\n\t\terror(\"Warning: ssh server tried X11 forwarding.\");\n\t\terror(\"Warning: this is probably a break-in attempt by a \"\n\t\t    \"malicious server.\");\n\t\treturn NULL;\n\t}\n\tif (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {\n\t\tverbose(\"Rejected X11 connection after ForwardX11Timeout \"\n\t\t    \"expired\");\n\t\treturn NULL;\n\t}\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\t/* XXX check permission */\n\tdebug(\"client_request_x11: request from %s %d\", originator,\n\t    originator_port);\n\tfree(originator);\n\tsock = x11_connect_display(ssh);\n\tif (sock < 0)\n\t\treturn NULL;\n\tc = channel_new(ssh, \"x11\",\n\t    SSH_CHANNEL_X11_OPEN, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT, 0, \"x11\", 1);\n\tc->force_drain = 1;\n\treturn c;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "static u_int x11_refuse_time;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "\"x11\"",
            "SSH_CHANNEL_X11_OPEN",
            "sock",
            "sock",
            "-1",
            "CHAN_TCP_WINDOW_DEFAULT",
            "CHAN_X11_PACKET_DEFAULT",
            "0",
            "\"x11\"",
            "1"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x11_connect_display",
          "args": [
            "ssh"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "x11_connect_display",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4693-4809",
          "snippet": "int\nx11_connect_display(struct ssh *ssh)\n{\n\tu_int display_number;\n\tconst char *display;\n\tchar buf[1024], *cp;\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar strport[NI_MAXSERV];\n\tint gaierr, sock = 0;\n\n\t/* Try to open a socket for the local X server. */\n\tdisplay = getenv(\"DISPLAY\");\n\tif (!display) {\n\t\terror(\"DISPLAY not set.\");\n\t\treturn -1;\n\t}\n\t/*\n\t * Now we decode the value of the DISPLAY variable and make a\n\t * connection to the real X server.\n\t */\n\n#ifdef __APPLE__\n\t/* Check if display is a path to a socket (as set by launchd). */\n\t{\n\t\tchar path[PATH_MAX];\n\n\t\tif (is_path_to_xsocket(display, path, sizeof(path))) {\n\t\t\tdebug(\"x11_connect_display: $DISPLAY is launchd\");\n\n\t\t\t/* Create a socket. */\n\t\t\tsock = connect_local_xsocket_path(path);\n\t\t\tif (sock < 0)\n\t\t\t\treturn -1;\n\n\t\t\t/* OK, we now have a connection to the display. */\n\t\t\treturn sock;\n\t\t}\n\t}\n#endif\n\t/*\n\t * Check if it is a unix domain socket.  Unix domain displays are in\n\t * one of the following formats: unix:d[.s], :d[.s], ::d[.s]\n\t */\n\tif (strncmp(display, \"unix:\", 5) == 0 ||\n\t    display[0] == ':') {\n\t\t/* Connect to the unix domain socket. */\n\t\tif (sscanf(strrchr(display, ':') + 1, \"%u\",\n\t\t    &display_number) != 1) {\n\t\t\terror(\"Could not parse display number from DISPLAY: \"\n\t\t\t    \"%.100s\", display);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Create a socket. */\n\t\tsock = connect_local_xsocket(display_number);\n\t\tif (sock < 0)\n\t\t\treturn -1;\n\n\t\t/* OK, we now have a connection to the display. */\n\t\treturn sock;\n\t}\n\t/*\n\t * Connect to an inet socket.  The DISPLAY value is supposedly\n\t * hostname:d[.s], where hostname may also be numeric IP address.\n\t */\n\tstrlcpy(buf, display, sizeof(buf));\n\tcp = strchr(buf, ':');\n\tif (!cp) {\n\t\terror(\"Could not find ':' in DISPLAY: %.100s\", display);\n\t\treturn -1;\n\t}\n\t*cp = 0;\n\t/*\n\t * buf now contains the host name.  But first we parse the\n\t * display number.\n\t */\n\tif (sscanf(cp + 1, \"%u\", &display_number) != 1) {\n\t\terror(\"Could not parse display number from DISPLAY: %.100s\",\n\t\t    display);\n\t\treturn -1;\n\t}\n\n\t/* Look up the host address */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = ssh->chanctxt->IPv4or6;\n\thints.ai_socktype = SOCK_STREAM;\n\tsnprintf(strport, sizeof strport, \"%u\", 6000 + display_number);\n\tif ((gaierr = getaddrinfo(buf, strport, &hints, &aitop)) != 0) {\n\t\terror(\"%.100s: unknown host. (%s)\", buf,\n\t\tssh_gai_strerror(gaierr));\n\t\treturn -1;\n\t}\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\t/* Create a socket. */\n\t\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (sock < 0) {\n\t\t\tdebug2(\"socket: %.100s\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Connect it to the display. */\n\t\tif (connect(sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\tdebug2(\"connect %.100s port %u: %.100s\", buf,\n\t\t\t    6000 + display_number, strerror(errno));\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Success */\n\t\tbreak;\n\t}\n\tfreeaddrinfo(aitop);\n\tif (!ai) {\n\t\terror(\"connect %.100s port %u: %.100s\", buf,\n\t\t    6000 + display_number, strerror(errno));\n\t\treturn -1;\n\t}\n\tset_nodelay(sock);\n\treturn sock;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nx11_connect_display(struct ssh *ssh)\n{\n\tu_int display_number;\n\tconst char *display;\n\tchar buf[1024], *cp;\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar strport[NI_MAXSERV];\n\tint gaierr, sock = 0;\n\n\t/* Try to open a socket for the local X server. */\n\tdisplay = getenv(\"DISPLAY\");\n\tif (!display) {\n\t\terror(\"DISPLAY not set.\");\n\t\treturn -1;\n\t}\n\t/*\n\t * Now we decode the value of the DISPLAY variable and make a\n\t * connection to the real X server.\n\t */\n\n#ifdef __APPLE__\n\t/* Check if display is a path to a socket (as set by launchd). */\n\t{\n\t\tchar path[PATH_MAX];\n\n\t\tif (is_path_to_xsocket(display, path, sizeof(path))) {\n\t\t\tdebug(\"x11_connect_display: $DISPLAY is launchd\");\n\n\t\t\t/* Create a socket. */\n\t\t\tsock = connect_local_xsocket_path(path);\n\t\t\tif (sock < 0)\n\t\t\t\treturn -1;\n\n\t\t\t/* OK, we now have a connection to the display. */\n\t\t\treturn sock;\n\t\t}\n\t}\n#endif\n\t/*\n\t * Check if it is a unix domain socket.  Unix domain displays are in\n\t * one of the following formats: unix:d[.s], :d[.s], ::d[.s]\n\t */\n\tif (strncmp(display, \"unix:\", 5) == 0 ||\n\t    display[0] == ':') {\n\t\t/* Connect to the unix domain socket. */\n\t\tif (sscanf(strrchr(display, ':') + 1, \"%u\",\n\t\t    &display_number) != 1) {\n\t\t\terror(\"Could not parse display number from DISPLAY: \"\n\t\t\t    \"%.100s\", display);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Create a socket. */\n\t\tsock = connect_local_xsocket(display_number);\n\t\tif (sock < 0)\n\t\t\treturn -1;\n\n\t\t/* OK, we now have a connection to the display. */\n\t\treturn sock;\n\t}\n\t/*\n\t * Connect to an inet socket.  The DISPLAY value is supposedly\n\t * hostname:d[.s], where hostname may also be numeric IP address.\n\t */\n\tstrlcpy(buf, display, sizeof(buf));\n\tcp = strchr(buf, ':');\n\tif (!cp) {\n\t\terror(\"Could not find ':' in DISPLAY: %.100s\", display);\n\t\treturn -1;\n\t}\n\t*cp = 0;\n\t/*\n\t * buf now contains the host name.  But first we parse the\n\t * display number.\n\t */\n\tif (sscanf(cp + 1, \"%u\", &display_number) != 1) {\n\t\terror(\"Could not parse display number from DISPLAY: %.100s\",\n\t\t    display);\n\t\treturn -1;\n\t}\n\n\t/* Look up the host address */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = ssh->chanctxt->IPv4or6;\n\thints.ai_socktype = SOCK_STREAM;\n\tsnprintf(strport, sizeof strport, \"%u\", 6000 + display_number);\n\tif ((gaierr = getaddrinfo(buf, strport, &hints, &aitop)) != 0) {\n\t\terror(\"%.100s: unknown host. (%s)\", buf,\n\t\tssh_gai_strerror(gaierr));\n\t\treturn -1;\n\t}\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\t/* Create a socket. */\n\t\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (sock < 0) {\n\t\t\tdebug2(\"socket: %.100s\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Connect it to the display. */\n\t\tif (connect(sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\tdebug2(\"connect %.100s port %u: %.100s\", buf,\n\t\t\t    6000 + display_number, strerror(errno));\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Success */\n\t\tbreak;\n\t}\n\tfreeaddrinfo(aitop);\n\tif (!ai) {\n\t\terror(\"connect %.100s port %u: %.100s\", buf,\n\t\t    6000 + display_number, strerror(errno));\n\t\treturn -1;\n\t}\n\tset_nodelay(sock);\n\treturn sock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "originator"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"client_request_x11: request from %s %d\"",
            "originator",
            "originator_port"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_check_eom",
          "args": [],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_int",
          "args": [],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "227-231",
          "snippet": "u_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "NULL"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Rejected X11 connection after ForwardX11Timeout \"\n\t\t    \"expired\""
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "monotime",
          "args": [],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "monotime_double",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1324-1331",
          "snippet": "double\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\ndouble\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Warning: this is probably a break-in attempt by a \"\n\t\t    \"malicious server.\""
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic u_int x11_refuse_time;\n\nstatic Channel *\nclient_request_x11(struct ssh *ssh, const char *request_type, int rchan)\n{\n\tChannel *c = NULL;\n\tchar *originator;\n\tu_short originator_port;\n\tint sock;\n\n\tif (!options.forward_x11) {\n\t\terror(\"Warning: ssh server tried X11 forwarding.\");\n\t\terror(\"Warning: this is probably a break-in attempt by a \"\n\t\t    \"malicious server.\");\n\t\treturn NULL;\n\t}\n\tif (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {\n\t\tverbose(\"Rejected X11 connection after ForwardX11Timeout \"\n\t\t    \"expired\");\n\t\treturn NULL;\n\t}\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\t/* XXX check permission */\n\tdebug(\"client_request_x11: request from %s %d\", originator,\n\t    originator_port);\n\tfree(originator);\n\tsock = x11_connect_display(ssh);\n\tif (sock < 0)\n\t\treturn NULL;\n\tc = channel_new(ssh, \"x11\",\n\t    SSH_CHANNEL_X11_OPEN, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT, 0, \"x11\", 1);\n\tc->force_drain = 1;\n\treturn c;\n}"
  },
  {
    "function_name": "client_request_forwarded_streamlocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "1537-1557",
    "snippet": "static Channel *\nclient_request_forwarded_streamlocal(struct ssh *ssh,\n    const char *request_type, int rchan)\n{\n\tChannel *c = NULL;\n\tchar *listen_path;\n\n\t/* Get the remote path. */\n\tlisten_path = packet_get_string(NULL);\n\t/* XXX: Skip reserved field for now. */\n\tif (packet_get_string_ptr(NULL) == NULL)\n\t\tfatal(\"%s: packet_get_string_ptr failed\", __func__);\n\tpacket_check_eom();\n\n\tdebug(\"%s: %s\", __func__, listen_path);\n\n\tc = channel_connect_by_listen_path(ssh, listen_path,\n\t    \"forwarded-streamlocal@openssh.com\", \"forwarded-streamlocal\");\n\tfree(listen_path);\n\treturn c;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "listen_path"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_connect_by_listen_path",
          "args": [
            "ssh",
            "listen_path",
            "\"forwarded-streamlocal@openssh.com\"",
            "\"forwarded-streamlocal\""
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_by_listen_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4334-4354",
          "snippet": "Channel *\nchannel_connect_by_listen_path(struct ssh *ssh, const char *path,\n    char *ctype, char *rname)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tu_int i;\n\tstruct permission *perm;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_streamlocal(perm, path)) {\n\t\t\treturn connect_to(ssh,\n\t\t\t    perm->host_to_connect, perm->port_to_connect,\n\t\t\t    ctype, rname);\n\t\t}\n\t}\n\terror(\"WARNING: Server requests forwarding for unknown path %.100s\",\n\t    path);\n\treturn NULL;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_connect_by_listen_path(struct ssh *ssh, const char *path,\n    char *ctype, char *rname)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tu_int i;\n\tstruct permission *perm;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_streamlocal(perm, path)) {\n\t\t\treturn connect_to(ssh,\n\t\t\t    perm->host_to_connect, perm->port_to_connect,\n\t\t\t    ctype, rname);\n\t\t}\n\t}\n\terror(\"WARNING: Server requests forwarding for unknown path %.100s\",\n\t    path);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "listen_path"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_check_eom",
          "args": [],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: packet_get_string_ptr failed\"",
            "__func__"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_string_ptr",
          "args": [
            "NULL"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "NULL"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *\nclient_request_forwarded_streamlocal(struct ssh *ssh,\n    const char *request_type, int rchan)\n{\n\tChannel *c = NULL;\n\tchar *listen_path;\n\n\t/* Get the remote path. */\n\tlisten_path = packet_get_string(NULL);\n\t/* XXX: Skip reserved field for now. */\n\tif (packet_get_string_ptr(NULL) == NULL)\n\t\tfatal(\"%s: packet_get_string_ptr failed\", __func__);\n\tpacket_check_eom();\n\n\tdebug(\"%s: %s\", __func__, listen_path);\n\n\tc = channel_connect_by_listen_path(ssh, listen_path,\n\t    \"forwarded-streamlocal@openssh.com\", \"forwarded-streamlocal\");\n\tfree(listen_path);\n\treturn c;\n}"
  },
  {
    "function_name": "client_request_forwarded_tcpip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "1484-1535",
    "snippet": "static Channel *\nclient_request_forwarded_tcpip(struct ssh *ssh, const char *request_type,\n    int rchan, u_int rwindow, u_int rmaxpack)\n{\n\tChannel *c = NULL;\n\tstruct sshbuf *b = NULL;\n\tchar *listen_address, *originator_address;\n\tu_short listen_port, originator_port;\n\tint r;\n\n\t/* Get rest of the packet */\n\tlisten_address = packet_get_string(NULL);\n\tlisten_port = packet_get_int();\n\toriginator_address = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"%s: listen %s port %d, originator %s port %d\", __func__,\n\t    listen_address, listen_port, originator_address, originator_port);\n\n\tc = channel_connect_by_listen_address(ssh, listen_address, listen_port,\n\t    \"forwarded-tcpip\", originator_address);\n\n\tif (c != NULL && c->type == SSH_CHANNEL_MUX_CLIENT) {\n\t\tif ((b = sshbuf_new()) == NULL) {\n\t\t\terror(\"%s: alloc reply\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\t/* reconstruct and send to muxclient */\n\t\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t\t    (r = sshbuf_put_u8(b, SSH2_MSG_CHANNEL_OPEN)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, request_type)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, rchan)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, rwindow)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, rmaxpack)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, listen_address)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, listen_port)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, originator_address)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, originator_port)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(c->output, b)) != 0) {\n\t\t\terror(\"%s: compose for muxclient %s\", __func__,\n\t\t\t    ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n out:\n\tsshbuf_free(b);\n\tfree(originator_address);\n\tfree(listen_address);\n\treturn c;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ssh_process_session2_setup(int, int, int, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "listen_address"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: compose for muxclient %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "c->output",
            "b"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "b",
            "originator_port"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "b",
            "originator_address"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "b",
            "SSH2_MSG_CHANNEL_OPEN"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_connect_by_listen_address",
          "args": [
            "ssh",
            "listen_address",
            "listen_port",
            "\"forwarded-tcpip\"",
            "originator_address"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_by_listen_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4306-4332",
          "snippet": "Channel *\nchannel_connect_by_listen_address(struct ssh *ssh, const char *listen_host,\n    u_short listen_port, char *ctype, char *rname)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tu_int i;\n\tstruct permission *perm;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_tcpip(perm,\n\t\t    listen_host, listen_port, 1)) {\n\t\t\tif (perm->downstream)\n\t\t\t\treturn perm->downstream;\n\t\t\tif (perm->port_to_connect == 0)\n\t\t\t\treturn rdynamic_connect_prepare(ssh,\n\t\t\t\t    ctype, rname);\n\t\t\treturn connect_to(ssh,\n\t\t\t    perm->host_to_connect, perm->port_to_connect,\n\t\t\t    ctype, rname);\n\t\t}\n\t}\n\terror(\"WARNING: Server requests forwarding for unknown listen_port %d\",\n\t    listen_port);\n\treturn NULL;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_connect_by_listen_address(struct ssh *ssh, const char *listen_host,\n    u_short listen_port, char *ctype, char *rname)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tu_int i;\n\tstruct permission *perm;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_tcpip(perm,\n\t\t    listen_host, listen_port, 1)) {\n\t\t\tif (perm->downstream)\n\t\t\t\treturn perm->downstream;\n\t\t\tif (perm->port_to_connect == 0)\n\t\t\t\treturn rdynamic_connect_prepare(ssh,\n\t\t\t\t    ctype, rname);\n\t\t\treturn connect_to(ssh,\n\t\t\t    perm->host_to_connect, perm->port_to_connect,\n\t\t\t    ctype, rname);\n\t\t}\n\t}\n\terror(\"WARNING: Server requests forwarding for unknown listen_port %d\",\n\t    listen_port);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: listen %s port %d, originator %s port %d\"",
            "__func__",
            "listen_address",
            "listen_port",
            "originator_address",
            "originator_port"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_check_eom",
          "args": [],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_int",
          "args": [],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "227-231",
          "snippet": "u_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "NULL"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "NULL"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid ssh_process_session2_setup(int, int, int, struct sshbuf *);\n\nstatic Channel *\nclient_request_forwarded_tcpip(struct ssh *ssh, const char *request_type,\n    int rchan, u_int rwindow, u_int rmaxpack)\n{\n\tChannel *c = NULL;\n\tstruct sshbuf *b = NULL;\n\tchar *listen_address, *originator_address;\n\tu_short listen_port, originator_port;\n\tint r;\n\n\t/* Get rest of the packet */\n\tlisten_address = packet_get_string(NULL);\n\tlisten_port = packet_get_int();\n\toriginator_address = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"%s: listen %s port %d, originator %s port %d\", __func__,\n\t    listen_address, listen_port, originator_address, originator_port);\n\n\tc = channel_connect_by_listen_address(ssh, listen_address, listen_port,\n\t    \"forwarded-tcpip\", originator_address);\n\n\tif (c != NULL && c->type == SSH_CHANNEL_MUX_CLIENT) {\n\t\tif ((b = sshbuf_new()) == NULL) {\n\t\t\terror(\"%s: alloc reply\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\t/* reconstruct and send to muxclient */\n\t\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t\t    (r = sshbuf_put_u8(b, SSH2_MSG_CHANNEL_OPEN)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, request_type)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, rchan)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, rwindow)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, rmaxpack)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, listen_address)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, listen_port)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, originator_address)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, originator_port)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(c->output, b)) != 0) {\n\t\t\terror(\"%s: compose for muxclient %s\", __func__,\n\t\t\t    ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n out:\n\tsshbuf_free(b);\n\tfree(originator_address);\n\tfree(listen_address);\n\treturn c;\n}"
  },
  {
    "function_name": "client_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "1235-1480",
    "snippet": "int\nclient_loop(struct ssh *ssh, int have_pty, int escape_char_arg,\n    int ssh2_chan_id)\n{\n\tfd_set *readset = NULL, *writeset = NULL;\n\tdouble start_time, total_time;\n\tint r, max_fd = 0, max_fd2 = 0, len;\n\tu_int64_t ibytes, obytes;\n\tu_int nalloc = 0;\n\tchar buf[100];\n\n\tdebug(\"Entering interactive session.\");\n\n\tif (options.control_master &&\n\t    !option_clear_or_none(options.control_path)) {\n\t\tdebug(\"pledge: id\");\n\t\tif (pledge(\"stdio rpath wpath cpath unix inet dns recvfd proc exec id tty\",\n\t\t    NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\n\t} else if (options.forward_x11 || options.permit_local_command) {\n\t\tdebug(\"pledge: exec\");\n\t\tif (pledge(\"stdio rpath wpath cpath unix inet dns proc exec tty\",\n\t\t    NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\n\t} else if (options.update_hostkeys) {\n\t\tdebug(\"pledge: filesystem full\");\n\t\tif (pledge(\"stdio rpath wpath cpath unix inet dns proc tty\",\n\t\t    NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\n\t} else if (!option_clear_or_none(options.proxy_command) ||\n\t    fork_after_authentication_flag) {\n\t\tdebug(\"pledge: proc\");\n\t\tif (pledge(\"stdio cpath unix inet dns proc tty\", NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\n\t} else {\n\t\tdebug(\"pledge: network\");\n\t\tif (pledge(\"stdio unix inet dns proc tty\", NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\t}\n\n\tstart_time = monotime_double();\n\n\t/* Initialize variables. */\n\tlast_was_cr = 1;\n\texit_status = -1;\n\tconnection_in = packet_get_connection_in();\n\tconnection_out = packet_get_connection_out();\n\tmax_fd = MAXIMUM(connection_in, connection_out);\n\n\tquit_pending = 0;\n\n\t/* Initialize buffer. */\n\tif ((stderr_buffer = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tclient_init_dispatch();\n\n\t/*\n\t * Set signal handlers, (e.g. to restore non-blocking mode)\n\t * but don't overwrite SIG_IGN, matches behaviour from rsh(1)\n\t */\n\tif (signal(SIGHUP, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGHUP, signal_handler);\n\tif (signal(SIGINT, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGINT, signal_handler);\n\tif (signal(SIGQUIT, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGQUIT, signal_handler);\n\tif (signal(SIGTERM, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGTERM, signal_handler);\n\tsignal(SIGWINCH, window_change_handler);\n\n\tif (have_pty)\n\t\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\tsession_ident = ssh2_chan_id;\n\tif (session_ident != -1) {\n\t\tif (escape_char_arg != SSH_ESCAPECHAR_NONE) {\n\t\t\tchannel_register_filter(ssh, session_ident,\n\t\t\t    client_simple_escape_filter, NULL,\n\t\t\t    client_filter_cleanup,\n\t\t\t    client_new_escape_filter_ctx(\n\t\t\t    escape_char_arg));\n\t\t}\n\t\tchannel_register_cleanup(ssh, session_ident,\n\t\t    client_channel_closed, 0);\n\t}\n\n\t/* Main loop of the client for the interactive session mode. */\n\twhile (!quit_pending) {\n\n\t\t/* Process buffered packets sent by the server. */\n\t\tclient_process_buffered_input_packets();\n\n\t\tif (session_closed && !channel_still_open(ssh))\n\t\t\tbreak;\n\n\t\tif (ssh_packet_is_rekeying(ssh)) {\n\t\t\tdebug(\"rekeying in progress\");\n\t\t} else if (need_rekeying) {\n\t\t\t/* manual rekey request */\n\t\t\tdebug(\"need rekeying\");\n\t\t\tif ((r = kex_start_rekex(ssh)) != 0)\n\t\t\t\tfatal(\"%s: kex_start_rekex: %s\", __func__,\n\t\t\t\t    ssh_err(r));\n\t\t\tneed_rekeying = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Make packets from buffered channel data, and\n\t\t\t * enqueue them for sending to the server.\n\t\t\t */\n\t\t\tif (packet_not_very_much_data_to_write())\n\t\t\t\tchannel_output_poll(ssh);\n\n\t\t\t/*\n\t\t\t * Check if the window size has changed, and buffer a\n\t\t\t * message about it to the server if so.\n\t\t\t */\n\t\t\tclient_check_window_change(ssh);\n\n\t\t\tif (quit_pending)\n\t\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Wait until we have something to do (something becomes\n\t\t * available on one of the descriptors).\n\t\t */\n\t\tmax_fd2 = max_fd;\n\t\tclient_wait_until_can_do_something(ssh, &readset, &writeset,\n\t\t    &max_fd2, &nalloc, ssh_packet_is_rekeying(ssh));\n\n\t\tif (quit_pending)\n\t\t\tbreak;\n\n\t\t/* Do channel operations unless rekeying in progress. */\n\t\tif (!ssh_packet_is_rekeying(ssh))\n\t\t\tchannel_after_select(ssh, readset, writeset);\n\n\t\t/* Buffer input from the connection.  */\n\t\tclient_process_net_input(readset);\n\n\t\tif (quit_pending)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Send as much buffered packet data as possible to the\n\t\t * sender.\n\t\t */\n\t\tif (FD_ISSET(connection_out, writeset))\n\t\t\tpacket_write_poll();\n\n\t\t/*\n\t\t * If we are a backgrounded control master, and the\n\t\t * timeout has expired without any active client\n\t\t * connections, then quit.\n\t\t */\n\t\tif (control_persist_exit_time > 0) {\n\t\t\tif (monotime() >= control_persist_exit_time) {\n\t\t\t\tdebug(\"ControlPersist timeout expired\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfree(readset);\n\tfree(writeset);\n\n\t/* Terminate the session. */\n\n\t/* Stop watching for window change. */\n\tsignal(SIGWINCH, SIG_DFL);\n\n\tpacket_start(SSH2_MSG_DISCONNECT);\n\tpacket_put_int(SSH2_DISCONNECT_BY_APPLICATION);\n\tpacket_put_cstring(\"disconnected by user\");\n\tpacket_put_cstring(\"\"); /* language tag */\n\tpacket_send();\n\tpacket_write_wait();\n\n\tchannel_free_all(ssh);\n\n\tif (have_pty)\n\t\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\t/* restore blocking io */\n\tif (!isatty(fileno(stdin)))\n\t\tunset_nonblock(fileno(stdin));\n\tif (!isatty(fileno(stdout)))\n\t\tunset_nonblock(fileno(stdout));\n\tif (!isatty(fileno(stderr)))\n\t\tunset_nonblock(fileno(stderr));\n\n\t/*\n\t * If there was no shell or command requested, there will be no remote\n\t * exit status to be returned.  In that case, clear error code if the\n\t * connection was deliberately terminated at this end.\n\t */\n\tif (no_shell_flag && received_signal == SIGTERM) {\n\t\treceived_signal = 0;\n\t\texit_status = 0;\n\t}\n\n\tif (received_signal) {\n\t\tverbose(\"Killed by signal %d.\", (int) received_signal);\n\t\tcleanup_exit(0);\n\t}\n\n\t/*\n\t * In interactive mode (with pseudo tty) display a message indicating\n\t * that the connection has been closed.\n\t */\n\tif (have_pty && options.log_level != SYSLOG_LEVEL_QUIET) {\n\t\tif ((r = sshbuf_putf(stderr_buffer,\n\t\t    \"Connection to %.64s closed.\\r\\n\", host)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\t/* Output any buffered data for stderr. */\n\tif (sshbuf_len(stderr_buffer) > 0) {\n\t\tlen = atomicio(vwrite, fileno(stderr),\n\t\t    (u_char *)sshbuf_ptr(stderr_buffer),\n\t\t    sshbuf_len(stderr_buffer));\n\t\tif (len < 0 || (u_int)len != sshbuf_len(stderr_buffer))\n\t\t\terror(\"Write failed flushing stderr buffer.\");\n\t\telse if ((r = sshbuf_consume(stderr_buffer, len)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\t/* Clear and free any buffers. */\n\texplicit_bzero(buf, sizeof(buf));\n\tsshbuf_free(stderr_buffer);\n\n\t/* Report bytes transferred, and transfer rates. */\n\ttotal_time = monotime_double() - start_time;\n\tpacket_get_bytes(&ibytes, &obytes);\n\tverbose(\"Transferred: sent %llu, received %llu bytes, in %.1f seconds\",\n\t    (unsigned long long)obytes, (unsigned long long)ibytes, total_time);\n\tif (total_time > 0)\n\t\tverbose(\"Bytes per second: sent %.1f, received %.1f\",\n\t\t    obytes / total_time, ibytes / total_time);\n\t/* Return the exit status of the program. */\n\tdebug(\"Exit status %d\", exit_status);\n\treturn exit_status;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "extern int no_shell_flag;",
      "extern int fork_after_authentication_flag;",
      "extern char *host;",
      "static volatile sig_atomic_t received_signal = 0;",
      "static time_t control_persist_exit_time = 0;",
      "volatile sig_atomic_t quit_pending;",
      "static int last_was_cr;",
      "static int exit_status;",
      "static struct sshbuf *stderr_buffer;",
      "static int connection_in;",
      "static int connection_out;",
      "static int need_rekeying;",
      "static int session_closed;",
      "static void client_init_dispatch(void);",
      "int\tsession_ident = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Exit status %d\"",
            "exit_status"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Bytes per second: sent %.1f, received %.1f\"",
            "obytes / total_time",
            "ibytes / total_time"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_bytes",
          "args": [
            "&ibytes",
            "&obytes"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "monotime_double",
          "args": [],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "monotime_double",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1324-1331",
          "snippet": "double\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\ndouble\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "stderr_buffer"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "buf",
            "sizeof(buf)"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "stderr_buffer",
            "len"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Write failed flushing stderr buffer.\""
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "stderr_buffer"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "vwrite",
            "fileno(stderr)",
            "(u_char *)sshbuf_ptr(stderr_buffer)",
            "sshbuf_len(stderr_buffer)"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "stderr_buffer"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stderr"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_putf",
          "args": [
            "stderr_buffer",
            "\"Connection to %.64s closed.\\r\\n\"",
            "host"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_exit",
          "args": [
            "0"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "2349-2358",
          "snippet": "void\ncleanup_exit(int i)\n{\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\tleave_non_blocking();\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\tssh_kill_proxy_command();\n\t_exit(i);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "extern int muxserver_sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nextern int muxserver_sock;\n\nvoid\ncleanup_exit(int i)\n{\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\tleave_non_blocking();\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\tssh_kill_proxy_command();\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unset_nonblock",
          "args": [
            "fileno(stderr)"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "unset_nonblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "116-138",
          "snippet": "int\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stderr"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "fileno(stderr)"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stderr"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdout"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "fileno(stdout)"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdout"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "fileno(stdin)"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leave_raw_mode",
          "args": [
            "options.request_tty == REQUEST_TTY_FORCE"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "leave_raw_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshtty.c",
          "lines": "56-66",
          "snippet": "void\nleave_raw_mode(int quiet)\n{\n\tif (!_in_raw_mode)\n\t\treturn;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 0;\n}",
          "includes": [
            "#include \"sshpty.h\"",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios _saved_tio;",
            "static int _in_raw_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sshpty.h\"\n#include <pwd.h>\n#include <termios.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct termios _saved_tio;\nstatic int _in_raw_mode = 0;\n\nvoid\nleave_raw_mode(int quiet)\n{\n\tif (!_in_raw_mode)\n\t\treturn;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_free_all",
          "args": [
            "ssh"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "channel_free_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "642-650",
          "snippet": "void\nchannel_free_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_free(ssh, ssh->chanctxt->channels[i]);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_free_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_free(ssh, ssh->chanctxt->channels[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_write_wait",
          "args": [],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "packet_write_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "271-278",
          "snippet": "void\npacket_write_wait(void)\n{\n\tint r;\n\n\tif ((r = ssh_packet_write_wait(active_state)) != 0)\n\t\tsshpkt_fatal(active_state, __func__, r);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_write_wait(void)\n{\n\tint r;\n\n\tif ((r = ssh_packet_write_wait(active_state)) != 0)\n\t\tsshpkt_fatal(active_state, __func__, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "\"\""
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "\"disconnected by user\""
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "SSH2_DISCONNECT_BY_APPLICATION"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_start",
          "args": [
            "SSH2_MSG_DISCONNECT"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGWINCH",
            "SIG_DFL"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "writeset"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_write_poll",
          "args": [],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "packet_write_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "280-287",
          "snippet": "void\npacket_write_poll(void)\n{\n\tint r;\n\n\tif ((r = ssh_packet_write_poll(active_state)) != 0)\n\t\tsshpkt_fatal(active_state, __func__, r);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_write_poll(void)\n{\n\tint r;\n\n\tif ((r = ssh_packet_write_poll(active_state)) != 0)\n\t\tsshpkt_fatal(active_state, __func__, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "connection_out",
            "writeset"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_ISSET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "22-24",
          "snippet": "int kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nint kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_process_net_input",
          "args": [
            "readset"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "client_process_net_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "614-663",
          "snippet": "static void\nclient_process_net_input(fd_set *readset)\n{\n\tchar buf[SSH_IOBUFSZ];\n\tint r, len;\n\n\t/*\n\t * Read input from the server, and add any such data to the buffer of\n\t * the packet subsystem.\n\t */\n\tif (FD_ISSET(connection_in, readset)) {\n\t\t/* Read as much as possible. */\n\t\tlen = read(connection_in, buf, sizeof(buf));\n\t\tif (len == 0) {\n\t\t\t/*\n\t\t\t * Received EOF.  The remote host has closed the\n\t\t\t * connection.\n\t\t\t */\n\t\t\tif ((r = sshbuf_putf(stderr_buffer,\n\t\t\t    \"Connection to %.300s closed by remote host.\\r\\n\",\n\t\t\t    host)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tquit_pending = 1;\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * There is a kernel bug on Solaris that causes select to\n\t\t * sometimes wake up even though there is no data available.\n\t\t */\n\t\tif (len < 0 &&\n\t\t    (errno == EAGAIN || errno == EINTR || errno == EWOULDBLOCK))\n\t\t\tlen = 0;\n\n\t\tif (len < 0) {\n\t\t\t/*\n\t\t\t * An error has encountered.  Perhaps there is a\n\t\t\t * network problem.\n\t\t\t */\n\t\t\tif ((r = sshbuf_putf(stderr_buffer,\n\t\t\t    \"Read from remote host %.300s: %.100s\\r\\n\",\n\t\t\t    host, strerror(errno))) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tquit_pending = 1;\n\t\t\treturn;\n\t\t}\n\t\tpacket_process_incoming(buf, len);\n\t}\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *host;",
            "volatile sig_atomic_t quit_pending;",
            "static struct sshbuf *stderr_buffer;",
            "static int connection_in;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern char *host;\nvolatile sig_atomic_t quit_pending;\nstatic struct sshbuf *stderr_buffer;\nstatic int connection_in;\n\nstatic void\nclient_process_net_input(fd_set *readset)\n{\n\tchar buf[SSH_IOBUFSZ];\n\tint r, len;\n\n\t/*\n\t * Read input from the server, and add any such data to the buffer of\n\t * the packet subsystem.\n\t */\n\tif (FD_ISSET(connection_in, readset)) {\n\t\t/* Read as much as possible. */\n\t\tlen = read(connection_in, buf, sizeof(buf));\n\t\tif (len == 0) {\n\t\t\t/*\n\t\t\t * Received EOF.  The remote host has closed the\n\t\t\t * connection.\n\t\t\t */\n\t\t\tif ((r = sshbuf_putf(stderr_buffer,\n\t\t\t    \"Connection to %.300s closed by remote host.\\r\\n\",\n\t\t\t    host)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tquit_pending = 1;\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * There is a kernel bug on Solaris that causes select to\n\t\t * sometimes wake up even though there is no data available.\n\t\t */\n\t\tif (len < 0 &&\n\t\t    (errno == EAGAIN || errno == EINTR || errno == EWOULDBLOCK))\n\t\t\tlen = 0;\n\n\t\tif (len < 0) {\n\t\t\t/*\n\t\t\t * An error has encountered.  Perhaps there is a\n\t\t\t * network problem.\n\t\t\t */\n\t\t\tif ((r = sshbuf_putf(stderr_buffer,\n\t\t\t    \"Read from remote host %.300s: %.100s\\r\\n\",\n\t\t\t    host, strerror(errno))) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tquit_pending = 1;\n\t\t\treturn;\n\t\t}\n\t\tpacket_process_incoming(buf, len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_after_select",
          "args": [
            "ssh",
            "readset",
            "writeset"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "channel_after_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2513-2517",
          "snippet": "void\nchannel_after_select(struct ssh *ssh, fd_set *readset, fd_set *writeset)\n{\n\tchannel_handler(ssh, CHAN_POST, readset, writeset, NULL);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_after_select(struct ssh *ssh, fd_set *readset, fd_set *writeset)\n{\n\tchannel_handler(ssh, CHAN_POST, readset, writeset, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_is_rekeying",
          "args": [
            "ssh"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_is_rekeying",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "272-277",
          "snippet": "int\nssh_packet_is_rekeying(struct ssh *ssh)\n{\n\treturn ssh->state->rekeying ||\n\t    (ssh->kex != NULL && ssh->kex->done == 0);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_is_rekeying(struct ssh *ssh)\n{\n\treturn ssh->state->rekeying ||\n\t    (ssh->kex != NULL && ssh->kex->done == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_wait_until_can_do_something",
          "args": [
            "ssh",
            "&readset",
            "&writeset",
            "&max_fd2",
            "&nalloc",
            "ssh_packet_is_rekeying(ssh)"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "client_wait_until_can_do_something",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "501-586",
          "snippet": "static void\nclient_wait_until_can_do_something(struct ssh *ssh,\n    fd_set **readsetp, fd_set **writesetp,\n    int *maxfdp, u_int *nallocp, int rekeying)\n{\n\tstruct timeval tv, *tvp;\n\tint timeout_secs;\n\ttime_t minwait_secs = 0, server_alive_time = 0, now = monotime();\n\tint r, ret;\n\n\t/* Add any selections by the channel mechanism. */\n\tchannel_prepare_select(active_state, readsetp, writesetp, maxfdp,\n\t    nallocp, &minwait_secs);\n\n\t/* channel_prepare_select could have closed the last channel */\n\tif (session_closed && !channel_still_open(ssh) &&\n\t    !packet_have_data_to_write()) {\n\t\t/* clear mask since we did not call select() */\n\t\tmemset(*readsetp, 0, *nallocp);\n\t\tmemset(*writesetp, 0, *nallocp);\n\t\treturn;\n\t}\n\n\tFD_SET(connection_in, *readsetp);\n\n\t/* Select server connection if have data to write to the server. */\n\tif (packet_have_data_to_write())\n\t\tFD_SET(connection_out, *writesetp);\n\n\t/*\n\t * Wait for something to happen.  This will suspend the process until\n\t * some selected descriptor can be read, written, or has some other\n\t * event pending, or a timeout expires.\n\t */\n\n\ttimeout_secs = INT_MAX; /* we use INT_MAX to mean no timeout */\n\tif (options.server_alive_interval > 0) {\n\t\ttimeout_secs = options.server_alive_interval;\n\t\tserver_alive_time = now + options.server_alive_interval;\n\t}\n\tif (options.rekey_interval > 0 && !rekeying)\n\t\ttimeout_secs = MINIMUM(timeout_secs, packet_get_rekey_timeout());\n\tset_control_persist_exit_time(ssh);\n\tif (control_persist_exit_time > 0) {\n\t\ttimeout_secs = MINIMUM(timeout_secs,\n\t\t\tcontrol_persist_exit_time - now);\n\t\tif (timeout_secs < 0)\n\t\t\ttimeout_secs = 0;\n\t}\n\tif (minwait_secs != 0)\n\t\ttimeout_secs = MINIMUM(timeout_secs, (int)minwait_secs);\n\tif (timeout_secs == INT_MAX)\n\t\ttvp = NULL;\n\telse {\n\t\ttv.tv_sec = timeout_secs;\n\t\ttv.tv_usec = 0;\n\t\ttvp = &tv;\n\t}\n\n\tret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);\n\tif (ret < 0) {\n\t\t/*\n\t\t * We have to clear the select masks, because we return.\n\t\t * We have to return, because the mainloop checks for the flags\n\t\t * set by the signal handlers.\n\t\t */\n\t\tmemset(*readsetp, 0, *nallocp);\n\t\tmemset(*writesetp, 0, *nallocp);\n\n\t\tif (errno == EINTR)\n\t\t\treturn;\n\t\t/* Note: we might still have data in the buffers. */\n\t\tif ((r = sshbuf_putf(stderr_buffer,\n\t\t    \"select: %s\\r\\n\", strerror(errno))) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tquit_pending = 1;\n\t} else if (ret == 0) {\n\t\t/*\n\t\t * Timeout.  Could have been either keepalive or rekeying.\n\t\t * Keepalive we check here, rekeying is checked in clientloop.\n\t\t */\n\t\tif (server_alive_time != 0 && server_alive_time <= monotime())\n\t\t\tserver_alive_check();\n\t}\n\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "static time_t control_persist_exit_time = 0;",
            "volatile sig_atomic_t quit_pending;",
            "static struct sshbuf *stderr_buffer;",
            "static int connection_in;",
            "static int connection_out;",
            "static int session_closed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic time_t control_persist_exit_time = 0;\nvolatile sig_atomic_t quit_pending;\nstatic struct sshbuf *stderr_buffer;\nstatic int connection_in;\nstatic int connection_out;\nstatic int session_closed;\n\nstatic void\nclient_wait_until_can_do_something(struct ssh *ssh,\n    fd_set **readsetp, fd_set **writesetp,\n    int *maxfdp, u_int *nallocp, int rekeying)\n{\n\tstruct timeval tv, *tvp;\n\tint timeout_secs;\n\ttime_t minwait_secs = 0, server_alive_time = 0, now = monotime();\n\tint r, ret;\n\n\t/* Add any selections by the channel mechanism. */\n\tchannel_prepare_select(active_state, readsetp, writesetp, maxfdp,\n\t    nallocp, &minwait_secs);\n\n\t/* channel_prepare_select could have closed the last channel */\n\tif (session_closed && !channel_still_open(ssh) &&\n\t    !packet_have_data_to_write()) {\n\t\t/* clear mask since we did not call select() */\n\t\tmemset(*readsetp, 0, *nallocp);\n\t\tmemset(*writesetp, 0, *nallocp);\n\t\treturn;\n\t}\n\n\tFD_SET(connection_in, *readsetp);\n\n\t/* Select server connection if have data to write to the server. */\n\tif (packet_have_data_to_write())\n\t\tFD_SET(connection_out, *writesetp);\n\n\t/*\n\t * Wait for something to happen.  This will suspend the process until\n\t * some selected descriptor can be read, written, or has some other\n\t * event pending, or a timeout expires.\n\t */\n\n\ttimeout_secs = INT_MAX; /* we use INT_MAX to mean no timeout */\n\tif (options.server_alive_interval > 0) {\n\t\ttimeout_secs = options.server_alive_interval;\n\t\tserver_alive_time = now + options.server_alive_interval;\n\t}\n\tif (options.rekey_interval > 0 && !rekeying)\n\t\ttimeout_secs = MINIMUM(timeout_secs, packet_get_rekey_timeout());\n\tset_control_persist_exit_time(ssh);\n\tif (control_persist_exit_time > 0) {\n\t\ttimeout_secs = MINIMUM(timeout_secs,\n\t\t\tcontrol_persist_exit_time - now);\n\t\tif (timeout_secs < 0)\n\t\t\ttimeout_secs = 0;\n\t}\n\tif (minwait_secs != 0)\n\t\ttimeout_secs = MINIMUM(timeout_secs, (int)minwait_secs);\n\tif (timeout_secs == INT_MAX)\n\t\ttvp = NULL;\n\telse {\n\t\ttv.tv_sec = timeout_secs;\n\t\ttv.tv_usec = 0;\n\t\ttvp = &tv;\n\t}\n\n\tret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);\n\tif (ret < 0) {\n\t\t/*\n\t\t * We have to clear the select masks, because we return.\n\t\t * We have to return, because the mainloop checks for the flags\n\t\t * set by the signal handlers.\n\t\t */\n\t\tmemset(*readsetp, 0, *nallocp);\n\t\tmemset(*writesetp, 0, *nallocp);\n\n\t\tif (errno == EINTR)\n\t\t\treturn;\n\t\t/* Note: we might still have data in the buffers. */\n\t\tif ((r = sshbuf_putf(stderr_buffer,\n\t\t    \"select: %s\\r\\n\", strerror(errno))) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tquit_pending = 1;\n\t} else if (ret == 0) {\n\t\t/*\n\t\t * Timeout.  Could have been either keepalive or rekeying.\n\t\t * Keepalive we check here, rekeying is checked in clientloop.\n\t\t */\n\t\tif (server_alive_time != 0 && server_alive_time <= monotime())\n\t\t\tserver_alive_check();\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_check_window_change",
          "args": [
            "ssh"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "client_check_window_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "450-461",
          "snippet": "static void\nclient_check_window_change(struct ssh *ssh)\n{\n\tif (!received_window_change_signal)\n\t\treturn;\n\t/** XXX race */\n\treceived_window_change_signal = 0;\n\n\tdebug2(\"%s: changed\", __func__);\n\n\tchannel_send_window_changes(ssh);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile sig_atomic_t received_window_change_signal = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t received_window_change_signal = 0;\n\nstatic void\nclient_check_window_change(struct ssh *ssh)\n{\n\tif (!received_window_change_signal)\n\t\treturn;\n\t/** XXX race */\n\treceived_window_change_signal = 0;\n\n\tdebug2(\"%s: changed\", __func__);\n\n\tchannel_send_window_changes(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_output_poll",
          "args": [
            "ssh"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "channel_output_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2635-2669",
          "snippet": "void\nchannel_output_poll(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tChannel *c;\n\tu_int i;\n\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We are only interested in channels that can have buffered\n\t\t * incoming data.\n\t\t */\n\t\tif (c->type != SSH_CHANNEL_OPEN)\n\t\t\tcontinue;\n\t\tif ((c->flags & (CHAN_CLOSE_SENT|CHAN_CLOSE_RCVD))) {\n\t\t\t/* XXX is this true? */\n\t\t\tdebug3(\"channel %d: will not send data after close\",\n\t\t\t    c->self);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the amount of buffered data for this channel. */\n\t\tif (c->istate == CHAN_INPUT_OPEN ||\n\t\t    c->istate == CHAN_INPUT_WAIT_DRAIN)\n\t\t\tchannel_output_poll_input_open(ssh, c);\n\t\t/* Send extended data, i.e. stderr */\n\t\tif (!(c->flags & CHAN_EOF_SENT) &&\n\t\t    c->extended_usage == CHAN_EXTENDED_READ)\n\t\t\tchannel_output_poll_extended_read(ssh, c);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_output_poll(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tChannel *c;\n\tu_int i;\n\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We are only interested in channels that can have buffered\n\t\t * incoming data.\n\t\t */\n\t\tif (c->type != SSH_CHANNEL_OPEN)\n\t\t\tcontinue;\n\t\tif ((c->flags & (CHAN_CLOSE_SENT|CHAN_CLOSE_RCVD))) {\n\t\t\t/* XXX is this true? */\n\t\t\tdebug3(\"channel %d: will not send data after close\",\n\t\t\t    c->self);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the amount of buffered data for this channel. */\n\t\tif (c->istate == CHAN_INPUT_OPEN ||\n\t\t    c->istate == CHAN_INPUT_WAIT_DRAIN)\n\t\t\tchannel_output_poll_input_open(ssh, c);\n\t\t/* Send extended data, i.e. stderr */\n\t\tif (!(c->flags & CHAN_EOF_SENT) &&\n\t\t    c->extended_usage == CHAN_EXTENDED_READ)\n\t\t\tchannel_output_poll_extended_read(ssh, c);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_not_very_much_data_to_write",
          "args": [],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kex_start_rekex",
          "args": [
            "ssh"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "kex_start_rekex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "683-696",
          "snippet": "int\nkex_start_rekex(struct ssh *ssh)\n{\n\tif (ssh->kex == NULL) {\n\t\terror(\"%s: no kex\", __func__);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tif (ssh->kex->done == 0) {\n\t\terror(\"%s: requested twice\", __func__);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tssh->kex->done = 0;\n\treturn kex_send_kexinit(ssh);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kex_choose_conf(struct ssh *);",
            "static int kex_input_newkeys(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nstatic int kex_choose_conf(struct ssh *);\nstatic int kex_input_newkeys(int, u_int32_t, struct ssh *);\n\nint\nkex_start_rekex(struct ssh *ssh)\n{\n\tif (ssh->kex == NULL) {\n\t\terror(\"%s: no kex\", __func__);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tif (ssh->kex->done == 0) {\n\t\terror(\"%s: requested twice\", __func__);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tssh->kex->done = 0;\n\treturn kex_send_kexinit(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_still_open",
          "args": [
            "ssh"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "channel_still_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "718-758",
          "snippet": "int\nchannel_still_open(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tfatal(\"%s: bad channel type %d\", __func__, c->type);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_still_open(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tfatal(\"%s: bad channel type %d\", __func__, c->type);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_process_buffered_input_packets",
          "args": [],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "client_process_buffered_input_packets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1184-1188",
          "snippet": "static void\nclient_process_buffered_input_packets(void)\n{\n\tssh_dispatch_run_fatal(active_state, DISPATCH_NONBLOCK, &quit_pending);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "volatile sig_atomic_t quit_pending;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvolatile sig_atomic_t quit_pending;\n\nstatic void\nclient_process_buffered_input_packets(void)\n{\n\tssh_dispatch_run_fatal(active_state, DISPATCH_NONBLOCK, &quit_pending);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_register_cleanup",
          "args": [
            "ssh",
            "session_ident",
            "client_channel_closed",
            "0"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "985-997",
          "snippet": "void\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_register_filter",
          "args": [
            "ssh",
            "session_ident",
            "client_simple_escape_filter",
            "NULL",
            "client_filter_cleanup",
            "client_new_escape_filter_ctx(\n\t\t\t    escape_char_arg)"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1012-1026",
          "snippet": "void\nchannel_register_filter(struct ssh *ssh, int id, channel_infilter_fn *ifn,\n    channel_outfilter_fn *ofn, channel_filter_cleanup_fn *cfn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->input_filter = ifn;\n\tc->output_filter = ofn;\n\tc->filter_ctx = ctx;\n\tc->filter_cleanup = cfn;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_filter(struct ssh *ssh, int id, channel_infilter_fn *ifn,\n    channel_outfilter_fn *ofn, channel_filter_cleanup_fn *cfn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->input_filter = ifn;\n\tc->output_filter = ofn;\n\tc->filter_ctx = ctx;\n\tc->filter_cleanup = cfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_new_escape_filter_ctx",
          "args": [
            "escape_char_arg"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "client_new_escape_filter_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1193-1202",
          "snippet": "void *\nclient_new_escape_filter_ctx(int escape_char)\n{\n\tstruct escape_filter_ctx *ret;\n\n\tret = xcalloc(1, sizeof(*ret));\n\tret->escape_pending = 0;\n\tret->escape_char = escape_char;\n\treturn (void *)ret;\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nclient_new_escape_filter_ctx(int escape_char)\n{\n\tstruct escape_filter_ctx *ret;\n\n\tret = xcalloc(1, sizeof(*ret));\n\tret->escape_pending = 0;\n\tret->escape_char = escape_char;\n\treturn (void *)ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enter_raw_mode",
          "args": [
            "options.request_tty == REQUEST_TTY_FORCE"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "enter_raw_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshtty.c",
          "lines": "68-96",
          "snippet": "void\nenter_raw_mode(int quiet)\n{\n\tstruct termios tio;\n\n\tif (tcgetattr(fileno(stdin), &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcgetattr\");\n\t\treturn;\n\t}\n\t_saved_tio = tio;\n\ttio.c_iflag |= IGNPAR;\n\ttio.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);\n#ifdef IUCLC\n\ttio.c_iflag &= ~IUCLC;\n#endif\n\ttio.c_lflag &= ~(ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);\n#ifdef IEXTEN\n\ttio.c_lflag &= ~IEXTEN;\n#endif\n\ttio.c_oflag &= ~OPOST;\n\ttio.c_cc[VMIN] = 1;\n\ttio.c_cc[VTIME] = 0;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 1;\n}",
          "includes": [
            "#include \"sshpty.h\"",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios _saved_tio;",
            "static int _in_raw_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sshpty.h\"\n#include <pwd.h>\n#include <termios.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct termios _saved_tio;\nstatic int _in_raw_mode = 0;\n\nvoid\nenter_raw_mode(int quiet)\n{\n\tstruct termios tio;\n\n\tif (tcgetattr(fileno(stdin), &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcgetattr\");\n\t\treturn;\n\t}\n\t_saved_tio = tio;\n\ttio.c_iflag |= IGNPAR;\n\ttio.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);\n#ifdef IUCLC\n\ttio.c_iflag &= ~IUCLC;\n#endif\n\ttio.c_lflag &= ~(ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);\n#ifdef IEXTEN\n\ttio.c_lflag &= ~IEXTEN;\n#endif\n\ttio.c_oflag &= ~OPOST;\n\ttio.c_cc[VMIN] = 1;\n\ttio.c_cc[VTIME] = 0;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_init_dispatch",
          "args": [],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "client_init_dispatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "2307-2331",
          "snippet": "static void\nclient_init_dispatch(void)\n{\n\tdispatch_init(&dispatch_protocol_error);\n\n\tdispatch_set(SSH2_MSG_CHANNEL_CLOSE, &channel_input_oclose);\n\tdispatch_set(SSH2_MSG_CHANNEL_DATA, &channel_input_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_EOF, &channel_input_ieof);\n\tdispatch_set(SSH2_MSG_CHANNEL_EXTENDED_DATA, &channel_input_extended_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN, &client_input_channel_open);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, &channel_input_open_confirmation);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_FAILURE, &channel_input_open_failure);\n\tdispatch_set(SSH2_MSG_CHANNEL_REQUEST, &client_input_channel_req);\n\tdispatch_set(SSH2_MSG_CHANNEL_WINDOW_ADJUST, &channel_input_window_adjust);\n\tdispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &channel_input_status_confirm);\n\tdispatch_set(SSH2_MSG_CHANNEL_FAILURE, &channel_input_status_confirm);\n\tdispatch_set(SSH2_MSG_GLOBAL_REQUEST, &client_input_global_request);\n\n\t/* rekeying */\n\tdispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);\n\n\t/* global request reply messages */\n\tdispatch_set(SSH2_MSG_REQUEST_FAILURE, &client_global_request_reply);\n\tdispatch_set(SSH2_MSG_REQUEST_SUCCESS, &client_global_request_reply);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void client_init_dispatch(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void client_init_dispatch(void);\n\nstatic void\nclient_init_dispatch(void)\n{\n\tdispatch_init(&dispatch_protocol_error);\n\n\tdispatch_set(SSH2_MSG_CHANNEL_CLOSE, &channel_input_oclose);\n\tdispatch_set(SSH2_MSG_CHANNEL_DATA, &channel_input_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_EOF, &channel_input_ieof);\n\tdispatch_set(SSH2_MSG_CHANNEL_EXTENDED_DATA, &channel_input_extended_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN, &client_input_channel_open);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, &channel_input_open_confirmation);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_FAILURE, &channel_input_open_failure);\n\tdispatch_set(SSH2_MSG_CHANNEL_REQUEST, &client_input_channel_req);\n\tdispatch_set(SSH2_MSG_CHANNEL_WINDOW_ADJUST, &channel_input_window_adjust);\n\tdispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &channel_input_status_confirm);\n\tdispatch_set(SSH2_MSG_CHANNEL_FAILURE, &channel_input_status_confirm);\n\tdispatch_set(SSH2_MSG_GLOBAL_REQUEST, &client_input_global_request);\n\n\t/* rekeying */\n\tdispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);\n\n\t/* global request reply messages */\n\tdispatch_set(SSH2_MSG_REQUEST_FAILURE, &client_global_request_reply);\n\tdispatch_set(SSH2_MSG_REQUEST_SUCCESS, &client_global_request_reply);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "connection_in",
            "connection_out"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_connection_out",
          "args": [],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_connection_in",
          "args": [],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pledge",
          "args": [
            "\"stdio unix inet dns proc tty\"",
            "NULL"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "pledge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "255-259",
          "snippet": "int\npledge(const char *promises, const char *paths[])\n{\n\treturn 0;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npledge(const char *promises, const char *paths[])\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "option_clear_or_none",
          "args": [
            "options.proxy_command"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "option_clear_or_none",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "186-190",
          "snippet": "static int\noption_clear_or_none(const char *o)\n{\n\treturn o == NULL || strcasecmp(o, \"none\") == 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\noption_clear_or_none(const char *o)\n{\n\treturn o == NULL || strcasecmp(o, \"none\") == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nextern int no_shell_flag;\nextern int fork_after_authentication_flag;\nextern char *host;\nstatic volatile sig_atomic_t received_signal = 0;\nstatic time_t control_persist_exit_time = 0;\nvolatile sig_atomic_t quit_pending;\nstatic int last_was_cr;\nstatic int exit_status;\nstatic struct sshbuf *stderr_buffer;\nstatic int connection_in;\nstatic int connection_out;\nstatic int need_rekeying;\nstatic int session_closed;\nstatic void client_init_dispatch(void);\nint\tsession_ident = -1;\n\nint\nclient_loop(struct ssh *ssh, int have_pty, int escape_char_arg,\n    int ssh2_chan_id)\n{\n\tfd_set *readset = NULL, *writeset = NULL;\n\tdouble start_time, total_time;\n\tint r, max_fd = 0, max_fd2 = 0, len;\n\tu_int64_t ibytes, obytes;\n\tu_int nalloc = 0;\n\tchar buf[100];\n\n\tdebug(\"Entering interactive session.\");\n\n\tif (options.control_master &&\n\t    !option_clear_or_none(options.control_path)) {\n\t\tdebug(\"pledge: id\");\n\t\tif (pledge(\"stdio rpath wpath cpath unix inet dns recvfd proc exec id tty\",\n\t\t    NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\n\t} else if (options.forward_x11 || options.permit_local_command) {\n\t\tdebug(\"pledge: exec\");\n\t\tif (pledge(\"stdio rpath wpath cpath unix inet dns proc exec tty\",\n\t\t    NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\n\t} else if (options.update_hostkeys) {\n\t\tdebug(\"pledge: filesystem full\");\n\t\tif (pledge(\"stdio rpath wpath cpath unix inet dns proc tty\",\n\t\t    NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\n\t} else if (!option_clear_or_none(options.proxy_command) ||\n\t    fork_after_authentication_flag) {\n\t\tdebug(\"pledge: proc\");\n\t\tif (pledge(\"stdio cpath unix inet dns proc tty\", NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\n\t} else {\n\t\tdebug(\"pledge: network\");\n\t\tif (pledge(\"stdio unix inet dns proc tty\", NULL) == -1)\n\t\t\tfatal(\"%s pledge(): %s\", __func__, strerror(errno));\n\t}\n\n\tstart_time = monotime_double();\n\n\t/* Initialize variables. */\n\tlast_was_cr = 1;\n\texit_status = -1;\n\tconnection_in = packet_get_connection_in();\n\tconnection_out = packet_get_connection_out();\n\tmax_fd = MAXIMUM(connection_in, connection_out);\n\n\tquit_pending = 0;\n\n\t/* Initialize buffer. */\n\tif ((stderr_buffer = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tclient_init_dispatch();\n\n\t/*\n\t * Set signal handlers, (e.g. to restore non-blocking mode)\n\t * but don't overwrite SIG_IGN, matches behaviour from rsh(1)\n\t */\n\tif (signal(SIGHUP, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGHUP, signal_handler);\n\tif (signal(SIGINT, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGINT, signal_handler);\n\tif (signal(SIGQUIT, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGQUIT, signal_handler);\n\tif (signal(SIGTERM, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGTERM, signal_handler);\n\tsignal(SIGWINCH, window_change_handler);\n\n\tif (have_pty)\n\t\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\tsession_ident = ssh2_chan_id;\n\tif (session_ident != -1) {\n\t\tif (escape_char_arg != SSH_ESCAPECHAR_NONE) {\n\t\t\tchannel_register_filter(ssh, session_ident,\n\t\t\t    client_simple_escape_filter, NULL,\n\t\t\t    client_filter_cleanup,\n\t\t\t    client_new_escape_filter_ctx(\n\t\t\t    escape_char_arg));\n\t\t}\n\t\tchannel_register_cleanup(ssh, session_ident,\n\t\t    client_channel_closed, 0);\n\t}\n\n\t/* Main loop of the client for the interactive session mode. */\n\twhile (!quit_pending) {\n\n\t\t/* Process buffered packets sent by the server. */\n\t\tclient_process_buffered_input_packets();\n\n\t\tif (session_closed && !channel_still_open(ssh))\n\t\t\tbreak;\n\n\t\tif (ssh_packet_is_rekeying(ssh)) {\n\t\t\tdebug(\"rekeying in progress\");\n\t\t} else if (need_rekeying) {\n\t\t\t/* manual rekey request */\n\t\t\tdebug(\"need rekeying\");\n\t\t\tif ((r = kex_start_rekex(ssh)) != 0)\n\t\t\t\tfatal(\"%s: kex_start_rekex: %s\", __func__,\n\t\t\t\t    ssh_err(r));\n\t\t\tneed_rekeying = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Make packets from buffered channel data, and\n\t\t\t * enqueue them for sending to the server.\n\t\t\t */\n\t\t\tif (packet_not_very_much_data_to_write())\n\t\t\t\tchannel_output_poll(ssh);\n\n\t\t\t/*\n\t\t\t * Check if the window size has changed, and buffer a\n\t\t\t * message about it to the server if so.\n\t\t\t */\n\t\t\tclient_check_window_change(ssh);\n\n\t\t\tif (quit_pending)\n\t\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Wait until we have something to do (something becomes\n\t\t * available on one of the descriptors).\n\t\t */\n\t\tmax_fd2 = max_fd;\n\t\tclient_wait_until_can_do_something(ssh, &readset, &writeset,\n\t\t    &max_fd2, &nalloc, ssh_packet_is_rekeying(ssh));\n\n\t\tif (quit_pending)\n\t\t\tbreak;\n\n\t\t/* Do channel operations unless rekeying in progress. */\n\t\tif (!ssh_packet_is_rekeying(ssh))\n\t\t\tchannel_after_select(ssh, readset, writeset);\n\n\t\t/* Buffer input from the connection.  */\n\t\tclient_process_net_input(readset);\n\n\t\tif (quit_pending)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Send as much buffered packet data as possible to the\n\t\t * sender.\n\t\t */\n\t\tif (FD_ISSET(connection_out, writeset))\n\t\t\tpacket_write_poll();\n\n\t\t/*\n\t\t * If we are a backgrounded control master, and the\n\t\t * timeout has expired without any active client\n\t\t * connections, then quit.\n\t\t */\n\t\tif (control_persist_exit_time > 0) {\n\t\t\tif (monotime() >= control_persist_exit_time) {\n\t\t\t\tdebug(\"ControlPersist timeout expired\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfree(readset);\n\tfree(writeset);\n\n\t/* Terminate the session. */\n\n\t/* Stop watching for window change. */\n\tsignal(SIGWINCH, SIG_DFL);\n\n\tpacket_start(SSH2_MSG_DISCONNECT);\n\tpacket_put_int(SSH2_DISCONNECT_BY_APPLICATION);\n\tpacket_put_cstring(\"disconnected by user\");\n\tpacket_put_cstring(\"\"); /* language tag */\n\tpacket_send();\n\tpacket_write_wait();\n\n\tchannel_free_all(ssh);\n\n\tif (have_pty)\n\t\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\t/* restore blocking io */\n\tif (!isatty(fileno(stdin)))\n\t\tunset_nonblock(fileno(stdin));\n\tif (!isatty(fileno(stdout)))\n\t\tunset_nonblock(fileno(stdout));\n\tif (!isatty(fileno(stderr)))\n\t\tunset_nonblock(fileno(stderr));\n\n\t/*\n\t * If there was no shell or command requested, there will be no remote\n\t * exit status to be returned.  In that case, clear error code if the\n\t * connection was deliberately terminated at this end.\n\t */\n\tif (no_shell_flag && received_signal == SIGTERM) {\n\t\treceived_signal = 0;\n\t\texit_status = 0;\n\t}\n\n\tif (received_signal) {\n\t\tverbose(\"Killed by signal %d.\", (int) received_signal);\n\t\tcleanup_exit(0);\n\t}\n\n\t/*\n\t * In interactive mode (with pseudo tty) display a message indicating\n\t * that the connection has been closed.\n\t */\n\tif (have_pty && options.log_level != SYSLOG_LEVEL_QUIET) {\n\t\tif ((r = sshbuf_putf(stderr_buffer,\n\t\t    \"Connection to %.64s closed.\\r\\n\", host)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\t/* Output any buffered data for stderr. */\n\tif (sshbuf_len(stderr_buffer) > 0) {\n\t\tlen = atomicio(vwrite, fileno(stderr),\n\t\t    (u_char *)sshbuf_ptr(stderr_buffer),\n\t\t    sshbuf_len(stderr_buffer));\n\t\tif (len < 0 || (u_int)len != sshbuf_len(stderr_buffer))\n\t\t\terror(\"Write failed flushing stderr buffer.\");\n\t\telse if ((r = sshbuf_consume(stderr_buffer, len)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\t/* Clear and free any buffers. */\n\texplicit_bzero(buf, sizeof(buf));\n\tsshbuf_free(stderr_buffer);\n\n\t/* Report bytes transferred, and transfer rates. */\n\ttotal_time = monotime_double() - start_time;\n\tpacket_get_bytes(&ibytes, &obytes);\n\tverbose(\"Transferred: sent %llu, received %llu bytes, in %.1f seconds\",\n\t    (unsigned long long)obytes, (unsigned long long)ibytes, total_time);\n\tif (total_time > 0)\n\t\tverbose(\"Bytes per second: sent %.1f, received %.1f\",\n\t\t    obytes / total_time, ibytes / total_time);\n\t/* Return the exit status of the program. */\n\tdebug(\"Exit status %d\", exit_status);\n\treturn exit_status;\n}"
  },
  {
    "function_name": "client_channel_closed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "1221-1227",
    "snippet": "static void\nclient_channel_closed(struct ssh *ssh, int id, void *arg)\n{\n\tchannel_cancel_cleanup(ssh, id);\n\tsession_closed = 1;\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "static int session_closed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "leave_raw_mode",
          "args": [
            "options.request_tty == REQUEST_TTY_FORCE"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "leave_raw_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshtty.c",
          "lines": "56-66",
          "snippet": "void\nleave_raw_mode(int quiet)\n{\n\tif (!_in_raw_mode)\n\t\treturn;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 0;\n}",
          "includes": [
            "#include \"sshpty.h\"",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios _saved_tio;",
            "static int _in_raw_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sshpty.h\"\n#include <pwd.h>\n#include <termios.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct termios _saved_tio;\nstatic int _in_raw_mode = 0;\n\nvoid\nleave_raw_mode(int quiet)\n{\n\tif (!_in_raw_mode)\n\t\treturn;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_cancel_cleanup",
          "args": [
            "ssh",
            "id"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "channel_cancel_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "999-1010",
          "snippet": "void\nchannel_cancel_cleanup(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = NULL;\n\tc->detach_close = 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_cancel_cleanup(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = NULL;\n\tc->detach_close = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic int session_closed;\n\nstatic void\nclient_channel_closed(struct ssh *ssh, int id, void *arg)\n{\n\tchannel_cancel_cleanup(ssh, id);\n\tsession_closed = 1;\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n}"
  },
  {
    "function_name": "client_simple_escape_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "1211-1219",
    "snippet": "int\nclient_simple_escape_filter(struct ssh *ssh, Channel *c, char *buf, int len)\n{\n\tif (c->extended_usage != CHAN_EXTENDED_WRITE)\n\t\treturn 0;\n\n\treturn process_escapes(ssh, c, c->input, c->output, c->extended,\n\t    buf, len);\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_escapes",
          "args": [
            "ssh",
            "c",
            "c->input",
            "c->output",
            "c->extended",
            "buf",
            "len"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "process_escapes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "945-1170",
          "snippet": "static int\nprocess_escapes(struct ssh *ssh, Channel *c,\n    struct sshbuf *bin, struct sshbuf *bout, struct sshbuf *berr,\n    char *buf, int len)\n{\n\tpid_t pid;\n\tint r, bytes = 0;\n\tu_int i;\n\tu_char ch;\n\tchar *s;\n\tstruct escape_filter_ctx *efc = c->filter_ctx == NULL ?\n\t    NULL : (struct escape_filter_ctx *)c->filter_ctx;\n\n\tif (c->filter_ctx == NULL)\n\t\treturn 0;\n\n\tif (len <= 0)\n\t\treturn (0);\n\n\tfor (i = 0; i < (u_int)len; i++) {\n\t\t/* Get one character at a time. */\n\t\tch = buf[i];\n\n\t\tif (efc->escape_pending) {\n\t\t\t/* We have previously seen an escape character. */\n\t\t\t/* Clear the flag now. */\n\t\t\tefc->escape_pending = 0;\n\n\t\t\t/* Process the escaped character. */\n\t\t\tswitch (ch) {\n\t\t\tcase '.':\n\t\t\t\t/* Terminate the connection. */\n\t\t\t\tif ((r = sshbuf_putf(berr, \"%c.\\r\\n\",\n\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tif (c && c->ctl_chan != -1) {\n\t\t\t\t\tchan_read_failed(ssh, c);\n\t\t\t\t\tchan_write_failed(ssh, c);\n\t\t\t\t\tif (c->detach_user) {\n\t\t\t\t\t\tc->detach_user(ssh,\n\t\t\t\t\t\t    c->self, NULL);\n\t\t\t\t\t}\n\t\t\t\t\tc->type = SSH_CHANNEL_ABANDONED;\n\t\t\t\t\tsshbuf_reset(c->input);\n\t\t\t\t\tchan_ibuf_empty(ssh, c);\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\tquit_pending = 1;\n\t\t\t\treturn -1;\n\n\t\t\tcase 'Z' - 64:\n\t\t\t\t/* XXX support this for mux clients */\n\t\t\t\tif (c && c->ctl_chan != -1) {\n\t\t\t\t\tchar b[16];\n noescape:\n\t\t\t\t\tif (ch == 'Z' - 64)\n\t\t\t\t\t\tsnprintf(b, sizeof b, \"^Z\");\n\t\t\t\t\telse\n\t\t\t\t\t\tsnprintf(b, sizeof b, \"%c\", ch);\n\t\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t\t    \"%c%s escape not available to \"\n\t\t\t\t\t    \"multiplexed sessions\\r\\n\",\n\t\t\t\t\t    efc->escape_char, b)) != 0)\n\t\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Suspend the program. Inform the user */\n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%c^Z [suspend ssh]\\r\\n\",\n\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\n\t\t\t\t/* Restore terminal modes and suspend. */\n\t\t\t\tclient_suspend_self(bin, bout, berr);\n\n\t\t\t\t/* We have been continued. */\n\t\t\t\tcontinue;\n\n\t\t\tcase 'B':\n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%cB\\r\\n\", efc->escape_char)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tchannel_request_start(ssh, c->self, \"break\", 0);\n\t\t\t\tif ((r = sshpkt_put_u32(ssh, 1000)) != 0 ||\n\t\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\t\tfatal(\"%s: %s\", __func__,\n\t\t\t\t\t    ssh_err(r));\n\t\t\t\tcontinue;\n\n\t\t\tcase 'R':\n\t\t\t\tif (datafellows & SSH_BUG_NOREKEY)\n\t\t\t\t\tlogit(\"Server does not \"\n\t\t\t\t\t    \"support re-keying\");\n\t\t\t\telse\n\t\t\t\t\tneed_rekeying = 1;\n\t\t\t\tcontinue;\n\n\t\t\tcase 'V':\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase 'v':\n\t\t\t\tif (c && c->ctl_chan != -1)\n\t\t\t\t\tgoto noescape;\n\t\t\t\tif (!log_is_on_stderr()) {\n\t\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t\t    \"%c%c [Logging to syslog]\\r\\n\",\n\t\t\t\t\t    efc->escape_char, ch)) != 0)\n\t\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ch == 'V' && options.log_level >\n\t\t\t\t    SYSLOG_LEVEL_QUIET)\n\t\t\t\t\tlog_change_level(--options.log_level);\n\t\t\t\tif (ch == 'v' && options.log_level <\n\t\t\t\t    SYSLOG_LEVEL_DEBUG3)\n\t\t\t\t\tlog_change_level(++options.log_level);\n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%c%c [LogLevel %s]\\r\\n\",\n\t\t\t\t    efc->escape_char, ch,\n\t\t\t\t    log_level_name(options.log_level))) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tcontinue;\n\n\t\t\tcase '&':\n\t\t\t\tif (c && c->ctl_chan != -1)\n\t\t\t\t\tgoto noescape;\n\t\t\t\t/*\n\t\t\t\t * Detach the program (continue to serve\n\t\t\t\t * connections, but put in background and no\n\t\t\t\t * more new connections).\n\t\t\t\t */\n\t\t\t\t/* Restore tty modes. */\n\t\t\t\tleave_raw_mode(\n\t\t\t\t    options.request_tty == REQUEST_TTY_FORCE);\n\n\t\t\t\t/* Stop listening for new connections. */\n\t\t\t\tchannel_stop_listening(ssh);\n\n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%c& [backgrounded]\\n\", efc->escape_char))\n\t\t\t\t     != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\n\t\t\t\t/* Fork into background. */\n\t\t\t\tpid = fork();\n\t\t\t\tif (pid < 0) {\n\t\t\t\t\terror(\"fork: %.100s\", strerror(errno));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pid != 0) {\t/* This is the parent. */\n\t\t\t\t\t/* The parent just exits. */\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t\t/* The child continues serving connections. */\n\t\t\t\t/* fake EOF on stdin */\n\t\t\t\tif ((r = sshbuf_put_u8(bin, 4)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\treturn -1;\n\t\t\tcase '?':\n\t\t\t\tprint_escape_help(berr, efc->escape_char,\n\t\t\t\t    (c && c->ctl_chan != -1),\n\t\t\t\t    log_is_on_stderr());\n\t\t\t\tcontinue;\n\n\t\t\tcase '#':\n\t\t\t\tif ((r = sshbuf_putf(berr, \"%c#\\r\\n\",\n\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\ts = channel_open_message(ssh);\n\t\t\t\tif ((r = sshbuf_put(berr, s, strlen(s))) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tfree(s);\n\t\t\t\tcontinue;\n\n\t\t\tcase 'C':\n\t\t\t\tif (c && c->ctl_chan != -1)\n\t\t\t\t\tgoto noescape;\n\t\t\t\tprocess_cmdline(ssh);\n\t\t\t\tcontinue;\n\n\t\t\tdefault:\n\t\t\t\tif (ch != efc->escape_char) {\n\t\t\t\t\tif ((r = sshbuf_put_u8(bin,\n\t\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\t\tbytes++;\n\t\t\t\t}\n\t\t\t\t/* Escaped characters fall through here */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * The previous character was not an escape char.\n\t\t\t * Check if this is an escape.\n\t\t\t */\n\t\t\tif (last_was_cr && ch == efc->escape_char) {\n\t\t\t\t/*\n\t\t\t\t * It is. Set the flag and continue to\n\t\t\t\t * next character.\n\t\t\t\t */\n\t\t\t\tefc->escape_pending = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Normal character.  Record whether it was a newline,\n\t\t * and append it to the buffer.\n\t\t */\n\t\tlast_was_cr = (ch == '\\r' || ch == '\\n');\n\t\tif ((r = sshbuf_put_u8(bin, ch)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tbytes++;\n\t}\n\treturn bytes;\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "volatile sig_atomic_t quit_pending;",
            "static int last_was_cr;",
            "static int need_rekeying;",
            "void ssh_process_session2_setup(int, int, int, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nvolatile sig_atomic_t quit_pending;\nstatic int last_was_cr;\nstatic int need_rekeying;\nvoid ssh_process_session2_setup(int, int, int, struct sshbuf *);\n\nstatic int\nprocess_escapes(struct ssh *ssh, Channel *c,\n    struct sshbuf *bin, struct sshbuf *bout, struct sshbuf *berr,\n    char *buf, int len)\n{\n\tpid_t pid;\n\tint r, bytes = 0;\n\tu_int i;\n\tu_char ch;\n\tchar *s;\n\tstruct escape_filter_ctx *efc = c->filter_ctx == NULL ?\n\t    NULL : (struct escape_filter_ctx *)c->filter_ctx;\n\n\tif (c->filter_ctx == NULL)\n\t\treturn 0;\n\n\tif (len <= 0)\n\t\treturn (0);\n\n\tfor (i = 0; i < (u_int)len; i++) {\n\t\t/* Get one character at a time. */\n\t\tch = buf[i];\n\n\t\tif (efc->escape_pending) {\n\t\t\t/* We have previously seen an escape character. */\n\t\t\t/* Clear the flag now. */\n\t\t\tefc->escape_pending = 0;\n\n\t\t\t/* Process the escaped character. */\n\t\t\tswitch (ch) {\n\t\t\tcase '.':\n\t\t\t\t/* Terminate the connection. */\n\t\t\t\tif ((r = sshbuf_putf(berr, \"%c.\\r\\n\",\n\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tif (c && c->ctl_chan != -1) {\n\t\t\t\t\tchan_read_failed(ssh, c);\n\t\t\t\t\tchan_write_failed(ssh, c);\n\t\t\t\t\tif (c->detach_user) {\n\t\t\t\t\t\tc->detach_user(ssh,\n\t\t\t\t\t\t    c->self, NULL);\n\t\t\t\t\t}\n\t\t\t\t\tc->type = SSH_CHANNEL_ABANDONED;\n\t\t\t\t\tsshbuf_reset(c->input);\n\t\t\t\t\tchan_ibuf_empty(ssh, c);\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\tquit_pending = 1;\n\t\t\t\treturn -1;\n\n\t\t\tcase 'Z' - 64:\n\t\t\t\t/* XXX support this for mux clients */\n\t\t\t\tif (c && c->ctl_chan != -1) {\n\t\t\t\t\tchar b[16];\n noescape:\n\t\t\t\t\tif (ch == 'Z' - 64)\n\t\t\t\t\t\tsnprintf(b, sizeof b, \"^Z\");\n\t\t\t\t\telse\n\t\t\t\t\t\tsnprintf(b, sizeof b, \"%c\", ch);\n\t\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t\t    \"%c%s escape not available to \"\n\t\t\t\t\t    \"multiplexed sessions\\r\\n\",\n\t\t\t\t\t    efc->escape_char, b)) != 0)\n\t\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Suspend the program. Inform the user */\n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%c^Z [suspend ssh]\\r\\n\",\n\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\n\t\t\t\t/* Restore terminal modes and suspend. */\n\t\t\t\tclient_suspend_self(bin, bout, berr);\n\n\t\t\t\t/* We have been continued. */\n\t\t\t\tcontinue;\n\n\t\t\tcase 'B':\n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%cB\\r\\n\", efc->escape_char)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tchannel_request_start(ssh, c->self, \"break\", 0);\n\t\t\t\tif ((r = sshpkt_put_u32(ssh, 1000)) != 0 ||\n\t\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\t\tfatal(\"%s: %s\", __func__,\n\t\t\t\t\t    ssh_err(r));\n\t\t\t\tcontinue;\n\n\t\t\tcase 'R':\n\t\t\t\tif (datafellows & SSH_BUG_NOREKEY)\n\t\t\t\t\tlogit(\"Server does not \"\n\t\t\t\t\t    \"support re-keying\");\n\t\t\t\telse\n\t\t\t\t\tneed_rekeying = 1;\n\t\t\t\tcontinue;\n\n\t\t\tcase 'V':\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase 'v':\n\t\t\t\tif (c && c->ctl_chan != -1)\n\t\t\t\t\tgoto noescape;\n\t\t\t\tif (!log_is_on_stderr()) {\n\t\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t\t    \"%c%c [Logging to syslog]\\r\\n\",\n\t\t\t\t\t    efc->escape_char, ch)) != 0)\n\t\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ch == 'V' && options.log_level >\n\t\t\t\t    SYSLOG_LEVEL_QUIET)\n\t\t\t\t\tlog_change_level(--options.log_level);\n\t\t\t\tif (ch == 'v' && options.log_level <\n\t\t\t\t    SYSLOG_LEVEL_DEBUG3)\n\t\t\t\t\tlog_change_level(++options.log_level);\n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%c%c [LogLevel %s]\\r\\n\",\n\t\t\t\t    efc->escape_char, ch,\n\t\t\t\t    log_level_name(options.log_level))) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tcontinue;\n\n\t\t\tcase '&':\n\t\t\t\tif (c && c->ctl_chan != -1)\n\t\t\t\t\tgoto noescape;\n\t\t\t\t/*\n\t\t\t\t * Detach the program (continue to serve\n\t\t\t\t * connections, but put in background and no\n\t\t\t\t * more new connections).\n\t\t\t\t */\n\t\t\t\t/* Restore tty modes. */\n\t\t\t\tleave_raw_mode(\n\t\t\t\t    options.request_tty == REQUEST_TTY_FORCE);\n\n\t\t\t\t/* Stop listening for new connections. */\n\t\t\t\tchannel_stop_listening(ssh);\n\n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%c& [backgrounded]\\n\", efc->escape_char))\n\t\t\t\t     != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\n\t\t\t\t/* Fork into background. */\n\t\t\t\tpid = fork();\n\t\t\t\tif (pid < 0) {\n\t\t\t\t\terror(\"fork: %.100s\", strerror(errno));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pid != 0) {\t/* This is the parent. */\n\t\t\t\t\t/* The parent just exits. */\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t\t/* The child continues serving connections. */\n\t\t\t\t/* fake EOF on stdin */\n\t\t\t\tif ((r = sshbuf_put_u8(bin, 4)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\treturn -1;\n\t\t\tcase '?':\n\t\t\t\tprint_escape_help(berr, efc->escape_char,\n\t\t\t\t    (c && c->ctl_chan != -1),\n\t\t\t\t    log_is_on_stderr());\n\t\t\t\tcontinue;\n\n\t\t\tcase '#':\n\t\t\t\tif ((r = sshbuf_putf(berr, \"%c#\\r\\n\",\n\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\ts = channel_open_message(ssh);\n\t\t\t\tif ((r = sshbuf_put(berr, s, strlen(s))) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tfree(s);\n\t\t\t\tcontinue;\n\n\t\t\tcase 'C':\n\t\t\t\tif (c && c->ctl_chan != -1)\n\t\t\t\t\tgoto noescape;\n\t\t\t\tprocess_cmdline(ssh);\n\t\t\t\tcontinue;\n\n\t\t\tdefault:\n\t\t\t\tif (ch != efc->escape_char) {\n\t\t\t\t\tif ((r = sshbuf_put_u8(bin,\n\t\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\t\tbytes++;\n\t\t\t\t}\n\t\t\t\t/* Escaped characters fall through here */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * The previous character was not an escape char.\n\t\t\t * Check if this is an escape.\n\t\t\t */\n\t\t\tif (last_was_cr && ch == efc->escape_char) {\n\t\t\t\t/*\n\t\t\t\t * It is. Set the flag and continue to\n\t\t\t\t * next character.\n\t\t\t\t */\n\t\t\t\tefc->escape_pending = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Normal character.  Record whether it was a newline,\n\t\t * and append it to the buffer.\n\t\t */\n\t\tlast_was_cr = (ch == '\\r' || ch == '\\n');\n\t\tif ((r = sshbuf_put_u8(bin, ch)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tbytes++;\n\t}\n\treturn bytes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nclient_simple_escape_filter(struct ssh *ssh, Channel *c, char *buf, int len)\n{\n\tif (c->extended_usage != CHAN_EXTENDED_WRITE)\n\t\treturn 0;\n\n\treturn process_escapes(ssh, c, c->input, c->output, c->extended,\n\t    buf, len);\n}"
  },
  {
    "function_name": "client_filter_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "1205-1209",
    "snippet": "void\nclient_filter_cleanup(struct ssh *ssh, int cid, void *ctx)\n{\n\tfree(ctx);\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ctx"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclient_filter_cleanup(struct ssh *ssh, int cid, void *ctx)\n{\n\tfree(ctx);\n}"
  },
  {
    "function_name": "client_new_escape_filter_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "1193-1202",
    "snippet": "void *\nclient_new_escape_filter_ctx(int escape_char)\n{\n\tstruct escape_filter_ctx *ret;\n\n\tret = xcalloc(1, sizeof(*ret));\n\tret->escape_pending = 0;\n\tret->escape_char = escape_char;\n\treturn (void *)ret;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(*ret)"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nclient_new_escape_filter_ctx(int escape_char)\n{\n\tstruct escape_filter_ctx *ret;\n\n\tret = xcalloc(1, sizeof(*ret));\n\tret->escape_pending = 0;\n\tret->escape_char = escape_char;\n\treturn (void *)ret;\n}"
  },
  {
    "function_name": "client_process_buffered_input_packets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "1184-1188",
    "snippet": "static void\nclient_process_buffered_input_packets(void)\n{\n\tssh_dispatch_run_fatal(active_state, DISPATCH_NONBLOCK, &quit_pending);\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "volatile sig_atomic_t quit_pending;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_dispatch_run_fatal",
          "args": [
            "active_state",
            "DISPATCH_NONBLOCK",
            "&quit_pending"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_run_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "128-135",
          "snippet": "void\nssh_dispatch_run_fatal(struct ssh *ssh, int mode, volatile sig_atomic_t *done)\n{\n\tint r;\n\n\tif ((r = ssh_dispatch_run(ssh, mode, done)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_run_fatal(struct ssh *ssh, int mode, volatile sig_atomic_t *done)\n{\n\tint r;\n\n\tif ((r = ssh_dispatch_run(ssh, mode, done)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvolatile sig_atomic_t quit_pending;\n\nstatic void\nclient_process_buffered_input_packets(void)\n{\n\tssh_dispatch_run_fatal(active_state, DISPATCH_NONBLOCK, &quit_pending);\n}"
  },
  {
    "function_name": "process_escapes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "945-1170",
    "snippet": "static int\nprocess_escapes(struct ssh *ssh, Channel *c,\n    struct sshbuf *bin, struct sshbuf *bout, struct sshbuf *berr,\n    char *buf, int len)\n{\n\tpid_t pid;\n\tint r, bytes = 0;\n\tu_int i;\n\tu_char ch;\n\tchar *s;\n\tstruct escape_filter_ctx *efc = c->filter_ctx == NULL ?\n\t    NULL : (struct escape_filter_ctx *)c->filter_ctx;\n\n\tif (c->filter_ctx == NULL)\n\t\treturn 0;\n\n\tif (len <= 0)\n\t\treturn (0);\n\n\tfor (i = 0; i < (u_int)len; i++) {\n\t\t/* Get one character at a time. */\n\t\tch = buf[i];\n\n\t\tif (efc->escape_pending) {\n\t\t\t/* We have previously seen an escape character. */\n\t\t\t/* Clear the flag now. */\n\t\t\tefc->escape_pending = 0;\n\n\t\t\t/* Process the escaped character. */\n\t\t\tswitch (ch) {\n\t\t\tcase '.':\n\t\t\t\t/* Terminate the connection. */\n\t\t\t\tif ((r = sshbuf_putf(berr, \"%c.\\r\\n\",\n\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tif (c && c->ctl_chan != -1) {\n\t\t\t\t\tchan_read_failed(ssh, c);\n\t\t\t\t\tchan_write_failed(ssh, c);\n\t\t\t\t\tif (c->detach_user) {\n\t\t\t\t\t\tc->detach_user(ssh,\n\t\t\t\t\t\t    c->self, NULL);\n\t\t\t\t\t}\n\t\t\t\t\tc->type = SSH_CHANNEL_ABANDONED;\n\t\t\t\t\tsshbuf_reset(c->input);\n\t\t\t\t\tchan_ibuf_empty(ssh, c);\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\tquit_pending = 1;\n\t\t\t\treturn -1;\n\n\t\t\tcase 'Z' - 64:\n\t\t\t\t/* XXX support this for mux clients */\n\t\t\t\tif (c && c->ctl_chan != -1) {\n\t\t\t\t\tchar b[16];\n noescape:\n\t\t\t\t\tif (ch == 'Z' - 64)\n\t\t\t\t\t\tsnprintf(b, sizeof b, \"^Z\");\n\t\t\t\t\telse\n\t\t\t\t\t\tsnprintf(b, sizeof b, \"%c\", ch);\n\t\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t\t    \"%c%s escape not available to \"\n\t\t\t\t\t    \"multiplexed sessions\\r\\n\",\n\t\t\t\t\t    efc->escape_char, b)) != 0)\n\t\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Suspend the program. Inform the user */\n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%c^Z [suspend ssh]\\r\\n\",\n\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\n\t\t\t\t/* Restore terminal modes and suspend. */\n\t\t\t\tclient_suspend_self(bin, bout, berr);\n\n\t\t\t\t/* We have been continued. */\n\t\t\t\tcontinue;\n\n\t\t\tcase 'B':\n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%cB\\r\\n\", efc->escape_char)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tchannel_request_start(ssh, c->self, \"break\", 0);\n\t\t\t\tif ((r = sshpkt_put_u32(ssh, 1000)) != 0 ||\n\t\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\t\tfatal(\"%s: %s\", __func__,\n\t\t\t\t\t    ssh_err(r));\n\t\t\t\tcontinue;\n\n\t\t\tcase 'R':\n\t\t\t\tif (datafellows & SSH_BUG_NOREKEY)\n\t\t\t\t\tlogit(\"Server does not \"\n\t\t\t\t\t    \"support re-keying\");\n\t\t\t\telse\n\t\t\t\t\tneed_rekeying = 1;\n\t\t\t\tcontinue;\n\n\t\t\tcase 'V':\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase 'v':\n\t\t\t\tif (c && c->ctl_chan != -1)\n\t\t\t\t\tgoto noescape;\n\t\t\t\tif (!log_is_on_stderr()) {\n\t\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t\t    \"%c%c [Logging to syslog]\\r\\n\",\n\t\t\t\t\t    efc->escape_char, ch)) != 0)\n\t\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ch == 'V' && options.log_level >\n\t\t\t\t    SYSLOG_LEVEL_QUIET)\n\t\t\t\t\tlog_change_level(--options.log_level);\n\t\t\t\tif (ch == 'v' && options.log_level <\n\t\t\t\t    SYSLOG_LEVEL_DEBUG3)\n\t\t\t\t\tlog_change_level(++options.log_level);\n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%c%c [LogLevel %s]\\r\\n\",\n\t\t\t\t    efc->escape_char, ch,\n\t\t\t\t    log_level_name(options.log_level))) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tcontinue;\n\n\t\t\tcase '&':\n\t\t\t\tif (c && c->ctl_chan != -1)\n\t\t\t\t\tgoto noescape;\n\t\t\t\t/*\n\t\t\t\t * Detach the program (continue to serve\n\t\t\t\t * connections, but put in background and no\n\t\t\t\t * more new connections).\n\t\t\t\t */\n\t\t\t\t/* Restore tty modes. */\n\t\t\t\tleave_raw_mode(\n\t\t\t\t    options.request_tty == REQUEST_TTY_FORCE);\n\n\t\t\t\t/* Stop listening for new connections. */\n\t\t\t\tchannel_stop_listening(ssh);\n\n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%c& [backgrounded]\\n\", efc->escape_char))\n\t\t\t\t     != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\n\t\t\t\t/* Fork into background. */\n\t\t\t\tpid = fork();\n\t\t\t\tif (pid < 0) {\n\t\t\t\t\terror(\"fork: %.100s\", strerror(errno));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pid != 0) {\t/* This is the parent. */\n\t\t\t\t\t/* The parent just exits. */\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t\t/* The child continues serving connections. */\n\t\t\t\t/* fake EOF on stdin */\n\t\t\t\tif ((r = sshbuf_put_u8(bin, 4)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\treturn -1;\n\t\t\tcase '?':\n\t\t\t\tprint_escape_help(berr, efc->escape_char,\n\t\t\t\t    (c && c->ctl_chan != -1),\n\t\t\t\t    log_is_on_stderr());\n\t\t\t\tcontinue;\n\n\t\t\tcase '#':\n\t\t\t\tif ((r = sshbuf_putf(berr, \"%c#\\r\\n\",\n\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\ts = channel_open_message(ssh);\n\t\t\t\tif ((r = sshbuf_put(berr, s, strlen(s))) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tfree(s);\n\t\t\t\tcontinue;\n\n\t\t\tcase 'C':\n\t\t\t\tif (c && c->ctl_chan != -1)\n\t\t\t\t\tgoto noescape;\n\t\t\t\tprocess_cmdline(ssh);\n\t\t\t\tcontinue;\n\n\t\t\tdefault:\n\t\t\t\tif (ch != efc->escape_char) {\n\t\t\t\t\tif ((r = sshbuf_put_u8(bin,\n\t\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\t\tbytes++;\n\t\t\t\t}\n\t\t\t\t/* Escaped characters fall through here */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * The previous character was not an escape char.\n\t\t\t * Check if this is an escape.\n\t\t\t */\n\t\t\tif (last_was_cr && ch == efc->escape_char) {\n\t\t\t\t/*\n\t\t\t\t * It is. Set the flag and continue to\n\t\t\t\t * next character.\n\t\t\t\t */\n\t\t\t\tefc->escape_pending = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Normal character.  Record whether it was a newline,\n\t\t * and append it to the buffer.\n\t\t */\n\t\tlast_was_cr = (ch == '\\r' || ch == '\\n');\n\t\tif ((r = sshbuf_put_u8(bin, ch)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tbytes++;\n\t}\n\treturn bytes;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "volatile sig_atomic_t quit_pending;",
      "static int last_was_cr;",
      "static int need_rekeying;",
      "void ssh_process_session2_setup(int, int, int, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "bin",
            "ch"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_cmdline",
          "args": [
            "ssh"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "process_cmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "768-884",
          "snippet": "static void\nprocess_cmdline(struct ssh *ssh)\n{\n\tvoid (*handler)(int);\n\tchar *s, *cmd;\n\tint ok, delete = 0, local = 0, remote = 0, dynamic = 0;\n\tstruct Forward fwd;\n\n\tmemset(&fwd, 0, sizeof(fwd));\n\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\thandler = signal(SIGINT, SIG_IGN);\n\tcmd = s = read_passphrase(\"\\r\\nssh> \", RP_ECHO);\n\tif (s == NULL)\n\t\tgoto out;\n\twhile (isspace((u_char)*s))\n\t\ts++;\n\tif (*s == '-')\n\t\ts++;\t/* Skip cmdline '-', if any */\n\tif (*s == '\\0')\n\t\tgoto out;\n\n\tif (*s == 'h' || *s == 'H' || *s == '?') {\n\t\tlogit(\"Commands:\");\n\t\tlogit(\"      -L[bind_address:]port:host:hostport    \"\n\t\t    \"Request local forward\");\n\t\tlogit(\"      -R[bind_address:]port:host:hostport    \"\n\t\t    \"Request remote forward\");\n\t\tlogit(\"      -D[bind_address:]port                  \"\n\t\t    \"Request dynamic forward\");\n\t\tlogit(\"      -KL[bind_address:]port                 \"\n\t\t    \"Cancel local forward\");\n\t\tlogit(\"      -KR[bind_address:]port                 \"\n\t\t    \"Cancel remote forward\");\n\t\tlogit(\"      -KD[bind_address:]port                 \"\n\t\t    \"Cancel dynamic forward\");\n\t\tif (!options.permit_local_command)\n\t\t\tgoto out;\n\t\tlogit(\"      !args                                  \"\n\t\t    \"Execute local command\");\n\t\tgoto out;\n\t}\n\n\tif (*s == '!' && options.permit_local_command) {\n\t\ts++;\n\t\tssh_local_cmd(s);\n\t\tgoto out;\n\t}\n\n\tif (*s == 'K') {\n\t\tdelete = 1;\n\t\ts++;\n\t}\n\tif (*s == 'L')\n\t\tlocal = 1;\n\telse if (*s == 'R')\n\t\tremote = 1;\n\telse if (*s == 'D')\n\t\tdynamic = 1;\n\telse {\n\t\tlogit(\"Invalid command.\");\n\t\tgoto out;\n\t}\n\n\twhile (isspace((u_char)*++s))\n\t\t;\n\n\t/* XXX update list of forwards in options */\n\tif (delete) {\n\t\t/* We pass 1 for dynamicfwd to restrict to 1 or 2 fields. */\n\t\tif (!parse_forward(&fwd, s, 1, 0)) {\n\t\t\tlogit(\"Bad forwarding close specification.\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (remote)\n\t\t\tok = channel_request_rforward_cancel(ssh, &fwd) == 0;\n\t\telse if (dynamic)\n\t\t\tok = channel_cancel_lport_listener(ssh, &fwd,\n\t\t\t    0, &options.fwd_opts) > 0;\n\t\telse\n\t\t\tok = channel_cancel_lport_listener(ssh, &fwd,\n\t\t\t    CHANNEL_CANCEL_PORT_STATIC,\n\t\t\t    &options.fwd_opts) > 0;\n\t\tif (!ok) {\n\t\t\tlogit(\"Unknown port forwarding.\");\n\t\t\tgoto out;\n\t\t}\n\t\tlogit(\"Canceled forwarding.\");\n\t} else {\n\t\tif (!parse_forward(&fwd, s, dynamic, remote)) {\n\t\t\tlogit(\"Bad forwarding specification.\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (local || dynamic) {\n\t\t\tif (!channel_setup_local_fwd_listener(ssh, &fwd,\n\t\t\t    &options.fwd_opts)) {\n\t\t\t\tlogit(\"Port forwarding failed.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tif (channel_request_remote_forwarding(ssh, &fwd) < 0) {\n\t\t\t\tlogit(\"Port forwarding failed.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tlogit(\"Forwarding port.\");\n\t}\n\nout:\n\tsignal(SIGINT, handler);\n\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\tfree(cmd);\n\tfree(fwd.listen_host);\n\tfree(fwd.listen_path);\n\tfree(fwd.connect_host);\n\tfree(fwd.connect_path);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "extern char *host;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nextern char *host;\n\nstatic void\nprocess_cmdline(struct ssh *ssh)\n{\n\tvoid (*handler)(int);\n\tchar *s, *cmd;\n\tint ok, delete = 0, local = 0, remote = 0, dynamic = 0;\n\tstruct Forward fwd;\n\n\tmemset(&fwd, 0, sizeof(fwd));\n\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\thandler = signal(SIGINT, SIG_IGN);\n\tcmd = s = read_passphrase(\"\\r\\nssh> \", RP_ECHO);\n\tif (s == NULL)\n\t\tgoto out;\n\twhile (isspace((u_char)*s))\n\t\ts++;\n\tif (*s == '-')\n\t\ts++;\t/* Skip cmdline '-', if any */\n\tif (*s == '\\0')\n\t\tgoto out;\n\n\tif (*s == 'h' || *s == 'H' || *s == '?') {\n\t\tlogit(\"Commands:\");\n\t\tlogit(\"      -L[bind_address:]port:host:hostport    \"\n\t\t    \"Request local forward\");\n\t\tlogit(\"      -R[bind_address:]port:host:hostport    \"\n\t\t    \"Request remote forward\");\n\t\tlogit(\"      -D[bind_address:]port                  \"\n\t\t    \"Request dynamic forward\");\n\t\tlogit(\"      -KL[bind_address:]port                 \"\n\t\t    \"Cancel local forward\");\n\t\tlogit(\"      -KR[bind_address:]port                 \"\n\t\t    \"Cancel remote forward\");\n\t\tlogit(\"      -KD[bind_address:]port                 \"\n\t\t    \"Cancel dynamic forward\");\n\t\tif (!options.permit_local_command)\n\t\t\tgoto out;\n\t\tlogit(\"      !args                                  \"\n\t\t    \"Execute local command\");\n\t\tgoto out;\n\t}\n\n\tif (*s == '!' && options.permit_local_command) {\n\t\ts++;\n\t\tssh_local_cmd(s);\n\t\tgoto out;\n\t}\n\n\tif (*s == 'K') {\n\t\tdelete = 1;\n\t\ts++;\n\t}\n\tif (*s == 'L')\n\t\tlocal = 1;\n\telse if (*s == 'R')\n\t\tremote = 1;\n\telse if (*s == 'D')\n\t\tdynamic = 1;\n\telse {\n\t\tlogit(\"Invalid command.\");\n\t\tgoto out;\n\t}\n\n\twhile (isspace((u_char)*++s))\n\t\t;\n\n\t/* XXX update list of forwards in options */\n\tif (delete) {\n\t\t/* We pass 1 for dynamicfwd to restrict to 1 or 2 fields. */\n\t\tif (!parse_forward(&fwd, s, 1, 0)) {\n\t\t\tlogit(\"Bad forwarding close specification.\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (remote)\n\t\t\tok = channel_request_rforward_cancel(ssh, &fwd) == 0;\n\t\telse if (dynamic)\n\t\t\tok = channel_cancel_lport_listener(ssh, &fwd,\n\t\t\t    0, &options.fwd_opts) > 0;\n\t\telse\n\t\t\tok = channel_cancel_lport_listener(ssh, &fwd,\n\t\t\t    CHANNEL_CANCEL_PORT_STATIC,\n\t\t\t    &options.fwd_opts) > 0;\n\t\tif (!ok) {\n\t\t\tlogit(\"Unknown port forwarding.\");\n\t\t\tgoto out;\n\t\t}\n\t\tlogit(\"Canceled forwarding.\");\n\t} else {\n\t\tif (!parse_forward(&fwd, s, dynamic, remote)) {\n\t\t\tlogit(\"Bad forwarding specification.\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (local || dynamic) {\n\t\t\tif (!channel_setup_local_fwd_listener(ssh, &fwd,\n\t\t\t    &options.fwd_opts)) {\n\t\t\t\tlogit(\"Port forwarding failed.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tif (channel_request_remote_forwarding(ssh, &fwd) < 0) {\n\t\t\t\tlogit(\"Port forwarding failed.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tlogit(\"Forwarding port.\");\n\t}\n\nout:\n\tsignal(SIGINT, handler);\n\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\tfree(cmd);\n\tfree(fwd.listen_host);\n\tfree(fwd.listen_path);\n\tfree(fwd.connect_host);\n\tfree(fwd.connect_path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "berr",
            "s",
            "strlen(s)"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_open_message",
          "args": [
            "ssh"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "channel_open_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "842-900",
          "snippet": "char *\nchannel_open_message(struct ssh *ssh)\n{\n\tstruct sshbuf *buf;\n\tChannel *c;\n\tu_int i;\n\tint r;\n\tchar *cp, *ret;\n\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_putf(buf,\n\t    \"The following connections are open:\\r\\n\")) != 0)\n\t\tfatal(\"%s: sshbuf_putf: %s\", __func__, ssh_err(r));\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\t\tcp = channel_format_status(c);\n\t\t\tif ((r = sshbuf_putf(buf, \"  #%d %.300s (%s)\\r\\n\",\n\t\t\t    c->self, c->remote_name, cp)) != 0) {\n\t\t\t\tfree(cp);\n\t\t\t\tfatal(\"%s: sshbuf_putf: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tfatal(\"%s: bad channel type %d\", __func__, c->type);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\tif ((ret = sshbuf_dup_string(buf)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string\", __func__);\n\tsshbuf_free(buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nchar *\nchannel_open_message(struct ssh *ssh)\n{\n\tstruct sshbuf *buf;\n\tChannel *c;\n\tu_int i;\n\tint r;\n\tchar *cp, *ret;\n\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_putf(buf,\n\t    \"The following connections are open:\\r\\n\")) != 0)\n\t\tfatal(\"%s: sshbuf_putf: %s\", __func__, ssh_err(r));\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\t\tcp = channel_format_status(c);\n\t\t\tif ((r = sshbuf_putf(buf, \"  #%d %.300s (%s)\\r\\n\",\n\t\t\t    c->self, c->remote_name, cp)) != 0) {\n\t\t\t\tfree(cp);\n\t\t\t\tfatal(\"%s: sshbuf_putf: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tfatal(\"%s: bad channel type %d\", __func__, c->type);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\tif ((ret = sshbuf_dup_string(buf)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string\", __func__);\n\tsshbuf_free(buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_escape_help",
          "args": [
            "berr",
            "efc->escape_char",
            "(c && c->ctl_chan != -1)",
            "log_is_on_stderr()"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "print_escape_help",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "911-940",
          "snippet": "static void\nprint_escape_help(struct sshbuf *b, int escape_char, int mux_client,\n    int using_stderr)\n{\n\tunsigned int i, suppress_flags;\n\tint r;\n\n\tif ((r = sshbuf_putf(b,\n\t    \"%c?\\r\\nSupported escape sequences:\\r\\n\", escape_char)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tsuppress_flags =\n\t    (mux_client ? SUPPRESS_MUXCLIENT : 0) |\n\t    (mux_client ? 0 : SUPPRESS_MUXMASTER) |\n\t    (using_stderr ? 0 : SUPPRESS_SYSLOG);\n\n\tfor (i = 0; i < sizeof(esc_txt)/sizeof(esc_txt[0]); i++) {\n\t\tif (esc_txt[i].flags & suppress_flags)\n\t\t\tcontinue;\n\t\tif ((r = sshbuf_putf(b, \" %c%-3s - %s\\r\\n\",\n\t\t    escape_char, esc_txt[i].cmd, esc_txt[i].text)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\tif ((r = sshbuf_putf(b,\n\t    \" %c%c   - send the escape character by typing it twice\\r\\n\"\n\t    \"(Note that escapes are only recognized immediately after \"\n\t    \"newline.)\\r\\n\", escape_char, escape_char)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SUPPRESS_SYSLOG\t\t4\t/* don't show when logging to syslog */",
            "#define SUPPRESS_MUXMASTER\t2\t/* don't show in mux master sessions */",
            "#define SUPPRESS_MUXCLIENT\t1\t/* don't show in mux client sessions */"
          ],
          "globals_used": [
            "void ssh_process_session2_setup(int, int, int, struct sshbuf *);",
            "static struct escape_help_text esc_txt[] = {\n    {\".\",  \"terminate session\", SUPPRESS_MUXMASTER},\n    {\".\",  \"terminate connection (and any multiplexed sessions)\",\n\tSUPPRESS_MUXCLIENT},\n    {\"B\",  \"send a BREAK to the remote system\", SUPPRESS_NEVER},\n    {\"C\",  \"open a command line\", SUPPRESS_MUXCLIENT},\n    {\"R\",  \"request rekey\", SUPPRESS_NEVER},\n    {\"V/v\",  \"decrease/increase verbosity (LogLevel)\", SUPPRESS_MUXCLIENT},\n    {\"^Z\", \"suspend ssh\", SUPPRESS_MUXCLIENT},\n    {\"#\",  \"list forwarded connections\", SUPPRESS_NEVER},\n    {\"&\",  \"background ssh (when waiting for connections to terminate)\",\n\tSUPPRESS_MUXCLIENT},\n    {\"?\", \"this message\", SUPPRESS_NEVER},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SUPPRESS_SYSLOG\t\t4\t/* don't show when logging to syslog */\n#define SUPPRESS_MUXMASTER\t2\t/* don't show in mux master sessions */\n#define SUPPRESS_MUXCLIENT\t1\t/* don't show in mux client sessions */\n\nvoid ssh_process_session2_setup(int, int, int, struct sshbuf *);\nstatic struct escape_help_text esc_txt[] = {\n    {\".\",  \"terminate session\", SUPPRESS_MUXMASTER},\n    {\".\",  \"terminate connection (and any multiplexed sessions)\",\n\tSUPPRESS_MUXCLIENT},\n    {\"B\",  \"send a BREAK to the remote system\", SUPPRESS_NEVER},\n    {\"C\",  \"open a command line\", SUPPRESS_MUXCLIENT},\n    {\"R\",  \"request rekey\", SUPPRESS_NEVER},\n    {\"V/v\",  \"decrease/increase verbosity (LogLevel)\", SUPPRESS_MUXCLIENT},\n    {\"^Z\", \"suspend ssh\", SUPPRESS_MUXCLIENT},\n    {\"#\",  \"list forwarded connections\", SUPPRESS_NEVER},\n    {\"&\",  \"background ssh (when waiting for connections to terminate)\",\n\tSUPPRESS_MUXCLIENT},\n    {\"?\", \"this message\", SUPPRESS_NEVER},\n};\n\nstatic void\nprint_escape_help(struct sshbuf *b, int escape_char, int mux_client,\n    int using_stderr)\n{\n\tunsigned int i, suppress_flags;\n\tint r;\n\n\tif ((r = sshbuf_putf(b,\n\t    \"%c?\\r\\nSupported escape sequences:\\r\\n\", escape_char)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tsuppress_flags =\n\t    (mux_client ? SUPPRESS_MUXCLIENT : 0) |\n\t    (mux_client ? 0 : SUPPRESS_MUXMASTER) |\n\t    (using_stderr ? 0 : SUPPRESS_SYSLOG);\n\n\tfor (i = 0; i < sizeof(esc_txt)/sizeof(esc_txt[0]); i++) {\n\t\tif (esc_txt[i].flags & suppress_flags)\n\t\t\tcontinue;\n\t\tif ((r = sshbuf_putf(b, \" %c%-3s - %s\\r\\n\",\n\t\t    escape_char, esc_txt[i].cmd, esc_txt[i].text)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\tif ((r = sshbuf_putf(b,\n\t    \" %c%c   - send the escape character by typing it twice\\r\\n\"\n\t    \"(Note that escapes are only recognized immediately after \"\n\t    \"newline.)\\r\\n\", escape_char, escape_char)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_is_on_stderr",
          "args": [],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "log_is_on_stderr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "361-365",
          "snippet": "int\nlog_is_on_stderr(void)\n{\n\treturn log_on_stderr && log_stderr_fd == STDERR_FILENO;\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int log_on_stderr = 1;",
            "static int log_stderr_fd = STDERR_FILENO;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int log_on_stderr = 1;\nstatic int log_stderr_fd = STDERR_FILENO;\n\nint\nlog_is_on_stderr(void)\n{\n\treturn log_on_stderr && log_stderr_fd == STDERR_FILENO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "2349-2358",
          "snippet": "void\ncleanup_exit(int i)\n{\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\tleave_non_blocking();\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\tssh_kill_proxy_command();\n\t_exit(i);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "extern int muxserver_sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nextern int muxserver_sock;\n\nvoid\ncleanup_exit(int i)\n{\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\tleave_non_blocking();\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\tssh_kill_proxy_command();\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"fork: %.100s\"",
            "strerror(errno)"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "69-78",
          "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_stop_listening",
          "args": [
            "ssh"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "channel_stop_listening",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "669-691",
          "snippet": "void\nchannel_stop_listening(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c != NULL) {\n\t\t\tswitch (c->type) {\n\t\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\t\tchannel_close_fd(ssh, &c->sock);\n\t\t\t\tchannel_free(ssh, c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_stop_listening(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c != NULL) {\n\t\t\tswitch (c->type) {\n\t\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\t\tchannel_close_fd(ssh, &c->sock);\n\t\t\t\tchannel_free(ssh, c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "leave_raw_mode",
          "args": [
            "options.request_tty == REQUEST_TTY_FORCE"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "leave_raw_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshtty.c",
          "lines": "56-66",
          "snippet": "void\nleave_raw_mode(int quiet)\n{\n\tif (!_in_raw_mode)\n\t\treturn;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 0;\n}",
          "includes": [
            "#include \"sshpty.h\"",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios _saved_tio;",
            "static int _in_raw_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sshpty.h\"\n#include <pwd.h>\n#include <termios.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct termios _saved_tio;\nstatic int _in_raw_mode = 0;\n\nvoid\nleave_raw_mode(int quiet)\n{\n\tif (!_in_raw_mode)\n\t\treturn;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_level_name",
          "args": [
            "options.log_level"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "log_level_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "149-158",
          "snippet": "const char *\nlog_level_name(LogLevel level)\n{\n\tu_int i;\n\n\tfor (i = 0; log_levels[i].name != NULL; i++)\n\t\tif (log_levels[i].val == level)\n\t\t\treturn log_levels[i].name;\n\treturn NULL;\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tLogLevel val;\n} log_levels[] =\n{\n\t{ \"QUIET\",\tSYSLOG_LEVEL_QUIET },\n\t{ \"FATAL\",\tSYSLOG_LEVEL_FATAL },\n\t{ \"ERROR\",\tSYSLOG_LEVEL_ERROR },\n\t{ \"INFO\",\tSYSLOG_LEVEL_INFO },\n\t{ \"VERBOSE\",\tSYSLOG_LEVEL_VERBOSE },\n\t{ \"DEBUG\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG1\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG2\",\tSYSLOG_LEVEL_DEBUG2 },\n\t{ \"DEBUG3\",\tSYSLOG_LEVEL_DEBUG3 },\n\t{ NULL,\t\tSYSLOG_LEVEL_NOT_SET }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tLogLevel val;\n} log_levels[] =\n{\n\t{ \"QUIET\",\tSYSLOG_LEVEL_QUIET },\n\t{ \"FATAL\",\tSYSLOG_LEVEL_FATAL },\n\t{ \"ERROR\",\tSYSLOG_LEVEL_ERROR },\n\t{ \"INFO\",\tSYSLOG_LEVEL_INFO },\n\t{ \"VERBOSE\",\tSYSLOG_LEVEL_VERBOSE },\n\t{ \"DEBUG\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG1\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG2\",\tSYSLOG_LEVEL_DEBUG2 },\n\t{ \"DEBUG3\",\tSYSLOG_LEVEL_DEBUG3 },\n\t{ NULL,\t\tSYSLOG_LEVEL_NOT_SET }\n};\n\nconst char *\nlog_level_name(LogLevel level)\n{\n\tu_int i;\n\n\tfor (i = 0; log_levels[i].name != NULL; i++)\n\t\tif (log_levels[i].val == level)\n\t\t\treturn log_levels[i].name;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_change_level",
          "args": [
            "++options.log_level"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "log_change_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "338-359",
          "snippet": "int\nlog_change_level(LogLevel new_log_level)\n{\n\t/* no-op if log_init has not been called */\n\tif (argv0 == NULL)\n\t\treturn 0;\n\n\tswitch (new_log_level) {\n\tcase SYSLOG_LEVEL_QUIET:\n\tcase SYSLOG_LEVEL_FATAL:\n\tcase SYSLOG_LEVEL_ERROR:\n\tcase SYSLOG_LEVEL_INFO:\n\tcase SYSLOG_LEVEL_VERBOSE:\n\tcase SYSLOG_LEVEL_DEBUG1:\n\tcase SYSLOG_LEVEL_DEBUG2:\n\tcase SYSLOG_LEVEL_DEBUG3:\n\t\tlog_level = new_log_level;\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LogLevel log_level = SYSLOG_LEVEL_INFO;",
            "static char *argv0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic LogLevel log_level = SYSLOG_LEVEL_INFO;\nstatic char *argv0;\n\nint\nlog_change_level(LogLevel new_log_level)\n{\n\t/* no-op if log_init has not been called */\n\tif (argv0 == NULL)\n\t\treturn 0;\n\n\tswitch (new_log_level) {\n\tcase SYSLOG_LEVEL_QUIET:\n\tcase SYSLOG_LEVEL_FATAL:\n\tcase SYSLOG_LEVEL_ERROR:\n\tcase SYSLOG_LEVEL_INFO:\n\tcase SYSLOG_LEVEL_VERBOSE:\n\tcase SYSLOG_LEVEL_DEBUG1:\n\tcase SYSLOG_LEVEL_DEBUG2:\n\tcase SYSLOG_LEVEL_DEBUG3:\n\t\tlog_level = new_log_level;\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Server does not \"\n\t\t\t\t\t    \"support re-keying\""
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "1000"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_request_start",
          "args": [
            "ssh",
            "c->self",
            "\"break\"",
            "0"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "channel_request_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "932-952",
          "snippet": "void\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: unknown channel id\", __func__, id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: unknown channel id\", __func__, id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_suspend_self",
          "args": [
            "bin",
            "bout",
            "berr"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "client_suspend_self",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "588-612",
          "snippet": "static void\nclient_suspend_self(struct sshbuf *bin, struct sshbuf *bout, struct sshbuf *berr)\n{\n\t/* Flush stdout and stderr buffers. */\n\tif (sshbuf_len(bout) > 0)\n\t\tatomicio(vwrite, fileno(stdout), sshbuf_mutable_ptr(bout),\n\t\t    sshbuf_len(bout));\n\tif (sshbuf_len(berr) > 0)\n\t\tatomicio(vwrite, fileno(stderr), sshbuf_mutable_ptr(berr),\n\t\t    sshbuf_len(berr));\n\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\tsshbuf_reset(bin);\n\tsshbuf_reset(bout);\n\tsshbuf_reset(berr);\n\n\t/* Send the suspend signal to the program itself. */\n\tkill(getpid(), SIGTSTP);\n\n\t/* Reset window sizes in case they have changed */\n\treceived_window_change_signal = 1;\n\n\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "static volatile sig_atomic_t received_window_change_signal = 0;",
            "void ssh_process_session2_setup(int, int, int, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic volatile sig_atomic_t received_window_change_signal = 0;\nvoid ssh_process_session2_setup(int, int, int, struct sshbuf *);\n\nstatic void\nclient_suspend_self(struct sshbuf *bin, struct sshbuf *bout, struct sshbuf *berr)\n{\n\t/* Flush stdout and stderr buffers. */\n\tif (sshbuf_len(bout) > 0)\n\t\tatomicio(vwrite, fileno(stdout), sshbuf_mutable_ptr(bout),\n\t\t    sshbuf_len(bout));\n\tif (sshbuf_len(berr) > 0)\n\t\tatomicio(vwrite, fileno(stderr), sshbuf_mutable_ptr(berr),\n\t\t    sshbuf_len(berr));\n\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\tsshbuf_reset(bin);\n\tsshbuf_reset(bout);\n\tsshbuf_reset(berr);\n\n\t/* Send the suspend signal to the program itself. */\n\tkill(getpid(), SIGTSTP);\n\n\t/* Reset window sizes in case they have changed */\n\treceived_window_change_signal = 1;\n\n\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "b",
            "sizeof b",
            "\"%c\"",
            "ch"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_ibuf_empty",
          "args": [
            "ssh",
            "c"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "chan_ibuf_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "124-144",
          "snippet": "void\nchan_ibuf_empty(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: ibuf empty\", c->self);\n\tif (sshbuf_len(c->input)) {\n\t\terror(\"channel %d: chan_ibuf_empty for non empty buffer\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & (CHAN_CLOSE_SENT|CHAN_LOCAL)))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_ibuf_empty for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_ibuf_empty(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: ibuf empty\", c->self);\n\tif (sshbuf_len(c->input)) {\n\t\terror(\"channel %d: chan_ibuf_empty for non empty buffer\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & (CHAN_CLOSE_SENT|CHAN_LOCAL)))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_ibuf_empty for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "c->input"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->detach_user",
          "args": [
            "ssh",
            "c->self",
            "NULL"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chan_write_failed",
          "args": [
            "ssh",
            "c"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "chan_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "305-322",
          "snippet": "void\nchan_write_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: write failed\", c->self);\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tif (strcmp(c->ctype, \"session\") == 0)\n\t\t\tchan_send_eow2(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_write_failed for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_write_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: write failed\", c->self);\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tif (strcmp(c->ctype, \"session\") == 0)\n\t\t\tchan_send_eow2(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_write_failed for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_read_failed",
          "args": [
            "ssh",
            "c"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "chan_read_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "108-122",
          "snippet": "void\nchan_read_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: read failed\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_WAIT_DRAIN);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_read_failed for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_read_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: read failed\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_WAIT_DRAIN);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_read_failed for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nvolatile sig_atomic_t quit_pending;\nstatic int last_was_cr;\nstatic int need_rekeying;\nvoid ssh_process_session2_setup(int, int, int, struct sshbuf *);\n\nstatic int\nprocess_escapes(struct ssh *ssh, Channel *c,\n    struct sshbuf *bin, struct sshbuf *bout, struct sshbuf *berr,\n    char *buf, int len)\n{\n\tpid_t pid;\n\tint r, bytes = 0;\n\tu_int i;\n\tu_char ch;\n\tchar *s;\n\tstruct escape_filter_ctx *efc = c->filter_ctx == NULL ?\n\t    NULL : (struct escape_filter_ctx *)c->filter_ctx;\n\n\tif (c->filter_ctx == NULL)\n\t\treturn 0;\n\n\tif (len <= 0)\n\t\treturn (0);\n\n\tfor (i = 0; i < (u_int)len; i++) {\n\t\t/* Get one character at a time. */\n\t\tch = buf[i];\n\n\t\tif (efc->escape_pending) {\n\t\t\t/* We have previously seen an escape character. */\n\t\t\t/* Clear the flag now. */\n\t\t\tefc->escape_pending = 0;\n\n\t\t\t/* Process the escaped character. */\n\t\t\tswitch (ch) {\n\t\t\tcase '.':\n\t\t\t\t/* Terminate the connection. */\n\t\t\t\tif ((r = sshbuf_putf(berr, \"%c.\\r\\n\",\n\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tif (c && c->ctl_chan != -1) {\n\t\t\t\t\tchan_read_failed(ssh, c);\n\t\t\t\t\tchan_write_failed(ssh, c);\n\t\t\t\t\tif (c->detach_user) {\n\t\t\t\t\t\tc->detach_user(ssh,\n\t\t\t\t\t\t    c->self, NULL);\n\t\t\t\t\t}\n\t\t\t\t\tc->type = SSH_CHANNEL_ABANDONED;\n\t\t\t\t\tsshbuf_reset(c->input);\n\t\t\t\t\tchan_ibuf_empty(ssh, c);\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\tquit_pending = 1;\n\t\t\t\treturn -1;\n\n\t\t\tcase 'Z' - 64:\n\t\t\t\t/* XXX support this for mux clients */\n\t\t\t\tif (c && c->ctl_chan != -1) {\n\t\t\t\t\tchar b[16];\n noescape:\n\t\t\t\t\tif (ch == 'Z' - 64)\n\t\t\t\t\t\tsnprintf(b, sizeof b, \"^Z\");\n\t\t\t\t\telse\n\t\t\t\t\t\tsnprintf(b, sizeof b, \"%c\", ch);\n\t\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t\t    \"%c%s escape not available to \"\n\t\t\t\t\t    \"multiplexed sessions\\r\\n\",\n\t\t\t\t\t    efc->escape_char, b)) != 0)\n\t\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Suspend the program. Inform the user */\n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%c^Z [suspend ssh]\\r\\n\",\n\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\n\t\t\t\t/* Restore terminal modes and suspend. */\n\t\t\t\tclient_suspend_self(bin, bout, berr);\n\n\t\t\t\t/* We have been continued. */\n\t\t\t\tcontinue;\n\n\t\t\tcase 'B':\n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%cB\\r\\n\", efc->escape_char)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tchannel_request_start(ssh, c->self, \"break\", 0);\n\t\t\t\tif ((r = sshpkt_put_u32(ssh, 1000)) != 0 ||\n\t\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\t\tfatal(\"%s: %s\", __func__,\n\t\t\t\t\t    ssh_err(r));\n\t\t\t\tcontinue;\n\n\t\t\tcase 'R':\n\t\t\t\tif (datafellows & SSH_BUG_NOREKEY)\n\t\t\t\t\tlogit(\"Server does not \"\n\t\t\t\t\t    \"support re-keying\");\n\t\t\t\telse\n\t\t\t\t\tneed_rekeying = 1;\n\t\t\t\tcontinue;\n\n\t\t\tcase 'V':\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase 'v':\n\t\t\t\tif (c && c->ctl_chan != -1)\n\t\t\t\t\tgoto noescape;\n\t\t\t\tif (!log_is_on_stderr()) {\n\t\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t\t    \"%c%c [Logging to syslog]\\r\\n\",\n\t\t\t\t\t    efc->escape_char, ch)) != 0)\n\t\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ch == 'V' && options.log_level >\n\t\t\t\t    SYSLOG_LEVEL_QUIET)\n\t\t\t\t\tlog_change_level(--options.log_level);\n\t\t\t\tif (ch == 'v' && options.log_level <\n\t\t\t\t    SYSLOG_LEVEL_DEBUG3)\n\t\t\t\t\tlog_change_level(++options.log_level);\n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%c%c [LogLevel %s]\\r\\n\",\n\t\t\t\t    efc->escape_char, ch,\n\t\t\t\t    log_level_name(options.log_level))) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tcontinue;\n\n\t\t\tcase '&':\n\t\t\t\tif (c && c->ctl_chan != -1)\n\t\t\t\t\tgoto noescape;\n\t\t\t\t/*\n\t\t\t\t * Detach the program (continue to serve\n\t\t\t\t * connections, but put in background and no\n\t\t\t\t * more new connections).\n\t\t\t\t */\n\t\t\t\t/* Restore tty modes. */\n\t\t\t\tleave_raw_mode(\n\t\t\t\t    options.request_tty == REQUEST_TTY_FORCE);\n\n\t\t\t\t/* Stop listening for new connections. */\n\t\t\t\tchannel_stop_listening(ssh);\n\n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%c& [backgrounded]\\n\", efc->escape_char))\n\t\t\t\t     != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\n\t\t\t\t/* Fork into background. */\n\t\t\t\tpid = fork();\n\t\t\t\tif (pid < 0) {\n\t\t\t\t\terror(\"fork: %.100s\", strerror(errno));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pid != 0) {\t/* This is the parent. */\n\t\t\t\t\t/* The parent just exits. */\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t\t/* The child continues serving connections. */\n\t\t\t\t/* fake EOF on stdin */\n\t\t\t\tif ((r = sshbuf_put_u8(bin, 4)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\treturn -1;\n\t\t\tcase '?':\n\t\t\t\tprint_escape_help(berr, efc->escape_char,\n\t\t\t\t    (c && c->ctl_chan != -1),\n\t\t\t\t    log_is_on_stderr());\n\t\t\t\tcontinue;\n\n\t\t\tcase '#':\n\t\t\t\tif ((r = sshbuf_putf(berr, \"%c#\\r\\n\",\n\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\ts = channel_open_message(ssh);\n\t\t\t\tif ((r = sshbuf_put(berr, s, strlen(s))) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tfree(s);\n\t\t\t\tcontinue;\n\n\t\t\tcase 'C':\n\t\t\t\tif (c && c->ctl_chan != -1)\n\t\t\t\t\tgoto noescape;\n\t\t\t\tprocess_cmdline(ssh);\n\t\t\t\tcontinue;\n\n\t\t\tdefault:\n\t\t\t\tif (ch != efc->escape_char) {\n\t\t\t\t\tif ((r = sshbuf_put_u8(bin,\n\t\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\t\tbytes++;\n\t\t\t\t}\n\t\t\t\t/* Escaped characters fall through here */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * The previous character was not an escape char.\n\t\t\t * Check if this is an escape.\n\t\t\t */\n\t\t\tif (last_was_cr && ch == efc->escape_char) {\n\t\t\t\t/*\n\t\t\t\t * It is. Set the flag and continue to\n\t\t\t\t * next character.\n\t\t\t\t */\n\t\t\t\tefc->escape_pending = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Normal character.  Record whether it was a newline,\n\t\t * and append it to the buffer.\n\t\t */\n\t\tlast_was_cr = (ch == '\\r' || ch == '\\n');\n\t\tif ((r = sshbuf_put_u8(bin, ch)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tbytes++;\n\t}\n\treturn bytes;\n}"
  },
  {
    "function_name": "print_escape_help",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "911-940",
    "snippet": "static void\nprint_escape_help(struct sshbuf *b, int escape_char, int mux_client,\n    int using_stderr)\n{\n\tunsigned int i, suppress_flags;\n\tint r;\n\n\tif ((r = sshbuf_putf(b,\n\t    \"%c?\\r\\nSupported escape sequences:\\r\\n\", escape_char)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tsuppress_flags =\n\t    (mux_client ? SUPPRESS_MUXCLIENT : 0) |\n\t    (mux_client ? 0 : SUPPRESS_MUXMASTER) |\n\t    (using_stderr ? 0 : SUPPRESS_SYSLOG);\n\n\tfor (i = 0; i < sizeof(esc_txt)/sizeof(esc_txt[0]); i++) {\n\t\tif (esc_txt[i].flags & suppress_flags)\n\t\t\tcontinue;\n\t\tif ((r = sshbuf_putf(b, \" %c%-3s - %s\\r\\n\",\n\t\t    escape_char, esc_txt[i].cmd, esc_txt[i].text)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\tif ((r = sshbuf_putf(b,\n\t    \" %c%c   - send the escape character by typing it twice\\r\\n\"\n\t    \"(Note that escapes are only recognized immediately after \"\n\t    \"newline.)\\r\\n\", escape_char, escape_char)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SUPPRESS_SYSLOG\t\t4\t/* don't show when logging to syslog */",
      "#define SUPPRESS_MUXMASTER\t2\t/* don't show in mux master sessions */",
      "#define SUPPRESS_MUXCLIENT\t1\t/* don't show in mux client sessions */"
    ],
    "globals_used": [
      "void ssh_process_session2_setup(int, int, int, struct sshbuf *);",
      "static struct escape_help_text esc_txt[] = {\n    {\".\",  \"terminate session\", SUPPRESS_MUXMASTER},\n    {\".\",  \"terminate connection (and any multiplexed sessions)\",\n\tSUPPRESS_MUXCLIENT},\n    {\"B\",  \"send a BREAK to the remote system\", SUPPRESS_NEVER},\n    {\"C\",  \"open a command line\", SUPPRESS_MUXCLIENT},\n    {\"R\",  \"request rekey\", SUPPRESS_NEVER},\n    {\"V/v\",  \"decrease/increase verbosity (LogLevel)\", SUPPRESS_MUXCLIENT},\n    {\"^Z\", \"suspend ssh\", SUPPRESS_MUXCLIENT},\n    {\"#\",  \"list forwarded connections\", SUPPRESS_NEVER},\n    {\"&\",  \"background ssh (when waiting for connections to terminate)\",\n\tSUPPRESS_MUXCLIENT},\n    {\"?\", \"this message\", SUPPRESS_NEVER},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_putf",
          "args": [
            "b",
            "\" %c%c   - send the escape character by typing it twice\\r\\n\"\n\t    \"(Note that escapes are only recognized immediately after \"\n\t    \"newline.)\\r\\n\"",
            "escape_char",
            "escape_char"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SUPPRESS_SYSLOG\t\t4\t/* don't show when logging to syslog */\n#define SUPPRESS_MUXMASTER\t2\t/* don't show in mux master sessions */\n#define SUPPRESS_MUXCLIENT\t1\t/* don't show in mux client sessions */\n\nvoid ssh_process_session2_setup(int, int, int, struct sshbuf *);\nstatic struct escape_help_text esc_txt[] = {\n    {\".\",  \"terminate session\", SUPPRESS_MUXMASTER},\n    {\".\",  \"terminate connection (and any multiplexed sessions)\",\n\tSUPPRESS_MUXCLIENT},\n    {\"B\",  \"send a BREAK to the remote system\", SUPPRESS_NEVER},\n    {\"C\",  \"open a command line\", SUPPRESS_MUXCLIENT},\n    {\"R\",  \"request rekey\", SUPPRESS_NEVER},\n    {\"V/v\",  \"decrease/increase verbosity (LogLevel)\", SUPPRESS_MUXCLIENT},\n    {\"^Z\", \"suspend ssh\", SUPPRESS_MUXCLIENT},\n    {\"#\",  \"list forwarded connections\", SUPPRESS_NEVER},\n    {\"&\",  \"background ssh (when waiting for connections to terminate)\",\n\tSUPPRESS_MUXCLIENT},\n    {\"?\", \"this message\", SUPPRESS_NEVER},\n};\n\nstatic void\nprint_escape_help(struct sshbuf *b, int escape_char, int mux_client,\n    int using_stderr)\n{\n\tunsigned int i, suppress_flags;\n\tint r;\n\n\tif ((r = sshbuf_putf(b,\n\t    \"%c?\\r\\nSupported escape sequences:\\r\\n\", escape_char)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tsuppress_flags =\n\t    (mux_client ? SUPPRESS_MUXCLIENT : 0) |\n\t    (mux_client ? 0 : SUPPRESS_MUXMASTER) |\n\t    (using_stderr ? 0 : SUPPRESS_SYSLOG);\n\n\tfor (i = 0; i < sizeof(esc_txt)/sizeof(esc_txt[0]); i++) {\n\t\tif (esc_txt[i].flags & suppress_flags)\n\t\t\tcontinue;\n\t\tif ((r = sshbuf_putf(b, \" %c%-3s - %s\\r\\n\",\n\t\t    escape_char, esc_txt[i].cmd, esc_txt[i].text)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\tif ((r = sshbuf_putf(b,\n\t    \" %c%c   - send the escape character by typing it twice\\r\\n\"\n\t    \"(Note that escapes are only recognized immediately after \"\n\t    \"newline.)\\r\\n\", escape_char, escape_char)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
  },
  {
    "function_name": "process_cmdline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "768-884",
    "snippet": "static void\nprocess_cmdline(struct ssh *ssh)\n{\n\tvoid (*handler)(int);\n\tchar *s, *cmd;\n\tint ok, delete = 0, local = 0, remote = 0, dynamic = 0;\n\tstruct Forward fwd;\n\n\tmemset(&fwd, 0, sizeof(fwd));\n\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\thandler = signal(SIGINT, SIG_IGN);\n\tcmd = s = read_passphrase(\"\\r\\nssh> \", RP_ECHO);\n\tif (s == NULL)\n\t\tgoto out;\n\twhile (isspace((u_char)*s))\n\t\ts++;\n\tif (*s == '-')\n\t\ts++;\t/* Skip cmdline '-', if any */\n\tif (*s == '\\0')\n\t\tgoto out;\n\n\tif (*s == 'h' || *s == 'H' || *s == '?') {\n\t\tlogit(\"Commands:\");\n\t\tlogit(\"      -L[bind_address:]port:host:hostport    \"\n\t\t    \"Request local forward\");\n\t\tlogit(\"      -R[bind_address:]port:host:hostport    \"\n\t\t    \"Request remote forward\");\n\t\tlogit(\"      -D[bind_address:]port                  \"\n\t\t    \"Request dynamic forward\");\n\t\tlogit(\"      -KL[bind_address:]port                 \"\n\t\t    \"Cancel local forward\");\n\t\tlogit(\"      -KR[bind_address:]port                 \"\n\t\t    \"Cancel remote forward\");\n\t\tlogit(\"      -KD[bind_address:]port                 \"\n\t\t    \"Cancel dynamic forward\");\n\t\tif (!options.permit_local_command)\n\t\t\tgoto out;\n\t\tlogit(\"      !args                                  \"\n\t\t    \"Execute local command\");\n\t\tgoto out;\n\t}\n\n\tif (*s == '!' && options.permit_local_command) {\n\t\ts++;\n\t\tssh_local_cmd(s);\n\t\tgoto out;\n\t}\n\n\tif (*s == 'K') {\n\t\tdelete = 1;\n\t\ts++;\n\t}\n\tif (*s == 'L')\n\t\tlocal = 1;\n\telse if (*s == 'R')\n\t\tremote = 1;\n\telse if (*s == 'D')\n\t\tdynamic = 1;\n\telse {\n\t\tlogit(\"Invalid command.\");\n\t\tgoto out;\n\t}\n\n\twhile (isspace((u_char)*++s))\n\t\t;\n\n\t/* XXX update list of forwards in options */\n\tif (delete) {\n\t\t/* We pass 1 for dynamicfwd to restrict to 1 or 2 fields. */\n\t\tif (!parse_forward(&fwd, s, 1, 0)) {\n\t\t\tlogit(\"Bad forwarding close specification.\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (remote)\n\t\t\tok = channel_request_rforward_cancel(ssh, &fwd) == 0;\n\t\telse if (dynamic)\n\t\t\tok = channel_cancel_lport_listener(ssh, &fwd,\n\t\t\t    0, &options.fwd_opts) > 0;\n\t\telse\n\t\t\tok = channel_cancel_lport_listener(ssh, &fwd,\n\t\t\t    CHANNEL_CANCEL_PORT_STATIC,\n\t\t\t    &options.fwd_opts) > 0;\n\t\tif (!ok) {\n\t\t\tlogit(\"Unknown port forwarding.\");\n\t\t\tgoto out;\n\t\t}\n\t\tlogit(\"Canceled forwarding.\");\n\t} else {\n\t\tif (!parse_forward(&fwd, s, dynamic, remote)) {\n\t\t\tlogit(\"Bad forwarding specification.\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (local || dynamic) {\n\t\t\tif (!channel_setup_local_fwd_listener(ssh, &fwd,\n\t\t\t    &options.fwd_opts)) {\n\t\t\t\tlogit(\"Port forwarding failed.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tif (channel_request_remote_forwarding(ssh, &fwd) < 0) {\n\t\t\t\tlogit(\"Port forwarding failed.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tlogit(\"Forwarding port.\");\n\t}\n\nout:\n\tsignal(SIGINT, handler);\n\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\tfree(cmd);\n\tfree(fwd.listen_host);\n\tfree(fwd.listen_path);\n\tfree(fwd.connect_host);\n\tfree(fwd.connect_path);\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "extern char *host;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fwd.connect_path"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "enter_raw_mode",
          "args": [
            "options.request_tty == REQUEST_TTY_FORCE"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "enter_raw_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshtty.c",
          "lines": "68-96",
          "snippet": "void\nenter_raw_mode(int quiet)\n{\n\tstruct termios tio;\n\n\tif (tcgetattr(fileno(stdin), &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcgetattr\");\n\t\treturn;\n\t}\n\t_saved_tio = tio;\n\ttio.c_iflag |= IGNPAR;\n\ttio.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);\n#ifdef IUCLC\n\ttio.c_iflag &= ~IUCLC;\n#endif\n\ttio.c_lflag &= ~(ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);\n#ifdef IEXTEN\n\ttio.c_lflag &= ~IEXTEN;\n#endif\n\ttio.c_oflag &= ~OPOST;\n\ttio.c_cc[VMIN] = 1;\n\ttio.c_cc[VTIME] = 0;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 1;\n}",
          "includes": [
            "#include \"sshpty.h\"",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios _saved_tio;",
            "static int _in_raw_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sshpty.h\"\n#include <pwd.h>\n#include <termios.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct termios _saved_tio;\nstatic int _in_raw_mode = 0;\n\nvoid\nenter_raw_mode(int quiet)\n{\n\tstruct termios tio;\n\n\tif (tcgetattr(fileno(stdin), &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcgetattr\");\n\t\treturn;\n\t}\n\t_saved_tio = tio;\n\ttio.c_iflag |= IGNPAR;\n\ttio.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);\n#ifdef IUCLC\n\ttio.c_iflag &= ~IUCLC;\n#endif\n\ttio.c_lflag &= ~(ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);\n#ifdef IEXTEN\n\ttio.c_lflag &= ~IEXTEN;\n#endif\n\ttio.c_oflag &= ~OPOST;\n\ttio.c_cc[VMIN] = 1;\n\ttio.c_cc[VTIME] = 0;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGINT",
            "handler"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Forwarding port.\""
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_request_remote_forwarding",
          "args": [
            "ssh",
            "&fwd"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "channel_request_remote_forwarding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3830-3886",
          "snippet": "int\nchannel_request_remote_forwarding(struct ssh *ssh, struct Forward *fwd)\n{\n\tint r, success = 0, idx = -1;\n\tchar *host_to_connect, *listen_host, *listen_path;\n\tint port_to_connect, listen_port;\n\n\t/* Send the forward request to the remote side. */\n\tif (fwd->listen_path != NULL) {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"streamlocal-forward@openssh.com\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0 || /* want reply */\n\t\t    (r = sshpkt_put_cstring(ssh, fwd->listen_path)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal(\"%s: request streamlocal: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t} else {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, \"tcpip-forward\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0 || /* want reply */\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    channel_rfwd_bind_host(fwd->listen_host))) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, fwd->listen_port)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal(\"%s: request tcpip-forward: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n\t/* Assume that server accepts the request */\n\tsuccess = 1;\n\tif (success) {\n\t\t/* Record that connection to this host/port is permitted. */\n\t\thost_to_connect = listen_host = listen_path = NULL;\n\t\tport_to_connect = listen_port = 0;\n\t\tif (fwd->connect_path != NULL) {\n\t\t\thost_to_connect = xstrdup(fwd->connect_path);\n\t\t\tport_to_connect = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\thost_to_connect = xstrdup(fwd->connect_host);\n\t\t\tport_to_connect = fwd->connect_port;\n\t\t}\n\t\tif (fwd->listen_path != NULL) {\n\t\t\tlisten_path = xstrdup(fwd->listen_path);\n\t\t\tlisten_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tif (fwd->listen_host != NULL)\n\t\t\t\tlisten_host = xstrdup(fwd->listen_host);\n\t\t\tlisten_port = fwd->listen_port;\n\t\t}\n\t\tidx = permission_set_add(ssh, FORWARD_USER, FORWARD_LOCAL,\n\t\t    host_to_connect, port_to_connect,\n\t\t    listen_host, listen_path, listen_port, NULL);\n\t}\n\treturn idx;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_request_remote_forwarding(struct ssh *ssh, struct Forward *fwd)\n{\n\tint r, success = 0, idx = -1;\n\tchar *host_to_connect, *listen_host, *listen_path;\n\tint port_to_connect, listen_port;\n\n\t/* Send the forward request to the remote side. */\n\tif (fwd->listen_path != NULL) {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"streamlocal-forward@openssh.com\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0 || /* want reply */\n\t\t    (r = sshpkt_put_cstring(ssh, fwd->listen_path)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal(\"%s: request streamlocal: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t} else {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, \"tcpip-forward\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0 || /* want reply */\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    channel_rfwd_bind_host(fwd->listen_host))) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, fwd->listen_port)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal(\"%s: request tcpip-forward: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n\t/* Assume that server accepts the request */\n\tsuccess = 1;\n\tif (success) {\n\t\t/* Record that connection to this host/port is permitted. */\n\t\thost_to_connect = listen_host = listen_path = NULL;\n\t\tport_to_connect = listen_port = 0;\n\t\tif (fwd->connect_path != NULL) {\n\t\t\thost_to_connect = xstrdup(fwd->connect_path);\n\t\t\tport_to_connect = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\thost_to_connect = xstrdup(fwd->connect_host);\n\t\t\tport_to_connect = fwd->connect_port;\n\t\t}\n\t\tif (fwd->listen_path != NULL) {\n\t\t\tlisten_path = xstrdup(fwd->listen_path);\n\t\t\tlisten_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tif (fwd->listen_host != NULL)\n\t\t\t\tlisten_host = xstrdup(fwd->listen_host);\n\t\t\tlisten_port = fwd->listen_port;\n\t\t}\n\t\tidx = permission_set_add(ssh, FORWARD_USER, FORWARD_LOCAL,\n\t\t    host_to_connect, port_to_connect,\n\t\t    listen_host, listen_path, listen_port, NULL);\n\t}\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_setup_local_fwd_listener",
          "args": [
            "ssh",
            "&fwd",
            "&options.fwd_opts"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "channel_setup_local_fwd_listener",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3714-3725",
          "snippet": "int\nchannel_setup_local_fwd_listener(struct ssh *ssh,\n    struct Forward *fwd, struct ForwardOptions *fwd_opts)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_setup_fwd_listener_streamlocal(ssh,\n\t\t    SSH_CHANNEL_UNIX_LISTENER, fwd, fwd_opts);\n\t} else {\n\t\treturn channel_setup_fwd_listener_tcpip(ssh,\n\t\t    SSH_CHANNEL_PORT_LISTENER, fwd, NULL, fwd_opts);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_setup_local_fwd_listener(struct ssh *ssh,\n    struct Forward *fwd, struct ForwardOptions *fwd_opts)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_setup_fwd_listener_streamlocal(ssh,\n\t\t    SSH_CHANNEL_UNIX_LISTENER, fwd, fwd_opts);\n\t} else {\n\t\treturn channel_setup_fwd_listener_tcpip(ssh,\n\t\t    SSH_CHANNEL_PORT_LISTENER, fwd, NULL, fwd_opts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_forward",
          "args": [
            "&fwd",
            "s",
            "dynamic",
            "remote"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "parse_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2229-2358",
          "snippet": "int\nparse_forward(struct Forward *fwd, const char *fwdspec, int dynamicfwd, int remotefwd)\n{\n\tstruct fwdarg fwdargs[4];\n\tchar *p, *cp;\n\tint i;\n\n\tmemset(fwd, 0, sizeof(*fwd));\n\tmemset(fwdargs, 0, sizeof(fwdargs));\n\n\tcp = p = xstrdup(fwdspec);\n\n\t/* skip leading spaces */\n\twhile (isspace((u_char)*cp))\n\t\tcp++;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (parse_fwd_field(&cp, &fwdargs[i]) != 0)\n\t\t\tbreak;\n\t}\n\n\t/* Check for trailing garbage */\n\tif (cp != NULL && *cp != '\\0') {\n\t\ti = 0;\t/* failure */\n\t}\n\n\tswitch (i) {\n\tcase 1:\n\t\tif (fwdargs[0].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t}\n\t\tfwd->connect_host = xstrdup(\"socks\");\n\t\tbreak;\n\n\tcase 2:\n\t\tif (fwdargs[0].ispath && fwdargs[1].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t\tfwd->connect_path = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else if (fwdargs[1].ispath) {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t\tfwd->connect_path = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\t\tfwd->connect_host = xstrdup(\"socks\");\n\t\t}\n\t\tbreak;\n\n\tcase 3:\n\t\tif (fwdargs[0].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t\tfwd->connect_host = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = a2port(fwdargs[2].arg);\n\t\t} else if (fwdargs[2].ispath) {\n\t\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\t\tfwd->connect_path = xstrdup(fwdargs[2].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t\tfwd->connect_host = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = a2port(fwdargs[2].arg);\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\tfwd->connect_host = xstrdup(fwdargs[2].arg);\n\t\tfwd->connect_port = a2port(fwdargs[3].arg);\n\t\tbreak;\n\tdefault:\n\t\ti = 0; /* failure */\n\t}\n\n\tfree(p);\n\n\tif (dynamicfwd) {\n\t\tif (!(i == 1 || i == 2))\n\t\t\tgoto fail_free;\n\t} else {\n\t\tif (!(i == 3 || i == 4)) {\n\t\t\tif (fwd->connect_path == NULL &&\n\t\t\t    fwd->listen_path == NULL)\n\t\t\t\tgoto fail_free;\n\t\t}\n\t\tif (fwd->connect_port <= 0 && fwd->connect_path == NULL)\n\t\t\tgoto fail_free;\n\t}\n\n\tif ((fwd->listen_port < 0 && fwd->listen_path == NULL) ||\n\t    (!remotefwd && fwd->listen_port == 0))\n\t\tgoto fail_free;\n\tif (fwd->connect_host != NULL &&\n\t    strlen(fwd->connect_host) >= NI_MAXHOST)\n\t\tgoto fail_free;\n\t/* XXX - if connecting to a remote socket, max sun len may not match this host */\n\tif (fwd->connect_path != NULL &&\n\t    strlen(fwd->connect_path) >= PATH_MAX_SUN)\n\t\tgoto fail_free;\n\tif (fwd->listen_host != NULL &&\n\t    strlen(fwd->listen_host) >= NI_MAXHOST)\n\t\tgoto fail_free;\n\tif (fwd->listen_path != NULL &&\n\t    strlen(fwd->listen_path) >= PATH_MAX_SUN)\n\t\tgoto fail_free;\n\n\treturn (i);\n\n fail_free:\n\tfree(fwd->connect_host);\n\tfwd->connect_host = NULL;\n\tfree(fwd->connect_path);\n\tfwd->connect_path = NULL;\n\tfree(fwd->listen_host);\n\tfwd->listen_host = NULL;\n\tfree(fwd->listen_path);\n\tfwd->listen_path = NULL;\n\treturn (0);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_forward(struct Forward *fwd, const char *fwdspec, int dynamicfwd, int remotefwd)\n{\n\tstruct fwdarg fwdargs[4];\n\tchar *p, *cp;\n\tint i;\n\n\tmemset(fwd, 0, sizeof(*fwd));\n\tmemset(fwdargs, 0, sizeof(fwdargs));\n\n\tcp = p = xstrdup(fwdspec);\n\n\t/* skip leading spaces */\n\twhile (isspace((u_char)*cp))\n\t\tcp++;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (parse_fwd_field(&cp, &fwdargs[i]) != 0)\n\t\t\tbreak;\n\t}\n\n\t/* Check for trailing garbage */\n\tif (cp != NULL && *cp != '\\0') {\n\t\ti = 0;\t/* failure */\n\t}\n\n\tswitch (i) {\n\tcase 1:\n\t\tif (fwdargs[0].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t}\n\t\tfwd->connect_host = xstrdup(\"socks\");\n\t\tbreak;\n\n\tcase 2:\n\t\tif (fwdargs[0].ispath && fwdargs[1].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t\tfwd->connect_path = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else if (fwdargs[1].ispath) {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t\tfwd->connect_path = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\t\tfwd->connect_host = xstrdup(\"socks\");\n\t\t}\n\t\tbreak;\n\n\tcase 3:\n\t\tif (fwdargs[0].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t\tfwd->connect_host = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = a2port(fwdargs[2].arg);\n\t\t} else if (fwdargs[2].ispath) {\n\t\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\t\tfwd->connect_path = xstrdup(fwdargs[2].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t\tfwd->connect_host = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = a2port(fwdargs[2].arg);\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\tfwd->connect_host = xstrdup(fwdargs[2].arg);\n\t\tfwd->connect_port = a2port(fwdargs[3].arg);\n\t\tbreak;\n\tdefault:\n\t\ti = 0; /* failure */\n\t}\n\n\tfree(p);\n\n\tif (dynamicfwd) {\n\t\tif (!(i == 1 || i == 2))\n\t\t\tgoto fail_free;\n\t} else {\n\t\tif (!(i == 3 || i == 4)) {\n\t\t\tif (fwd->connect_path == NULL &&\n\t\t\t    fwd->listen_path == NULL)\n\t\t\t\tgoto fail_free;\n\t\t}\n\t\tif (fwd->connect_port <= 0 && fwd->connect_path == NULL)\n\t\t\tgoto fail_free;\n\t}\n\n\tif ((fwd->listen_port < 0 && fwd->listen_path == NULL) ||\n\t    (!remotefwd && fwd->listen_port == 0))\n\t\tgoto fail_free;\n\tif (fwd->connect_host != NULL &&\n\t    strlen(fwd->connect_host) >= NI_MAXHOST)\n\t\tgoto fail_free;\n\t/* XXX - if connecting to a remote socket, max sun len may not match this host */\n\tif (fwd->connect_path != NULL &&\n\t    strlen(fwd->connect_path) >= PATH_MAX_SUN)\n\t\tgoto fail_free;\n\tif (fwd->listen_host != NULL &&\n\t    strlen(fwd->listen_host) >= NI_MAXHOST)\n\t\tgoto fail_free;\n\tif (fwd->listen_path != NULL &&\n\t    strlen(fwd->listen_path) >= PATH_MAX_SUN)\n\t\tgoto fail_free;\n\n\treturn (i);\n\n fail_free:\n\tfree(fwd->connect_host);\n\tfwd->connect_host = NULL;\n\tfree(fwd->connect_path);\n\tfwd->connect_path = NULL;\n\tfree(fwd->listen_host);\n\tfwd->listen_host = NULL;\n\tfree(fwd->listen_path);\n\tfwd->listen_path = NULL;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_cancel_lport_listener",
          "args": [
            "ssh",
            "&fwd",
            "CHANNEL_CANCEL_PORT_STATIC",
            "&options.fwd_opts"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "channel_cancel_lport_listener",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3700-3711",
          "snippet": "int\nchannel_cancel_lport_listener(struct ssh *ssh,\n    struct Forward *fwd, int cport, struct ForwardOptions *fwd_opts)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_cancel_lport_listener_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_cancel_lport_listener_tcpip(ssh,\n\t\t    fwd->listen_host, fwd->listen_port, cport, fwd_opts);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_cancel_lport_listener(struct ssh *ssh,\n    struct Forward *fwd, int cport, struct ForwardOptions *fwd_opts)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_cancel_lport_listener_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_cancel_lport_listener_tcpip(ssh,\n\t\t    fwd->listen_host, fwd->listen_port, cport, fwd_opts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_request_rforward_cancel",
          "args": [
            "ssh",
            "&fwd"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "channel_request_rforward_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4021-4032",
          "snippet": "int\nchannel_request_rforward_cancel(struct ssh *ssh, struct Forward *fwd)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_request_rforward_cancel_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_request_rforward_cancel_tcpip(ssh,\n\t\t    fwd->listen_host,\n\t\t    fwd->listen_port ? fwd->listen_port : fwd->allocated_port);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_request_rforward_cancel(struct ssh *ssh, struct Forward *fwd)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_request_rforward_cancel_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_request_rforward_cancel_tcpip(ssh,\n\t\t    fwd->listen_host,\n\t\t    fwd->listen_port ? fwd->listen_port : fwd->allocated_port);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(u_char)*++s"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_local_cmd",
          "args": [
            "s"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_local_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "1513-1548",
          "snippet": "int\nssh_local_cmd(const char *args)\n{\n\tchar *shell;\n\tpid_t pid;\n\tint status;\n\tvoid (*osighand)(int);\n\n\tif (!options.permit_local_command ||\n\t    args == NULL || !*args)\n\t\treturn (1);\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\tosighand = signal(SIGCHLD, SIG_DFL);\n\tpid = fork();\n\tif (pid == 0) {\n\t\tsignal(SIGPIPE, SIG_DFL);\n\t\tdebug3(\"Executing %s -c \\\"%s\\\"\", shell, args);\n\t\texecl(shell, shell, \"-c\", args, (char *)NULL);\n\t\terror(\"Couldn't execute %s -c \\\"%s\\\": %s\",\n\t\t    shell, args, strerror(errno));\n\t\t_exit(1);\n\t} else if (pid == -1)\n\t\tfatal(\"fork failed: %.100s\", strerror(errno));\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\tsignal(SIGCHLD, osighand);\n\n\tif (!WIFEXITED(status))\n\t\treturn (1);\n\n\treturn (WEXITSTATUS(status));\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nint\nssh_local_cmd(const char *args)\n{\n\tchar *shell;\n\tpid_t pid;\n\tint status;\n\tvoid (*osighand)(int);\n\n\tif (!options.permit_local_command ||\n\t    args == NULL || !*args)\n\t\treturn (1);\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\tosighand = signal(SIGCHLD, SIG_DFL);\n\tpid = fork();\n\tif (pid == 0) {\n\t\tsignal(SIGPIPE, SIG_DFL);\n\t\tdebug3(\"Executing %s -c \\\"%s\\\"\", shell, args);\n\t\texecl(shell, shell, \"-c\", args, (char *)NULL);\n\t\terror(\"Couldn't execute %s -c \\\"%s\\\": %s\",\n\t\t    shell, args, strerror(errno));\n\t\t_exit(1);\n\t} else if (pid == -1)\n\t\tfatal(\"fork failed: %.100s\", strerror(errno));\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\tsignal(SIGCHLD, osighand);\n\n\tif (!WIFEXITED(status))\n\t\treturn (1);\n\n\treturn (WEXITSTATUS(status));\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(u_char)*s"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_passphrase",
          "args": [
            "\"\\r\\nssh> \"",
            "RP_ECHO"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "read_passphrase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readpass.c",
          "lines": "117-166",
          "snippet": "char *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "leave_raw_mode",
          "args": [
            "options.request_tty == REQUEST_TTY_FORCE"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "leave_raw_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshtty.c",
          "lines": "56-66",
          "snippet": "void\nleave_raw_mode(int quiet)\n{\n\tif (!_in_raw_mode)\n\t\treturn;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 0;\n}",
          "includes": [
            "#include \"sshpty.h\"",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios _saved_tio;",
            "static int _in_raw_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sshpty.h\"\n#include <pwd.h>\n#include <termios.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct termios _saved_tio;\nstatic int _in_raw_mode = 0;\n\nvoid\nleave_raw_mode(int quiet)\n{\n\tif (!_in_raw_mode)\n\t\treturn;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fwd",
            "0",
            "sizeof(fwd)"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nextern char *host;\n\nstatic void\nprocess_cmdline(struct ssh *ssh)\n{\n\tvoid (*handler)(int);\n\tchar *s, *cmd;\n\tint ok, delete = 0, local = 0, remote = 0, dynamic = 0;\n\tstruct Forward fwd;\n\n\tmemset(&fwd, 0, sizeof(fwd));\n\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\thandler = signal(SIGINT, SIG_IGN);\n\tcmd = s = read_passphrase(\"\\r\\nssh> \", RP_ECHO);\n\tif (s == NULL)\n\t\tgoto out;\n\twhile (isspace((u_char)*s))\n\t\ts++;\n\tif (*s == '-')\n\t\ts++;\t/* Skip cmdline '-', if any */\n\tif (*s == '\\0')\n\t\tgoto out;\n\n\tif (*s == 'h' || *s == 'H' || *s == '?') {\n\t\tlogit(\"Commands:\");\n\t\tlogit(\"      -L[bind_address:]port:host:hostport    \"\n\t\t    \"Request local forward\");\n\t\tlogit(\"      -R[bind_address:]port:host:hostport    \"\n\t\t    \"Request remote forward\");\n\t\tlogit(\"      -D[bind_address:]port                  \"\n\t\t    \"Request dynamic forward\");\n\t\tlogit(\"      -KL[bind_address:]port                 \"\n\t\t    \"Cancel local forward\");\n\t\tlogit(\"      -KR[bind_address:]port                 \"\n\t\t    \"Cancel remote forward\");\n\t\tlogit(\"      -KD[bind_address:]port                 \"\n\t\t    \"Cancel dynamic forward\");\n\t\tif (!options.permit_local_command)\n\t\t\tgoto out;\n\t\tlogit(\"      !args                                  \"\n\t\t    \"Execute local command\");\n\t\tgoto out;\n\t}\n\n\tif (*s == '!' && options.permit_local_command) {\n\t\ts++;\n\t\tssh_local_cmd(s);\n\t\tgoto out;\n\t}\n\n\tif (*s == 'K') {\n\t\tdelete = 1;\n\t\ts++;\n\t}\n\tif (*s == 'L')\n\t\tlocal = 1;\n\telse if (*s == 'R')\n\t\tremote = 1;\n\telse if (*s == 'D')\n\t\tdynamic = 1;\n\telse {\n\t\tlogit(\"Invalid command.\");\n\t\tgoto out;\n\t}\n\n\twhile (isspace((u_char)*++s))\n\t\t;\n\n\t/* XXX update list of forwards in options */\n\tif (delete) {\n\t\t/* We pass 1 for dynamicfwd to restrict to 1 or 2 fields. */\n\t\tif (!parse_forward(&fwd, s, 1, 0)) {\n\t\t\tlogit(\"Bad forwarding close specification.\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (remote)\n\t\t\tok = channel_request_rforward_cancel(ssh, &fwd) == 0;\n\t\telse if (dynamic)\n\t\t\tok = channel_cancel_lport_listener(ssh, &fwd,\n\t\t\t    0, &options.fwd_opts) > 0;\n\t\telse\n\t\t\tok = channel_cancel_lport_listener(ssh, &fwd,\n\t\t\t    CHANNEL_CANCEL_PORT_STATIC,\n\t\t\t    &options.fwd_opts) > 0;\n\t\tif (!ok) {\n\t\t\tlogit(\"Unknown port forwarding.\");\n\t\t\tgoto out;\n\t\t}\n\t\tlogit(\"Canceled forwarding.\");\n\t} else {\n\t\tif (!parse_forward(&fwd, s, dynamic, remote)) {\n\t\t\tlogit(\"Bad forwarding specification.\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (local || dynamic) {\n\t\t\tif (!channel_setup_local_fwd_listener(ssh, &fwd,\n\t\t\t    &options.fwd_opts)) {\n\t\t\t\tlogit(\"Port forwarding failed.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tif (channel_request_remote_forwarding(ssh, &fwd) < 0) {\n\t\t\t\tlogit(\"Port forwarding failed.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tlogit(\"Forwarding port.\");\n\t}\n\nout:\n\tsignal(SIGINT, handler);\n\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\tfree(cmd);\n\tfree(fwd.listen_host);\n\tfree(fwd.listen_path);\n\tfree(fwd.connect_host);\n\tfree(fwd.connect_path);\n}"
  },
  {
    "function_name": "client_register_global_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "747-766",
    "snippet": "void\nclient_register_global_confirm(global_confirm_cb *cb, void *ctx)\n{\n\tstruct global_confirm *gc, *last_gc;\n\n\t/* Coalesce identical callbacks */\n\tlast_gc = TAILQ_LAST(&global_confirms, global_confirms);\n\tif (last_gc && last_gc->cb == cb && last_gc->ctx == ctx) {\n\t\tif (++last_gc->ref_count >= INT_MAX)\n\t\t\tfatal(\"%s: last_gc->ref_count = %d\",\n\t\t\t    __func__, last_gc->ref_count);\n\t\treturn;\n\t}\n\n\tgc = xcalloc(1, sizeof(*gc));\n\tgc->cb = cb;\n\tgc->ctx = ctx;\n\tgc->ref_count = 1;\n\tTAILQ_INSERT_TAIL(&global_confirms, gc, entry);\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct global_confirms global_confirms =\n    TAILQ_HEAD_INITIALIZER(global_confirms);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&global_confirms",
            "gc",
            "entry"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(*gc)"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: last_gc->ref_count = %d\"",
            "__func__",
            "last_gc->ref_count"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_LAST",
          "args": [
            "&global_confirms",
            "global_confirms"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct global_confirms global_confirms =\n    TAILQ_HEAD_INITIALIZER(global_confirms);\n\nvoid\nclient_register_global_confirm(global_confirm_cb *cb, void *ctx)\n{\n\tstruct global_confirm *gc, *last_gc;\n\n\t/* Coalesce identical callbacks */\n\tlast_gc = TAILQ_LAST(&global_confirms, global_confirms);\n\tif (last_gc && last_gc->cb == cb && last_gc->ctx == ctx) {\n\t\tif (++last_gc->ref_count >= INT_MAX)\n\t\t\tfatal(\"%s: last_gc->ref_count = %d\",\n\t\t\t    __func__, last_gc->ref_count);\n\t\treturn;\n\t}\n\n\tgc = xcalloc(1, sizeof(*gc));\n\tgc->cb = cb;\n\tgc->ctx = ctx;\n\tgc->ref_count = 1;\n\tTAILQ_INSERT_TAIL(&global_confirms, gc, entry);\n}"
  },
  {
    "function_name": "client_expect_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "734-745",
    "snippet": "void\nclient_expect_confirm(struct ssh *ssh, int id, const char *request,\n    enum confirm_action action)\n{\n\tstruct channel_reply_ctx *cr = xcalloc(1, sizeof(*cr));\n\n\tcr->request_type = request;\n\tcr->action = action;\n\n\tchannel_register_status_confirm(ssh, id, client_status_confirm,\n\t    client_abandon_status_confirm, cr);\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_register_status_confirm",
          "args": [
            "ssh",
            "id",
            "client_status_confirm",
            "client_abandon_status_confirm",
            "cr"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_status_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "954-969",
          "snippet": "void\nchannel_register_status_confirm(struct ssh *ssh, int id,\n    channel_confirm_cb *cb, channel_confirm_abandon_cb *abandon_cb, void *ctx)\n{\n\tstruct channel_confirm *cc;\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL)\n\t\tfatal(\"%s: %d: bad id\", __func__, id);\n\n\tcc = xcalloc(1, sizeof(*cc));\n\tcc->cb = cb;\n\tcc->abandon_cb = abandon_cb;\n\tcc->ctx = ctx;\n\tTAILQ_INSERT_TAIL(&c->status_confirms, cc, entry);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_status_confirm(struct ssh *ssh, int id,\n    channel_confirm_cb *cb, channel_confirm_abandon_cb *abandon_cb, void *ctx)\n{\n\tstruct channel_confirm *cc;\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL)\n\t\tfatal(\"%s: %d: bad id\", __func__, id);\n\n\tcc = xcalloc(1, sizeof(*cc));\n\tcc->cb = cb;\n\tcc->abandon_cb = abandon_cb;\n\tcc->ctx = ctx;\n\tTAILQ_INSERT_TAIL(&c->status_confirms, cc, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(*cr)"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclient_expect_confirm(struct ssh *ssh, int id, const char *request,\n    enum confirm_action action)\n{\n\tstruct channel_reply_ctx *cr = xcalloc(1, sizeof(*cr));\n\n\tcr->request_type = request;\n\tcr->action = action;\n\n\tchannel_register_status_confirm(ssh, id, client_status_confirm,\n\t    client_abandon_status_confirm, cr);\n}"
  },
  {
    "function_name": "client_abandon_status_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "728-732",
    "snippet": "static void\nclient_abandon_status_confirm(struct ssh *ssh, Channel *c, void *ctx)\n{\n\tfree(ctx);\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ctx"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nclient_abandon_status_confirm(struct ssh *ssh, Channel *c, void *ctx)\n{\n\tfree(ctx);\n}"
  },
  {
    "function_name": "client_status_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "665-726",
    "snippet": "static void\nclient_status_confirm(struct ssh *ssh, int type, Channel *c, void *ctx)\n{\n\tstruct channel_reply_ctx *cr = (struct channel_reply_ctx *)ctx;\n\tchar errmsg[256];\n\tint r, tochan;\n\n\t/*\n\t * If a TTY was explicitly requested, then a failure to allocate\n\t * one is fatal.\n\t */\n\tif (cr->action == CONFIRM_TTY &&\n\t    (options.request_tty == REQUEST_TTY_FORCE ||\n\t    options.request_tty == REQUEST_TTY_YES))\n\t\tcr->action = CONFIRM_CLOSE;\n\n\t/* XXX suppress on mux _client_ quietmode */\n\ttochan = options.log_level >= SYSLOG_LEVEL_ERROR &&\n\t    c->ctl_chan != -1 && c->extended_usage == CHAN_EXTENDED_WRITE;\n\n\tif (type == SSH2_MSG_CHANNEL_SUCCESS) {\n\t\tdebug2(\"%s request accepted on channel %d\",\n\t\t    cr->request_type, c->self);\n\t} else if (type == SSH2_MSG_CHANNEL_FAILURE) {\n\t\tif (tochan) {\n\t\t\tsnprintf(errmsg, sizeof(errmsg),\n\t\t\t    \"%s request failed\\r\\n\", cr->request_type);\n\t\t} else {\n\t\t\tsnprintf(errmsg, sizeof(errmsg),\n\t\t\t    \"%s request failed on channel %d\",\n\t\t\t    cr->request_type, c->self);\n\t\t}\n\t\t/* If error occurred on primary session channel, then exit */\n\t\tif (cr->action == CONFIRM_CLOSE && c->self == session_ident)\n\t\t\tfatal(\"%s\", errmsg);\n\t\t/*\n\t\t * If error occurred on mux client, append to\n\t\t * their stderr.\n\t\t */\n\t\tif (tochan) {\n\t\t\tif ((r = sshbuf_put(c->extended, errmsg,\n\t\t\t    strlen(errmsg))) != 0)\n\t\t\t\tfatal(\"%s: buffer error %s\", __func__,\n\t\t\t\t    ssh_err(r));\n\t\t} else\n\t\t\terror(\"%s\", errmsg);\n\t\tif (cr->action == CONFIRM_TTY) {\n\t\t\t/*\n\t\t\t * If a TTY allocation error occurred, then arrange\n\t\t\t * for the correct TTY to leave raw mode.\n\t\t\t */\n\t\t\tif (c->self == session_ident)\n\t\t\t\tleave_raw_mode(0);\n\t\t\telse\n\t\t\t\tmux_tty_alloc_failed(ssh, c);\n\t\t} else if (cr->action == CONFIRM_CLOSE) {\n\t\t\tchan_read_failed(ssh, c);\n\t\t\tchan_write_failed(ssh, c);\n\t\t}\n\t}\n\tfree(cr);\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "int\tsession_ident = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cr"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_write_failed",
          "args": [
            "ssh",
            "c"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "chan_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "305-322",
          "snippet": "void\nchan_write_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: write failed\", c->self);\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tif (strcmp(c->ctype, \"session\") == 0)\n\t\t\tchan_send_eow2(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_write_failed for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_write_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: write failed\", c->self);\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tif (strcmp(c->ctype, \"session\") == 0)\n\t\t\tchan_send_eow2(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_write_failed for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_read_failed",
          "args": [
            "ssh",
            "c"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "chan_read_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "108-122",
          "snippet": "void\nchan_read_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: read failed\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_WAIT_DRAIN);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_read_failed for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_read_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: read failed\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_WAIT_DRAIN);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_read_failed for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_tty_alloc_failed",
          "args": [
            "ssh",
            "c"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "mux_tty_alloc_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1253-1274",
          "snippet": "void\nmux_tty_alloc_failed(struct ssh *ssh, Channel *c)\n{\n\tstruct sshbuf *m;\n\tChannel *mux_chan;\n\tint r;\n\n\tdebug3(\"%s: channel %d: TTY alloc failed\", __func__, c->self);\n\n\tif ((mux_chan = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\tfatal(\"%s: channel %d missing mux channel %d\",\n\t\t    __func__, c->self, c->ctl_chan);\n\n\t/* Append exit message packet to control socket output queue */\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_S_TTY_ALLOC_FAIL)) != 0 ||\n\t    (r = sshbuf_put_u32(m, c->self)) != 0 ||\n\t    (r = sshbuf_put_stringb(mux_chan->output, m)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\tsshbuf_free(m);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_S_TTY_ALLOC_FAIL\t0x80000008"
          ],
          "globals_used": [
            "static void mux_session_confirm(struct ssh *, int, int, void *);",
            "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_TTY_ALLOC_FAIL\t0x80000008\n\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nvoid\nmux_tty_alloc_failed(struct ssh *ssh, Channel *c)\n{\n\tstruct sshbuf *m;\n\tChannel *mux_chan;\n\tint r;\n\n\tdebug3(\"%s: channel %d: TTY alloc failed\", __func__, c->self);\n\n\tif ((mux_chan = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\tfatal(\"%s: channel %d missing mux channel %d\",\n\t\t    __func__, c->self, c->ctl_chan);\n\n\t/* Append exit message packet to control socket output queue */\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_put_u32(m, MUX_S_TTY_ALLOC_FAIL)) != 0 ||\n\t    (r = sshbuf_put_u32(m, c->self)) != 0 ||\n\t    (r = sshbuf_put_stringb(mux_chan->output, m)) != 0)\n\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\tsshbuf_free(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leave_raw_mode",
          "args": [
            "0"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "leave_raw_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshtty.c",
          "lines": "56-66",
          "snippet": "void\nleave_raw_mode(int quiet)\n{\n\tif (!_in_raw_mode)\n\t\treturn;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 0;\n}",
          "includes": [
            "#include \"sshpty.h\"",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios _saved_tio;",
            "static int _in_raw_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sshpty.h\"\n#include <pwd.h>\n#include <termios.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct termios _saved_tio;\nstatic int _in_raw_mode = 0;\n\nvoid\nleave_raw_mode(int quiet)\n{\n\tif (!_in_raw_mode)\n\t\treturn;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s\"",
            "errmsg"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "c->extended",
            "errmsg",
            "strlen(errmsg)"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "errmsg"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s\"",
            "errmsg"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "errmsg",
            "sizeof(errmsg)",
            "\"%s request failed on channel %d\"",
            "cr->request_type",
            "c->self"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s request accepted on channel %d\"",
            "cr->request_type",
            "c->self"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint\tsession_ident = -1;\n\nstatic void\nclient_status_confirm(struct ssh *ssh, int type, Channel *c, void *ctx)\n{\n\tstruct channel_reply_ctx *cr = (struct channel_reply_ctx *)ctx;\n\tchar errmsg[256];\n\tint r, tochan;\n\n\t/*\n\t * If a TTY was explicitly requested, then a failure to allocate\n\t * one is fatal.\n\t */\n\tif (cr->action == CONFIRM_TTY &&\n\t    (options.request_tty == REQUEST_TTY_FORCE ||\n\t    options.request_tty == REQUEST_TTY_YES))\n\t\tcr->action = CONFIRM_CLOSE;\n\n\t/* XXX suppress on mux _client_ quietmode */\n\ttochan = options.log_level >= SYSLOG_LEVEL_ERROR &&\n\t    c->ctl_chan != -1 && c->extended_usage == CHAN_EXTENDED_WRITE;\n\n\tif (type == SSH2_MSG_CHANNEL_SUCCESS) {\n\t\tdebug2(\"%s request accepted on channel %d\",\n\t\t    cr->request_type, c->self);\n\t} else if (type == SSH2_MSG_CHANNEL_FAILURE) {\n\t\tif (tochan) {\n\t\t\tsnprintf(errmsg, sizeof(errmsg),\n\t\t\t    \"%s request failed\\r\\n\", cr->request_type);\n\t\t} else {\n\t\t\tsnprintf(errmsg, sizeof(errmsg),\n\t\t\t    \"%s request failed on channel %d\",\n\t\t\t    cr->request_type, c->self);\n\t\t}\n\t\t/* If error occurred on primary session channel, then exit */\n\t\tif (cr->action == CONFIRM_CLOSE && c->self == session_ident)\n\t\t\tfatal(\"%s\", errmsg);\n\t\t/*\n\t\t * If error occurred on mux client, append to\n\t\t * their stderr.\n\t\t */\n\t\tif (tochan) {\n\t\t\tif ((r = sshbuf_put(c->extended, errmsg,\n\t\t\t    strlen(errmsg))) != 0)\n\t\t\t\tfatal(\"%s: buffer error %s\", __func__,\n\t\t\t\t    ssh_err(r));\n\t\t} else\n\t\t\terror(\"%s\", errmsg);\n\t\tif (cr->action == CONFIRM_TTY) {\n\t\t\t/*\n\t\t\t * If a TTY allocation error occurred, then arrange\n\t\t\t * for the correct TTY to leave raw mode.\n\t\t\t */\n\t\t\tif (c->self == session_ident)\n\t\t\t\tleave_raw_mode(0);\n\t\t\telse\n\t\t\t\tmux_tty_alloc_failed(ssh, c);\n\t\t} else if (cr->action == CONFIRM_CLOSE) {\n\t\t\tchan_read_failed(ssh, c);\n\t\t\tchan_write_failed(ssh, c);\n\t\t}\n\t}\n\tfree(cr);\n}"
  },
  {
    "function_name": "client_process_net_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "614-663",
    "snippet": "static void\nclient_process_net_input(fd_set *readset)\n{\n\tchar buf[SSH_IOBUFSZ];\n\tint r, len;\n\n\t/*\n\t * Read input from the server, and add any such data to the buffer of\n\t * the packet subsystem.\n\t */\n\tif (FD_ISSET(connection_in, readset)) {\n\t\t/* Read as much as possible. */\n\t\tlen = read(connection_in, buf, sizeof(buf));\n\t\tif (len == 0) {\n\t\t\t/*\n\t\t\t * Received EOF.  The remote host has closed the\n\t\t\t * connection.\n\t\t\t */\n\t\t\tif ((r = sshbuf_putf(stderr_buffer,\n\t\t\t    \"Connection to %.300s closed by remote host.\\r\\n\",\n\t\t\t    host)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tquit_pending = 1;\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * There is a kernel bug on Solaris that causes select to\n\t\t * sometimes wake up even though there is no data available.\n\t\t */\n\t\tif (len < 0 &&\n\t\t    (errno == EAGAIN || errno == EINTR || errno == EWOULDBLOCK))\n\t\t\tlen = 0;\n\n\t\tif (len < 0) {\n\t\t\t/*\n\t\t\t * An error has encountered.  Perhaps there is a\n\t\t\t * network problem.\n\t\t\t */\n\t\t\tif ((r = sshbuf_putf(stderr_buffer,\n\t\t\t    \"Read from remote host %.300s: %.100s\\r\\n\",\n\t\t\t    host, strerror(errno))) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tquit_pending = 1;\n\t\t\treturn;\n\t\t}\n\t\tpacket_process_incoming(buf, len);\n\t}\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *host;",
      "volatile sig_atomic_t quit_pending;",
      "static struct sshbuf *stderr_buffer;",
      "static int connection_in;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "packet_process_incoming",
          "args": [
            "buf",
            "len"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "packet_process_incoming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "262-269",
          "snippet": "void\npacket_process_incoming(const char *buf, u_int len)\n{\n\tint r;\n\n\tif ((r = ssh_packet_process_incoming(active_state, buf, len)) != 0)\n\t\tsshpkt_fatal(active_state, __func__, r);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_process_incoming(const char *buf, u_int len)\n{\n\tint r;\n\n\tif ((r = ssh_packet_process_incoming(active_state, buf, len)) != 0)\n\t\tsshpkt_fatal(active_state, __func__, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_putf",
          "args": [
            "stderr_buffer",
            "\"Read from remote host %.300s: %.100s\\r\\n\"",
            "host",
            "strerror(errno)"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "connection_in",
            "buf",
            "sizeof(buf)"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "do_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "675-679",
          "snippet": "int\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "connection_in",
            "readset"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_ISSET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "22-24",
          "snippet": "int kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nint kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern char *host;\nvolatile sig_atomic_t quit_pending;\nstatic struct sshbuf *stderr_buffer;\nstatic int connection_in;\n\nstatic void\nclient_process_net_input(fd_set *readset)\n{\n\tchar buf[SSH_IOBUFSZ];\n\tint r, len;\n\n\t/*\n\t * Read input from the server, and add any such data to the buffer of\n\t * the packet subsystem.\n\t */\n\tif (FD_ISSET(connection_in, readset)) {\n\t\t/* Read as much as possible. */\n\t\tlen = read(connection_in, buf, sizeof(buf));\n\t\tif (len == 0) {\n\t\t\t/*\n\t\t\t * Received EOF.  The remote host has closed the\n\t\t\t * connection.\n\t\t\t */\n\t\t\tif ((r = sshbuf_putf(stderr_buffer,\n\t\t\t    \"Connection to %.300s closed by remote host.\\r\\n\",\n\t\t\t    host)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tquit_pending = 1;\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * There is a kernel bug on Solaris that causes select to\n\t\t * sometimes wake up even though there is no data available.\n\t\t */\n\t\tif (len < 0 &&\n\t\t    (errno == EAGAIN || errno == EINTR || errno == EWOULDBLOCK))\n\t\t\tlen = 0;\n\n\t\tif (len < 0) {\n\t\t\t/*\n\t\t\t * An error has encountered.  Perhaps there is a\n\t\t\t * network problem.\n\t\t\t */\n\t\t\tif ((r = sshbuf_putf(stderr_buffer,\n\t\t\t    \"Read from remote host %.300s: %.100s\\r\\n\",\n\t\t\t    host, strerror(errno))) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tquit_pending = 1;\n\t\t\treturn;\n\t\t}\n\t\tpacket_process_incoming(buf, len);\n\t}\n}"
  },
  {
    "function_name": "client_suspend_self",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "588-612",
    "snippet": "static void\nclient_suspend_self(struct sshbuf *bin, struct sshbuf *bout, struct sshbuf *berr)\n{\n\t/* Flush stdout and stderr buffers. */\n\tif (sshbuf_len(bout) > 0)\n\t\tatomicio(vwrite, fileno(stdout), sshbuf_mutable_ptr(bout),\n\t\t    sshbuf_len(bout));\n\tif (sshbuf_len(berr) > 0)\n\t\tatomicio(vwrite, fileno(stderr), sshbuf_mutable_ptr(berr),\n\t\t    sshbuf_len(berr));\n\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\tsshbuf_reset(bin);\n\tsshbuf_reset(bout);\n\tsshbuf_reset(berr);\n\n\t/* Send the suspend signal to the program itself. */\n\tkill(getpid(), SIGTSTP);\n\n\t/* Reset window sizes in case they have changed */\n\treceived_window_change_signal = 1;\n\n\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "static volatile sig_atomic_t received_window_change_signal = 0;",
      "void ssh_process_session2_setup(int, int, int, struct sshbuf *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enter_raw_mode",
          "args": [
            "options.request_tty == REQUEST_TTY_FORCE"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "enter_raw_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshtty.c",
          "lines": "68-96",
          "snippet": "void\nenter_raw_mode(int quiet)\n{\n\tstruct termios tio;\n\n\tif (tcgetattr(fileno(stdin), &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcgetattr\");\n\t\treturn;\n\t}\n\t_saved_tio = tio;\n\ttio.c_iflag |= IGNPAR;\n\ttio.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);\n#ifdef IUCLC\n\ttio.c_iflag &= ~IUCLC;\n#endif\n\ttio.c_lflag &= ~(ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);\n#ifdef IEXTEN\n\ttio.c_lflag &= ~IEXTEN;\n#endif\n\ttio.c_oflag &= ~OPOST;\n\ttio.c_cc[VMIN] = 1;\n\ttio.c_cc[VTIME] = 0;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 1;\n}",
          "includes": [
            "#include \"sshpty.h\"",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios _saved_tio;",
            "static int _in_raw_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sshpty.h\"\n#include <pwd.h>\n#include <termios.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct termios _saved_tio;\nstatic int _in_raw_mode = 0;\n\nvoid\nenter_raw_mode(int quiet)\n{\n\tstruct termios tio;\n\n\tif (tcgetattr(fileno(stdin), &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcgetattr\");\n\t\treturn;\n\t}\n\t_saved_tio = tio;\n\ttio.c_iflag |= IGNPAR;\n\ttio.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);\n#ifdef IUCLC\n\ttio.c_iflag &= ~IUCLC;\n#endif\n\ttio.c_lflag &= ~(ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);\n#ifdef IEXTEN\n\ttio.c_lflag &= ~IEXTEN;\n#endif\n\ttio.c_oflag &= ~OPOST;\n\ttio.c_cc[VMIN] = 1;\n\ttio.c_cc[VTIME] = 0;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "getpid()",
            "SIGTSTP"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "berr"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leave_raw_mode",
          "args": [
            "options.request_tty == REQUEST_TTY_FORCE"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "leave_raw_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshtty.c",
          "lines": "56-66",
          "snippet": "void\nleave_raw_mode(int quiet)\n{\n\tif (!_in_raw_mode)\n\t\treturn;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 0;\n}",
          "includes": [
            "#include \"sshpty.h\"",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios _saved_tio;",
            "static int _in_raw_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sshpty.h\"\n#include <pwd.h>\n#include <termios.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct termios _saved_tio;\nstatic int _in_raw_mode = 0;\n\nvoid\nleave_raw_mode(int quiet)\n{\n\tif (!_in_raw_mode)\n\t\treturn;\n\tif (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {\n\t\tif (!quiet)\n\t\t\tperror(\"tcsetattr\");\n\t} else\n\t\t_in_raw_mode = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "vwrite",
            "fileno(stderr)",
            "sshbuf_mutable_ptr(berr)",
            "sshbuf_len(berr)"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "berr"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_mutable_ptr",
          "args": [
            "berr"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_mutable_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "276-282",
          "snippet": "u_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stderr"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdout"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic volatile sig_atomic_t received_window_change_signal = 0;\nvoid ssh_process_session2_setup(int, int, int, struct sshbuf *);\n\nstatic void\nclient_suspend_self(struct sshbuf *bin, struct sshbuf *bout, struct sshbuf *berr)\n{\n\t/* Flush stdout and stderr buffers. */\n\tif (sshbuf_len(bout) > 0)\n\t\tatomicio(vwrite, fileno(stdout), sshbuf_mutable_ptr(bout),\n\t\t    sshbuf_len(bout));\n\tif (sshbuf_len(berr) > 0)\n\t\tatomicio(vwrite, fileno(stderr), sshbuf_mutable_ptr(berr),\n\t\t    sshbuf_len(berr));\n\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\tsshbuf_reset(bin);\n\tsshbuf_reset(bout);\n\tsshbuf_reset(berr);\n\n\t/* Send the suspend signal to the program itself. */\n\tkill(getpid(), SIGTSTP);\n\n\t/* Reset window sizes in case they have changed */\n\treceived_window_change_signal = 1;\n\n\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n}"
  },
  {
    "function_name": "client_wait_until_can_do_something",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "501-586",
    "snippet": "static void\nclient_wait_until_can_do_something(struct ssh *ssh,\n    fd_set **readsetp, fd_set **writesetp,\n    int *maxfdp, u_int *nallocp, int rekeying)\n{\n\tstruct timeval tv, *tvp;\n\tint timeout_secs;\n\ttime_t minwait_secs = 0, server_alive_time = 0, now = monotime();\n\tint r, ret;\n\n\t/* Add any selections by the channel mechanism. */\n\tchannel_prepare_select(active_state, readsetp, writesetp, maxfdp,\n\t    nallocp, &minwait_secs);\n\n\t/* channel_prepare_select could have closed the last channel */\n\tif (session_closed && !channel_still_open(ssh) &&\n\t    !packet_have_data_to_write()) {\n\t\t/* clear mask since we did not call select() */\n\t\tmemset(*readsetp, 0, *nallocp);\n\t\tmemset(*writesetp, 0, *nallocp);\n\t\treturn;\n\t}\n\n\tFD_SET(connection_in, *readsetp);\n\n\t/* Select server connection if have data to write to the server. */\n\tif (packet_have_data_to_write())\n\t\tFD_SET(connection_out, *writesetp);\n\n\t/*\n\t * Wait for something to happen.  This will suspend the process until\n\t * some selected descriptor can be read, written, or has some other\n\t * event pending, or a timeout expires.\n\t */\n\n\ttimeout_secs = INT_MAX; /* we use INT_MAX to mean no timeout */\n\tif (options.server_alive_interval > 0) {\n\t\ttimeout_secs = options.server_alive_interval;\n\t\tserver_alive_time = now + options.server_alive_interval;\n\t}\n\tif (options.rekey_interval > 0 && !rekeying)\n\t\ttimeout_secs = MINIMUM(timeout_secs, packet_get_rekey_timeout());\n\tset_control_persist_exit_time(ssh);\n\tif (control_persist_exit_time > 0) {\n\t\ttimeout_secs = MINIMUM(timeout_secs,\n\t\t\tcontrol_persist_exit_time - now);\n\t\tif (timeout_secs < 0)\n\t\t\ttimeout_secs = 0;\n\t}\n\tif (minwait_secs != 0)\n\t\ttimeout_secs = MINIMUM(timeout_secs, (int)minwait_secs);\n\tif (timeout_secs == INT_MAX)\n\t\ttvp = NULL;\n\telse {\n\t\ttv.tv_sec = timeout_secs;\n\t\ttv.tv_usec = 0;\n\t\ttvp = &tv;\n\t}\n\n\tret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);\n\tif (ret < 0) {\n\t\t/*\n\t\t * We have to clear the select masks, because we return.\n\t\t * We have to return, because the mainloop checks for the flags\n\t\t * set by the signal handlers.\n\t\t */\n\t\tmemset(*readsetp, 0, *nallocp);\n\t\tmemset(*writesetp, 0, *nallocp);\n\n\t\tif (errno == EINTR)\n\t\t\treturn;\n\t\t/* Note: we might still have data in the buffers. */\n\t\tif ((r = sshbuf_putf(stderr_buffer,\n\t\t    \"select: %s\\r\\n\", strerror(errno))) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tquit_pending = 1;\n\t} else if (ret == 0) {\n\t\t/*\n\t\t * Timeout.  Could have been either keepalive or rekeying.\n\t\t * Keepalive we check here, rekeying is checked in clientloop.\n\t\t */\n\t\tif (server_alive_time != 0 && server_alive_time <= monotime())\n\t\t\tserver_alive_check();\n\t}\n\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "static time_t control_persist_exit_time = 0;",
      "volatile sig_atomic_t quit_pending;",
      "static struct sshbuf *stderr_buffer;",
      "static int connection_in;",
      "static int connection_out;",
      "static int session_closed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "server_alive_check",
          "args": [],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "server_alive_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "482-495",
          "snippet": "static void\nserver_alive_check(void)\n{\n\tif (packet_inc_alive_timeouts() > options.server_alive_count_max) {\n\t\tlogit(\"Timeout, server %s not responding.\", host);\n\t\tcleanup_exit(255);\n\t}\n\tpacket_start(SSH2_MSG_GLOBAL_REQUEST);\n\tpacket_put_cstring(\"keepalive@openssh.com\");\n\tpacket_put_char(1);     /* boolean: want reply */\n\tpacket_send();\n\t/* Insert an empty placeholder to maintain ordering */\n\tclient_register_global_confirm(NULL, NULL);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "extern char *host;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nextern char *host;\n\nstatic void\nserver_alive_check(void)\n{\n\tif (packet_inc_alive_timeouts() > options.server_alive_count_max) {\n\t\tlogit(\"Timeout, server %s not responding.\", host);\n\t\tcleanup_exit(255);\n\t}\n\tpacket_start(SSH2_MSG_GLOBAL_REQUEST);\n\tpacket_put_cstring(\"keepalive@openssh.com\");\n\tpacket_put_char(1);     /* boolean: want reply */\n\tpacket_send();\n\t/* Insert an empty placeholder to maintain ordering */\n\tclient_register_global_confirm(NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "monotime",
          "args": [],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "monotime_double",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1324-1331",
          "snippet": "double\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\ndouble\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_putf",
          "args": [
            "stderr_buffer",
            "\"select: %s\\r\\n\"",
            "strerror(errno)"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "*writesetp",
            "0",
            "*nallocp"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "*readsetp",
            "0",
            "*nallocp"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "(*maxfdp)+1",
            "*readsetp",
            "*writesetp",
            "NULL",
            "tvp"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "110-122",
          "snippet": "static void select(unsigned int p[64],unsigned int q[64],const unsigned int r[64],const unsigned int s[64],unsigned int b)\n{\n  unsigned int j;\n  unsigned int t;\n  unsigned int bminus1;\n\n  bminus1 = b - 1;\n  for (j = 0;j < 64;++j) {\n    t = bminus1 & (r[j] ^ s[j]);\n    p[j] = s[j] ^ t;\n    q[j] = r[j] ^ t;\n  }\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void select(unsigned int p[64],unsigned int q[64],const unsigned int r[64],const unsigned int s[64],unsigned int b)\n{\n  unsigned int j;\n  unsigned int t;\n  unsigned int bminus1;\n\n  bminus1 = b - 1;\n  for (j = 0;j < 64;++j) {\n    t = bminus1 & (r[j] ^ s[j]);\n    p[j] = s[j] ^ t;\n    q[j] = r[j] ^ t;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "timeout_secs",
            "(int)minwait_secs"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "timeout_secs",
            "control_persist_exit_time - now"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_control_persist_exit_time",
          "args": [
            "ssh"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "set_control_persist_exit_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "233-253",
          "snippet": "static void\nset_control_persist_exit_time(struct ssh *ssh)\n{\n\tif (muxserver_sock == -1 || !options.control_persist\n\t    || options.control_persist_timeout == 0) {\n\t\t/* not using a ControlPersist timeout */\n\t\tcontrol_persist_exit_time = 0;\n\t} else if (channel_still_open(ssh)) {\n\t\t/* some client connections are still open */\n\t\tif (control_persist_exit_time > 0)\n\t\t\tdebug2(\"%s: cancel scheduled exit\", __func__);\n\t\tcontrol_persist_exit_time = 0;\n\t} else if (control_persist_exit_time <= 0) {\n\t\t/* a client connection has recently closed */\n\t\tcontrol_persist_exit_time = monotime() +\n\t\t\t(time_t)options.control_persist_timeout;\n\t\tdebug2(\"%s: schedule exit in %d seconds\", __func__,\n\t\t    options.control_persist_timeout);\n\t}\n\t/* else we are already counting down to the timeout */\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "extern int muxserver_sock;",
            "static time_t control_persist_exit_time = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nextern int muxserver_sock;\nstatic time_t control_persist_exit_time = 0;\n\nstatic void\nset_control_persist_exit_time(struct ssh *ssh)\n{\n\tif (muxserver_sock == -1 || !options.control_persist\n\t    || options.control_persist_timeout == 0) {\n\t\t/* not using a ControlPersist timeout */\n\t\tcontrol_persist_exit_time = 0;\n\t} else if (channel_still_open(ssh)) {\n\t\t/* some client connections are still open */\n\t\tif (control_persist_exit_time > 0)\n\t\t\tdebug2(\"%s: cancel scheduled exit\", __func__);\n\t\tcontrol_persist_exit_time = 0;\n\t} else if (control_persist_exit_time <= 0) {\n\t\t/* a client connection has recently closed */\n\t\tcontrol_persist_exit_time = monotime() +\n\t\t\t(time_t)options.control_persist_timeout;\n\t\tdebug2(\"%s: schedule exit in %d seconds\", __func__,\n\t\t    options.control_persist_timeout);\n\t}\n\t/* else we are already counting down to the timeout */\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "timeout_secs",
            "packet_get_rekey_timeout()"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_rekey_timeout",
          "args": [],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "connection_out",
            "*writesetp"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_SET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "19-21",
          "snippet": "void kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nvoid kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_have_data_to_write",
          "args": [],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "*writesetp",
            "0",
            "*nallocp"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "*readsetp",
            "0",
            "*nallocp"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_have_data_to_write",
          "args": [],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_still_open",
          "args": [
            "ssh"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "channel_still_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "718-758",
          "snippet": "int\nchannel_still_open(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tfatal(\"%s: bad channel type %d\", __func__, c->type);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_still_open(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tfatal(\"%s: bad channel type %d\", __func__, c->type);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_prepare_select",
          "args": [
            "active_state",
            "readsetp",
            "writesetp",
            "maxfdp",
            "nallocp",
            "&minwait_secs"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "channel_prepare_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2478-2507",
          "snippet": "void\nchannel_prepare_select(struct ssh *ssh, fd_set **readsetp, fd_set **writesetp,\n    int *maxfdp, u_int *nallocp, time_t *minwait_secs)\n{\n\tu_int n, sz, nfdset;\n\n\tchannel_before_prepare_select(ssh); /* might update channel_max_fd */\n\n\tn = MAXIMUM(*maxfdp, ssh->chanctxt->channel_max_fd);\n\n\tnfdset = howmany(n+1, NFDBITS);\n\t/* Explicitly test here, because xrealloc isn't always called */\n\tif (nfdset && SIZE_MAX / nfdset < sizeof(fd_mask))\n\t\tfatal(\"channel_prepare_select: max_fd (%d) is too large\", n);\n\tsz = nfdset * sizeof(fd_mask);\n\n\t/* perhaps check sz < nalloc/2 and shrink? */\n\tif (*readsetp == NULL || sz > *nallocp) {\n\t\t*readsetp = xreallocarray(*readsetp, nfdset, sizeof(fd_mask));\n\t\t*writesetp = xreallocarray(*writesetp, nfdset, sizeof(fd_mask));\n\t\t*nallocp = sz;\n\t}\n\t*maxfdp = n;\n\tmemset(*readsetp, 0, sz);\n\tmemset(*writesetp, 0, sz);\n\n\tif (!ssh_packet_is_rekeying(ssh))\n\t\tchannel_handler(ssh, CHAN_PRE, *readsetp, *writesetp,\n\t\t    minwait_secs);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_prepare_select(struct ssh *ssh, fd_set **readsetp, fd_set **writesetp,\n    int *maxfdp, u_int *nallocp, time_t *minwait_secs)\n{\n\tu_int n, sz, nfdset;\n\n\tchannel_before_prepare_select(ssh); /* might update channel_max_fd */\n\n\tn = MAXIMUM(*maxfdp, ssh->chanctxt->channel_max_fd);\n\n\tnfdset = howmany(n+1, NFDBITS);\n\t/* Explicitly test here, because xrealloc isn't always called */\n\tif (nfdset && SIZE_MAX / nfdset < sizeof(fd_mask))\n\t\tfatal(\"channel_prepare_select: max_fd (%d) is too large\", n);\n\tsz = nfdset * sizeof(fd_mask);\n\n\t/* perhaps check sz < nalloc/2 and shrink? */\n\tif (*readsetp == NULL || sz > *nallocp) {\n\t\t*readsetp = xreallocarray(*readsetp, nfdset, sizeof(fd_mask));\n\t\t*writesetp = xreallocarray(*writesetp, nfdset, sizeof(fd_mask));\n\t\t*nallocp = sz;\n\t}\n\t*maxfdp = n;\n\tmemset(*readsetp, 0, sz);\n\tmemset(*writesetp, 0, sz);\n\n\tif (!ssh_packet_is_rekeying(ssh))\n\t\tchannel_handler(ssh, CHAN_PRE, *readsetp, *writesetp,\n\t\t    minwait_secs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic time_t control_persist_exit_time = 0;\nvolatile sig_atomic_t quit_pending;\nstatic struct sshbuf *stderr_buffer;\nstatic int connection_in;\nstatic int connection_out;\nstatic int session_closed;\n\nstatic void\nclient_wait_until_can_do_something(struct ssh *ssh,\n    fd_set **readsetp, fd_set **writesetp,\n    int *maxfdp, u_int *nallocp, int rekeying)\n{\n\tstruct timeval tv, *tvp;\n\tint timeout_secs;\n\ttime_t minwait_secs = 0, server_alive_time = 0, now = monotime();\n\tint r, ret;\n\n\t/* Add any selections by the channel mechanism. */\n\tchannel_prepare_select(active_state, readsetp, writesetp, maxfdp,\n\t    nallocp, &minwait_secs);\n\n\t/* channel_prepare_select could have closed the last channel */\n\tif (session_closed && !channel_still_open(ssh) &&\n\t    !packet_have_data_to_write()) {\n\t\t/* clear mask since we did not call select() */\n\t\tmemset(*readsetp, 0, *nallocp);\n\t\tmemset(*writesetp, 0, *nallocp);\n\t\treturn;\n\t}\n\n\tFD_SET(connection_in, *readsetp);\n\n\t/* Select server connection if have data to write to the server. */\n\tif (packet_have_data_to_write())\n\t\tFD_SET(connection_out, *writesetp);\n\n\t/*\n\t * Wait for something to happen.  This will suspend the process until\n\t * some selected descriptor can be read, written, or has some other\n\t * event pending, or a timeout expires.\n\t */\n\n\ttimeout_secs = INT_MAX; /* we use INT_MAX to mean no timeout */\n\tif (options.server_alive_interval > 0) {\n\t\ttimeout_secs = options.server_alive_interval;\n\t\tserver_alive_time = now + options.server_alive_interval;\n\t}\n\tif (options.rekey_interval > 0 && !rekeying)\n\t\ttimeout_secs = MINIMUM(timeout_secs, packet_get_rekey_timeout());\n\tset_control_persist_exit_time(ssh);\n\tif (control_persist_exit_time > 0) {\n\t\ttimeout_secs = MINIMUM(timeout_secs,\n\t\t\tcontrol_persist_exit_time - now);\n\t\tif (timeout_secs < 0)\n\t\t\ttimeout_secs = 0;\n\t}\n\tif (minwait_secs != 0)\n\t\ttimeout_secs = MINIMUM(timeout_secs, (int)minwait_secs);\n\tif (timeout_secs == INT_MAX)\n\t\ttvp = NULL;\n\telse {\n\t\ttv.tv_sec = timeout_secs;\n\t\ttv.tv_usec = 0;\n\t\ttvp = &tv;\n\t}\n\n\tret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);\n\tif (ret < 0) {\n\t\t/*\n\t\t * We have to clear the select masks, because we return.\n\t\t * We have to return, because the mainloop checks for the flags\n\t\t * set by the signal handlers.\n\t\t */\n\t\tmemset(*readsetp, 0, *nallocp);\n\t\tmemset(*writesetp, 0, *nallocp);\n\n\t\tif (errno == EINTR)\n\t\t\treturn;\n\t\t/* Note: we might still have data in the buffers. */\n\t\tif ((r = sshbuf_putf(stderr_buffer,\n\t\t    \"select: %s\\r\\n\", strerror(errno))) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tquit_pending = 1;\n\t} else if (ret == 0) {\n\t\t/*\n\t\t * Timeout.  Could have been either keepalive or rekeying.\n\t\t * Keepalive we check here, rekeying is checked in clientloop.\n\t\t */\n\t\tif (server_alive_time != 0 && server_alive_time <= monotime())\n\t\t\tserver_alive_check();\n\t}\n\n}"
  },
  {
    "function_name": "server_alive_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "482-495",
    "snippet": "static void\nserver_alive_check(void)\n{\n\tif (packet_inc_alive_timeouts() > options.server_alive_count_max) {\n\t\tlogit(\"Timeout, server %s not responding.\", host);\n\t\tcleanup_exit(255);\n\t}\n\tpacket_start(SSH2_MSG_GLOBAL_REQUEST);\n\tpacket_put_cstring(\"keepalive@openssh.com\");\n\tpacket_put_char(1);     /* boolean: want reply */\n\tpacket_send();\n\t/* Insert an empty placeholder to maintain ordering */\n\tclient_register_global_confirm(NULL, NULL);\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "extern char *host;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "client_register_global_confirm",
          "args": [
            "NULL",
            "NULL"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "client_register_global_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "747-766",
          "snippet": "void\nclient_register_global_confirm(global_confirm_cb *cb, void *ctx)\n{\n\tstruct global_confirm *gc, *last_gc;\n\n\t/* Coalesce identical callbacks */\n\tlast_gc = TAILQ_LAST(&global_confirms, global_confirms);\n\tif (last_gc && last_gc->cb == cb && last_gc->ctx == ctx) {\n\t\tif (++last_gc->ref_count >= INT_MAX)\n\t\t\tfatal(\"%s: last_gc->ref_count = %d\",\n\t\t\t    __func__, last_gc->ref_count);\n\t\treturn;\n\t}\n\n\tgc = xcalloc(1, sizeof(*gc));\n\tgc->cb = cb;\n\tgc->ctx = ctx;\n\tgc->ref_count = 1;\n\tTAILQ_INSERT_TAIL(&global_confirms, gc, entry);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct global_confirms global_confirms =\n    TAILQ_HEAD_INITIALIZER(global_confirms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct global_confirms global_confirms =\n    TAILQ_HEAD_INITIALIZER(global_confirms);\n\nvoid\nclient_register_global_confirm(global_confirm_cb *cb, void *ctx)\n{\n\tstruct global_confirm *gc, *last_gc;\n\n\t/* Coalesce identical callbacks */\n\tlast_gc = TAILQ_LAST(&global_confirms, global_confirms);\n\tif (last_gc && last_gc->cb == cb && last_gc->ctx == ctx) {\n\t\tif (++last_gc->ref_count >= INT_MAX)\n\t\t\tfatal(\"%s: last_gc->ref_count = %d\",\n\t\t\t    __func__, last_gc->ref_count);\n\t\treturn;\n\t}\n\n\tgc = xcalloc(1, sizeof(*gc));\n\tgc->cb = cb;\n\tgc->ctx = ctx;\n\tgc->ref_count = 1;\n\tTAILQ_INSERT_TAIL(&global_confirms, gc, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_char",
          "args": [
            "1"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "\"keepalive@openssh.com\""
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_start",
          "args": [
            "SSH2_MSG_GLOBAL_REQUEST"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleanup_exit",
          "args": [
            "255"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "2349-2358",
          "snippet": "void\ncleanup_exit(int i)\n{\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\tleave_non_blocking();\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\tssh_kill_proxy_command();\n\t_exit(i);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "extern int muxserver_sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nextern int muxserver_sock;\n\nvoid\ncleanup_exit(int i)\n{\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\tleave_non_blocking();\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\tssh_kill_proxy_command();\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Timeout, server %s not responding.\"",
            "host"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_inc_alive_timeouts",
          "args": [],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nextern char *host;\n\nstatic void\nserver_alive_check(void)\n{\n\tif (packet_inc_alive_timeouts() > options.server_alive_count_max) {\n\t\tlogit(\"Timeout, server %s not responding.\", host);\n\t\tcleanup_exit(255);\n\t}\n\tpacket_start(SSH2_MSG_GLOBAL_REQUEST);\n\tpacket_put_cstring(\"keepalive@openssh.com\");\n\tpacket_put_char(1);     /* boolean: want reply */\n\tpacket_send();\n\t/* Insert an empty placeholder to maintain ordering */\n\tclient_register_global_confirm(NULL, NULL);\n}"
  },
  {
    "function_name": "client_global_request_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "463-480",
    "snippet": "static int\nclient_global_request_reply(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct global_confirm *gc;\n\n\tif ((gc = TAILQ_FIRST(&global_confirms)) == NULL)\n\t\treturn 0;\n\tif (gc->cb != NULL)\n\t\tgc->cb(ssh, type, seq, gc->ctx);\n\tif (--gc->ref_count <= 0) {\n\t\tTAILQ_REMOVE(&global_confirms, gc, entry);\n\t\texplicit_bzero(gc, sizeof(*gc));\n\t\tfree(gc);\n\t}\n\n\tpacket_set_alive_timeouts(0);\n\treturn 0;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct global_confirms global_confirms =\n    TAILQ_HEAD_INITIALIZER(global_confirms);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "packet_set_alive_timeouts",
          "args": [
            "0"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "gc"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "gc",
            "sizeof(*gc)"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&global_confirms",
            "gc",
            "entry"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gc->cb",
          "args": [
            "ssh",
            "type",
            "seq",
            "gc->ctx"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&global_confirms"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct global_confirms global_confirms =\n    TAILQ_HEAD_INITIALIZER(global_confirms);\n\nstatic int\nclient_global_request_reply(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct global_confirm *gc;\n\n\tif ((gc = TAILQ_FIRST(&global_confirms)) == NULL)\n\t\treturn 0;\n\tif (gc->cb != NULL)\n\t\tgc->cb(ssh, type, seq, gc->ctx);\n\tif (--gc->ref_count <= 0) {\n\t\tTAILQ_REMOVE(&global_confirms, gc, entry);\n\t\texplicit_bzero(gc, sizeof(*gc));\n\t\tfree(gc);\n\t}\n\n\tpacket_set_alive_timeouts(0);\n\treturn 0;\n}"
  },
  {
    "function_name": "client_check_window_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "450-461",
    "snippet": "static void\nclient_check_window_change(struct ssh *ssh)\n{\n\tif (!received_window_change_signal)\n\t\treturn;\n\t/** XXX race */\n\treceived_window_change_signal = 0;\n\n\tdebug2(\"%s: changed\", __func__);\n\n\tchannel_send_window_changes(ssh);\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile sig_atomic_t received_window_change_signal = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_send_window_changes",
          "args": [
            "ssh"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "channel_send_window_changes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4456-4479",
          "snippet": "void\nchannel_send_window_changes(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct winsize ws;\n\tint r;\n\tu_int i;\n\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL || !sc->channels[i]->client_tty ||\n\t\t    sc->channels[i]->type != SSH_CHANNEL_OPEN)\n\t\t\tcontinue;\n\t\tif (ioctl(sc->channels[i]->rfd, TIOCGWINSZ, &ws) < 0)\n\t\t\tcontinue;\n\t\tchannel_request_start(ssh, i, \"window-change\", 0);\n\t\tif ((r = sshpkt_put_u32(ssh, (u_int)ws.ws_col)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_row)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_xpixel)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_ypixel)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal(\"%s: channel %u: send window-change: %s\",\n\t\t\t    __func__, i, ssh_err(r));\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_send_window_changes(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct winsize ws;\n\tint r;\n\tu_int i;\n\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL || !sc->channels[i]->client_tty ||\n\t\t    sc->channels[i]->type != SSH_CHANNEL_OPEN)\n\t\t\tcontinue;\n\t\tif (ioctl(sc->channels[i]->rfd, TIOCGWINSZ, &ws) < 0)\n\t\t\tcontinue;\n\t\tchannel_request_start(ssh, i, \"window-change\", 0);\n\t\tif ((r = sshpkt_put_u32(ssh, (u_int)ws.ws_col)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_row)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_xpixel)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_ypixel)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal(\"%s: channel %u: send window-change: %s\",\n\t\t\t    __func__, i, ssh_err(r));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: changed\"",
            "__func__"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t received_window_change_signal = 0;\n\nstatic void\nclient_check_window_change(struct ssh *ssh)\n{\n\tif (!received_window_change_signal)\n\t\treturn;\n\t/** XXX race */\n\treceived_window_change_signal = 0;\n\n\tdebug2(\"%s: changed\", __func__);\n\n\tchannel_send_window_changes(ssh);\n}"
  },
  {
    "function_name": "client_x11_get_proto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "277-441",
    "snippet": "int\nclient_x11_get_proto(struct ssh *ssh, const char *display,\n    const char *xauth_path, u_int trusted, u_int timeout,\n    char **_proto, char **_data)\n{\n\tchar *cmd, line[512], xdisplay[512];\n\tchar xauthfile[PATH_MAX], xauthdir[PATH_MAX];\n\tstatic char proto[512], data[512];\n\tFILE *f;\n\tint got_data = 0, generated = 0, do_unlink = 0, r;\n\tstruct stat st;\n\tu_int now, x11_timeout_real;\n\n\t*_proto = proto;\n\t*_data = data;\n\tproto[0] = data[0] = xauthfile[0] = xauthdir[0] = '\\0';\n\n\tif (!client_x11_display_valid(display)) {\n\t\tif (display != NULL)\n\t\t\tlogit(\"DISPLAY \\\"%s\\\" invalid; disabling X11 forwarding\",\n\t\t\t    display);\n\t\treturn -1;\n\t}\n\tif (xauth_path != NULL && stat(xauth_path, &st) == -1) {\n\t\tdebug(\"No xauth program.\");\n\t\txauth_path = NULL;\n\t}\n\n\tif (xauth_path != NULL) {\n\t\t/*\n\t\t * Handle FamilyLocal case where $DISPLAY does\n\t\t * not match an authorization entry.  For this we\n\t\t * just try \"xauth list unix:displaynum.screennum\".\n\t\t * XXX: \"localhost\" match to determine FamilyLocal\n\t\t *      is not perfect.\n\t\t */\n\t\tif (strncmp(display, \"localhost:\", 10) == 0) {\n\t\t\tif ((r = snprintf(xdisplay, sizeof(xdisplay), \"unix:%s\",\n\t\t\t    display + 10)) < 0 ||\n\t\t\t    (size_t)r >= sizeof(xdisplay)) {\n\t\t\t\terror(\"%s: display name too long\", __func__);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdisplay = xdisplay;\n\t\t}\n\t\tif (trusted == 0) {\n\t\t\t/*\n\t\t\t * Generate an untrusted X11 auth cookie.\n\t\t\t *\n\t\t\t * The authentication cookie should briefly outlive\n\t\t\t * ssh's willingness to forward X11 connections to\n\t\t\t * avoid nasty fail-open behaviour in the X server.\n\t\t\t */\n\t\t\tmktemp_proto(xauthdir, sizeof(xauthdir));\n\t\t\tif (mkdtemp(xauthdir) == NULL) {\n\t\t\t\terror(\"%s: mkdtemp: %s\",\n\t\t\t\t    __func__, strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdo_unlink = 1;\n\t\t\tif ((r = snprintf(xauthfile, sizeof(xauthfile),\n\t\t\t    \"%s/xauthfile\", xauthdir)) < 0 ||\n\t\t\t    (size_t)r >= sizeof(xauthfile)) {\n\t\t\t\terror(\"%s: xauthfile path too long\", __func__);\n\t\t\t\tunlink(xauthfile);\n\t\t\t\trmdir(xauthdir);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (timeout == 0) {\n\t\t\t\t/* auth doesn't time out */\n\t\t\t\txasprintf(&cmd, \"%s -f %s generate %s %s \"\n\t\t\t\t    \"untrusted 2>%s\",\n\t\t\t\t    xauth_path, xauthfile, display,\n\t\t\t\t    SSH_X11_PROTO, _PATH_DEVNULL);\n\t\t\t} else {\n\t\t\t\t/* Add some slack to requested expiry */\n\t\t\t\tif (timeout < UINT_MAX - X11_TIMEOUT_SLACK)\n\t\t\t\t\tx11_timeout_real = timeout +\n\t\t\t\t\t    X11_TIMEOUT_SLACK;\n\t\t\t\telse {\n\t\t\t\t\t/* Don't overflow on long timeouts */\n\t\t\t\t\tx11_timeout_real = UINT_MAX;\n\t\t\t\t}\n\t\t\t\txasprintf(&cmd, \"%s -f %s generate %s %s \"\n\t\t\t\t    \"untrusted timeout %u 2>%s\",\n\t\t\t\t    xauth_path, xauthfile, display,\n\t\t\t\t    SSH_X11_PROTO, x11_timeout_real,\n\t\t\t\t    _PATH_DEVNULL);\n\t\t\t}\n\t\t\tdebug2(\"%s: %s\", __func__, cmd);\n\n\t\t\tif (timeout != 0 && x11_refuse_time == 0) {\n\t\t\t\tnow = monotime() + 1;\n\t\t\t\tif (UINT_MAX - timeout < now)\n\t\t\t\t\tx11_refuse_time = UINT_MAX;\n\t\t\t\telse\n\t\t\t\t\tx11_refuse_time = now + timeout;\n\t\t\t\tchannel_set_x11_refuse_time(ssh,\n\t\t\t\t    x11_refuse_time);\n\t\t\t}\n\t\t\tif (system(cmd) == 0)\n\t\t\t\tgenerated = 1;\n\t\t\tfree(cmd);\n\t\t}\n\n\t\t/*\n\t\t * When in untrusted mode, we read the cookie only if it was\n\t\t * successfully generated as an untrusted one in the step\n\t\t * above.\n\t\t */\n\t\tif (trusted || generated) {\n\t\t\txasprintf(&cmd,\n\t\t\t    \"%s %s%s list %s 2>\" _PATH_DEVNULL,\n\t\t\t    xauth_path,\n\t\t\t    generated ? \"-f \" : \"\" ,\n\t\t\t    generated ? xauthfile : \"\",\n\t\t\t    display);\n\t\t\tdebug2(\"x11_get_proto: %s\", cmd);\n\t\t\tf = popen(cmd, \"r\");\n\t\t\tif (f && fgets(line, sizeof(line), f) &&\n\t\t\t    sscanf(line, \"%*s %511s %511s\", proto, data) == 2)\n\t\t\t\tgot_data = 1;\n\t\t\tif (f)\n\t\t\t\tpclose(f);\n\t\t\tfree(cmd);\n\t\t}\n\t}\n\n\tif (do_unlink) {\n\t\tunlink(xauthfile);\n\t\trmdir(xauthdir);\n\t}\n\n\t/* Don't fall back to fake X11 data for untrusted forwarding */\n\tif (!trusted && !got_data) {\n\t\terror(\"Warning: untrusted X11 forwarding setup failed: \"\n\t\t    \"xauth key data not generated\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * If we didn't get authentication data, just make up some\n\t * data.  The forwarding code will check the validity of the\n\t * response anyway, and substitute this data.  The X11\n\t * server, however, will ignore this fake data and use\n\t * whatever authentication mechanisms it was using otherwise\n\t * for the local connection.\n\t */\n\tif (!got_data) {\n\t\tu_int8_t rnd[16];\n\t\tu_int i;\n\n\t\tlogit(\"Warning: No xauth data; \"\n\t\t    \"using fake authentication data for X11 forwarding.\");\n\t\tstrlcpy(proto, SSH_X11_PROTO, sizeof proto);\n\t\tarc4random_buf(rnd, sizeof(rnd));\n\t\tfor (i = 0; i < sizeof(rnd); i++) {\n\t\t\tsnprintf(data + 2 * i, sizeof data - 2 * i, \"%02x\",\n\t\t\t    rnd[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define X11_TIMEOUT_SLACK\t60",
      "#define SSH_X11_PROTO\t\t\"MIT-MAGIC-COOKIE-1\""
    ],
    "globals_used": [
      "static u_int x11_refuse_time;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "data + 2 * i",
            "sizeof data - 2 * i",
            "\"%02x\"",
            "rnd[i]"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arc4random_buf",
          "args": [
            "rnd",
            "sizeof(rnd)"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "263-277",
          "snippet": "void\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "proto",
            "SSH_X11_PROTO",
            "sizeof proto"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Warning: No xauth data; \"\n\t\t    \"using fake authentication data for X11 forwarding.\""
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Warning: untrusted X11 forwarding setup failed: \"\n\t\t    \"xauth key data not generated\""
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "xauthdir"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "process_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1128-1143",
          "snippet": "static void\nprocess_rmdir(u_int32_t id)\n{\n\tchar *name;\n\tint r, status;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: rmdir\", id);\n\tlogit(\"rmdir name \\\"%s\\\"\", name);\n\tr = rmdir(name);\n\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\tsend_status(id, status);\n\tfree(name);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct sshbuf *iqueue;",
            "static void process_open(u_int32_t id);",
            "static void process_close(u_int32_t id);",
            "static void process_read(u_int32_t id);",
            "static void process_write(u_int32_t id);",
            "static void process_stat(u_int32_t id);",
            "static void process_lstat(u_int32_t id);",
            "static void process_fstat(u_int32_t id);",
            "static void process_setstat(u_int32_t id);",
            "static void process_fsetstat(u_int32_t id);",
            "static void process_opendir(u_int32_t id);",
            "static void process_readdir(u_int32_t id);",
            "static void process_remove(u_int32_t id);",
            "static void process_mkdir(u_int32_t id);",
            "static void process_rmdir(u_int32_t id);",
            "static void process_realpath(u_int32_t id);",
            "static void process_rename(u_int32_t id);",
            "static void process_readlink(u_int32_t id);",
            "static void process_symlink(u_int32_t id);",
            "static void process_extended_posix_rename(u_int32_t id);",
            "static void process_extended_statvfs(u_int32_t id);",
            "static void process_extended_fstatvfs(u_int32_t id);",
            "static void process_extended_hardlink(u_int32_t id);",
            "static void process_extended_fsync(u_int32_t id);",
            "static void process_extended(u_int32_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *iqueue;\nstatic void process_open(u_int32_t id);\nstatic void process_close(u_int32_t id);\nstatic void process_read(u_int32_t id);\nstatic void process_write(u_int32_t id);\nstatic void process_stat(u_int32_t id);\nstatic void process_lstat(u_int32_t id);\nstatic void process_fstat(u_int32_t id);\nstatic void process_setstat(u_int32_t id);\nstatic void process_fsetstat(u_int32_t id);\nstatic void process_opendir(u_int32_t id);\nstatic void process_readdir(u_int32_t id);\nstatic void process_remove(u_int32_t id);\nstatic void process_mkdir(u_int32_t id);\nstatic void process_rmdir(u_int32_t id);\nstatic void process_realpath(u_int32_t id);\nstatic void process_rename(u_int32_t id);\nstatic void process_readlink(u_int32_t id);\nstatic void process_symlink(u_int32_t id);\nstatic void process_extended_posix_rename(u_int32_t id);\nstatic void process_extended_statvfs(u_int32_t id);\nstatic void process_extended_fstatvfs(u_int32_t id);\nstatic void process_extended_hardlink(u_int32_t id);\nstatic void process_extended_fsync(u_int32_t id);\nstatic void process_extended(u_int32_t id);\n\nstatic void\nprocess_rmdir(u_int32_t id)\n{\n\tchar *name;\n\tint r, status;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: rmdir\", id);\n\tlogit(\"rmdir name \\\"%s\\\"\", name);\n\tr = rmdir(name);\n\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\tsend_status(id, status);\n\tfree(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "xauthfile"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cmd"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_update_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "1796-1813",
          "snippet": "static void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_seen);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "f"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "line",
            "\"%*s %511s %511s\"",
            "proto",
            "data"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "f"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "cmd",
            "\"r\""
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"x11_get_proto: %s\"",
            "cmd"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&cmd",
            "\"%s %s%s list %s 2>\" _PATH_DEVNULL",
            "xauth_path",
            "generated ? \"-f \" : \"\"",
            "generated ? xauthfile : \"\"",
            "display"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_set_x11_refuse_time",
          "args": [
            "ssh",
            "x11_refuse_time"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "channel_set_x11_refuse_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1757-1761",
          "snippet": "void\nchannel_set_x11_refuse_time(struct ssh *ssh, u_int refuse_time)\n{\n\tssh->chanctxt->x11_refuse_time = refuse_time;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_set_x11_refuse_time(struct ssh *ssh, u_int refuse_time)\n{\n\tssh->chanctxt->x11_refuse_time = refuse_time;\n}"
        }
      },
      {
        "call_info": {
          "callee": "monotime",
          "args": [],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "monotime_double",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1324-1331",
          "snippet": "double\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\ndouble\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "xauthfile"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdtemp",
          "args": [
            "xauthdir"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "mkdtemp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
          "lines": "132-139",
          "snippet": "char *\nmkdtemp(char *path)\n{\n\tint error;\n\n\terror = mktemp_internal(path, 0, MKTEMP_DIR);\n\treturn(error ? NULL : path);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MKTEMP_DIR\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MKTEMP_DIR\t2\n\nchar *\nmkdtemp(char *path)\n{\n\tint error;\n\n\terror = mktemp_internal(path, 0, MKTEMP_DIR);\n\treturn(error ? NULL : path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mktemp_proto",
          "args": [
            "xauthdir",
            "sizeof(xauthdir)"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "mktemp_proto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1398-1412",
          "snippet": "void\nmktemp_proto(char *s, size_t len)\n{\n\tconst char *tmpdir;\n\tint r;\n\n\tif ((tmpdir = getenv(\"TMPDIR\")) != NULL) {\n\t\tr = snprintf(s, len, \"%s/ssh-XXXXXXXXXXXX\", tmpdir);\n\t\tif (r > 0 && (size_t)r < len)\n\t\t\treturn;\n\t}\n\tr = snprintf(s, len, \"/tmp/ssh-XXXXXXXXXXXX\");\n\tif (r < 0 || (size_t)r >= len)\n\t\tfatal(\"%s: template string too short\", __func__);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmktemp_proto(char *s, size_t len)\n{\n\tconst char *tmpdir;\n\tint r;\n\n\tif ((tmpdir = getenv(\"TMPDIR\")) != NULL) {\n\t\tr = snprintf(s, len, \"%s/ssh-XXXXXXXXXXXX\", tmpdir);\n\t\tif (r > 0 && (size_t)r < len)\n\t\t\treturn;\n\t}\n\tr = snprintf(s, len, \"/tmp/ssh-XXXXXXXXXXXX\");\n\tif (r < 0 || (size_t)r >= len)\n\t\tfatal(\"%s: template string too short\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "display",
            "\"localhost:\"",
            "10"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"No xauth program.\""
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "xauth_path",
            "&st"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_x11_display_valid",
          "args": [
            "display"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "client_x11_display_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
          "lines": "256-273",
          "snippet": "static int\nclient_x11_display_valid(const char *display)\n{\n\tsize_t i, dlen;\n\n\tif (display == NULL)\n\t\treturn 0;\n\n\tdlen = strlen(display);\n\tfor (i = 0; i < dlen; i++) {\n\t\tif (!isalnum((u_char)display[i]) &&\n\t\t    strchr(SSH_X11_VALID_DISPLAY_CHARS, display[i]) == NULL) {\n\t\t\tdebug(\"Invalid character '%c' in DISPLAY\", display[i]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"msg.h\"",
            "#include \"match.h\"",
            "#include \"sshpty.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshconnect.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"dispatch.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SSH_X11_VALID_DISPLAY_CHARS \":/.-_\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SSH_X11_VALID_DISPLAY_CHARS \":/.-_\"\n\nstatic int\nclient_x11_display_valid(const char *display)\n{\n\tsize_t i, dlen;\n\n\tif (display == NULL)\n\t\treturn 0;\n\n\tdlen = strlen(display);\n\tfor (i = 0; i < dlen; i++) {\n\t\tif (!isalnum((u_char)display[i]) &&\n\t\t    strchr(SSH_X11_VALID_DISPLAY_CHARS, display[i]) == NULL) {\n\t\t\tdebug(\"Invalid character '%c' in DISPLAY\", display[i]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define X11_TIMEOUT_SLACK\t60\n#define SSH_X11_PROTO\t\t\"MIT-MAGIC-COOKIE-1\"\n\nstatic u_int x11_refuse_time;\n\nint\nclient_x11_get_proto(struct ssh *ssh, const char *display,\n    const char *xauth_path, u_int trusted, u_int timeout,\n    char **_proto, char **_data)\n{\n\tchar *cmd, line[512], xdisplay[512];\n\tchar xauthfile[PATH_MAX], xauthdir[PATH_MAX];\n\tstatic char proto[512], data[512];\n\tFILE *f;\n\tint got_data = 0, generated = 0, do_unlink = 0, r;\n\tstruct stat st;\n\tu_int now, x11_timeout_real;\n\n\t*_proto = proto;\n\t*_data = data;\n\tproto[0] = data[0] = xauthfile[0] = xauthdir[0] = '\\0';\n\n\tif (!client_x11_display_valid(display)) {\n\t\tif (display != NULL)\n\t\t\tlogit(\"DISPLAY \\\"%s\\\" invalid; disabling X11 forwarding\",\n\t\t\t    display);\n\t\treturn -1;\n\t}\n\tif (xauth_path != NULL && stat(xauth_path, &st) == -1) {\n\t\tdebug(\"No xauth program.\");\n\t\txauth_path = NULL;\n\t}\n\n\tif (xauth_path != NULL) {\n\t\t/*\n\t\t * Handle FamilyLocal case where $DISPLAY does\n\t\t * not match an authorization entry.  For this we\n\t\t * just try \"xauth list unix:displaynum.screennum\".\n\t\t * XXX: \"localhost\" match to determine FamilyLocal\n\t\t *      is not perfect.\n\t\t */\n\t\tif (strncmp(display, \"localhost:\", 10) == 0) {\n\t\t\tif ((r = snprintf(xdisplay, sizeof(xdisplay), \"unix:%s\",\n\t\t\t    display + 10)) < 0 ||\n\t\t\t    (size_t)r >= sizeof(xdisplay)) {\n\t\t\t\terror(\"%s: display name too long\", __func__);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdisplay = xdisplay;\n\t\t}\n\t\tif (trusted == 0) {\n\t\t\t/*\n\t\t\t * Generate an untrusted X11 auth cookie.\n\t\t\t *\n\t\t\t * The authentication cookie should briefly outlive\n\t\t\t * ssh's willingness to forward X11 connections to\n\t\t\t * avoid nasty fail-open behaviour in the X server.\n\t\t\t */\n\t\t\tmktemp_proto(xauthdir, sizeof(xauthdir));\n\t\t\tif (mkdtemp(xauthdir) == NULL) {\n\t\t\t\terror(\"%s: mkdtemp: %s\",\n\t\t\t\t    __func__, strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdo_unlink = 1;\n\t\t\tif ((r = snprintf(xauthfile, sizeof(xauthfile),\n\t\t\t    \"%s/xauthfile\", xauthdir)) < 0 ||\n\t\t\t    (size_t)r >= sizeof(xauthfile)) {\n\t\t\t\terror(\"%s: xauthfile path too long\", __func__);\n\t\t\t\tunlink(xauthfile);\n\t\t\t\trmdir(xauthdir);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (timeout == 0) {\n\t\t\t\t/* auth doesn't time out */\n\t\t\t\txasprintf(&cmd, \"%s -f %s generate %s %s \"\n\t\t\t\t    \"untrusted 2>%s\",\n\t\t\t\t    xauth_path, xauthfile, display,\n\t\t\t\t    SSH_X11_PROTO, _PATH_DEVNULL);\n\t\t\t} else {\n\t\t\t\t/* Add some slack to requested expiry */\n\t\t\t\tif (timeout < UINT_MAX - X11_TIMEOUT_SLACK)\n\t\t\t\t\tx11_timeout_real = timeout +\n\t\t\t\t\t    X11_TIMEOUT_SLACK;\n\t\t\t\telse {\n\t\t\t\t\t/* Don't overflow on long timeouts */\n\t\t\t\t\tx11_timeout_real = UINT_MAX;\n\t\t\t\t}\n\t\t\t\txasprintf(&cmd, \"%s -f %s generate %s %s \"\n\t\t\t\t    \"untrusted timeout %u 2>%s\",\n\t\t\t\t    xauth_path, xauthfile, display,\n\t\t\t\t    SSH_X11_PROTO, x11_timeout_real,\n\t\t\t\t    _PATH_DEVNULL);\n\t\t\t}\n\t\t\tdebug2(\"%s: %s\", __func__, cmd);\n\n\t\t\tif (timeout != 0 && x11_refuse_time == 0) {\n\t\t\t\tnow = monotime() + 1;\n\t\t\t\tif (UINT_MAX - timeout < now)\n\t\t\t\t\tx11_refuse_time = UINT_MAX;\n\t\t\t\telse\n\t\t\t\t\tx11_refuse_time = now + timeout;\n\t\t\t\tchannel_set_x11_refuse_time(ssh,\n\t\t\t\t    x11_refuse_time);\n\t\t\t}\n\t\t\tif (system(cmd) == 0)\n\t\t\t\tgenerated = 1;\n\t\t\tfree(cmd);\n\t\t}\n\n\t\t/*\n\t\t * When in untrusted mode, we read the cookie only if it was\n\t\t * successfully generated as an untrusted one in the step\n\t\t * above.\n\t\t */\n\t\tif (trusted || generated) {\n\t\t\txasprintf(&cmd,\n\t\t\t    \"%s %s%s list %s 2>\" _PATH_DEVNULL,\n\t\t\t    xauth_path,\n\t\t\t    generated ? \"-f \" : \"\" ,\n\t\t\t    generated ? xauthfile : \"\",\n\t\t\t    display);\n\t\t\tdebug2(\"x11_get_proto: %s\", cmd);\n\t\t\tf = popen(cmd, \"r\");\n\t\t\tif (f && fgets(line, sizeof(line), f) &&\n\t\t\t    sscanf(line, \"%*s %511s %511s\", proto, data) == 2)\n\t\t\t\tgot_data = 1;\n\t\t\tif (f)\n\t\t\t\tpclose(f);\n\t\t\tfree(cmd);\n\t\t}\n\t}\n\n\tif (do_unlink) {\n\t\tunlink(xauthfile);\n\t\trmdir(xauthdir);\n\t}\n\n\t/* Don't fall back to fake X11 data for untrusted forwarding */\n\tif (!trusted && !got_data) {\n\t\terror(\"Warning: untrusted X11 forwarding setup failed: \"\n\t\t    \"xauth key data not generated\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * If we didn't get authentication data, just make up some\n\t * data.  The forwarding code will check the validity of the\n\t * response anyway, and substitute this data.  The X11\n\t * server, however, will ignore this fake data and use\n\t * whatever authentication mechanisms it was using otherwise\n\t * for the local connection.\n\t */\n\tif (!got_data) {\n\t\tu_int8_t rnd[16];\n\t\tu_int i;\n\n\t\tlogit(\"Warning: No xauth data; \"\n\t\t    \"using fake authentication data for X11 forwarding.\");\n\t\tstrlcpy(proto, SSH_X11_PROTO, sizeof proto);\n\t\tarc4random_buf(rnd, sizeof(rnd));\n\t\tfor (i = 0; i < sizeof(rnd); i++) {\n\t\t\tsnprintf(data + 2 * i, sizeof data - 2 * i, \"%02x\",\n\t\t\t    rnd[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "client_x11_display_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "256-273",
    "snippet": "static int\nclient_x11_display_valid(const char *display)\n{\n\tsize_t i, dlen;\n\n\tif (display == NULL)\n\t\treturn 0;\n\n\tdlen = strlen(display);\n\tfor (i = 0; i < dlen; i++) {\n\t\tif (!isalnum((u_char)display[i]) &&\n\t\t    strchr(SSH_X11_VALID_DISPLAY_CHARS, display[i]) == NULL) {\n\t\t\tdebug(\"Invalid character '%c' in DISPLAY\", display[i]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SSH_X11_VALID_DISPLAY_CHARS \":/.-_\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Invalid character '%c' in DISPLAY\"",
            "display[i]"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "SSH_X11_VALID_DISPLAY_CHARS",
            "display[i]"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "(u_char)display[i]"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "display"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SSH_X11_VALID_DISPLAY_CHARS \":/.-_\"\n\nstatic int\nclient_x11_display_valid(const char *display)\n{\n\tsize_t i, dlen;\n\n\tif (display == NULL)\n\t\treturn 0;\n\n\tdlen = strlen(display);\n\tfor (i = 0; i < dlen; i++) {\n\t\tif (!isalnum((u_char)display[i]) &&\n\t\t    strchr(SSH_X11_VALID_DISPLAY_CHARS, display[i]) == NULL) {\n\t\t\tdebug(\"Invalid character '%c' in DISPLAY\", display[i]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "set_control_persist_exit_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "233-253",
    "snippet": "static void\nset_control_persist_exit_time(struct ssh *ssh)\n{\n\tif (muxserver_sock == -1 || !options.control_persist\n\t    || options.control_persist_timeout == 0) {\n\t\t/* not using a ControlPersist timeout */\n\t\tcontrol_persist_exit_time = 0;\n\t} else if (channel_still_open(ssh)) {\n\t\t/* some client connections are still open */\n\t\tif (control_persist_exit_time > 0)\n\t\t\tdebug2(\"%s: cancel scheduled exit\", __func__);\n\t\tcontrol_persist_exit_time = 0;\n\t} else if (control_persist_exit_time <= 0) {\n\t\t/* a client connection has recently closed */\n\t\tcontrol_persist_exit_time = monotime() +\n\t\t\t(time_t)options.control_persist_timeout;\n\t\tdebug2(\"%s: schedule exit in %d seconds\", __func__,\n\t\t    options.control_persist_timeout);\n\t}\n\t/* else we are already counting down to the timeout */\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "extern int muxserver_sock;",
      "static time_t control_persist_exit_time = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: schedule exit in %d seconds\"",
            "__func__",
            "options.control_persist_timeout"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "monotime",
          "args": [],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "monotime_double",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1324-1331",
          "snippet": "double\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\ndouble\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_still_open",
          "args": [
            "ssh"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "channel_still_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "718-758",
          "snippet": "int\nchannel_still_open(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tfatal(\"%s: bad channel type %d\", __func__, c->type);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_still_open(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tfatal(\"%s: bad channel type %d\", __func__, c->type);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nextern int muxserver_sock;\nstatic time_t control_persist_exit_time = 0;\n\nstatic void\nset_control_persist_exit_time(struct ssh *ssh)\n{\n\tif (muxserver_sock == -1 || !options.control_persist\n\t    || options.control_persist_timeout == 0) {\n\t\t/* not using a ControlPersist timeout */\n\t\tcontrol_persist_exit_time = 0;\n\t} else if (channel_still_open(ssh)) {\n\t\t/* some client connections are still open */\n\t\tif (control_persist_exit_time > 0)\n\t\t\tdebug2(\"%s: cancel scheduled exit\", __func__);\n\t\tcontrol_persist_exit_time = 0;\n\t} else if (control_persist_exit_time <= 0) {\n\t\t/* a client connection has recently closed */\n\t\tcontrol_persist_exit_time = monotime() +\n\t\t\t(time_t)options.control_persist_timeout;\n\t\tdebug2(\"%s: schedule exit in %d seconds\", __func__,\n\t\t    options.control_persist_timeout);\n\t}\n\t/* else we are already counting down to the timeout */\n}"
  },
  {
    "function_name": "signal_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "220-225",
    "snippet": "static void\nsignal_handler(int sig)\n{\n\treceived_signal = sig;\n\tquit_pending = 1;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile sig_atomic_t received_signal = 0;",
      "volatile sig_atomic_t quit_pending;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t received_signal = 0;\nvolatile sig_atomic_t quit_pending;\n\nstatic void\nsignal_handler(int sig)\n{\n\treceived_signal = sig;\n\tquit_pending = 1;\n}"
  },
  {
    "function_name": "window_change_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "209-213",
    "snippet": "static void\nwindow_change_handler(int sig)\n{\n\treceived_window_change_signal = 1;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile sig_atomic_t received_window_change_signal = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t received_window_change_signal = 0;\n\nstatic void\nwindow_change_handler(int sig)\n{\n\treceived_window_change_signal = 1;\n}"
  },
  {
    "function_name": "leave_non_blocking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/clientloop.c",
    "lines": "195-202",
    "snippet": "static void\nleave_non_blocking(void)\n{\n\tif (in_non_blocking_mode) {\n\t\tunset_nonblock(fileno(stdin));\n\t\tin_non_blocking_mode = 0;\n\t}\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"msg.h\"",
      "#include \"match.h\"",
      "#include \"sshpty.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshconnect.h\"",
      "#include \"clientloop.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"dispatch.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int in_non_blocking_mode = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unset_nonblock",
          "args": [
            "fileno(stdin)"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "unset_nonblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "116-138",
          "snippet": "int\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"msg.h\"\n#include \"match.h\"\n#include \"sshpty.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshconnect.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int in_non_blocking_mode = 0;\n\nstatic void\nleave_non_blocking(void)\n{\n\tif (in_non_blocking_mode) {\n\t\tunset_nonblock(fileno(stdin));\n\t\tin_non_blocking_mode = 0;\n\t}\n}"
  }
]