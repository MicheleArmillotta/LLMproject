[
  {
    "function_name": "dirname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/dirname.c",
    "lines": "28-71",
    "snippet": "char *\ndirname(const char *path)\n{\n\tstatic char dname[MAXPATHLEN];\n\tsize_t len;\n\tconst char *endp;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tdname[0] = '.';\n\t\tdname[1] = '\\0';\n\t\treturn (dname);\n\t}\n\n\t/* Strip any trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tdname[0] = *endp == '/' ? '/' : '.';\n\t\tdname[1] = '\\0';\n\t\treturn (dname);\n\t} else {\n\t\t/* Move forward past the separating slashes */\n\t\tdo {\n\t\t\tendp--;\n\t\t} while (endp > path && *endp == '/');\n\t}\n\n\tlen = endp - path + 1;\n\tif (len >= sizeof(dname)) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn (NULL);\n\t}\n\tmemcpy(dname, path, len);\n\tdname[len] = '\\0';\n\treturn (dname);\n}",
    "includes": [
      "#include <sys/param.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dname",
            "path",
            "len"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/param.h>\n#include <string.h>\n#include <errno.h>\n#include \"includes.h\"\n\nchar *\ndirname(const char *path)\n{\n\tstatic char dname[MAXPATHLEN];\n\tsize_t len;\n\tconst char *endp;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tdname[0] = '.';\n\t\tdname[1] = '\\0';\n\t\treturn (dname);\n\t}\n\n\t/* Strip any trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tdname[0] = *endp == '/' ? '/' : '.';\n\t\tdname[1] = '\\0';\n\t\treturn (dname);\n\t} else {\n\t\t/* Move forward past the separating slashes */\n\t\tdo {\n\t\t\tendp--;\n\t\t} while (endp > path && *endp == '/');\n\t}\n\n\tlen = endp - path + 1;\n\tif (len >= sizeof(dname)) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn (NULL);\n\t}\n\tmemcpy(dname, path, len);\n\tdname[len] = '\\0';\n\treturn (dname);\n}"
  }
]