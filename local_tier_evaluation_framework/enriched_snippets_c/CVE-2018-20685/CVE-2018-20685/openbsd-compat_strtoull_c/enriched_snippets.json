[
  {
    "function_name": "strtoull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtoull.c",
    "lines": "49-109",
    "snippet": "unsigned long long\nstrtoull(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tunsigned long long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * See strtoq for comments as to the logic used.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else { \n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\tcutoff = ULLONG_MAX / (unsigned long long)base;\n\tcutlim = ULLONG_MAX % (unsigned long long)base;\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\tany = -1;\n\t\t\tacc = ULLONG_MAX;\n\t\t\terrno = ERANGE;\n\t\t} else {\n\t\t\tany = 1;\n\t\t\tacc *= (unsigned long long)base;\n\t\t\tacc += c;\n\t\t}\n\t}\n\tif (neg && any > 0)\n\t\tacc = -acc;\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isupper",
          "args": [
            "c"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "c"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "c"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "c"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nunsigned long long\nstrtoull(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tunsigned long long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * See strtoq for comments as to the logic used.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else { \n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\tcutoff = ULLONG_MAX / (unsigned long long)base;\n\tcutlim = ULLONG_MAX % (unsigned long long)base;\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\tany = -1;\n\t\t\tacc = ULLONG_MAX;\n\t\t\terrno = ERANGE;\n\t\t} else {\n\t\t\tany = 1;\n\t\t\tacc *= (unsigned long long)base;\n\t\t\tacc += c;\n\t\t}\n\t}\n\tif (neg && any > 0)\n\t\tacc = -acc;\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}"
  }
]