[
  {
    "function_name": "cleanup_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "2331-2353",
    "snippet": "void\ncleanup_exit(int i)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (the_authctxt) {\n\t\tdo_cleanup(ssh, the_authctxt);\n\t\tif (use_privsep && privsep_is_preauth &&\n\t\t    pmonitor != NULL && pmonitor->m_pid > 1) {\n\t\t\tdebug(\"Killing privsep child %d\", pmonitor->m_pid);\n\t\t\tif (kill(pmonitor->m_pid, SIGKILL) != 0 &&\n\t\t\t    errno != ESRCH)\n\t\t\t\terror(\"%s: kill(%d): %s\", __func__,\n\t\t\t\t    pmonitor->m_pid, strerror(errno));\n\t\t}\n\t}\n#ifdef SSH_AUDIT_EVENTS\n\t/* done after do_cleanup so it can cancel the PAM auth 'thread' */\n\tif (!use_privsep || mm_is_monitor())\n\t\taudit_event(SSH_CONNECTION_ABANDON);\n#endif\n\t_exit(i);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int use_privsep = -1;",
      "struct monitor *pmonitor = NULL;",
      "int privsep_is_preauth = 1;",
      "Authctxt *the_authctxt = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "i"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "2331-2353",
          "snippet": "void\ncleanup_exit(int i)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (the_authctxt) {\n\t\tdo_cleanup(ssh, the_authctxt);\n\t\tif (use_privsep && privsep_is_preauth &&\n\t\t    pmonitor != NULL && pmonitor->m_pid > 1) {\n\t\t\tdebug(\"Killing privsep child %d\", pmonitor->m_pid);\n\t\t\tif (kill(pmonitor->m_pid, SIGKILL) != 0 &&\n\t\t\t    errno != ESRCH)\n\t\t\t\terror(\"%s: kill(%d): %s\", __func__,\n\t\t\t\t    pmonitor->m_pid, strerror(errno));\n\t\t}\n\t}\n#ifdef SSH_AUDIT_EVENTS\n\t/* done after do_cleanup so it can cancel the PAM auth 'thread' */\n\tif (!use_privsep || mm_is_monitor())\n\t\taudit_event(SSH_CONNECTION_ABANDON);\n#endif\n\t_exit(i);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "audit_event",
          "args": [
            "SSH_CONNECTION_ABANDON"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "audit_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit.c",
          "lines": "133-138",
          "snippet": "void\naudit_event(ssh_audit_event_t event)\n{\n\tdebug(\"audit event euid %d user %s event %d (%s)\", geteuid(),\n\t    audit_username(), event, audit_event_lookup(event));\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"log.h\"",
            "#include \"audit.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"audit.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\naudit_event(ssh_audit_event_t event)\n{\n\tdebug(\"audit event euid %d user %s event %d (%s)\", geteuid(),\n\t    audit_username(), event, audit_event_lookup(event));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_is_monitor",
          "args": [],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "mm_is_monitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "111-119",
          "snippet": "int\nmm_is_monitor(void)\n{\n\t/*\n\t * m_pid is only set in the privileged part, and\n\t * points to the unprivileged child.\n\t */\n\treturn (pmonitor && pmonitor->m_pid > 0);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct monitor *pmonitor;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern struct monitor *pmonitor;\n\nint\nmm_is_monitor(void)\n{\n\t/*\n\t * m_pid is only set in the privileged part, and\n\t * points to the unprivileged child.\n\t */\n\treturn (pmonitor && pmonitor->m_pid > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: kill(%d): %s\"",
            "__func__",
            "pmonitor->m_pid",
            "strerror(errno)"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "pmonitor->m_pid",
            "SIGKILL"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Killing privsep child %d\"",
            "pmonitor->m_pid"
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_cleanup",
          "args": [
            "ssh",
            "the_authctxt"
          ],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "do_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2641-2699",
          "snippet": "void\ndo_cleanup(struct ssh *ssh, Authctxt *authctxt)\n{\n\tstatic int called = 0;\n\n\tdebug(\"do_cleanup\");\n\n\t/* no cleanup if we're in the child for login shell */\n\tif (is_child)\n\t\treturn;\n\n\t/* avoid double cleanup */\n\tif (called)\n\t\treturn;\n\tcalled = 1;\n\n\tif (authctxt == NULL)\n\t\treturn;\n\n#ifdef USE_PAM\n\tif (options.use_pam) {\n\t\tsshpam_cleanup();\n\t\tsshpam_thread_cleanup();\n\t}\n#endif\n\n\tif (!authctxt->authenticated)\n\t\treturn;\n\n#ifdef KRB5\n\tif (options.kerberos_ticket_cleanup &&\n\t    authctxt->krb5_ctx)\n\t\tkrb5_cleanup_proc(authctxt);\n#endif\n\n#ifdef GSSAPI\n\tif (options.gss_cleanup_creds)\n\t\tssh_gssapi_cleanup_creds();\n#endif\n\n\t/* remove agent socket */\n\tauth_sock_cleanup_proc(authctxt->pw);\n\n\t/* remove userauth info */\n\tif (auth_info_file != NULL) {\n\t\ttemporarily_use_uid(authctxt->pw);\n\t\tunlink(auth_info_file);\n\t\trestore_uid();\n\t\tfree(auth_info_file);\n\t\tauth_info_file = NULL;\n\t}\n\n\t/*\n\t * Cleanup ptys/utmp only if privsep is disabled,\n\t * or if running in monitor.\n\t */\n\tif (!use_privsep || mm_is_monitor())\n\t\tsession_destroy_all(ssh, session_pty_cleanup2);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void do_authenticated2(struct ssh *, Authctxt *);",
            "extern ServerOptions options;",
            "static int is_child = 0;",
            "static char *auth_info_file = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void do_authenticated2(struct ssh *, Authctxt *);\nextern ServerOptions options;\nstatic int is_child = 0;\nstatic char *auth_info_file = NULL;\n\nvoid\ndo_cleanup(struct ssh *ssh, Authctxt *authctxt)\n{\n\tstatic int called = 0;\n\n\tdebug(\"do_cleanup\");\n\n\t/* no cleanup if we're in the child for login shell */\n\tif (is_child)\n\t\treturn;\n\n\t/* avoid double cleanup */\n\tif (called)\n\t\treturn;\n\tcalled = 1;\n\n\tif (authctxt == NULL)\n\t\treturn;\n\n#ifdef USE_PAM\n\tif (options.use_pam) {\n\t\tsshpam_cleanup();\n\t\tsshpam_thread_cleanup();\n\t}\n#endif\n\n\tif (!authctxt->authenticated)\n\t\treturn;\n\n#ifdef KRB5\n\tif (options.kerberos_ticket_cleanup &&\n\t    authctxt->krb5_ctx)\n\t\tkrb5_cleanup_proc(authctxt);\n#endif\n\n#ifdef GSSAPI\n\tif (options.gss_cleanup_creds)\n\t\tssh_gssapi_cleanup_creds();\n#endif\n\n\t/* remove agent socket */\n\tauth_sock_cleanup_proc(authctxt->pw);\n\n\t/* remove userauth info */\n\tif (auth_info_file != NULL) {\n\t\ttemporarily_use_uid(authctxt->pw);\n\t\tunlink(auth_info_file);\n\t\trestore_uid();\n\t\tfree(auth_info_file);\n\t\tauth_info_file = NULL;\n\t}\n\n\t/*\n\t * Cleanup ptys/utmp only if privsep is disabled,\n\t * or if running in monitor.\n\t */\n\tif (!use_privsep || mm_is_monitor())\n\t\tsession_destroy_all(ssh, session_pty_cleanup2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint use_privsep = -1;\nstruct monitor *pmonitor = NULL;\nint privsep_is_preauth = 1;\nAuthctxt *the_authctxt = NULL;\n\nvoid\ncleanup_exit(int i)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (the_authctxt) {\n\t\tdo_cleanup(ssh, the_authctxt);\n\t\tif (use_privsep && privsep_is_preauth &&\n\t\t    pmonitor != NULL && pmonitor->m_pid > 1) {\n\t\t\tdebug(\"Killing privsep child %d\", pmonitor->m_pid);\n\t\t\tif (kill(pmonitor->m_pid, SIGKILL) != 0 &&\n\t\t\t    errno != ESRCH)\n\t\t\t\terror(\"%s: kill(%d): %s\", __func__,\n\t\t\t\t    pmonitor->m_pid, strerror(errno));\n\t\t}\n\t}\n#ifdef SSH_AUDIT_EVENTS\n\t/* done after do_cleanup so it can cancel the PAM auth 'thread' */\n\tif (!use_privsep || mm_is_monitor())\n\t\taudit_event(SSH_CONNECTION_ABANDON);\n#endif\n\t_exit(i);\n}"
  },
  {
    "function_name": "do_ssh2_kex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "2262-2328",
    "snippet": "static void\ndo_ssh2_kex(void)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_SERVER };\n\tstruct kex *kex;\n\tint r;\n\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(\n\t    options.kex_algorithms);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] = compat_cipher_proposal(\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] = compat_cipher_proposal(\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\n\tif (options.compression == COMP_NONE) {\n\t\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t\t    myproposal[PROPOSAL_COMP_ALGS_STOC] = \"none\";\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tpacket_set_rekey_limits(options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = compat_pkalg_proposal(\n\t    list_hostkey_types());\n\n\t/* start key exchange */\n\tif ((r = kex_setup(active_state, myproposal)) != 0)\n\t\tfatal(\"kex_setup: %s\", ssh_err(r));\n\tkex = active_state->kex;\n#ifdef WITH_OPENSSL\n\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\tkex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n# endif\n#endif\n\tkex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\tkex->server = 1;\n\tkex->client_version_string=client_version_string;\n\tkex->server_version_string=server_version_string;\n\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\tkex->host_key_index=&get_hostkey_index;\n\tkex->sign = sshd_hostkey_sign;\n\n\tssh_dispatch_run_fatal(active_state, DISPATCH_BLOCK, &kex->done);\n\n\tsession_id2 = kex->session_id;\n\tsession_id2_len = kex->session_id_len;\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tpacket_start(SSH2_MSG_IGNORE);\n\tpacket_put_cstring(\"markus\");\n\tpacket_send();\n\tpacket_write_wait();\n#endif\n\tdebug(\"KEX done\");\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ServerOptions options;",
      "char *client_version_string = NULL;",
      "char *server_version_string = NULL;",
      "u_char session_id[16];",
      "u_char *session_id2 = NULL;",
      "u_int session_id2_len = 0;",
      "static void do_ssh2_kex(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"KEX done\""
          ],
          "line": 2327
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_write_wait",
          "args": [],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "packet_write_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "271-278",
          "snippet": "void\npacket_write_wait(void)\n{\n\tint r;\n\n\tif ((r = ssh_packet_write_wait(active_state)) != 0)\n\t\tsshpkt_fatal(active_state, __func__, r);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_write_wait(void)\n{\n\tint r;\n\n\tif ((r = ssh_packet_write_wait(active_state)) != 0)\n\t\tsshpkt_fatal(active_state, __func__, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "\"markus\""
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_start",
          "args": [
            "SSH2_MSG_IGNORE"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_dispatch_run_fatal",
          "args": [
            "active_state",
            "DISPATCH_BLOCK",
            "&kex->done"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_run_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "128-135",
          "snippet": "void\nssh_dispatch_run_fatal(struct ssh *ssh, int mode, volatile sig_atomic_t *done)\n{\n\tint r;\n\n\tif ((r = ssh_dispatch_run(ssh, mode, done)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_run_fatal(struct ssh *ssh, int mode, volatile sig_atomic_t *done)\n{\n\tint r;\n\n\tif ((r = ssh_dispatch_run(ssh, mode, done)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"kex_setup: %s\"",
            "ssh_err(r)"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kex_setup",
          "args": [
            "active_state",
            "myproposal"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "kex_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "664-677",
          "snippet": "int\nkex_setup(struct ssh *ssh, char *proposal[PROPOSAL_MAX])\n{\n\tint r;\n\n\tif ((r = kex_new(ssh, proposal, &ssh->kex)) != 0)\n\t\treturn r;\n\tif ((r = kex_send_kexinit(ssh)) != 0) {\t\t/* we start */\n\t\tkex_free(ssh->kex);\n\t\tssh->kex = NULL;\n\t\treturn r;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kex_choose_conf(struct ssh *);",
            "static int kex_input_newkeys(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nstatic int kex_choose_conf(struct ssh *);\nstatic int kex_input_newkeys(int, u_int32_t, struct ssh *);\n\nint\nkex_setup(struct ssh *ssh, char *proposal[PROPOSAL_MAX])\n{\n\tint r;\n\n\tif ((r = kex_new(ssh, proposal, &ssh->kex)) != 0)\n\t\treturn r;\n\tif ((r = kex_send_kexinit(ssh)) != 0) {\t\t/* we start */\n\t\tkex_free(ssh->kex);\n\t\tssh->kex = NULL;\n\t\treturn r;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_pkalg_proposal",
          "args": [
            "list_hostkey_types()"
          ],
          "line": 2287
        },
        "resolved": true,
        "details": {
          "function_name": "compat_pkalg_proposal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/compat.c",
          "lines": "200-212",
          "snippet": "char *\ncompat_pkalg_proposal(char *pkalg_prop)\n{\n\tif (!(datafellows & SSH_BUG_RSASIGMD5))\n\t\treturn pkalg_prop;\n\tdebug2(\"%s: original public key proposal: %s\", __func__, pkalg_prop);\n\tif ((pkalg_prop = match_filter_blacklist(pkalg_prop, \"ssh-rsa\")) == NULL)\n\t\tfatal(\"match_filter_blacklist failed\");\n\tdebug2(\"%s: compat public key proposal: %s\", __func__, pkalg_prop);\n\tif (*pkalg_prop == '\\0')\n\t\tfatal(\"No supported PK algorithms found\");\n\treturn pkalg_prop;\n}",
          "includes": [
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int datafellows = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kex.h\"\n#include \"match.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint datafellows = 0;\n\nchar *\ncompat_pkalg_proposal(char *pkalg_prop)\n{\n\tif (!(datafellows & SSH_BUG_RSASIGMD5))\n\t\treturn pkalg_prop;\n\tdebug2(\"%s: original public key proposal: %s\", __func__, pkalg_prop);\n\tif ((pkalg_prop = match_filter_blacklist(pkalg_prop, \"ssh-rsa\")) == NULL)\n\t\tfatal(\"match_filter_blacklist failed\");\n\tdebug2(\"%s: compat public key proposal: %s\", __func__, pkalg_prop);\n\tif (*pkalg_prop == '\\0')\n\t\tfatal(\"No supported PK algorithms found\");\n\treturn pkalg_prop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_hostkey_types",
          "args": [],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "list_hostkey_types",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "702-756",
          "snippet": "static char *\nlist_hostkey_types(void)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *key;\n\tchar *ret;\n\tu_int i;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tkey = sensitive_data.host_keys[i];\n\t\tif (key == NULL)\n\t\t\tkey = sensitive_data.host_pubkeys[i];\n\t\tif (key == NULL)\n\t\t\tcontinue;\n\t\tswitch (key->type) {\n\t\tcase KEY_RSA:\n\t\t\t/* for RSA we also support SHA2 signatures */\n\t\t\tappend_hostkey_type(b, \"rsa-sha2-512\");\n\t\t\tappend_hostkey_type(b, \"rsa-sha2-256\");\n\t\t\t/* FALLTHROUGH */\n\t\tcase KEY_DSA:\n\t\tcase KEY_ECDSA:\n\t\tcase KEY_ED25519:\n\t\tcase KEY_XMSS:\n\t\t\tappend_hostkey_type(b, sshkey_ssh_name(key));\n\t\t\tbreak;\n\t\t}\n\t\t/* If the private key has a cert peer, then list that too */\n\t\tkey = sensitive_data.host_certificates[i];\n\t\tif (key == NULL)\n\t\t\tcontinue;\n\t\tswitch (key->type) {\n\t\tcase KEY_RSA_CERT:\n\t\t\t/* for RSA we also support SHA2 signatures */\n\t\t\tappend_hostkey_type(b,\n\t\t\t    \"rsa-sha2-512-cert-v01@openssh.com\");\n\t\t\tappend_hostkey_type(b,\n\t\t\t    \"rsa-sha2-256-cert-v01@openssh.com\");\n\t\t\t/* FALLTHROUGH */\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ED25519_CERT:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tappend_hostkey_type(b, sshkey_ssh_name(key));\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((ret = sshbuf_dup_string(b)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\tsshbuf_free(b);\n\tdebug(\"%s: %s\", __func__, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;",
            "struct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nstruct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;\n\nstatic char *\nlist_hostkey_types(void)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *key;\n\tchar *ret;\n\tu_int i;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tkey = sensitive_data.host_keys[i];\n\t\tif (key == NULL)\n\t\t\tkey = sensitive_data.host_pubkeys[i];\n\t\tif (key == NULL)\n\t\t\tcontinue;\n\t\tswitch (key->type) {\n\t\tcase KEY_RSA:\n\t\t\t/* for RSA we also support SHA2 signatures */\n\t\t\tappend_hostkey_type(b, \"rsa-sha2-512\");\n\t\t\tappend_hostkey_type(b, \"rsa-sha2-256\");\n\t\t\t/* FALLTHROUGH */\n\t\tcase KEY_DSA:\n\t\tcase KEY_ECDSA:\n\t\tcase KEY_ED25519:\n\t\tcase KEY_XMSS:\n\t\t\tappend_hostkey_type(b, sshkey_ssh_name(key));\n\t\t\tbreak;\n\t\t}\n\t\t/* If the private key has a cert peer, then list that too */\n\t\tkey = sensitive_data.host_certificates[i];\n\t\tif (key == NULL)\n\t\t\tcontinue;\n\t\tswitch (key->type) {\n\t\tcase KEY_RSA_CERT:\n\t\t\t/* for RSA we also support SHA2 signatures */\n\t\t\tappend_hostkey_type(b,\n\t\t\t    \"rsa-sha2-512-cert-v01@openssh.com\");\n\t\t\tappend_hostkey_type(b,\n\t\t\t    \"rsa-sha2-256-cert-v01@openssh.com\");\n\t\t\t/* FALLTHROUGH */\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ED25519_CERT:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tappend_hostkey_type(b, sshkey_ssh_name(key));\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((ret = sshbuf_dup_string(b)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\tsshbuf_free(b);\n\tdebug(\"%s: %s\", __func__, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_set_rekey_limits",
          "args": [
            "options.rekey_limit",
            "options.rekey_interval"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_cipher_proposal",
          "args": [
            "options.ciphers"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "compat_cipher_proposal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/compat.c",
          "lines": "186-198",
          "snippet": "char *\ncompat_cipher_proposal(char *cipher_prop)\n{\n\tif (!(datafellows & SSH_BUG_BIGENDIANAES))\n\t\treturn cipher_prop;\n\tdebug2(\"%s: original cipher proposal: %s\", __func__, cipher_prop);\n\tif ((cipher_prop = match_filter_blacklist(cipher_prop, \"aes*\")) == NULL)\n\t\tfatal(\"match_filter_blacklist failed\");\n\tdebug2(\"%s: compat cipher proposal: %s\", __func__, cipher_prop);\n\tif (*cipher_prop == '\\0')\n\t\tfatal(\"No supported ciphers found\");\n\treturn cipher_prop;\n}",
          "includes": [
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int datafellows = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kex.h\"\n#include \"match.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint datafellows = 0;\n\nchar *\ncompat_cipher_proposal(char *cipher_prop)\n{\n\tif (!(datafellows & SSH_BUG_BIGENDIANAES))\n\t\treturn cipher_prop;\n\tdebug2(\"%s: original cipher proposal: %s\", __func__, cipher_prop);\n\tif ((cipher_prop = match_filter_blacklist(cipher_prop, \"aes*\")) == NULL)\n\t\tfatal(\"match_filter_blacklist failed\");\n\tdebug2(\"%s: compat cipher proposal: %s\", __func__, cipher_prop);\n\tif (*cipher_prop == '\\0')\n\t\tfatal(\"No supported ciphers found\");\n\treturn cipher_prop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_kex_proposal",
          "args": [
            "options.kex_algorithms"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "compat_kex_proposal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/compat.c",
          "lines": "214-234",
          "snippet": "char *\ncompat_kex_proposal(char *p)\n{\n\tif ((datafellows & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)\n\t\treturn p;\n\tdebug2(\"%s: original KEX proposal: %s\", __func__, p);\n\tif ((datafellows & SSH_BUG_CURVE25519PAD) != 0)\n\t\tif ((p = match_filter_blacklist(p,\n\t\t    \"curve25519-sha256@libssh.org\")) == NULL)\n\t\t\tfatal(\"match_filter_blacklist failed\");\n\tif ((datafellows & SSH_OLD_DHGEX) != 0) {\n\t\tif ((p = match_filter_blacklist(p,\n\t\t    \"diffie-hellman-group-exchange-sha256,\"\n\t\t    \"diffie-hellman-group-exchange-sha1\")) == NULL)\n\t\t\tfatal(\"match_filter_blacklist failed\");\n\t}\n\tdebug2(\"%s: compat KEX proposal: %s\", __func__, p);\n\tif (*p == '\\0')\n\t\tfatal(\"No supported key exchange algorithms found\");\n\treturn p;\n}",
          "includes": [
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int datafellows = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kex.h\"\n#include \"match.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint datafellows = 0;\n\nchar *\ncompat_kex_proposal(char *p)\n{\n\tif ((datafellows & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)\n\t\treturn p;\n\tdebug2(\"%s: original KEX proposal: %s\", __func__, p);\n\tif ((datafellows & SSH_BUG_CURVE25519PAD) != 0)\n\t\tif ((p = match_filter_blacklist(p,\n\t\t    \"curve25519-sha256@libssh.org\")) == NULL)\n\t\t\tfatal(\"match_filter_blacklist failed\");\n\tif ((datafellows & SSH_OLD_DHGEX) != 0) {\n\t\tif ((p = match_filter_blacklist(p,\n\t\t    \"diffie-hellman-group-exchange-sha256,\"\n\t\t    \"diffie-hellman-group-exchange-sha1\")) == NULL)\n\t\t\tfatal(\"match_filter_blacklist failed\");\n\t}\n\tdebug2(\"%s: compat KEX proposal: %s\", __func__, p);\n\tif (*p == '\\0')\n\t\tfatal(\"No supported key exchange algorithms found\");\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nchar *client_version_string = NULL;\nchar *server_version_string = NULL;\nu_char session_id[16];\nu_char *session_id2 = NULL;\nu_int session_id2_len = 0;\nstatic void do_ssh2_kex(void);\n\nstatic void\ndo_ssh2_kex(void)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_SERVER };\n\tstruct kex *kex;\n\tint r;\n\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(\n\t    options.kex_algorithms);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] = compat_cipher_proposal(\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] = compat_cipher_proposal(\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\n\tif (options.compression == COMP_NONE) {\n\t\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t\t    myproposal[PROPOSAL_COMP_ALGS_STOC] = \"none\";\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tpacket_set_rekey_limits(options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = compat_pkalg_proposal(\n\t    list_hostkey_types());\n\n\t/* start key exchange */\n\tif ((r = kex_setup(active_state, myproposal)) != 0)\n\t\tfatal(\"kex_setup: %s\", ssh_err(r));\n\tkex = active_state->kex;\n#ifdef WITH_OPENSSL\n\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\tkex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n# endif\n#endif\n\tkex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\tkex->server = 1;\n\tkex->client_version_string=client_version_string;\n\tkex->server_version_string=server_version_string;\n\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\tkex->host_key_index=&get_hostkey_index;\n\tkex->sign = sshd_hostkey_sign;\n\n\tssh_dispatch_run_fatal(active_state, DISPATCH_BLOCK, &kex->done);\n\n\tsession_id2 = kex->session_id;\n\tsession_id2_len = kex->session_id_len;\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tpacket_start(SSH2_MSG_IGNORE);\n\tpacket_put_cstring(\"markus\");\n\tpacket_send();\n\tpacket_write_wait();\n#endif\n\tdebug(\"KEX done\");\n}"
  },
  {
    "function_name": "sshd_hostkey_sign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "2237-2259",
    "snippet": "int\nsshd_hostkey_sign(struct sshkey *privkey, struct sshkey *pubkey,\n    u_char **signature, size_t *slenp, const u_char *data, size_t dlen,\n    const char *alg, u_int flag)\n{\n\tint r;\n\n\tif (privkey) {\n\t\tif (PRIVSEP(sshkey_sign(privkey, signature, slenp, data, dlen,\n\t\t    alg, datafellows)) < 0)\n\t\t\tfatal(\"%s: key_sign failed\", __func__);\n\t} else if (use_privsep) {\n\t\tif (mm_sshkey_sign(pubkey, signature, slenp, data, dlen,\n\t\t    alg, datafellows) < 0)\n\t\t\tfatal(\"%s: pubkey_sign failed\", __func__);\n\t} else {\n\t\tif ((r = ssh_agent_sign(auth_sock, pubkey, signature, slenp,\n\t\t    data, dlen, alg, datafellows)) != 0)\n\t\t\tfatal(\"%s: ssh_agent_sign failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int auth_sock = -1;",
      "int use_privsep = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: ssh_agent_sign failed: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_agent_sign",
          "args": [
            "auth_sock",
            "pubkey",
            "signature",
            "slenp",
            "data",
            "dlen",
            "alg",
            "datafellows"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_agent_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "340-390",
          "snippet": "int\nssh_agent_sign(int sock, const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tstruct sshbuf *msg;\n\tu_char *sig = NULL, type = 0;\n\tsize_t len = 0;\n\tu_int flags = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t*sigp = NULL;\n\t*lenp = 0;\n\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tflags |= agent_encode_alg(key, alg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_SIGN_REQUEST)) != 0 ||\n\t    (r = sshkey_puts(key, msg)) != 0 ||\n\t    (r = sshbuf_put_string(msg, data, datalen)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, flags)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tif (agent_failed(type)) {\n\t\tr = SSH_ERR_AGENT_FAILURE;\n\t\tgoto out;\n\t} else if (type != SSH2_AGENT_SIGN_RESPONSE) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_string(msg, &sig, &len)) != 0)\n\t\tgoto out;\n\t/* Check what we actually got back from the agent. */\n\tif ((r = sshkey_check_sigtype(sig, len, alg)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*sigp = sig;\n\t*lenp = len;\n\tsig = NULL;\n\tlen = 0;\n\tr = 0;\n out:\n\tfreezero(sig, len);\n\tsshbuf_free(msg);\n\treturn r;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_agent_sign(int sock, const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tstruct sshbuf *msg;\n\tu_char *sig = NULL, type = 0;\n\tsize_t len = 0;\n\tu_int flags = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t*sigp = NULL;\n\t*lenp = 0;\n\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tflags |= agent_encode_alg(key, alg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_SIGN_REQUEST)) != 0 ||\n\t    (r = sshkey_puts(key, msg)) != 0 ||\n\t    (r = sshbuf_put_string(msg, data, datalen)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, flags)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tif (agent_failed(type)) {\n\t\tr = SSH_ERR_AGENT_FAILURE;\n\t\tgoto out;\n\t} else if (type != SSH2_AGENT_SIGN_RESPONSE) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_string(msg, &sig, &len)) != 0)\n\t\tgoto out;\n\t/* Check what we actually got back from the agent. */\n\tif ((r = sshkey_check_sigtype(sig, len, alg)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*sigp = sig;\n\t*lenp = len;\n\tsig = NULL;\n\tlen = 0;\n\tr = 0;\n out:\n\tfreezero(sig, len);\n\tsshbuf_free(msg);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: pubkey_sign failed\"",
            "__func__"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_sshkey_sign",
          "args": [
            "pubkey",
            "signature",
            "slenp",
            "data",
            "dlen",
            "alg",
            "datafellows"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "mm_sshkey_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "220-248",
          "snippet": "int\nmm_sshkey_sign(struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *hostkey_alg, u_int compat)\n{\n\tstruct kex *kex = *pmonitor->m_pkex;\n\tstruct sshbuf *m;\n\tu_int ndx = kex->host_key_index(key, 0, active_state);\n\tint r;\n\n\tdebug3(\"%s entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u32(m, ndx)) != 0 ||\n\t    (r = sshbuf_put_string(m, data, datalen)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, hostkey_alg)) != 0 ||\n\t    (r = sshbuf_put_u32(m, compat)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SIGN, m);\n\n\tdebug3(\"%s: waiting for MONITOR_ANS_SIGN\", __func__);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_SIGN, m);\n\tif ((r = sshbuf_get_string(m, sigp, lenp)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(m);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct monitor *pmonitor;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern struct monitor *pmonitor;\n\nint\nmm_sshkey_sign(struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *hostkey_alg, u_int compat)\n{\n\tstruct kex *kex = *pmonitor->m_pkex;\n\tstruct sshbuf *m;\n\tu_int ndx = kex->host_key_index(key, 0, active_state);\n\tint r;\n\n\tdebug3(\"%s entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u32(m, ndx)) != 0 ||\n\t    (r = sshbuf_put_string(m, data, datalen)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, hostkey_alg)) != 0 ||\n\t    (r = sshbuf_put_u32(m, compat)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SIGN, m);\n\n\tdebug3(\"%s: waiting for MONITOR_ANS_SIGN\", __func__);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_SIGN, m);\n\tif ((r = sshbuf_get_string(m, sigp, lenp)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(m);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRIVSEP",
          "args": [
            "sshkey_sign(privkey, signature, slenp, data, dlen,\n\t\t    alg, datafellows)"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_sign",
          "args": [
            "privkey",
            "signature",
            "slenp",
            "data",
            "dlen",
            "alg",
            "datafellows"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2385-2421",
          "snippet": "int\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint auth_sock = -1;\nint use_privsep = -1;\n\nint\nsshd_hostkey_sign(struct sshkey *privkey, struct sshkey *pubkey,\n    u_char **signature, size_t *slenp, const u_char *data, size_t dlen,\n    const char *alg, u_int flag)\n{\n\tint r;\n\n\tif (privkey) {\n\t\tif (PRIVSEP(sshkey_sign(privkey, signature, slenp, data, dlen,\n\t\t    alg, datafellows)) < 0)\n\t\t\tfatal(\"%s: key_sign failed\", __func__);\n\t} else if (use_privsep) {\n\t\tif (mm_sshkey_sign(pubkey, signature, slenp, data, dlen,\n\t\t    alg, datafellows) < 0)\n\t\t\tfatal(\"%s: pubkey_sign failed\", __func__);\n\t} else {\n\t\tif ((r = ssh_agent_sign(auth_sock, pubkey, signature, slenp,\n\t\t    data, dlen, alg, datafellows)) != 0)\n\t\t\tfatal(\"%s: ssh_agent_sign failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "1466-2235",
    "snippet": "int\nmain(int ac, char **av)\n{\n\tstruct ssh *ssh = NULL;\n\textern char *optarg;\n\textern int optind;\n\tint r, opt, on = 1, already_daemon, remote_port;\n\tint sock_in = -1, sock_out = -1, newsock = -1;\n\tconst char *remote_ip, *rdomain;\n\tchar *fp, *line, *laddr, *logfile = NULL;\n\tint config_s[2] = { -1 , -1 };\n\tu_int i, j;\n\tu_int64_t ibytes, obytes;\n\tmode_t new_umask;\n\tstruct sshkey *key;\n\tstruct sshkey *pubkey;\n\tint keytype;\n\tAuthctxt *authctxt;\n\tstruct connection_info *connection_info = NULL;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\n#ifdef HAVE_SECUREWARE\n\t(void)set_auth_parameters(ac, av);\n#endif\n\t__progname = ssh_get_progname(av[0]);\n\n\t/* Save argv. Duplicate so setproctitle emulation doesn't clobber it */\n\tsaved_argc = ac;\n\trexec_argc = ac;\n\tsaved_argv = xcalloc(ac + 1, sizeof(*saved_argv));\n\tfor (i = 0; (int)i < ac; i++)\n\t\tsaved_argv[i] = xstrdup(av[i]);\n\tsaved_argv[i] = NULL;\n\n#ifndef HAVE_SETPROCTITLE\n\t/* Prepare for later setproctitle emulation */\n\tcompat_init_setproctitle(ac, av);\n\tav = saved_argv;\n#endif\n\n\tif (geteuid() == 0 && setgroups(0, NULL) == -1)\n\t\tdebug(\"setgroups(): %.200s\", strerror(errno));\n\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t/* Initialize configuration options to their default values. */\n\tinitialize_server_options(&options);\n\n\t/* Parse command-line arguments. */\n\twhile ((opt = getopt(ac, av,\n\t    \"C:E:b:c:f:g:h:k:o:p:u:46DQRTdeiqrt\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase '4':\n\t\t\toptions.address_family = AF_INET;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\toptions.address_family = AF_INET6;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tconfig_file_name = optarg;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tservconf_add_hostcert(\"[command-line]\", 0,\n\t\t\t    &options, optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (debug_flag == 0) {\n\t\t\t\tdebug_flag = 1;\n\t\t\t\toptions.log_level = SYSLOG_LEVEL_DEBUG1;\n\t\t\t} else if (options.log_level < SYSLOG_LEVEL_DEBUG3)\n\t\t\t\toptions.log_level++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tno_daemon_flag = 1;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tlogfile = optarg;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 'e':\n\t\t\tlog_stderr = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tinetd_flag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trexec_flag = 0;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trexeced_flag = 1;\n\t\t\tinetd_flag = 1;\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\t/* ignored */\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\toptions.log_level = SYSLOG_LEVEL_QUIET;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\t/* protocol 1, ignored */\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\toptions.ports_from_cmdline = 1;\n\t\t\tif (options.num_ports >= MAX_PORTS) {\n\t\t\t\tfprintf(stderr, \"too many ports.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\toptions.ports[options.num_ports++] = a2port(optarg);\n\t\t\tif (options.ports[options.num_ports-1] <= 0) {\n\t\t\t\tfprintf(stderr, \"Bad port number.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tif ((options.login_grace_time = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid login grace time.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\t/* protocol 1, ignored */\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tservconf_add_hostkey(\"[command-line]\", 0,\n\t\t\t    &options, optarg);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttest_flag = 1;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\ttest_flag = 2;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tconnection_info = get_connection_info(0, 0);\n\t\t\tif (parse_server_match_testspec(connection_info,\n\t\t\t    optarg) == -1)\n\t\t\t\texit(1);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tutmp_len = (u_int)strtonum(optarg, 0, HOST_NAME_MAX+1+1, NULL);\n\t\t\tif (utmp_len > HOST_NAME_MAX+1) {\n\t\t\t\tfprintf(stderr, \"Invalid utmp length.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tline = xstrdup(optarg);\n\t\t\tif (process_server_config_line(&options, line,\n\t\t\t    \"command-line\", 0, NULL, NULL) != 0)\n\t\t\t\texit(1);\n\t\t\tfree(line);\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rexeced_flag || inetd_flag)\n\t\trexec_flag = 0;\n\tif (!test_flag && (rexec_flag && (av[0] == NULL || *av[0] != '/')))\n\t\tfatal(\"sshd re-exec requires execution with an absolute path\");\n\tif (rexeced_flag)\n\t\tclosefrom(REEXEC_MIN_FREE_FD);\n\telse\n\t\tclosefrom(REEXEC_DEVCRYPTO_RESERVED_FD);\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n#endif\n\n\t/* If requested, redirect the logs to the specified logfile. */\n\tif (logfile != NULL)\n\t\tlog_redirect_stderr_to(logfile);\n\t/*\n\t * Force logging to stderr until we have loaded the private host\n\t * key (unless started from inetd)\n\t */\n\tlog_init(__progname,\n\t    options.log_level == SYSLOG_LEVEL_NOT_SET ?\n\t    SYSLOG_LEVEL_INFO : options.log_level,\n\t    options.log_facility == SYSLOG_FACILITY_NOT_SET ?\n\t    SYSLOG_FACILITY_AUTH : options.log_facility,\n\t    log_stderr || !inetd_flag);\n\n\t/*\n\t * Unset KRB5CCNAME, otherwise the user's session may inherit it from\n\t * root's environment\n\t */\n\tif (getenv(\"KRB5CCNAME\") != NULL)\n\t\t(void) unsetenv(\"KRB5CCNAME\");\n\n\tsensitive_data.have_ssh2_key = 0;\n\n\t/*\n\t * If we're not doing an extended test do not silently ignore connection\n\t * test params.\n\t */\n\tif (test_flag < 2 && connection_info != NULL)\n\t\tfatal(\"Config test connection parameter (-C) provided without \"\n\t\t   \"test mode (-T)\");\n\n\t/* Fetch our configuration */\n\tif ((cfg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif (rexeced_flag)\n\t\trecv_rexec_state(REEXEC_CONFIG_PASS_FD, cfg);\n\telse if (strcasecmp(config_file_name, \"none\") != 0)\n\t\tload_server_config(config_file_name, cfg);\n\n\tparse_server_config(&options, rexeced_flag ? \"rexec\" : config_file_name,\n\t    cfg, NULL);\n\n\tseed_rng();\n\n\t/* Fill in default values for those options not explicitly set. */\n\tfill_default_server_options(&options);\n\n\t/* challenge-response is implemented via keyboard interactive */\n\tif (options.challenge_response_authentication)\n\t\toptions.kbd_interactive_authentication = 1;\n\n\t/* Check that options are sensible */\n\tif (options.authorized_keys_command_user == NULL &&\n\t    (options.authorized_keys_command != NULL &&\n\t    strcasecmp(options.authorized_keys_command, \"none\") != 0))\n\t\tfatal(\"AuthorizedKeysCommand set without \"\n\t\t    \"AuthorizedKeysCommandUser\");\n\tif (options.authorized_principals_command_user == NULL &&\n\t    (options.authorized_principals_command != NULL &&\n\t    strcasecmp(options.authorized_principals_command, \"none\") != 0))\n\t\tfatal(\"AuthorizedPrincipalsCommand set without \"\n\t\t    \"AuthorizedPrincipalsCommandUser\");\n\n\t/*\n\t * Check whether there is any path through configured auth methods.\n\t * Unfortunately it is not possible to verify this generally before\n\t * daemonisation in the presence of Match block, but this catches\n\t * and warns for trivial misconfigurations that could break login.\n\t */\n\tif (options.num_auth_methods != 0) {\n\t\tfor (i = 0; i < options.num_auth_methods; i++) {\n\t\t\tif (auth2_methods_valid(options.auth_methods[i],\n\t\t\t    1) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= options.num_auth_methods)\n\t\t\tfatal(\"AuthenticationMethods cannot be satisfied by \"\n\t\t\t    \"enabled authentication methods\");\n\t}\n\n\t/* Check that there are no remaining arguments. */\n\tif (optind < ac) {\n\t\tfprintf(stderr, \"Extra argument %s.\\n\", av[optind]);\n\t\texit(1);\n\t}\n\n\tdebug(\"sshd version %s, %s\", SSH_VERSION,\n#ifdef WITH_OPENSSL\n\t    OpenSSL_version(OPENSSL_VERSION)\n#else\n\t    \"without OpenSSL\"\n#endif\n\t);\n\n\t/* Store privilege separation user for later use if required. */\n\tprivsep_chroot = use_privsep && (getuid() == 0 || geteuid() == 0);\n\tif ((privsep_pw = getpwnam(SSH_PRIVSEP_USER)) == NULL) {\n\t\tif (privsep_chroot || options.kerberos_authentication)\n\t\t\tfatal(\"Privilege separation user %s does not exist\",\n\t\t\t    SSH_PRIVSEP_USER);\n\t} else {\n\t\tprivsep_pw = pwcopy(privsep_pw);\n\t\tfreezero(privsep_pw->pw_passwd, strlen(privsep_pw->pw_passwd));\n\t\tprivsep_pw->pw_passwd = xstrdup(\"*\");\n\t}\n\tendpwent();\n\n\t/* load host keys */\n\tsensitive_data.host_keys = xcalloc(options.num_host_key_files,\n\t    sizeof(struct sshkey *));\n\tsensitive_data.host_pubkeys = xcalloc(options.num_host_key_files,\n\t    sizeof(struct sshkey *));\n\n\tif (options.host_key_agent) {\n\t\tif (strcmp(options.host_key_agent, SSH_AUTHSOCKET_ENV_NAME))\n\t\t\tsetenv(SSH_AUTHSOCKET_ENV_NAME,\n\t\t\t    options.host_key_agent, 1);\n\t\tif ((r = ssh_get_authentication_socket(NULL)) == 0)\n\t\t\thave_agent = 1;\n\t\telse\n\t\t\terror(\"Could not connect to agent \\\"%s\\\": %s\",\n\t\t\t    options.host_key_agent, ssh_err(r));\n\t}\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tif (options.host_key_files[i] == NULL)\n\t\t\tcontinue;\n\t\tif ((r = sshkey_load_private(options.host_key_files[i], \"\",\n\t\t    &key, NULL)) != 0 && r != SSH_ERR_SYSTEM_ERROR)\n\t\t\terror(\"Error loading host key \\\"%s\\\": %s\",\n\t\t\t    options.host_key_files[i], ssh_err(r));\n\t\tif ((r = sshkey_load_public(options.host_key_files[i],\n\t\t    &pubkey, NULL)) != 0 && r != SSH_ERR_SYSTEM_ERROR)\n\t\t\terror(\"Error loading host key \\\"%s\\\": %s\",\n\t\t\t    options.host_key_files[i], ssh_err(r));\n\t\tif (pubkey == NULL && key != NULL)\n\t\t\tif ((r = sshkey_from_private(key, &pubkey)) != 0)\n\t\t\t\tfatal(\"Could not demote key: \\\"%s\\\": %s\",\n\t\t\t\t    options.host_key_files[i], ssh_err(r));\n\t\tsensitive_data.host_keys[i] = key;\n\t\tsensitive_data.host_pubkeys[i] = pubkey;\n\n\t\tif (key == NULL && pubkey != NULL && have_agent) {\n\t\t\tdebug(\"will rely on agent for hostkey %s\",\n\t\t\t    options.host_key_files[i]);\n\t\t\tkeytype = pubkey->type;\n\t\t} else if (key != NULL) {\n\t\t\tkeytype = key->type;\n\t\t\taccumulate_host_timing_secret(cfg, key);\n\t\t} else {\n\t\t\terror(\"Could not load host key: %s\",\n\t\t\t    options.host_key_files[i]);\n\t\t\tsensitive_data.host_keys[i] = NULL;\n\t\t\tsensitive_data.host_pubkeys[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (keytype) {\n\t\tcase KEY_RSA:\n\t\tcase KEY_DSA:\n\t\tcase KEY_ECDSA:\n\t\tcase KEY_ED25519:\n\t\tcase KEY_XMSS:\n\t\t\tif (have_agent || key != NULL)\n\t\t\t\tsensitive_data.have_ssh2_key = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif ((fp = sshkey_fingerprint(pubkey, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal(\"sshkey_fingerprint failed\");\n\t\tdebug(\"%s host key #%d: %s %s\",\n\t\t    key ? \"private\" : \"agent\", i, sshkey_ssh_name(pubkey), fp);\n\t\tfree(fp);\n\t}\n\taccumulate_host_timing_secret(cfg, NULL);\n\tif (!sensitive_data.have_ssh2_key) {\n\t\tlogit(\"sshd: no hostkeys available -- exiting.\");\n\t\texit(1);\n\t}\n\n\t/*\n\t * Load certificates. They are stored in an array at identical\n\t * indices to the public keys that they relate to.\n\t */\n\tsensitive_data.host_certificates = xcalloc(options.num_host_key_files,\n\t    sizeof(struct sshkey *));\n\tfor (i = 0; i < options.num_host_key_files; i++)\n\t\tsensitive_data.host_certificates[i] = NULL;\n\n\tfor (i = 0; i < options.num_host_cert_files; i++) {\n\t\tif (options.host_cert_files[i] == NULL)\n\t\t\tcontinue;\n\t\tif ((r = sshkey_load_public(options.host_cert_files[i],\n\t\t    &key, NULL)) != 0) {\n\t\t\terror(\"Could not load host certificate \\\"%s\\\": %s\",\n\t\t\t    options.host_cert_files[i], ssh_err(r));\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sshkey_is_cert(key)) {\n\t\t\terror(\"Certificate file is not a certificate: %s\",\n\t\t\t    options.host_cert_files[i]);\n\t\t\tsshkey_free(key);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Find matching private key */\n\t\tfor (j = 0; j < options.num_host_key_files; j++) {\n\t\t\tif (sshkey_equal_public(key,\n\t\t\t    sensitive_data.host_keys[j])) {\n\t\t\t\tsensitive_data.host_certificates[j] = key;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= options.num_host_key_files) {\n\t\t\terror(\"No matching private key for certificate: %s\",\n\t\t\t    options.host_cert_files[i]);\n\t\t\tsshkey_free(key);\n\t\t\tcontinue;\n\t\t}\n\t\tsensitive_data.host_certificates[j] = key;\n\t\tdebug(\"host certificate: #%u type %d %s\", j, key->type,\n\t\t    sshkey_type(key));\n\t}\n\n\tif (privsep_chroot) {\n\t\tstruct stat st;\n\n\t\tif ((stat(_PATH_PRIVSEP_CHROOT_DIR, &st) == -1) ||\n\t\t    (S_ISDIR(st.st_mode) == 0))\n\t\t\tfatal(\"Missing privilege separation directory: %s\",\n\t\t\t    _PATH_PRIVSEP_CHROOT_DIR);\n\n#ifdef HAVE_CYGWIN\n\t\tif (check_ntsec(_PATH_PRIVSEP_CHROOT_DIR) &&\n\t\t    (st.st_uid != getuid () ||\n\t\t    (st.st_mode & (S_IWGRP|S_IWOTH)) != 0))\n#else\n\t\tif (st.st_uid != 0 || (st.st_mode & (S_IWGRP|S_IWOTH)) != 0)\n#endif\n\t\t\tfatal(\"%s must be owned by root and not group or \"\n\t\t\t    \"world-writable.\", _PATH_PRIVSEP_CHROOT_DIR);\n\t}\n\n\tif (test_flag > 1) {\n\t\t/*\n\t\t * If no connection info was provided by -C then use\n\t\t * use a blank one that will cause no predicate to match.\n\t\t */\n\t\tif (connection_info == NULL)\n\t\t\tconnection_info = get_connection_info(0, 0);\n\t\tparse_server_match_config(&options, connection_info);\n\t\tdump_config(&options);\n\t}\n\n\t/* Configuration looks good, so exit if in test mode. */\n\tif (test_flag)\n\t\texit(0);\n\n\t/*\n\t * Clear out any supplemental groups we may have inherited.  This\n\t * prevents inadvertent creation of files with bad modes (in the\n\t * portable version at least, it's certainly possible for PAM\n\t * to create a file, and we can't control the code in every\n\t * module which might be used).\n\t */\n\tif (setgroups(0, NULL) < 0)\n\t\tdebug(\"setgroups() failed: %.200s\", strerror(errno));\n\n\tif (rexec_flag) {\n\t\tif (rexec_argc < 0)\n\t\t\tfatal(\"rexec_argc %d < 0\", rexec_argc);\n\t\trexec_argv = xcalloc(rexec_argc + 2, sizeof(char *));\n\t\tfor (i = 0; i < (u_int)rexec_argc; i++) {\n\t\t\tdebug(\"rexec_argv[%d]='%s'\", i, saved_argv[i]);\n\t\t\trexec_argv[i] = saved_argv[i];\n\t\t}\n\t\trexec_argv[rexec_argc] = \"-R\";\n\t\trexec_argv[rexec_argc + 1] = NULL;\n\t}\n\n\t/* Ensure that umask disallows at least group and world write */\n\tnew_umask = umask(0077) | 0022;\n\t(void) umask(new_umask);\n\n\t/* Initialize the log (it is reinitialized below in case we forked). */\n\tif (debug_flag && (!inetd_flag || rexeced_flag))\n\t\tlog_stderr = 1;\n\tlog_init(__progname, options.log_level, options.log_facility, log_stderr);\n\n\t/*\n\t * If not in debugging mode, not started from inetd and not already\n\t * daemonized (eg re-exec via SIGHUP), disconnect from the controlling\n\t * terminal, and fork.  The original process exits.\n\t */\n\talready_daemon = daemonized();\n\tif (!(debug_flag || inetd_flag || no_daemon_flag || already_daemon)) {\n\n\t\tif (daemon(0, 0) < 0)\n\t\t\tfatal(\"daemon() failed: %.200s\", strerror(errno));\n\n\t\tdisconnect_controlling_tty();\n\t}\n\t/* Reinitialize the log (because of the fork above). */\n\tlog_init(__progname, options.log_level, options.log_facility, log_stderr);\n\n\t/* Chdir to the root directory so that the current disk can be\n\t   unmounted if desired. */\n\tif (chdir(\"/\") == -1)\n\t\terror(\"chdir(\\\"/\\\"): %s\", strerror(errno));\n\n\t/* ignore SIGPIPE */\n\tsignal(SIGPIPE, SIG_IGN);\n\n\t/* Get a connection, either from inetd or a listening TCP socket */\n\tif (inetd_flag) {\n\t\tserver_accept_inetd(&sock_in, &sock_out);\n\t} else {\n\t\tplatform_pre_listen();\n\t\tserver_listen();\n\n\t\tsignal(SIGHUP, sighup_handler);\n\t\tsignal(SIGCHLD, main_sigchld_handler);\n\t\tsignal(SIGTERM, sigterm_handler);\n\t\tsignal(SIGQUIT, sigterm_handler);\n\n\t\t/*\n\t\t * Write out the pid file after the sigterm handler\n\t\t * is setup and the listen sockets are bound\n\t\t */\n\t\tif (options.pid_file != NULL && !debug_flag) {\n\t\t\tFILE *f = fopen(options.pid_file, \"w\");\n\n\t\t\tif (f == NULL) {\n\t\t\t\terror(\"Couldn't create pid file \\\"%s\\\": %s\",\n\t\t\t\t    options.pid_file, strerror(errno));\n\t\t\t} else {\n\t\t\t\tfprintf(f, \"%ld\\n\", (long) getpid());\n\t\t\t\tfclose(f);\n\t\t\t}\n\t\t}\n\n\t\t/* Accept a connection and return in a forked child */\n\t\tserver_accept_loop(&sock_in, &sock_out,\n\t\t    &newsock, config_s);\n\t}\n\n\t/* This is the child processing a new connection. */\n\tsetproctitle(\"%s\", \"[accepted]\");\n\n\t/*\n\t * Create a new session and process group since the 4.4BSD\n\t * setlogin() affects the entire process group.  We don't\n\t * want the child to be able to affect the parent.\n\t */\n#if !defined(SSHD_ACQUIRES_CTTY)\n\t/*\n\t * If setsid is called, on some platforms sshd will later acquire a\n\t * controlling terminal which will result in \"could not set\n\t * controlling tty\" errors.\n\t */\n\tif (!debug_flag && !inetd_flag && setsid() < 0)\n\t\terror(\"setsid: %.100s\", strerror(errno));\n#endif\n\n\tif (rexec_flag) {\n\t\tint fd;\n\n\t\tdebug(\"rexec start in %d out %d newsock %d pipe %d sock %d\",\n\t\t    sock_in, sock_out, newsock, startup_pipe, config_s[0]);\n\t\tdup2(newsock, STDIN_FILENO);\n\t\tdup2(STDIN_FILENO, STDOUT_FILENO);\n\t\tif (startup_pipe == -1)\n\t\t\tclose(REEXEC_STARTUP_PIPE_FD);\n\t\telse if (startup_pipe != REEXEC_STARTUP_PIPE_FD) {\n\t\t\tdup2(startup_pipe, REEXEC_STARTUP_PIPE_FD);\n\t\t\tclose(startup_pipe);\n\t\t\tstartup_pipe = REEXEC_STARTUP_PIPE_FD;\n\t\t}\n\n\t\tdup2(config_s[1], REEXEC_CONFIG_PASS_FD);\n\t\tclose(config_s[1]);\n\n\t\texecv(rexec_argv[0], rexec_argv);\n\n\t\t/* Reexec has failed, fall back and continue */\n\t\terror(\"rexec of %s failed: %s\", rexec_argv[0], strerror(errno));\n\t\trecv_rexec_state(REEXEC_CONFIG_PASS_FD, NULL);\n\t\tlog_init(__progname, options.log_level,\n\t\t    options.log_facility, log_stderr);\n\n\t\t/* Clean up fds */\n\t\tclose(REEXEC_CONFIG_PASS_FD);\n\t\tnewsock = sock_out = sock_in = dup(STDIN_FILENO);\n\t\tif ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\t\tdup2(fd, STDIN_FILENO);\n\t\t\tdup2(fd, STDOUT_FILENO);\n\t\t\tif (fd > STDERR_FILENO)\n\t\t\t\tclose(fd);\n\t\t}\n\t\tdebug(\"rexec cleanup in %d out %d newsock %d pipe %d sock %d\",\n\t\t    sock_in, sock_out, newsock, startup_pipe, config_s[0]);\n\t}\n\n\t/* Executed child processes don't need these. */\n\tfcntl(sock_out, F_SETFD, FD_CLOEXEC);\n\tfcntl(sock_in, F_SETFD, FD_CLOEXEC);\n\n\t/*\n\t * Disable the key regeneration alarm.  We will not regenerate the\n\t * key since we are no longer in a position to give it to anyone. We\n\t * will not restart on SIGHUP since it no longer makes sense.\n\t */\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tsignal(SIGHUP, SIG_DFL);\n\tsignal(SIGTERM, SIG_DFL);\n\tsignal(SIGQUIT, SIG_DFL);\n\tsignal(SIGCHLD, SIG_DFL);\n\tsignal(SIGINT, SIG_DFL);\n\n\t/*\n\t * Register our connection.  This turns encryption off because we do\n\t * not have a key.\n\t */\n\tpacket_set_connection(sock_in, sock_out);\n\tpacket_set_server();\n\tssh = active_state; /* XXX */\n\n\tcheck_ip_options(ssh);\n\n\t/* Prepare the channels layer */\n\tchannel_init_channels(ssh);\n\tchannel_set_af(ssh, options.address_family);\n\tprocess_permitopen(ssh, &options);\n\n\t/* Set SO_KEEPALIVE if requested. */\n\tif (options.tcp_keep_alive && packet_connection_is_on_socket() &&\n\t    setsockopt(sock_in, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_KEEPALIVE: %.100s\", strerror(errno));\n\n\tif ((remote_port = ssh_remote_port(ssh)) < 0) {\n\t\tdebug(\"ssh_remote_port failed\");\n\t\tcleanup_exit(255);\n\t}\n\n\tif (options.routing_domain != NULL)\n\t\tset_process_rdomain(ssh, options.routing_domain);\n\n\t/*\n\t * The rest of the code depends on the fact that\n\t * ssh_remote_ipaddr() caches the remote ip, even if\n\t * the socket goes away.\n\t */\n\tremote_ip = ssh_remote_ipaddr(ssh);\n\n#ifdef SSH_AUDIT_EVENTS\n\taudit_connection_from(remote_ip, remote_port);\n#endif\n\n\trdomain = ssh_packet_rdomain_in(ssh);\n\n\t/* Log the connection. */\n\tladdr = get_local_ipaddr(sock_in);\n\tverbose(\"Connection from %s port %d on %s port %d%s%s%s\",\n\t    remote_ip, remote_port, laddr,  ssh_local_port(ssh),\n\t    rdomain == NULL ? \"\" : \" rdomain \\\"\",\n\t    rdomain == NULL ? \"\" : rdomain,\n\t    rdomain == NULL ? \"\" : \"\\\"\");\n\tfree(laddr);\n\n\t/*\n\t * We don't want to listen forever unless the other side\n\t * successfully authenticates itself.  So we set up an alarm which is\n\t * cleared after successful authentication.  A limit of zero\n\t * indicates no limit. Note that we don't set the alarm in debugging\n\t * mode; it is just annoying to have the server exit just when you\n\t * are about to discover the bug.\n\t */\n\tsignal(SIGALRM, grace_alarm_handler);\n\tif (!debug_flag)\n\t\talarm(options.login_grace_time);\n\n\tsshd_exchange_identification(ssh, sock_in, sock_out);\n\tpacket_set_nonblocking();\n\n\t/* allocate authentication context */\n\tauthctxt = xcalloc(1, sizeof(*authctxt));\n\n\tauthctxt->loginmsg = loginmsg;\n\n\t/* XXX global for cleanup, access from other modules */\n\tthe_authctxt = authctxt;\n\n\t/* Set default key authentication options */\n\tif ((auth_opts = sshauthopt_new_with_keys_defaults()) == NULL)\n\t\tfatal(\"allocation failed\");\n\n\t/* prepare buffer to collect messages to display to user after login */\n\tif ((loginmsg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tauth_debug_reset();\n\n\tif (use_privsep) {\n\t\tif (privsep_preauth(authctxt) == 1)\n\t\t\tgoto authenticated;\n\t} else if (have_agent) {\n\t\tif ((r = ssh_get_authentication_socket(&auth_sock)) != 0) {\n\t\t\terror(\"Unable to get agent socket: %s\", ssh_err(r));\n\t\t\thave_agent = 0;\n\t\t}\n\t}\n\n\t/* perform the key exchange */\n\t/* authenticate user and start session */\n\tdo_ssh2_kex();\n\tdo_authentication2(authctxt);\n\n\t/*\n\t * If we use privilege separation, the unprivileged child transfers\n\t * the current keystate and exits\n\t */\n\tif (use_privsep) {\n\t\tmm_send_keystate(pmonitor);\n\t\tpacket_clear_keys();\n\t\texit(0);\n\t}\n\n authenticated:\n\t/*\n\t * Cancel the alarm we set to limit the time taken for\n\t * authentication.\n\t */\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tauthctxt->authenticated = 1;\n\tif (startup_pipe != -1) {\n\t\tclose(startup_pipe);\n\t\tstartup_pipe = -1;\n\t}\n\n#ifdef SSH_AUDIT_EVENTS\n\taudit_event(SSH_AUTH_SUCCESS);\n#endif\n\n#ifdef GSSAPI\n\tif (options.gss_authentication) {\n\t\ttemporarily_use_uid(authctxt->pw);\n\t\tssh_gssapi_storecreds();\n\t\trestore_uid();\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam) {\n\t\tdo_pam_setcred(1);\n\t\tdo_pam_session(ssh);\n\t}\n#endif\n\n\t/*\n\t * In privilege separation, we fork another child and prepare\n\t * file descriptor passing.\n\t */\n\tif (use_privsep) {\n\t\tprivsep_postauth(authctxt);\n\t\t/* the monitor process [priv] will not return */\n\t}\n\n\tpacket_set_timeout(options.client_alive_interval,\n\t    options.client_alive_count_max);\n\n\t/* Try to send all our hostkeys to the client */\n\tnotify_hostkeys(ssh);\n\n\t/* Start session. */\n\tdo_authenticated(ssh, authctxt);\n\n\t/* The connection has been terminated. */\n\tpacket_get_bytes(&ibytes, &obytes);\n\tverbose(\"Transferred: sent %llu, received %llu bytes\",\n\t    (unsigned long long)obytes, (unsigned long long)ibytes);\n\n\tverbose(\"Closing connection to %.500s port %d\", remote_ip, remote_port);\n\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\tfinish_pam();\n#endif /* USE_PAM */\n\n#ifdef SSH_AUDIT_EVENTS\n\tPRIVSEP(audit_event(SSH_CONNECTION_CLOSE));\n#endif\n\n\tpacket_close();\n\n\tif (use_privsep)\n\t\tmm_terminate();\n\n\texit(0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define REEXEC_MIN_FREE_FD\t\t(STDERR_FILENO + 4)",
      "#define REEXEC_CONFIG_PASS_FD\t\t(STDERR_FILENO + 3)",
      "#define REEXEC_STARTUP_PIPE_FD\t\t(STDERR_FILENO + 2)",
      "#define REEXEC_DEVCRYPTO_RESERVED_FD\t(STDERR_FILENO + 1)"
    ],
    "globals_used": [
      "extern char *__progname;",
      "ServerOptions options;",
      "char *config_file_name = _PATH_SERVER_CONFIG_FILE;",
      "int debug_flag = 0;",
      "int test_flag = 0;",
      "int inetd_flag = 0;",
      "int no_daemon_flag = 0;",
      "int log_stderr = 0;",
      "char **saved_argv;",
      "int saved_argc;",
      "int rexeced_flag = 0;",
      "int rexec_flag = 1;",
      "int rexec_argc = 0;",
      "char **rexec_argv;",
      "int auth_sock = -1;",
      "int have_agent = 0;",
      "struct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;",
      "u_int utmp_len = HOST_NAME_MAX+1;",
      "int startup_pipe;",
      "int use_privsep = -1;",
      "struct monitor *pmonitor = NULL;",
      "static int privsep_chroot = 1;",
      "Authctxt *the_authctxt = NULL;",
      "struct sshauthopt *auth_opts = NULL;",
      "struct sshbuf *cfg;",
      "struct sshbuf *loginmsg;",
      "struct passwd *privsep_pw = NULL;",
      "static void do_ssh2_kex(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "2331-2353",
          "snippet": "void\ncleanup_exit(int i)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (the_authctxt) {\n\t\tdo_cleanup(ssh, the_authctxt);\n\t\tif (use_privsep && privsep_is_preauth &&\n\t\t    pmonitor != NULL && pmonitor->m_pid > 1) {\n\t\t\tdebug(\"Killing privsep child %d\", pmonitor->m_pid);\n\t\t\tif (kill(pmonitor->m_pid, SIGKILL) != 0 &&\n\t\t\t    errno != ESRCH)\n\t\t\t\terror(\"%s: kill(%d): %s\", __func__,\n\t\t\t\t    pmonitor->m_pid, strerror(errno));\n\t\t}\n\t}\n#ifdef SSH_AUDIT_EVENTS\n\t/* done after do_cleanup so it can cancel the PAM auth 'thread' */\n\tif (!use_privsep || mm_is_monitor())\n\t\taudit_event(SSH_CONNECTION_ABANDON);\n#endif\n\t_exit(i);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int use_privsep = -1;",
            "struct monitor *pmonitor = NULL;",
            "int privsep_is_preauth = 1;",
            "Authctxt *the_authctxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint use_privsep = -1;\nstruct monitor *pmonitor = NULL;\nint privsep_is_preauth = 1;\nAuthctxt *the_authctxt = NULL;\n\nvoid\ncleanup_exit(int i)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (the_authctxt) {\n\t\tdo_cleanup(ssh, the_authctxt);\n\t\tif (use_privsep && privsep_is_preauth &&\n\t\t    pmonitor != NULL && pmonitor->m_pid > 1) {\n\t\t\tdebug(\"Killing privsep child %d\", pmonitor->m_pid);\n\t\t\tif (kill(pmonitor->m_pid, SIGKILL) != 0 &&\n\t\t\t    errno != ESRCH)\n\t\t\t\terror(\"%s: kill(%d): %s\", __func__,\n\t\t\t\t    pmonitor->m_pid, strerror(errno));\n\t\t}\n\t}\n#ifdef SSH_AUDIT_EVENTS\n\t/* done after do_cleanup so it can cancel the PAM auth 'thread' */\n\tif (!use_privsep || mm_is_monitor())\n\t\taudit_event(SSH_CONNECTION_ABANDON);\n#endif\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_terminate",
          "args": [],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "mm_terminate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "783-792",
          "snippet": "void\nmm_terminate(void)\n{\n\tstruct sshbuf *m;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_TERM, m);\n\tsshbuf_free(m);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct monitor *pmonitor;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern struct monitor *pmonitor;\n\nvoid\nmm_terminate(void)\n{\n\tstruct sshbuf *m;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_TERM, m);\n\tsshbuf_free(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_close",
          "args": [],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "packet_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "255-260",
          "snippet": "void\npacket_close(void)\n{\n\tssh_packet_close(active_state);\n\tactive_state = NULL;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_close(void)\n{\n\tssh_packet_close(active_state);\n\tactive_state = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRIVSEP",
          "args": [
            "audit_event(SSH_CONNECTION_CLOSE)"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_event",
          "args": [
            "SSH_CONNECTION_CLOSE"
          ],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "audit_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit.c",
          "lines": "133-138",
          "snippet": "void\naudit_event(ssh_audit_event_t event)\n{\n\tdebug(\"audit event euid %d user %s event %d (%s)\", geteuid(),\n\t    audit_username(), event, audit_event_lookup(event));\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"log.h\"",
            "#include \"audit.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"audit.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\naudit_event(ssh_audit_event_t event)\n{\n\tdebug(\"audit event euid %d user %s event %d (%s)\", geteuid(),\n\t    audit_username(), event, audit_event_lookup(event));\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_pam",
          "args": [],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "finish_pam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "1007-1011",
          "snippet": "void\nfinish_pam(void)\n{\n\tsshpam_cleanup();\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfinish_pam(void)\n{\n\tsshpam_cleanup();\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Closing connection to %.500s port %d\"",
            "remote_ip",
            "remote_port"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_bytes",
          "args": [
            "&ibytes",
            "&obytes"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_authenticated",
          "args": [
            "ssh",
            "authctxt"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "do_authenticated2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2635-2639",
          "snippet": "static void\ndo_authenticated2(struct ssh *ssh, Authctxt *authctxt)\n{\n\tserver_loop2(ssh, authctxt);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void do_authenticated2(struct ssh *, Authctxt *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void do_authenticated2(struct ssh *, Authctxt *);\n\nstatic void\ndo_authenticated2(struct ssh *ssh, Authctxt *authctxt)\n{\n\tserver_loop2(ssh, authctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notify_hostkeys",
          "args": [
            "ssh"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "notify_hostkeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "842-884",
          "snippet": "static void\nnotify_hostkeys(struct ssh *ssh)\n{\n\tstruct sshbuf *buf;\n\tstruct sshkey *key;\n\tu_int i, nkeys;\n\tint r;\n\tchar *fp;\n\n\t/* Some clients cannot cope with the hostkeys message, skip those. */\n\tif (datafellows & SSH_BUG_HOSTKEYS)\n\t\treturn;\n\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tfor (i = nkeys = 0; i < options.num_host_key_files; i++) {\n\t\tkey = get_hostkey_public_by_index(i, ssh);\n\t\tif (key == NULL || key->type == KEY_UNSPEC ||\n\t\t    sshkey_is_cert(key))\n\t\t\tcontinue;\n\t\tfp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\tdebug3(\"%s: key %d: %s %s\", __func__, i,\n\t\t    sshkey_ssh_name(key), fp);\n\t\tfree(fp);\n\t\tif (nkeys == 0) {\n\t\t\tpacket_start(SSH2_MSG_GLOBAL_REQUEST);\n\t\t\tpacket_put_cstring(\"hostkeys-00@openssh.com\");\n\t\t\tpacket_put_char(0); /* want-reply */\n\t\t}\n\t\tsshbuf_reset(buf);\n\t\tif ((r = sshkey_putb(key, buf)) != 0)\n\t\t\tfatal(\"%s: couldn't put hostkey %d: %s\",\n\t\t\t    __func__, i, ssh_err(r));\n\t\tpacket_put_string(sshbuf_ptr(buf), sshbuf_len(buf));\n\t\tnkeys++;\n\t}\n\tdebug3(\"%s: sent %u hostkeys\", __func__, nkeys);\n\tif (nkeys == 0)\n\t\tfatal(\"%s: no hostkeys\", __func__);\n\tpacket_send();\n\tsshbuf_free(buf);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\n\nstatic void\nnotify_hostkeys(struct ssh *ssh)\n{\n\tstruct sshbuf *buf;\n\tstruct sshkey *key;\n\tu_int i, nkeys;\n\tint r;\n\tchar *fp;\n\n\t/* Some clients cannot cope with the hostkeys message, skip those. */\n\tif (datafellows & SSH_BUG_HOSTKEYS)\n\t\treturn;\n\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tfor (i = nkeys = 0; i < options.num_host_key_files; i++) {\n\t\tkey = get_hostkey_public_by_index(i, ssh);\n\t\tif (key == NULL || key->type == KEY_UNSPEC ||\n\t\t    sshkey_is_cert(key))\n\t\t\tcontinue;\n\t\tfp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\tdebug3(\"%s: key %d: %s %s\", __func__, i,\n\t\t    sshkey_ssh_name(key), fp);\n\t\tfree(fp);\n\t\tif (nkeys == 0) {\n\t\t\tpacket_start(SSH2_MSG_GLOBAL_REQUEST);\n\t\t\tpacket_put_cstring(\"hostkeys-00@openssh.com\");\n\t\t\tpacket_put_char(0); /* want-reply */\n\t\t}\n\t\tsshbuf_reset(buf);\n\t\tif ((r = sshkey_putb(key, buf)) != 0)\n\t\t\tfatal(\"%s: couldn't put hostkey %d: %s\",\n\t\t\t    __func__, i, ssh_err(r));\n\t\tpacket_put_string(sshbuf_ptr(buf), sshbuf_len(buf));\n\t\tnkeys++;\n\t}\n\tdebug3(\"%s: sent %u hostkeys\", __func__, nkeys);\n\tif (nkeys == 0)\n\t\tfatal(\"%s: no hostkeys\", __func__);\n\tpacket_send();\n\tsshbuf_free(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_set_timeout",
          "args": [
            "options.client_alive_interval",
            "options.client_alive_count_max"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "privsep_postauth",
          "args": [
            "authctxt"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_pam_session",
          "args": [
            "ssh"
          ],
          "line": 2191
        },
        "resolved": true,
        "details": {
          "function_name": "do_pam_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "1143-1165",
          "snippet": "void\ndo_pam_session(struct ssh *ssh)\n{\n\tdebug3(\"PAM: opening session\");\n\n\texpose_authinfo(__func__);\n\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&store_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: failed to set PAM_CONV: %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\tsshpam_err = pam_open_session(sshpam_handle, 0);\n\tif (sshpam_err == PAM_SUCCESS)\n\t\tsshpam_session_open = 1;\n\telse {\n\t\tsshpam_session_open = 0;\n\t\tauth_restrict_session(ssh);\n\t\terror(\"PAM: pam_open_session(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\t}\n\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndo_pam_session(struct ssh *ssh)\n{\n\tdebug3(\"PAM: opening session\");\n\n\texpose_authinfo(__func__);\n\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&store_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: failed to set PAM_CONV: %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\tsshpam_err = pam_open_session(sshpam_handle, 0);\n\tif (sshpam_err == PAM_SUCCESS)\n\t\tsshpam_session_open = 1;\n\telse {\n\t\tsshpam_session_open = 0;\n\t\tauth_restrict_session(ssh);\n\t\terror(\"PAM: pam_open_session(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_pam_setcred",
          "args": [
            "1"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "do_pam_setcred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "1039-1064",
          "snippet": "void\ndo_pam_setcred(int init)\n{\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&store_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: failed to set PAM_CONV: %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\tif (init) {\n\t\tdebug(\"PAM: establishing credentials\");\n\t\tsshpam_err = pam_setcred(sshpam_handle, PAM_ESTABLISH_CRED);\n\t} else {\n\t\tdebug(\"PAM: reinitializing credentials\");\n\t\tsshpam_err = pam_setcred(sshpam_handle, PAM_REINITIALIZE_CRED);\n\t}\n\tif (sshpam_err == PAM_SUCCESS) {\n\t\tsshpam_cred_established = 1;\n\t\treturn;\n\t}\n\tif (sshpam_authenticated)\n\t\tfatal(\"PAM: pam_setcred(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\telse\n\t\tdebug(\"PAM: pam_setcred(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndo_pam_setcred(int init)\n{\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&store_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: failed to set PAM_CONV: %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\tif (init) {\n\t\tdebug(\"PAM: establishing credentials\");\n\t\tsshpam_err = pam_setcred(sshpam_handle, PAM_ESTABLISH_CRED);\n\t} else {\n\t\tdebug(\"PAM: reinitializing credentials\");\n\t\tsshpam_err = pam_setcred(sshpam_handle, PAM_REINITIALIZE_CRED);\n\t}\n\tif (sshpam_err == PAM_SUCCESS) {\n\t\tsshpam_cred_established = 1;\n\t\treturn;\n\t}\n\tif (sshpam_authenticated)\n\t\tfatal(\"PAM: pam_setcred(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\telse\n\t\tdebug(\"PAM: pam_setcred(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_uid",
          "args": [],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "restore_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "141-172",
          "snippet": "void\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_storecreds",
          "args": [],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_storecreds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-serv.c",
          "lines": "331-338",
          "snippet": "void\nssh_gssapi_storecreds(void)\n{\n\tif (gssapi_client.mech && gssapi_client.mech->storecreds) {\n\t\t(*gssapi_client.mech->storecreds)(&gssapi_client);\n\t} else\n\t\tdebug(\"ssh_gssapi_storecreds: Not a GSSAPI mechanism\");\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_gssapi_storecreds(void)\n{\n\tif (gssapi_client.mech && gssapi_client.mech->storecreds) {\n\t\t(*gssapi_client.mech->storecreds)(&gssapi_client);\n\t} else\n\t\tdebug(\"ssh_gssapi_storecreds: Not a GSSAPI mechanism\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "temporarily_use_uid",
          "args": [
            "authctxt->pw"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "temporarily_use_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "60-136",
          "snippet": "void\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static uid_t\tuser_groups_uid;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic uid_t\tuser_groups_uid;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "startup_pipe"
          ],
          "line": 2173
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGALRM",
            "SIG_DFL"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarm",
          "args": [
            "0"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "grace_alarm_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "346-364",
          "snippet": "static void\ngrace_alarm_handler(int sig)\n{\n\tif (use_privsep && pmonitor != NULL && pmonitor->m_pid > 0)\n\t\tkill(pmonitor->m_pid, SIGALRM);\n\n\t/*\n\t * Try to kill any processes that we have spawned, E.g. authorized\n\t * keys command helpers.\n\t */\n\tif (getpgid(0) == getpid()) {\n\t\tsignal(SIGTERM, SIG_IGN);\n\t\tkill(0, SIGTERM);\n\t}\n\n\t/* Log error and exit. */\n\tsigdie(\"Timeout before authentication for %s port %d\",\n\t    ssh_remote_ipaddr(active_state), ssh_remote_port(active_state));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int use_privsep = -1;",
            "struct monitor *pmonitor = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint use_privsep = -1;\nstruct monitor *pmonitor = NULL;\n\nstatic void\ngrace_alarm_handler(int sig)\n{\n\tif (use_privsep && pmonitor != NULL && pmonitor->m_pid > 0)\n\t\tkill(pmonitor->m_pid, SIGALRM);\n\n\t/*\n\t * Try to kill any processes that we have spawned, E.g. authorized\n\t * keys command helpers.\n\t */\n\tif (getpgid(0) == getpid()) {\n\t\tsignal(SIGTERM, SIG_IGN);\n\t\tkill(0, SIGTERM);\n\t}\n\n\t/* Log error and exit. */\n\tsigdie(\"Timeout before authentication for %s port %d\",\n\t    ssh_remote_ipaddr(active_state), ssh_remote_port(active_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_clear_keys",
          "args": [],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_send_keystate",
          "args": [
            "pmonitor"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "mm_send_keystate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "534-549",
          "snippet": "void\nmm_send_keystate(struct monitor *monitor)\n{\n\tstruct ssh *ssh = active_state;\t\t/* XXX */\n\tstruct sshbuf *m;\n\tint r;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = ssh_packet_get_state(ssh, m)) != 0)\n\t\tfatal(\"%s: get_state failed: %s\",\n\t\t    __func__, ssh_err(r));\n\tmm_request_send(monitor->m_recvfd, MONITOR_REQ_KEYEXPORT, m);\n\tdebug3(\"%s: Finished sending state\", __func__);\n\tsshbuf_free(m);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmm_send_keystate(struct monitor *monitor)\n{\n\tstruct ssh *ssh = active_state;\t\t/* XXX */\n\tstruct sshbuf *m;\n\tint r;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = ssh_packet_get_state(ssh, m)) != 0)\n\t\tfatal(\"%s: get_state failed: %s\",\n\t\t    __func__, ssh_err(r));\n\tmm_request_send(monitor->m_recvfd, MONITOR_REQ_KEYEXPORT, m);\n\tdebug3(\"%s: Finished sending state\", __func__);\n\tsshbuf_free(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_authentication2",
          "args": [
            "authctxt"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "do_authentication2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "169-178",
          "snippet": "void\ndo_authentication2(Authctxt *authctxt)\n{\n\tstruct ssh *ssh = active_state;\t\t/* XXX */\n\tssh->authctxt = authctxt;\t\t/* XXX move to caller */\n\tssh_dispatch_init(ssh, &dispatch_protocol_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_SERVICE_REQUEST, &input_service_request);\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &authctxt->success);\n\tssh->authctxt = NULL;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int input_service_request(int, u_int32_t, struct ssh *);",
            "static int input_userauth_request(int, u_int32_t, struct ssh *);",
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int input_service_request(int, u_int32_t, struct ssh *);\nstatic int input_userauth_request(int, u_int32_t, struct ssh *);\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\nvoid\ndo_authentication2(Authctxt *authctxt)\n{\n\tstruct ssh *ssh = active_state;\t\t/* XXX */\n\tssh->authctxt = authctxt;\t\t/* XXX move to caller */\n\tssh_dispatch_init(ssh, &dispatch_protocol_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_SERVICE_REQUEST, &input_service_request);\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &authctxt->success);\n\tssh->authctxt = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_ssh2_kex",
          "args": [],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "do_ssh2_kex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "2262-2328",
          "snippet": "static void\ndo_ssh2_kex(void)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_SERVER };\n\tstruct kex *kex;\n\tint r;\n\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(\n\t    options.kex_algorithms);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] = compat_cipher_proposal(\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] = compat_cipher_proposal(\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\n\tif (options.compression == COMP_NONE) {\n\t\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t\t    myproposal[PROPOSAL_COMP_ALGS_STOC] = \"none\";\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tpacket_set_rekey_limits(options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = compat_pkalg_proposal(\n\t    list_hostkey_types());\n\n\t/* start key exchange */\n\tif ((r = kex_setup(active_state, myproposal)) != 0)\n\t\tfatal(\"kex_setup: %s\", ssh_err(r));\n\tkex = active_state->kex;\n#ifdef WITH_OPENSSL\n\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\tkex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n# endif\n#endif\n\tkex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\tkex->server = 1;\n\tkex->client_version_string=client_version_string;\n\tkex->server_version_string=server_version_string;\n\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\tkex->host_key_index=&get_hostkey_index;\n\tkex->sign = sshd_hostkey_sign;\n\n\tssh_dispatch_run_fatal(active_state, DISPATCH_BLOCK, &kex->done);\n\n\tsession_id2 = kex->session_id;\n\tsession_id2_len = kex->session_id_len;\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tpacket_start(SSH2_MSG_IGNORE);\n\tpacket_put_cstring(\"markus\");\n\tpacket_send();\n\tpacket_write_wait();\n#endif\n\tdebug(\"KEX done\");\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;",
            "char *client_version_string = NULL;",
            "char *server_version_string = NULL;",
            "u_char session_id[16];",
            "u_char *session_id2 = NULL;",
            "u_int session_id2_len = 0;",
            "static void do_ssh2_kex(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nchar *client_version_string = NULL;\nchar *server_version_string = NULL;\nu_char session_id[16];\nu_char *session_id2 = NULL;\nu_int session_id2_len = 0;\nstatic void do_ssh2_kex(void);\n\nstatic void\ndo_ssh2_kex(void)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_SERVER };\n\tstruct kex *kex;\n\tint r;\n\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(\n\t    options.kex_algorithms);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] = compat_cipher_proposal(\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] = compat_cipher_proposal(\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\n\tif (options.compression == COMP_NONE) {\n\t\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t\t    myproposal[PROPOSAL_COMP_ALGS_STOC] = \"none\";\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tpacket_set_rekey_limits(options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = compat_pkalg_proposal(\n\t    list_hostkey_types());\n\n\t/* start key exchange */\n\tif ((r = kex_setup(active_state, myproposal)) != 0)\n\t\tfatal(\"kex_setup: %s\", ssh_err(r));\n\tkex = active_state->kex;\n#ifdef WITH_OPENSSL\n\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\tkex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n# endif\n#endif\n\tkex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\tkex->server = 1;\n\tkex->client_version_string=client_version_string;\n\tkex->server_version_string=server_version_string;\n\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\tkex->host_key_index=&get_hostkey_index;\n\tkex->sign = sshd_hostkey_sign;\n\n\tssh_dispatch_run_fatal(active_state, DISPATCH_BLOCK, &kex->done);\n\n\tsession_id2 = kex->session_id;\n\tsession_id2_len = kex->session_id_len;\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tpacket_start(SSH2_MSG_IGNORE);\n\tpacket_put_cstring(\"markus\");\n\tpacket_send();\n\tpacket_write_wait();\n#endif\n\tdebug(\"KEX done\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unable to get agent socket: %s\"",
            "ssh_err(r)"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_get_authentication_socket",
          "args": [
            "&auth_sock"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_get_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "86-120",
          "snippet": "int\nssh_get_authentication_socket(int *fdp)\n{\n\tconst char *authsocket;\n\tint sock, oerrno;\n\tstruct sockaddr_un sunaddr;\n\n\tif (fdp != NULL)\n\t\t*fdp = -1;\n\n\tauthsocket = getenv(SSH_AUTHSOCKET_ENV_NAME);\n\tif (!authsocket)\n\t\treturn SSH_ERR_AGENT_NOT_PRESENT;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tstrlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));\n\n\tif ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\t/* close on exec */\n\tif (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1 ||\n\t    connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\toerrno = errno;\n\t\tclose(sock);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (fdp != NULL)\n\t\t*fdp = sock;\n\telse\n\t\tclose(sock);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_get_authentication_socket(int *fdp)\n{\n\tconst char *authsocket;\n\tint sock, oerrno;\n\tstruct sockaddr_un sunaddr;\n\n\tif (fdp != NULL)\n\t\t*fdp = -1;\n\n\tauthsocket = getenv(SSH_AUTHSOCKET_ENV_NAME);\n\tif (!authsocket)\n\t\treturn SSH_ERR_AGENT_NOT_PRESENT;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tstrlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));\n\n\tif ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\t/* close on exec */\n\tif (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1 ||\n\t    connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\toerrno = errno;\n\t\tclose(sock);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (fdp != NULL)\n\t\t*fdp = sock;\n\telse\n\t\tclose(sock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "privsep_preauth",
          "args": [
            "authctxt"
          ],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "privsep_preauth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "566-633",
          "snippet": "static int\nprivsep_preauth(Authctxt *authctxt)\n{\n\tint status, r;\n\tpid_t pid;\n\tstruct ssh_sandbox *box = NULL;\n\n\t/* Set up unprivileged child process to deal with network data */\n\tpmonitor = monitor_init();\n\t/* Store a pointer to the kex for later rekeying */\n\tpmonitor->m_pkex = &active_state->kex;\n\n\tif (use_privsep == PRIVSEP_ON)\n\t\tbox = ssh_sandbox_init(pmonitor);\n\tpid = fork();\n\tif (pid == -1) {\n\t\tfatal(\"fork of unprivileged child failed\");\n\t} else if (pid != 0) {\n\t\tdebug2(\"Network child is on pid %ld\", (long)pid);\n\n\t\tpmonitor->m_pid = pid;\n\t\tif (have_agent) {\n\t\t\tr = ssh_get_authentication_socket(&auth_sock);\n\t\t\tif (r != 0) {\n\t\t\t\terror(\"Could not get agent socket: %s\",\n\t\t\t\t    ssh_err(r));\n\t\t\t\thave_agent = 0;\n\t\t\t}\n\t\t}\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_preauth(box, pid);\n\t\tmonitor_child_preauth(authctxt, pmonitor);\n\n\t\t/* Wait for the child's exit status */\n\t\twhile (waitpid(pid, &status, 0) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tpmonitor->m_pid = -1;\n\t\t\tfatal(\"%s: waitpid: %s\", __func__, strerror(errno));\n\t\t}\n\t\tprivsep_is_preauth = 0;\n\t\tpmonitor->m_pid = -1;\n\t\tif (WIFEXITED(status)) {\n\t\t\tif (WEXITSTATUS(status) != 0)\n\t\t\t\tfatal(\"%s: preauth child exited with status %d\",\n\t\t\t\t    __func__, WEXITSTATUS(status));\n\t\t} else if (WIFSIGNALED(status))\n\t\t\tfatal(\"%s: preauth child terminated by signal %d\",\n\t\t\t    __func__, WTERMSIG(status));\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_finish(box);\n\t\treturn 1;\n\t} else {\n\t\t/* child */\n\t\tclose(pmonitor->m_sendfd);\n\t\tclose(pmonitor->m_log_recvfd);\n\n\t\t/* Arrange for logging to be sent to the monitor */\n\t\tset_log_handler(mm_log_handler, pmonitor);\n\n\t\tprivsep_preauth_child();\n\t\tsetproctitle(\"%s\", \"[net]\");\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_child(box);\n\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int auth_sock = -1;",
            "int have_agent = 0;",
            "int use_privsep = -1;",
            "struct monitor *pmonitor = NULL;",
            "int privsep_is_preauth = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint auth_sock = -1;\nint have_agent = 0;\nint use_privsep = -1;\nstruct monitor *pmonitor = NULL;\nint privsep_is_preauth = 1;\n\nstatic int\nprivsep_preauth(Authctxt *authctxt)\n{\n\tint status, r;\n\tpid_t pid;\n\tstruct ssh_sandbox *box = NULL;\n\n\t/* Set up unprivileged child process to deal with network data */\n\tpmonitor = monitor_init();\n\t/* Store a pointer to the kex for later rekeying */\n\tpmonitor->m_pkex = &active_state->kex;\n\n\tif (use_privsep == PRIVSEP_ON)\n\t\tbox = ssh_sandbox_init(pmonitor);\n\tpid = fork();\n\tif (pid == -1) {\n\t\tfatal(\"fork of unprivileged child failed\");\n\t} else if (pid != 0) {\n\t\tdebug2(\"Network child is on pid %ld\", (long)pid);\n\n\t\tpmonitor->m_pid = pid;\n\t\tif (have_agent) {\n\t\t\tr = ssh_get_authentication_socket(&auth_sock);\n\t\t\tif (r != 0) {\n\t\t\t\terror(\"Could not get agent socket: %s\",\n\t\t\t\t    ssh_err(r));\n\t\t\t\thave_agent = 0;\n\t\t\t}\n\t\t}\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_preauth(box, pid);\n\t\tmonitor_child_preauth(authctxt, pmonitor);\n\n\t\t/* Wait for the child's exit status */\n\t\twhile (waitpid(pid, &status, 0) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tpmonitor->m_pid = -1;\n\t\t\tfatal(\"%s: waitpid: %s\", __func__, strerror(errno));\n\t\t}\n\t\tprivsep_is_preauth = 0;\n\t\tpmonitor->m_pid = -1;\n\t\tif (WIFEXITED(status)) {\n\t\t\tif (WEXITSTATUS(status) != 0)\n\t\t\t\tfatal(\"%s: preauth child exited with status %d\",\n\t\t\t\t    __func__, WEXITSTATUS(status));\n\t\t} else if (WIFSIGNALED(status))\n\t\t\tfatal(\"%s: preauth child terminated by signal %d\",\n\t\t\t    __func__, WTERMSIG(status));\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_finish(box);\n\t\treturn 1;\n\t} else {\n\t\t/* child */\n\t\tclose(pmonitor->m_sendfd);\n\t\tclose(pmonitor->m_log_recvfd);\n\n\t\t/* Arrange for logging to be sent to the monitor */\n\t\tset_log_handler(mm_log_handler, pmonitor);\n\n\t\tprivsep_preauth_child();\n\t\tsetproctitle(\"%s\", \"[net]\");\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_child(box);\n\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_debug_reset",
          "args": [],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "auth_debug_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "708-715",
          "snippet": "void\nauth_debug_reset(void)\n{\n\tif (auth_debug != NULL)\n\t\tsshbuf_reset(auth_debug);\n\telse if ((auth_debug = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sshbuf *auth_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *auth_debug;\n\nvoid\nauth_debug_reset(void)\n{\n\tif (auth_debug != NULL)\n\t\tsshbuf_reset(auth_debug);\n\telse if ((auth_debug = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"allocation failed\""
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshauthopt_new_with_keys_defaults",
          "args": [],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_new_with_keys_defaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "294-309",
          "snippet": "struct sshauthopt *\nsshauthopt_new_with_keys_defaults(void)\n{\n\tstruct sshauthopt *ret = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Defaults for authorized_keys flags */\n\tret->permit_port_forwarding_flag = 1;\n\tret->permit_agent_forwarding_flag = 1;\n\tret->permit_x11_forwarding_flag = 1;\n\tret->permit_pty_flag = 1;\n\tret->permit_user_rc = 1;\n\treturn ret;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshauthopt *\nsshauthopt_new_with_keys_defaults(void)\n{\n\tstruct sshauthopt *ret = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Defaults for authorized_keys flags */\n\tret->permit_port_forwarding_flag = 1;\n\tret->permit_agent_forwarding_flag = 1;\n\tret->permit_x11_forwarding_flag = 1;\n\tret->permit_pty_flag = 1;\n\tret->permit_user_rc = 1;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(*authctxt)"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_set_nonblocking",
          "args": [],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshd_exchange_identification",
          "args": [
            "ssh",
            "sock_in",
            "sock_out"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "sshd_exchange_identification",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "366-466",
          "snippet": "static void\nsshd_exchange_identification(struct ssh *ssh, int sock_in, int sock_out)\n{\n\tu_int i;\n\tint remote_major, remote_minor;\n\tchar *s;\n\tchar buf[256];\t\t\t/* Must not be larger than remote_version. */\n\tchar remote_version[256];\t/* Must be at least as big as buf. */\n\n\txasprintf(&server_version_string, \"SSH-%d.%d-%.100s%s%s\\r\\n\",\n\t    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_VERSION,\n\t    *options.version_addendum == '\\0' ? \"\" : \" \",\n\t    options.version_addendum);\n\n\t/* Send our protocol version identification. */\n\tif (atomicio(vwrite, sock_out, server_version_string,\n\t    strlen(server_version_string))\n\t    != strlen(server_version_string)) {\n\t\tlogit(\"Could not write ident string to %s port %d\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\tcleanup_exit(255);\n\t}\n\n\t/* Read other sides version identification. */\n\tmemset(buf, 0, sizeof(buf));\n\tfor (i = 0; i < sizeof(buf) - 1; i++) {\n\t\tif (atomicio(read, sock_in, &buf[i], 1) != 1) {\n\t\t\tlogit(\"Did not receive identification string \"\n\t\t\t    \"from %s port %d\",\n\t\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\t\tcleanup_exit(255);\n\t\t}\n\t\tif (buf[i] == '\\r') {\n\t\t\tbuf[i] = 0;\n\t\t\t/* Kludge for F-Secure Macintosh < 1.0.2 */\n\t\t\tif (i == 12 &&\n\t\t\t    strncmp(buf, \"SSH-1.5-W1.0\", 12) == 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[i] == '\\n') {\n\t\t\tbuf[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbuf[sizeof(buf) - 1] = 0;\n\tclient_version_string = xstrdup(buf);\n\n\t/*\n\t * Check that the versions match.  In future this might accept\n\t * several versions and set appropriate flags to handle them.\n\t */\n\tif (sscanf(client_version_string, \"SSH-%d.%d-%[^\\n]\\n\",\n\t    &remote_major, &remote_minor, remote_version) != 3) {\n\t\ts = \"Protocol mismatch.\\n\";\n\t\t(void) atomicio(vwrite, sock_out, s, strlen(s));\n\t\tlogit(\"Bad protocol version identification '%.100s' \"\n\t\t    \"from %s port %d\", client_version_string,\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\tclose(sock_in);\n\t\tclose(sock_out);\n\t\tcleanup_exit(255);\n\t}\n\tdebug(\"Client protocol version %d.%d; client software version %.100s\",\n\t    remote_major, remote_minor, remote_version);\n\n\tssh->compat = compat_datafellows(remote_version);\n\n\tif ((ssh->compat & SSH_BUG_PROBE) != 0) {\n\t\tlogit(\"probed from %s port %d with %s.  Don't panic.\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    client_version_string);\n\t\tcleanup_exit(255);\n\t}\n\tif ((ssh->compat & SSH_BUG_SCANNER) != 0) {\n\t\tlogit(\"scanned from %s port %d with %s.  Don't panic.\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    client_version_string);\n\t\tcleanup_exit(255);\n\t}\n\tif ((ssh->compat & SSH_BUG_RSASIGMD5) != 0) {\n\t\tlogit(\"Client version \\\"%.100s\\\" uses unsafe RSA signature \"\n\t\t    \"scheme; disabling use of RSA keys\", remote_version);\n\t}\n\n\tchop(server_version_string);\n\tdebug(\"Local version string %.200s\", server_version_string);\n\n\tif (remote_major != 2 &&\n\t    !(remote_major == 1 && remote_minor == 99)) {\n\t\ts = \"Protocol major versions differ.\\n\";\n\t\t(void) atomicio(vwrite, sock_out, s, strlen(s));\n\t\tclose(sock_in);\n\t\tclose(sock_out);\n\t\tlogit(\"Protocol major versions differ for %s port %d: \"\n\t\t    \"%.200s vs. %.200s\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    server_version_string, client_version_string);\n\t\tcleanup_exit(255);\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;",
            "char *client_version_string = NULL;",
            "char *server_version_string = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nchar *client_version_string = NULL;\nchar *server_version_string = NULL;\n\nstatic void\nsshd_exchange_identification(struct ssh *ssh, int sock_in, int sock_out)\n{\n\tu_int i;\n\tint remote_major, remote_minor;\n\tchar *s;\n\tchar buf[256];\t\t\t/* Must not be larger than remote_version. */\n\tchar remote_version[256];\t/* Must be at least as big as buf. */\n\n\txasprintf(&server_version_string, \"SSH-%d.%d-%.100s%s%s\\r\\n\",\n\t    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_VERSION,\n\t    *options.version_addendum == '\\0' ? \"\" : \" \",\n\t    options.version_addendum);\n\n\t/* Send our protocol version identification. */\n\tif (atomicio(vwrite, sock_out, server_version_string,\n\t    strlen(server_version_string))\n\t    != strlen(server_version_string)) {\n\t\tlogit(\"Could not write ident string to %s port %d\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\tcleanup_exit(255);\n\t}\n\n\t/* Read other sides version identification. */\n\tmemset(buf, 0, sizeof(buf));\n\tfor (i = 0; i < sizeof(buf) - 1; i++) {\n\t\tif (atomicio(read, sock_in, &buf[i], 1) != 1) {\n\t\t\tlogit(\"Did not receive identification string \"\n\t\t\t    \"from %s port %d\",\n\t\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\t\tcleanup_exit(255);\n\t\t}\n\t\tif (buf[i] == '\\r') {\n\t\t\tbuf[i] = 0;\n\t\t\t/* Kludge for F-Secure Macintosh < 1.0.2 */\n\t\t\tif (i == 12 &&\n\t\t\t    strncmp(buf, \"SSH-1.5-W1.0\", 12) == 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[i] == '\\n') {\n\t\t\tbuf[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbuf[sizeof(buf) - 1] = 0;\n\tclient_version_string = xstrdup(buf);\n\n\t/*\n\t * Check that the versions match.  In future this might accept\n\t * several versions and set appropriate flags to handle them.\n\t */\n\tif (sscanf(client_version_string, \"SSH-%d.%d-%[^\\n]\\n\",\n\t    &remote_major, &remote_minor, remote_version) != 3) {\n\t\ts = \"Protocol mismatch.\\n\";\n\t\t(void) atomicio(vwrite, sock_out, s, strlen(s));\n\t\tlogit(\"Bad protocol version identification '%.100s' \"\n\t\t    \"from %s port %d\", client_version_string,\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\tclose(sock_in);\n\t\tclose(sock_out);\n\t\tcleanup_exit(255);\n\t}\n\tdebug(\"Client protocol version %d.%d; client software version %.100s\",\n\t    remote_major, remote_minor, remote_version);\n\n\tssh->compat = compat_datafellows(remote_version);\n\n\tif ((ssh->compat & SSH_BUG_PROBE) != 0) {\n\t\tlogit(\"probed from %s port %d with %s.  Don't panic.\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    client_version_string);\n\t\tcleanup_exit(255);\n\t}\n\tif ((ssh->compat & SSH_BUG_SCANNER) != 0) {\n\t\tlogit(\"scanned from %s port %d with %s.  Don't panic.\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    client_version_string);\n\t\tcleanup_exit(255);\n\t}\n\tif ((ssh->compat & SSH_BUG_RSASIGMD5) != 0) {\n\t\tlogit(\"Client version \\\"%.100s\\\" uses unsafe RSA signature \"\n\t\t    \"scheme; disabling use of RSA keys\", remote_version);\n\t}\n\n\tchop(server_version_string);\n\tdebug(\"Local version string %.200s\", server_version_string);\n\n\tif (remote_major != 2 &&\n\t    !(remote_major == 1 && remote_minor == 99)) {\n\t\ts = \"Protocol major versions differ.\\n\";\n\t\t(void) atomicio(vwrite, sock_out, s, strlen(s));\n\t\tclose(sock_in);\n\t\tclose(sock_out);\n\t\tlogit(\"Protocol major versions differ for %s port %d: \"\n\t\t    \"%.200s vs. %.200s\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    server_version_string, client_version_string);\n\t\tcleanup_exit(255);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "laddr"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_local_port",
          "args": [
            "ssh"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_local_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "560-565",
          "snippet": "int\nssh_local_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->local_port;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_local_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->local_port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_local_ipaddr",
          "args": [
            "sock_in"
          ],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "get_local_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "123-131",
          "snippet": "char *\nget_local_ipaddr(int sock)\n{\n\tchar *p;\n\n\tif ((p = get_socket_address(sock, 0, NI_NUMERICHOST)) != NULL)\n\t\treturn p;\n\treturn xstrdup(\"UNKNOWN\");\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nget_local_ipaddr(int sock)\n{\n\tchar *p;\n\n\tif ((p = get_socket_address(sock, 0, NI_NUMERICHOST)) != NULL)\n\t\treturn p;\n\treturn xstrdup(\"UNKNOWN\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_rdomain_in",
          "args": [
            "ssh"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_rdomain_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "568-577",
          "snippet": "const char *\nssh_packet_rdomain_in(struct ssh *ssh)\n{\n\tif (ssh->rdomain_in != NULL)\n\t\treturn ssh->rdomain_in;\n\tif (!ssh_packet_connection_is_on_socket(ssh))\n\t\treturn NULL;\n\tssh->rdomain_in = get_rdomain(ssh->state->connection_in);\n\treturn ssh->rdomain_in;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_packet_rdomain_in(struct ssh *ssh)\n{\n\tif (ssh->rdomain_in != NULL)\n\t\treturn ssh->rdomain_in;\n\tif (!ssh_packet_connection_is_on_socket(ssh))\n\t\treturn NULL;\n\tssh->rdomain_in = get_rdomain(ssh->state->connection_in);\n\treturn ssh->rdomain_in;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_connection_from",
          "args": [
            "remote_ip",
            "remote_port"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "audit_connection_from",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit.c",
          "lines": "122-127",
          "snippet": "void\naudit_connection_from(const char *host, int port)\n{\n\tdebug(\"audit connection from %s port %d euid %d\", host, port,\n\t    (int)geteuid());\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"log.h\"",
            "#include \"audit.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"audit.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\naudit_connection_from(const char *host, int port)\n{\n\tdebug(\"audit connection from %s port %d euid %d\", host, port,\n\t    (int)geteuid());\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_process_rdomain",
          "args": [
            "ssh",
            "options.routing_domain"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "set_process_rdomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "1387-1424",
          "snippet": "static void\nset_process_rdomain(struct ssh *ssh, const char *name)\n{\n#if defined(HAVE_SYS_SET_PROCESS_RDOMAIN)\n\tif (name == NULL)\n\t\treturn; /* default */\n\n\tif (strcmp(name, \"%D\") == 0) {\n\t\t/* \"expands\" to routing domain of connection */\n\t\tif ((name = ssh_packet_rdomain_in(ssh)) == NULL)\n\t\t\treturn;\n\t}\n\t/* NB. We don't pass 'ssh' to sys_set_process_rdomain() */\n\treturn sys_set_process_rdomain(name);\n#elif defined(__OpenBSD__)\n\tint rtable, ortable = getrtable();\n\tconst char *errstr;\n\n\tif (name == NULL)\n\t\treturn; /* default */\n\n\tif (strcmp(name, \"%D\") == 0) {\n\t\t/* \"expands\" to routing domain of connection */\n\t\tif ((name = ssh_packet_rdomain_in(ssh)) == NULL)\n\t\t\treturn;\n\t}\n\n\trtable = (int)strtonum(name, 0, 255, &errstr);\n\tif (errstr != NULL) /* Shouldn't happen */\n\t\tfatal(\"Invalid routing domain \\\"%s\\\": %s\", name, errstr);\n\tif (rtable != ortable && setrtable(rtable) != 0)\n\t\tfatal(\"Unable to set routing domain %d: %s\",\n\t\t    rtable, strerror(errno));\n\tdebug(\"%s: set routing domain %d (was %d)\", __func__, rtable, ortable);\n#else /* defined(__OpenBSD__) */\n\tfatal(\"Unable to set routing domain: not supported in this platform\");\n#endif\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nset_process_rdomain(struct ssh *ssh, const char *name)\n{\n#if defined(HAVE_SYS_SET_PROCESS_RDOMAIN)\n\tif (name == NULL)\n\t\treturn; /* default */\n\n\tif (strcmp(name, \"%D\") == 0) {\n\t\t/* \"expands\" to routing domain of connection */\n\t\tif ((name = ssh_packet_rdomain_in(ssh)) == NULL)\n\t\t\treturn;\n\t}\n\t/* NB. We don't pass 'ssh' to sys_set_process_rdomain() */\n\treturn sys_set_process_rdomain(name);\n#elif defined(__OpenBSD__)\n\tint rtable, ortable = getrtable();\n\tconst char *errstr;\n\n\tif (name == NULL)\n\t\treturn; /* default */\n\n\tif (strcmp(name, \"%D\") == 0) {\n\t\t/* \"expands\" to routing domain of connection */\n\t\tif ((name = ssh_packet_rdomain_in(ssh)) == NULL)\n\t\t\treturn;\n\t}\n\n\trtable = (int)strtonum(name, 0, 255, &errstr);\n\tif (errstr != NULL) /* Shouldn't happen */\n\t\tfatal(\"Invalid routing domain \\\"%s\\\": %s\", name, errstr);\n\tif (rtable != ortable && setrtable(rtable) != 0)\n\t\tfatal(\"Unable to set routing domain %d: %s\",\n\t\t    rtable, strerror(errno));\n\tdebug(\"%s: set routing domain %d (was %d)\", __func__, rtable, ortable);\n#else /* defined(__OpenBSD__) */\n\tfatal(\"Unable to set routing domain: not supported in this platform\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"ssh_remote_port failed\""
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_port",
          "args": [
            "ssh"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "539-544",
          "snippet": "int\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "sock_in",
            "SOL_SOCKET",
            "SO_KEEPALIVE",
            "&on",
            "sizeof(on)"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_connection_is_on_socket",
          "args": [],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_permitopen",
          "args": [
            "ssh",
            "&options"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "901-909",
          "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_set_af",
          "args": [
            "ssh",
            "options.address_family"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "channel_set_af",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3278-3282",
          "snippet": "void\nchannel_set_af(struct ssh *ssh, int af)\n{\n\tssh->chanctxt->IPv4or6 = af;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_set_af(struct ssh *ssh, int af)\n{\n\tssh->chanctxt->IPv4or6 = af;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_init_channels",
          "args": [
            "ssh"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "channel_init_channels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "225-242",
          "snippet": "void\nchannel_init_channels(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc;\n\n\tif ((sc = calloc(1, sizeof(*sc))) == NULL ||\n\t    (sc->channel_pre = calloc(SSH_CHANNEL_MAX_TYPE,\n\t    sizeof(*sc->channel_pre))) == NULL ||\n\t    (sc->channel_post = calloc(SSH_CHANNEL_MAX_TYPE,\n\t    sizeof(*sc->channel_post))) == NULL)\n\t\tfatal(\"%s: allocation failed\", __func__);\n\tsc->channels_alloc = 10;\n\tsc->channels = xcalloc(sc->channels_alloc, sizeof(*sc->channels));\n\tsc->IPv4or6 = AF_UNSPEC;\n\tchannel_handler_init(sc);\n\n\tssh->chanctxt = sc;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_init_channels(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc;\n\n\tif ((sc = calloc(1, sizeof(*sc))) == NULL ||\n\t    (sc->channel_pre = calloc(SSH_CHANNEL_MAX_TYPE,\n\t    sizeof(*sc->channel_pre))) == NULL ||\n\t    (sc->channel_post = calloc(SSH_CHANNEL_MAX_TYPE,\n\t    sizeof(*sc->channel_post))) == NULL)\n\t\tfatal(\"%s: allocation failed\", __func__);\n\tsc->channels_alloc = 10;\n\tsc->channels = xcalloc(sc->channels_alloc, sizeof(*sc->channels));\n\tsc->IPv4or6 = AF_UNSPEC;\n\tchannel_handler_init(sc);\n\n\tssh->chanctxt = sc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_ip_options",
          "args": [
            "ssh"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "check_ip_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "1355-1384",
          "snippet": "static void\ncheck_ip_options(struct ssh *ssh)\n{\n#ifdef IP_OPTIONS\n\tint sock_in = ssh_packet_get_connection_in(ssh);\n\tstruct sockaddr_storage from;\n\tu_char opts[200];\n\tsocklen_t i, option_size = sizeof(opts), fromlen = sizeof(from);\n\tchar text[sizeof(opts) * 3 + 1];\n\n\tmemset(&from, 0, sizeof(from));\n\tif (getpeername(sock_in, (struct sockaddr *)&from,\n\t    &fromlen) < 0)\n\t\treturn;\n\tif (from.ss_family != AF_INET)\n\t\treturn;\n\t/* XXX IPv6 options? */\n\n\tif (getsockopt(sock_in, IPPROTO_IP, IP_OPTIONS, opts,\n\t    &option_size) >= 0 && option_size != 0) {\n\t\ttext[0] = '\\0';\n\t\tfor (i = 0; i < option_size; i++)\n\t\t\tsnprintf(text + i*3, sizeof(text) - i*3,\n\t\t\t    \" %2.2x\", opts[i]);\n\t\tfatal(\"Connection from %.100s port %d with IP opts: %.800s\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh), text);\n\t}\n\treturn;\n#endif /* IP_OPTIONS */\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\n\nstatic void\ncheck_ip_options(struct ssh *ssh)\n{\n#ifdef IP_OPTIONS\n\tint sock_in = ssh_packet_get_connection_in(ssh);\n\tstruct sockaddr_storage from;\n\tu_char opts[200];\n\tsocklen_t i, option_size = sizeof(opts), fromlen = sizeof(from);\n\tchar text[sizeof(opts) * 3 + 1];\n\n\tmemset(&from, 0, sizeof(from));\n\tif (getpeername(sock_in, (struct sockaddr *)&from,\n\t    &fromlen) < 0)\n\t\treturn;\n\tif (from.ss_family != AF_INET)\n\t\treturn;\n\t/* XXX IPv6 options? */\n\n\tif (getsockopt(sock_in, IPPROTO_IP, IP_OPTIONS, opts,\n\t    &option_size) >= 0 && option_size != 0) {\n\t\ttext[0] = '\\0';\n\t\tfor (i = 0; i < option_size; i++)\n\t\t\tsnprintf(text + i*3, sizeof(text) - i*3,\n\t\t\t    \" %2.2x\", opts[i]);\n\t\tfatal(\"Connection from %.100s port %d with IP opts: %.800s\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh), text);\n\t}\n\treturn;\n#endif /* IP_OPTIONS */\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_set_server",
          "args": [],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_set_connection",
          "args": [
            "sock_in",
            "sock_out"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "packet_set_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "213-219",
          "snippet": "void\npacket_set_connection(int fd_in, int fd_out)\n{\n\tactive_state = ssh_packet_set_connection(active_state, fd_in, fd_out);\n\tif (active_state == NULL)\n\t\tfatal(\"%s: ssh_packet_set_connection failed\", __func__);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_set_connection(int fd_in, int fd_out)\n{\n\tactive_state = ssh_packet_set_connection(active_state, fd_in, fd_out);\n\tif (active_state == NULL)\n\t\tfatal(\"%s: ssh_packet_set_connection failed\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "sock_in",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "sock_out",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "STDOUT_FILENO"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "STDIN_FILENO"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_DEVNULL",
            "O_RDWR",
            "0"
          ],
          "line": 2030
        },
        "resolved": true,
        "details": {
          "function_name": "lastlog_openseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/loginrec.c",
          "lines": "1471-1514",
          "snippet": "static int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "# include <util.h>",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"canohost.h\"",
            "#include \"packet.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"loginrec.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int utmp_write_entry(struct logininfo *li);",
            "int utmpx_write_entry(struct logininfo *li);",
            "int wtmp_write_entry(struct logininfo *li);",
            "int wtmpx_write_entry(struct logininfo *li);",
            "int lastlog_write_entry(struct logininfo *li);",
            "int syslogin_write_entry(struct logininfo *li);",
            "int getlast_entry(struct logininfo *li);",
            "int lastlog_get_entry(struct logininfo *li);",
            "int utmpx_get_entry(struct logininfo *li);",
            "int wtmp_get_entry(struct logininfo *li);",
            "int wtmpx_get_entry(struct logininfo *li);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <util.h>\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"canohost.h\"\n#include \"packet.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"loginrec.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint utmp_write_entry(struct logininfo *li);\nint utmpx_write_entry(struct logininfo *li);\nint wtmp_write_entry(struct logininfo *li);\nint wtmpx_write_entry(struct logininfo *li);\nint lastlog_write_entry(struct logininfo *li);\nint syslogin_write_entry(struct logininfo *li);\nint getlast_entry(struct logininfo *li);\nint lastlog_get_entry(struct logininfo *li);\nint utmpx_get_entry(struct logininfo *li);\nint wtmp_get_entry(struct logininfo *li);\nint wtmpx_get_entry(struct logininfo *li);\n\nstatic int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 2029
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_init",
          "args": [
            "__progname",
            "options.log_level",
            "options.log_facility",
            "log_stderr"
          ],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "log_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "256-336",
          "snippet": "void\nlog_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)\n{\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\tstruct syslog_data sdata = SYSLOG_DATA_INIT;\n#endif\n\n\targv0 = av0;\n\n\tif (log_change_level(level) != 0) {\n\t\tfprintf(stderr, \"Unrecognized internal syslog level code %d\\n\",\n\t\t    (int) level);\n\t\texit(1);\n\t}\n\n\tlog_handler = NULL;\n\tlog_handler_ctx = NULL;\n\n\tlog_on_stderr = on_stderr;\n\tif (on_stderr)\n\t\treturn;\n\n\tswitch (facility) {\n\tcase SYSLOG_FACILITY_DAEMON:\n\t\tlog_facility = LOG_DAEMON;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_USER:\n\t\tlog_facility = LOG_USER;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_AUTH:\n\t\tlog_facility = LOG_AUTH;\n\t\tbreak;\n#ifdef LOG_AUTHPRIV\n\tcase SYSLOG_FACILITY_AUTHPRIV:\n\t\tlog_facility = LOG_AUTHPRIV;\n\t\tbreak;\n#endif\n\tcase SYSLOG_FACILITY_LOCAL0:\n\t\tlog_facility = LOG_LOCAL0;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL1:\n\t\tlog_facility = LOG_LOCAL1;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL2:\n\t\tlog_facility = LOG_LOCAL2;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL3:\n\t\tlog_facility = LOG_LOCAL3;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL4:\n\t\tlog_facility = LOG_LOCAL4;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL5:\n\t\tlog_facility = LOG_LOCAL5;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL6:\n\t\tlog_facility = LOG_LOCAL6;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL7:\n\t\tlog_facility = LOG_LOCAL7;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t    \"Unrecognized internal syslog facility code %d\\n\",\n\t\t    (int) facility);\n\t\texit(1);\n\t}\n\n\t/*\n\t * If an external library (eg libwrap) attempts to use syslog\n\t * immediately after reexec, syslog may be pointing to the wrong\n\t * facility, so we force an open/close of syslog here.\n\t */\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\topenlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);\n\tcloselog_r(&sdata);\n#else\n\topenlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);\n\tcloselog();\n#endif\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int log_on_stderr = 1;",
            "static int log_facility = LOG_AUTH;",
            "static char *argv0;",
            "static log_handler_fn *log_handler;",
            "static void *log_handler_ctx;",
            "extern char *__progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int log_on_stderr = 1;\nstatic int log_facility = LOG_AUTH;\nstatic char *argv0;\nstatic log_handler_fn *log_handler;\nstatic void *log_handler_ctx;\nextern char *__progname;\n\nvoid\nlog_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)\n{\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\tstruct syslog_data sdata = SYSLOG_DATA_INIT;\n#endif\n\n\targv0 = av0;\n\n\tif (log_change_level(level) != 0) {\n\t\tfprintf(stderr, \"Unrecognized internal syslog level code %d\\n\",\n\t\t    (int) level);\n\t\texit(1);\n\t}\n\n\tlog_handler = NULL;\n\tlog_handler_ctx = NULL;\n\n\tlog_on_stderr = on_stderr;\n\tif (on_stderr)\n\t\treturn;\n\n\tswitch (facility) {\n\tcase SYSLOG_FACILITY_DAEMON:\n\t\tlog_facility = LOG_DAEMON;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_USER:\n\t\tlog_facility = LOG_USER;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_AUTH:\n\t\tlog_facility = LOG_AUTH;\n\t\tbreak;\n#ifdef LOG_AUTHPRIV\n\tcase SYSLOG_FACILITY_AUTHPRIV:\n\t\tlog_facility = LOG_AUTHPRIV;\n\t\tbreak;\n#endif\n\tcase SYSLOG_FACILITY_LOCAL0:\n\t\tlog_facility = LOG_LOCAL0;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL1:\n\t\tlog_facility = LOG_LOCAL1;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL2:\n\t\tlog_facility = LOG_LOCAL2;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL3:\n\t\tlog_facility = LOG_LOCAL3;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL4:\n\t\tlog_facility = LOG_LOCAL4;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL5:\n\t\tlog_facility = LOG_LOCAL5;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL6:\n\t\tlog_facility = LOG_LOCAL6;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL7:\n\t\tlog_facility = LOG_LOCAL7;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t    \"Unrecognized internal syslog facility code %d\\n\",\n\t\t    (int) facility);\n\t\texit(1);\n\t}\n\n\t/*\n\t * If an external library (eg libwrap) attempts to use syslog\n\t * immediately after reexec, syslog may be pointing to the wrong\n\t * facility, so we force an open/close of syslog here.\n\t */\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\topenlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);\n\tcloselog_r(&sdata);\n#else\n\topenlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);\n\tcloselog();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "recv_rexec_state",
          "args": [
            "REEXEC_CONFIG_PASS_FD",
            "NULL"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "recv_rexec_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "964-994",
          "snippet": "static void\nrecv_rexec_state(int fd, struct sshbuf *conf)\n{\n\tstruct sshbuf *m;\n\tu_char *cp, ver;\n\tsize_t len;\n\tint r;\n\n\tdebug3(\"%s: entering fd = %d\", __func__, fd);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif (ssh_msg_recv(fd, m) == -1)\n\t\tfatal(\"%s: ssh_msg_recv failed\", __func__);\n\tif ((r = sshbuf_get_u8(m, &ver)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (ver != 0)\n\t\tfatal(\"%s: rexec version mismatch\", __func__);\n\tif ((r = sshbuf_get_string(m, &cp, &len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (conf != NULL && (r = sshbuf_put(conf, cp, len)))\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n#if defined(WITH_OPENSSL) && !defined(OPENSSL_PRNG_ONLY)\n\trexec_recv_rng_seed(m);\n#endif\n\n\tfree(cp);\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done\", __func__);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nrecv_rexec_state(int fd, struct sshbuf *conf)\n{\n\tstruct sshbuf *m;\n\tu_char *cp, ver;\n\tsize_t len;\n\tint r;\n\n\tdebug3(\"%s: entering fd = %d\", __func__, fd);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif (ssh_msg_recv(fd, m) == -1)\n\t\tfatal(\"%s: ssh_msg_recv failed\", __func__);\n\tif ((r = sshbuf_get_u8(m, &ver)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (ver != 0)\n\t\tfatal(\"%s: rexec version mismatch\", __func__);\n\tif ((r = sshbuf_get_string(m, &cp, &len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (conf != NULL && (r = sshbuf_put(conf, cp, len)))\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n#if defined(WITH_OPENSSL) && !defined(OPENSSL_PRNG_ONLY)\n\trexec_recv_rng_seed(m);\n#endif\n\n\tfree(cp);\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "execv",
          "args": [
            "rexec_argv[0]",
            "rexec_argv"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "config_s[1]",
            "REEXEC_CONFIG_PASS_FD"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "startup_pipe",
            "REEXEC_STARTUP_PIPE_FD"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "STDIN_FILENO",
            "STDOUT_FILENO"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "newsock",
            "STDIN_FILENO"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setproctitle",
          "args": [
            "\"%s\"",
            "\"[accepted]\""
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "setproctitle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/setproctitle.c",
          "lines": "122-167",
          "snippet": "void\nsetproctitle(const char *fmt, ...)\n{\n#if SPT_TYPE != SPT_NONE\n\tva_list ap;\n\tchar buf[1024], ptitle[1024];\n\tsize_t len = 0;\n\tint r;\n\textern char *__progname;\n#if SPT_TYPE == SPT_PSTAT\n\tunion pstun pst;\n#endif\n\n#if SPT_TYPE == SPT_REUSEARGV\n\tif (argv_env_len <= 0)\n\t\treturn;\n#endif\n\n\tstrlcpy(buf, __progname, sizeof(buf));\n\n\tr = -1;\n\tva_start(ap, fmt);\n\tif (fmt != NULL) {\n\t\tlen = strlcat(buf, \": \", sizeof(buf));\n\t\tif (len < sizeof(buf))\n\t\t\tr = vsnprintf(buf + len, sizeof(buf) - len , fmt, ap);\n\t}\n\tva_end(ap);\n\tif (r == -1 || (size_t)r >= sizeof(buf) - len)\n\t\treturn;\n\tstrnvis(ptitle, buf, sizeof(ptitle),\n\t    VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL);\n\n#if SPT_TYPE == SPT_PSTAT\n\tpst.pst_command = ptitle;\n\tpstat(PSTAT_SETCMD, pst, strlen(ptitle), 0, 0);\n#elif SPT_TYPE == SPT_REUSEARGV\n/*\tdebug(\"setproctitle: copy \\\"%s\\\" into len %d\",\n\t    buf, argv_env_len); */\n\tlen = strlcpy(argv_start, ptitle, argv_env_len);\n\tfor(; len < argv_env_len; len++)\n\t\targv_start[len] = SPT_PADCHAR;\n#endif\n\n#endif /* SPT_NONE */\n}",
          "includes": [
            "#include <vis.h>",
            "#include <string.h>",
            "#include <sys/pstat.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SPT_REUSEARGV\t2\t/* cover argv with title information */",
            "#define SPT_PSTAT\t1\t/* use pstat(PSTAT_SETCMD, ...) */",
            "#define SPT_NONE\t0\t/* don't use it at all */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vis.h>\n#include <string.h>\n#include <sys/pstat.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\n#define SPT_REUSEARGV\t2\t/* cover argv with title information */\n#define SPT_PSTAT\t1\t/* use pstat(PSTAT_SETCMD, ...) */\n#define SPT_NONE\t0\t/* don't use it at all */\n\nvoid\nsetproctitle(const char *fmt, ...)\n{\n#if SPT_TYPE != SPT_NONE\n\tva_list ap;\n\tchar buf[1024], ptitle[1024];\n\tsize_t len = 0;\n\tint r;\n\textern char *__progname;\n#if SPT_TYPE == SPT_PSTAT\n\tunion pstun pst;\n#endif\n\n#if SPT_TYPE == SPT_REUSEARGV\n\tif (argv_env_len <= 0)\n\t\treturn;\n#endif\n\n\tstrlcpy(buf, __progname, sizeof(buf));\n\n\tr = -1;\n\tva_start(ap, fmt);\n\tif (fmt != NULL) {\n\t\tlen = strlcat(buf, \": \", sizeof(buf));\n\t\tif (len < sizeof(buf))\n\t\t\tr = vsnprintf(buf + len, sizeof(buf) - len , fmt, ap);\n\t}\n\tva_end(ap);\n\tif (r == -1 || (size_t)r >= sizeof(buf) - len)\n\t\treturn;\n\tstrnvis(ptitle, buf, sizeof(ptitle),\n\t    VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL);\n\n#if SPT_TYPE == SPT_PSTAT\n\tpst.pst_command = ptitle;\n\tpstat(PSTAT_SETCMD, pst, strlen(ptitle), 0, 0);\n#elif SPT_TYPE == SPT_REUSEARGV\n/*\tdebug(\"setproctitle: copy \\\"%s\\\" into len %d\",\n\t    buf, argv_env_len); */\n\tlen = strlcpy(argv_start, ptitle, argv_env_len);\n\tfor(; len < argv_env_len; len++)\n\t\targv_start[len] = SPT_PADCHAR;\n#endif\n\n#endif /* SPT_NONE */\n}"
        }
      },
      {
        "call_info": {
          "callee": "server_accept_loop",
          "args": [
            "&sock_in",
            "&sock_out",
            "&newsock",
            "config_s"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "server_accept_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "1129-1342",
          "snippet": "static void\nserver_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)\n{\n\tfd_set *fdset;\n\tint i, j, ret, maxfd;\n\tint startups = 0;\n\tint startup_p[2] = { -1 , -1 };\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen;\n\tpid_t pid;\n\tu_char rnd[256];\n\n\t/* setup fd set for accept */\n\tfdset = NULL;\n\tmaxfd = 0;\n\tfor (i = 0; i < num_listen_socks; i++)\n\t\tif (listen_socks[i] > maxfd)\n\t\t\tmaxfd = listen_socks[i];\n\t/* pipes connected to unauthenticated childs */\n\tstartup_pipes = xcalloc(options.max_startups, sizeof(int));\n\tfor (i = 0; i < options.max_startups; i++)\n\t\tstartup_pipes[i] = -1;\n\n\t/*\n\t * Stay listening for connections until the system crashes or\n\t * the daemon is killed with a signal.\n\t */\n\tfor (;;) {\n\t\tif (received_sighup)\n\t\t\tsighup_restart();\n\t\tfree(fdset);\n\t\tfdset = xcalloc(howmany(maxfd + 1, NFDBITS),\n\t\t    sizeof(fd_mask));\n\n\t\tfor (i = 0; i < num_listen_socks; i++)\n\t\t\tFD_SET(listen_socks[i], fdset);\n\t\tfor (i = 0; i < options.max_startups; i++)\n\t\t\tif (startup_pipes[i] != -1)\n\t\t\t\tFD_SET(startup_pipes[i], fdset);\n\n\t\t/* Wait in select until there is a connection. */\n\t\tret = select(maxfd+1, fdset, NULL, NULL, NULL);\n\t\tif (ret < 0 && errno != EINTR)\n\t\t\terror(\"select: %.100s\", strerror(errno));\n\t\tif (received_sigterm) {\n\t\t\tlogit(\"Received signal %d; terminating.\",\n\t\t\t    (int) received_sigterm);\n\t\t\tclose_listen_socks();\n\t\t\tif (options.pid_file != NULL)\n\t\t\t\tunlink(options.pid_file);\n\t\t\texit(received_sigterm == SIGTERM ? 0 : 255);\n\t\t}\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < options.max_startups; i++)\n\t\t\tif (startup_pipes[i] != -1 &&\n\t\t\t    FD_ISSET(startup_pipes[i], fdset)) {\n\t\t\t\t/*\n\t\t\t\t * the read end of the pipe is ready\n\t\t\t\t * if the child has closed the pipe\n\t\t\t\t * after successful authentication\n\t\t\t\t * or if the child has died\n\t\t\t\t */\n\t\t\t\tclose(startup_pipes[i]);\n\t\t\t\tstartup_pipes[i] = -1;\n\t\t\t\tstartups--;\n\t\t\t}\n\t\tfor (i = 0; i < num_listen_socks; i++) {\n\t\t\tif (!FD_ISSET(listen_socks[i], fdset))\n\t\t\t\tcontinue;\n\t\t\tfromlen = sizeof(from);\n\t\t\t*newsock = accept(listen_socks[i],\n\t\t\t    (struct sockaddr *)&from, &fromlen);\n\t\t\tif (*newsock < 0) {\n\t\t\t\tif (errno != EINTR && errno != EWOULDBLOCK &&\n\t\t\t\t    errno != ECONNABORTED && errno != EAGAIN)\n\t\t\t\t\terror(\"accept: %.100s\",\n\t\t\t\t\t    strerror(errno));\n\t\t\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (unset_nonblock(*newsock) == -1) {\n\t\t\t\tclose(*newsock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (drop_connection(startups) == 1) {\n\t\t\t\tchar *laddr = get_local_ipaddr(*newsock);\n\t\t\t\tchar *raddr = get_peer_ipaddr(*newsock);\n\n\t\t\t\tverbose(\"drop connection #%d from [%s]:%d \"\n\t\t\t\t    \"on [%s]:%d past MaxStartups\", startups,\n\t\t\t\t    raddr, get_peer_port(*newsock),\n\t\t\t\t    laddr, get_local_port(*newsock));\n\t\t\t\tfree(laddr);\n\t\t\t\tfree(raddr);\n\t\t\t\tclose(*newsock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pipe(startup_p) == -1) {\n\t\t\t\tclose(*newsock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rexec_flag && socketpair(AF_UNIX,\n\t\t\t    SOCK_STREAM, 0, config_s) == -1) {\n\t\t\t\terror(\"reexec socketpair: %s\",\n\t\t\t\t    strerror(errno));\n\t\t\t\tclose(*newsock);\n\t\t\t\tclose(startup_p[0]);\n\t\t\t\tclose(startup_p[1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < options.max_startups; j++)\n\t\t\t\tif (startup_pipes[j] == -1) {\n\t\t\t\t\tstartup_pipes[j] = startup_p[0];\n\t\t\t\t\tif (maxfd < startup_p[0])\n\t\t\t\t\t\tmaxfd = startup_p[0];\n\t\t\t\t\tstartups++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/*\n\t\t\t * Got connection.  Fork a child to handle it, unless\n\t\t\t * we are in debugging mode.\n\t\t\t */\n\t\t\tif (debug_flag) {\n\t\t\t\t/*\n\t\t\t\t * In debugging mode.  Close the listening\n\t\t\t\t * socket, and start processing the\n\t\t\t\t * connection without forking.\n\t\t\t\t */\n\t\t\t\tdebug(\"Server will not fork when running in debugging mode.\");\n\t\t\t\tclose_listen_socks();\n\t\t\t\t*sock_in = *newsock;\n\t\t\t\t*sock_out = *newsock;\n\t\t\t\tclose(startup_p[0]);\n\t\t\t\tclose(startup_p[1]);\n\t\t\t\tstartup_pipe = -1;\n\t\t\t\tpid = getpid();\n\t\t\t\tif (rexec_flag) {\n\t\t\t\t\tsend_rexec_state(config_s[0], cfg);\n\t\t\t\t\tclose(config_s[0]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Normal production daemon.  Fork, and have\n\t\t\t * the child process the connection. The\n\t\t\t * parent continues listening.\n\t\t\t */\n\t\t\tplatform_pre_fork();\n\t\t\tif ((pid = fork()) == 0) {\n\t\t\t\t/*\n\t\t\t\t * Child.  Close the listening and\n\t\t\t\t * max_startup sockets.  Start using\n\t\t\t\t * the accepted socket. Reinitialize\n\t\t\t\t * logging (since our pid has changed).\n\t\t\t\t * We break out of the loop to handle\n\t\t\t\t * the connection.\n\t\t\t\t */\n\t\t\t\tplatform_post_fork_child();\n\t\t\t\tstartup_pipe = startup_p[1];\n\t\t\t\tclose_startup_pipes();\n\t\t\t\tclose_listen_socks();\n\t\t\t\t*sock_in = *newsock;\n\t\t\t\t*sock_out = *newsock;\n\t\t\t\tlog_init(__progname,\n\t\t\t\t    options.log_level,\n\t\t\t\t    options.log_facility,\n\t\t\t\t    log_stderr);\n\t\t\t\tif (rexec_flag)\n\t\t\t\t\tclose(config_s[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Parent.  Stay in the loop. */\n\t\t\tplatform_post_fork_parent(pid);\n\t\t\tif (pid < 0)\n\t\t\t\terror(\"fork: %.100s\", strerror(errno));\n\t\t\telse\n\t\t\t\tdebug(\"Forked child %ld.\", (long)pid);\n\n\t\t\tclose(startup_p[1]);\n\n\t\t\tif (rexec_flag) {\n\t\t\t\tsend_rexec_state(config_s[0], cfg);\n\t\t\t\tclose(config_s[0]);\n\t\t\t\tclose(config_s[1]);\n\t\t\t}\n\t\t\tclose(*newsock);\n\n\t\t\t/*\n\t\t\t * Ensure that our random state differs\n\t\t\t * from that of the child\n\t\t\t */\n\t\t\tarc4random_stir();\n\t\t\tarc4random_buf(rnd, sizeof(rnd));\n#ifdef WITH_OPENSSL\n\t\t\tRAND_seed(rnd, sizeof(rnd));\n\t\t\tif ((RAND_bytes((u_char *)rnd, 1)) != 1)\n\t\t\t\tfatal(\"%s: RAND_bytes failed\", __func__);\n#endif\n\t\t\texplicit_bzero(rnd, sizeof(rnd));\n\t\t}\n\n\t\t/* child process check (or debug mode) */\n\t\tif (num_listen_socks < 0)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *__progname;",
            "ServerOptions options;",
            "int debug_flag = 0;",
            "int log_stderr = 0;",
            "int rexec_flag = 1;",
            "int listen_socks[MAX_LISTEN_SOCKS];",
            "int num_listen_socks = 0;",
            "static volatile sig_atomic_t received_sighup = 0;",
            "static volatile sig_atomic_t received_sigterm = 0;",
            "int *startup_pipes = NULL;",
            "int startup_pipe;",
            "struct sshbuf *cfg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern char *__progname;\nServerOptions options;\nint debug_flag = 0;\nint log_stderr = 0;\nint rexec_flag = 1;\nint listen_socks[MAX_LISTEN_SOCKS];\nint num_listen_socks = 0;\nstatic volatile sig_atomic_t received_sighup = 0;\nstatic volatile sig_atomic_t received_sigterm = 0;\nint *startup_pipes = NULL;\nint startup_pipe;\nstruct sshbuf *cfg;\n\nstatic void\nserver_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)\n{\n\tfd_set *fdset;\n\tint i, j, ret, maxfd;\n\tint startups = 0;\n\tint startup_p[2] = { -1 , -1 };\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen;\n\tpid_t pid;\n\tu_char rnd[256];\n\n\t/* setup fd set for accept */\n\tfdset = NULL;\n\tmaxfd = 0;\n\tfor (i = 0; i < num_listen_socks; i++)\n\t\tif (listen_socks[i] > maxfd)\n\t\t\tmaxfd = listen_socks[i];\n\t/* pipes connected to unauthenticated childs */\n\tstartup_pipes = xcalloc(options.max_startups, sizeof(int));\n\tfor (i = 0; i < options.max_startups; i++)\n\t\tstartup_pipes[i] = -1;\n\n\t/*\n\t * Stay listening for connections until the system crashes or\n\t * the daemon is killed with a signal.\n\t */\n\tfor (;;) {\n\t\tif (received_sighup)\n\t\t\tsighup_restart();\n\t\tfree(fdset);\n\t\tfdset = xcalloc(howmany(maxfd + 1, NFDBITS),\n\t\t    sizeof(fd_mask));\n\n\t\tfor (i = 0; i < num_listen_socks; i++)\n\t\t\tFD_SET(listen_socks[i], fdset);\n\t\tfor (i = 0; i < options.max_startups; i++)\n\t\t\tif (startup_pipes[i] != -1)\n\t\t\t\tFD_SET(startup_pipes[i], fdset);\n\n\t\t/* Wait in select until there is a connection. */\n\t\tret = select(maxfd+1, fdset, NULL, NULL, NULL);\n\t\tif (ret < 0 && errno != EINTR)\n\t\t\terror(\"select: %.100s\", strerror(errno));\n\t\tif (received_sigterm) {\n\t\t\tlogit(\"Received signal %d; terminating.\",\n\t\t\t    (int) received_sigterm);\n\t\t\tclose_listen_socks();\n\t\t\tif (options.pid_file != NULL)\n\t\t\t\tunlink(options.pid_file);\n\t\t\texit(received_sigterm == SIGTERM ? 0 : 255);\n\t\t}\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < options.max_startups; i++)\n\t\t\tif (startup_pipes[i] != -1 &&\n\t\t\t    FD_ISSET(startup_pipes[i], fdset)) {\n\t\t\t\t/*\n\t\t\t\t * the read end of the pipe is ready\n\t\t\t\t * if the child has closed the pipe\n\t\t\t\t * after successful authentication\n\t\t\t\t * or if the child has died\n\t\t\t\t */\n\t\t\t\tclose(startup_pipes[i]);\n\t\t\t\tstartup_pipes[i] = -1;\n\t\t\t\tstartups--;\n\t\t\t}\n\t\tfor (i = 0; i < num_listen_socks; i++) {\n\t\t\tif (!FD_ISSET(listen_socks[i], fdset))\n\t\t\t\tcontinue;\n\t\t\tfromlen = sizeof(from);\n\t\t\t*newsock = accept(listen_socks[i],\n\t\t\t    (struct sockaddr *)&from, &fromlen);\n\t\t\tif (*newsock < 0) {\n\t\t\t\tif (errno != EINTR && errno != EWOULDBLOCK &&\n\t\t\t\t    errno != ECONNABORTED && errno != EAGAIN)\n\t\t\t\t\terror(\"accept: %.100s\",\n\t\t\t\t\t    strerror(errno));\n\t\t\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (unset_nonblock(*newsock) == -1) {\n\t\t\t\tclose(*newsock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (drop_connection(startups) == 1) {\n\t\t\t\tchar *laddr = get_local_ipaddr(*newsock);\n\t\t\t\tchar *raddr = get_peer_ipaddr(*newsock);\n\n\t\t\t\tverbose(\"drop connection #%d from [%s]:%d \"\n\t\t\t\t    \"on [%s]:%d past MaxStartups\", startups,\n\t\t\t\t    raddr, get_peer_port(*newsock),\n\t\t\t\t    laddr, get_local_port(*newsock));\n\t\t\t\tfree(laddr);\n\t\t\t\tfree(raddr);\n\t\t\t\tclose(*newsock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pipe(startup_p) == -1) {\n\t\t\t\tclose(*newsock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rexec_flag && socketpair(AF_UNIX,\n\t\t\t    SOCK_STREAM, 0, config_s) == -1) {\n\t\t\t\terror(\"reexec socketpair: %s\",\n\t\t\t\t    strerror(errno));\n\t\t\t\tclose(*newsock);\n\t\t\t\tclose(startup_p[0]);\n\t\t\t\tclose(startup_p[1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < options.max_startups; j++)\n\t\t\t\tif (startup_pipes[j] == -1) {\n\t\t\t\t\tstartup_pipes[j] = startup_p[0];\n\t\t\t\t\tif (maxfd < startup_p[0])\n\t\t\t\t\t\tmaxfd = startup_p[0];\n\t\t\t\t\tstartups++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/*\n\t\t\t * Got connection.  Fork a child to handle it, unless\n\t\t\t * we are in debugging mode.\n\t\t\t */\n\t\t\tif (debug_flag) {\n\t\t\t\t/*\n\t\t\t\t * In debugging mode.  Close the listening\n\t\t\t\t * socket, and start processing the\n\t\t\t\t * connection without forking.\n\t\t\t\t */\n\t\t\t\tdebug(\"Server will not fork when running in debugging mode.\");\n\t\t\t\tclose_listen_socks();\n\t\t\t\t*sock_in = *newsock;\n\t\t\t\t*sock_out = *newsock;\n\t\t\t\tclose(startup_p[0]);\n\t\t\t\tclose(startup_p[1]);\n\t\t\t\tstartup_pipe = -1;\n\t\t\t\tpid = getpid();\n\t\t\t\tif (rexec_flag) {\n\t\t\t\t\tsend_rexec_state(config_s[0], cfg);\n\t\t\t\t\tclose(config_s[0]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Normal production daemon.  Fork, and have\n\t\t\t * the child process the connection. The\n\t\t\t * parent continues listening.\n\t\t\t */\n\t\t\tplatform_pre_fork();\n\t\t\tif ((pid = fork()) == 0) {\n\t\t\t\t/*\n\t\t\t\t * Child.  Close the listening and\n\t\t\t\t * max_startup sockets.  Start using\n\t\t\t\t * the accepted socket. Reinitialize\n\t\t\t\t * logging (since our pid has changed).\n\t\t\t\t * We break out of the loop to handle\n\t\t\t\t * the connection.\n\t\t\t\t */\n\t\t\t\tplatform_post_fork_child();\n\t\t\t\tstartup_pipe = startup_p[1];\n\t\t\t\tclose_startup_pipes();\n\t\t\t\tclose_listen_socks();\n\t\t\t\t*sock_in = *newsock;\n\t\t\t\t*sock_out = *newsock;\n\t\t\t\tlog_init(__progname,\n\t\t\t\t    options.log_level,\n\t\t\t\t    options.log_facility,\n\t\t\t\t    log_stderr);\n\t\t\t\tif (rexec_flag)\n\t\t\t\t\tclose(config_s[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Parent.  Stay in the loop. */\n\t\t\tplatform_post_fork_parent(pid);\n\t\t\tif (pid < 0)\n\t\t\t\terror(\"fork: %.100s\", strerror(errno));\n\t\t\telse\n\t\t\t\tdebug(\"Forked child %ld.\", (long)pid);\n\n\t\t\tclose(startup_p[1]);\n\n\t\t\tif (rexec_flag) {\n\t\t\t\tsend_rexec_state(config_s[0], cfg);\n\t\t\t\tclose(config_s[0]);\n\t\t\t\tclose(config_s[1]);\n\t\t\t}\n\t\t\tclose(*newsock);\n\n\t\t\t/*\n\t\t\t * Ensure that our random state differs\n\t\t\t * from that of the child\n\t\t\t */\n\t\t\tarc4random_stir();\n\t\t\tarc4random_buf(rnd, sizeof(rnd));\n#ifdef WITH_OPENSSL\n\t\t\tRAND_seed(rnd, sizeof(rnd));\n\t\t\tif ((RAND_bytes((u_char *)rnd, 1)) != 1)\n\t\t\t\tfatal(\"%s: RAND_bytes failed\", __func__);\n#endif\n\t\t\texplicit_bzero(rnd, sizeof(rnd));\n\t\t}\n\n\t\t/* child process check (or debug mode) */\n\t\tif (num_listen_socks < 0)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%ld\\n\"",
            "(long) getpid()"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "options.pid_file",
            "\"w\""
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server_listen",
          "args": [],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "server_listen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "1105-1123",
          "snippet": "static void\nserver_listen(void)\n{\n\tu_int i;\n\n\tfor (i = 0; i < options.num_listen_addrs; i++) {\n\t\tlisten_on_addrs(&options.listen_addrs[i]);\n\t\tfreeaddrinfo(options.listen_addrs[i].addrs);\n\t\tfree(options.listen_addrs[i].rdomain);\n\t\tmemset(&options.listen_addrs[i], 0,\n\t\t    sizeof(options.listen_addrs[i]));\n\t}\n\tfree(options.listen_addrs);\n\toptions.listen_addrs = NULL;\n\toptions.num_listen_addrs = 0;\n\n\tif (!num_listen_socks)\n\t\tfatal(\"Cannot bind any address.\");\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;",
            "int num_listen_socks = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nint num_listen_socks = 0;\n\nstatic void\nserver_listen(void)\n{\n\tu_int i;\n\n\tfor (i = 0; i < options.num_listen_addrs; i++) {\n\t\tlisten_on_addrs(&options.listen_addrs[i]);\n\t\tfreeaddrinfo(options.listen_addrs[i].addrs);\n\t\tfree(options.listen_addrs[i].rdomain);\n\t\tmemset(&options.listen_addrs[i], 0,\n\t\t    sizeof(options.listen_addrs[i]));\n\t}\n\tfree(options.listen_addrs);\n\toptions.listen_addrs = NULL;\n\toptions.num_listen_addrs = 0;\n\n\tif (!num_listen_socks)\n\t\tfatal(\"Cannot bind any address.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_pre_listen",
          "args": [],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "platform_pre_listen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "36-43",
          "snippet": "void\nplatform_pre_listen(void)\n{\n#ifdef LINUX_OOM_ADJUST\n\t/* Adjust out-of-memory killer so listening process is not killed */\n\toom_adjust_setup();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_pre_listen(void)\n{\n#ifdef LINUX_OOM_ADJUST\n\t/* Adjust out-of-memory killer so listening process is not killed */\n\toom_adjust_setup();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "server_accept_inetd",
          "args": [
            "&sock_in",
            "&sock_out"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "server_accept_inetd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "997-1028",
          "snippet": "static void\nserver_accept_inetd(int *sock_in, int *sock_out)\n{\n\tint fd;\n\n\tstartup_pipe = -1;\n\tif (rexeced_flag) {\n\t\tclose(REEXEC_CONFIG_PASS_FD);\n\t\t*sock_in = *sock_out = dup(STDIN_FILENO);\n\t\tif (!debug_flag) {\n\t\t\tstartup_pipe = dup(REEXEC_STARTUP_PIPE_FD);\n\t\t\tclose(REEXEC_STARTUP_PIPE_FD);\n\t\t}\n\t} else {\n\t\t*sock_in = dup(STDIN_FILENO);\n\t\t*sock_out = dup(STDOUT_FILENO);\n\t}\n\t/*\n\t * We intentionally do not close the descriptors 0, 1, and 2\n\t * as our code for setting the descriptors won't work if\n\t * ttyfd happens to be one of those.\n\t */\n\tif ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\tdup2(fd, STDIN_FILENO);\n\t\tdup2(fd, STDOUT_FILENO);\n\t\tif (!log_stderr)\n\t\t\tdup2(fd, STDERR_FILENO);\n\t\tif (fd > (log_stderr ? STDERR_FILENO : STDOUT_FILENO))\n\t\t\tclose(fd);\n\t}\n\tdebug(\"inetd sockets after dupping: %d, %d\", *sock_in, *sock_out);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define REEXEC_CONFIG_PASS_FD\t\t(STDERR_FILENO + 3)",
            "#define REEXEC_STARTUP_PIPE_FD\t\t(STDERR_FILENO + 2)"
          ],
          "globals_used": [
            "int debug_flag = 0;",
            "int log_stderr = 0;",
            "int rexeced_flag = 0;",
            "int startup_pipe;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define REEXEC_CONFIG_PASS_FD\t\t(STDERR_FILENO + 3)\n#define REEXEC_STARTUP_PIPE_FD\t\t(STDERR_FILENO + 2)\n\nint debug_flag = 0;\nint log_stderr = 0;\nint rexeced_flag = 0;\nint startup_pipe;\n\nstatic void\nserver_accept_inetd(int *sock_in, int *sock_out)\n{\n\tint fd;\n\n\tstartup_pipe = -1;\n\tif (rexeced_flag) {\n\t\tclose(REEXEC_CONFIG_PASS_FD);\n\t\t*sock_in = *sock_out = dup(STDIN_FILENO);\n\t\tif (!debug_flag) {\n\t\t\tstartup_pipe = dup(REEXEC_STARTUP_PIPE_FD);\n\t\t\tclose(REEXEC_STARTUP_PIPE_FD);\n\t\t}\n\t} else {\n\t\t*sock_in = dup(STDIN_FILENO);\n\t\t*sock_out = dup(STDOUT_FILENO);\n\t}\n\t/*\n\t * We intentionally do not close the descriptors 0, 1, and 2\n\t * as our code for setting the descriptors won't work if\n\t * ttyfd happens to be one of those.\n\t */\n\tif ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\tdup2(fd, STDIN_FILENO);\n\t\tdup2(fd, STDOUT_FILENO);\n\t\tif (!log_stderr)\n\t\t\tdup2(fd, STDERR_FILENO);\n\t\tif (fd > (log_stderr ? STDERR_FILENO : STDOUT_FILENO))\n\t\t\tclose(fd);\n\t}\n\tdebug(\"inetd sockets after dupping: %d, %d\", *sock_in, *sock_out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disconnect_controlling_tty",
          "args": [],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "disconnect_controlling_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshpty.c",
          "lines": "218-229",
          "snippet": "void\ndisconnect_controlling_tty(void)\n{\n#ifdef TIOCNOTTY\n\tint fd;\n\n\tif ((fd = open(_PATH_TTY, O_RDWR | O_NOCTTY)) >= 0) {\n\t\t(void) ioctl(fd, TIOCNOTTY, NULL);\n\t\tclose(fd);\n\t}\n#endif /* TIOCNOTTY */\n}",
          "includes": [
            "# include <AvailabilityMacros.h>",
            "# include <pty.h>",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshpty.h\"",
            "#include <unistd.h>",
            "# include <util.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define O_NOCTTY 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <AvailabilityMacros.h>\n# include <pty.h>\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshpty.h\"\n#include <unistd.h>\n# include <util.h>\n#include <termios.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define O_NOCTTY 0\n\nvoid\ndisconnect_controlling_tty(void)\n{\n#ifdef TIOCNOTTY\n\tint fd;\n\n\tif ((fd = open(_PATH_TTY, O_RDWR | O_NOCTTY)) >= 0) {\n\t\t(void) ioctl(fd, TIOCNOTTY, NULL);\n\t\tclose(fd);\n\t}\n#endif /* TIOCNOTTY */\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemon",
          "args": [
            "0",
            "0"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "daemon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/daemon.c",
          "lines": "51-79",
          "snippet": "int\ndaemon(int nochdir, int noclose)\n{\n\tint fd;\n\n\tswitch (fork()) {\n\tcase -1:\n\t\treturn (-1);\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\t_exit(0);\n\t}\n\n\tif (setsid() == -1)\n\t\treturn (-1);\n\n\tif (!nochdir)\n\t\t(void)chdir(\"/\");\n\n\tif (!noclose && (fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\t(void)dup2(fd, STDIN_FILENO);\n\t\t(void)dup2(fd, STDOUT_FILENO);\n\t\t(void)dup2(fd, STDERR_FILENO);\n\t\tif (fd > 2)\n\t\t\t(void)close (fd);\n\t}\n\treturn (0);\n}",
          "includes": [
            "# include <unistd.h>",
            "# include <fcntl.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <unistd.h>\n# include <fcntl.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndaemon(int nochdir, int noclose)\n{\n\tint fd;\n\n\tswitch (fork()) {\n\tcase -1:\n\t\treturn (-1);\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\t_exit(0);\n\t}\n\n\tif (setsid() == -1)\n\t\treturn (-1);\n\n\tif (!nochdir)\n\t\t(void)chdir(\"/\");\n\n\tif (!noclose && (fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\t(void)dup2(fd, STDIN_FILENO);\n\t\t(void)dup2(fd, STDOUT_FILENO);\n\t\t(void)dup2(fd, STDERR_FILENO);\n\t\tif (fd > 2)\n\t\t\t(void)close (fd);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemonized",
          "args": [],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "daemonized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1584-1599",
          "snippet": "int\ndaemonized(void)\n{\n\tint fd;\n\n\tif ((fd = open(_PATH_TTY, O_RDONLY | O_NOCTTY)) >= 0) {\n\t\tclose(fd);\n\t\treturn 0;\t/* have controlling terminal */\n\t}\n\tif (getppid() != 1)\n\t\treturn 0;\t/* parent is not init */\n\tif (getsid(0) != getpid())\n\t\treturn 0;\t/* not session leader */\n\tdebug3(\"already daemonized\");\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndaemonized(void)\n{\n\tint fd;\n\n\tif ((fd = open(_PATH_TTY, O_RDONLY | O_NOCTTY)) >= 0) {\n\t\tclose(fd);\n\t\treturn 0;\t/* have controlling terminal */\n\t}\n\tif (getppid() != 1)\n\t\treturn 0;\t/* parent is not init */\n\tif (getsid(0) != getpid())\n\t\treturn 0;\t/* not session leader */\n\tdebug3(\"already daemonized\");\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "new_umask"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "0077"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_config",
          "args": [
            "&options"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "dump_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2516-2690",
          "snippet": "void\ndump_config(ServerOptions *o)\n{\n\tchar *s;\n\tu_int i;\n\n\t/* these are usually at the top of the config */\n\tfor (i = 0; i < o->num_ports; i++)\n\t\tprintf(\"port %d\\n\", o->ports[i]);\n\tdump_cfg_fmtint(sAddressFamily, o->address_family);\n\n\tfor (i = 0; i < o->num_listen_addrs; i++) {\n\t\ts = format_listen_addrs(&o->listen_addrs[i]);\n\t\tprintf(\"%s\", s);\n\t\tfree(s);\n\t}\n\n\t/* integer arguments */\n#ifdef USE_PAM\n\tdump_cfg_fmtint(sUsePAM, o->use_pam);\n#endif\n\tdump_cfg_int(sLoginGraceTime, o->login_grace_time);\n\tdump_cfg_int(sX11DisplayOffset, o->x11_display_offset);\n\tdump_cfg_int(sMaxAuthTries, o->max_authtries);\n\tdump_cfg_int(sMaxSessions, o->max_sessions);\n\tdump_cfg_int(sClientAliveInterval, o->client_alive_interval);\n\tdump_cfg_int(sClientAliveCountMax, o->client_alive_count_max);\n\tdump_cfg_oct(sStreamLocalBindMask, o->fwd_opts.streamlocal_bind_mask);\n\n\t/* formatted integer arguments */\n\tdump_cfg_fmtint(sPermitRootLogin, o->permit_root_login);\n\tdump_cfg_fmtint(sIgnoreRhosts, o->ignore_rhosts);\n\tdump_cfg_fmtint(sIgnoreUserKnownHosts, o->ignore_user_known_hosts);\n\tdump_cfg_fmtint(sHostbasedAuthentication, o->hostbased_authentication);\n\tdump_cfg_fmtint(sHostbasedUsesNameFromPacketOnly,\n\t    o->hostbased_uses_name_from_packet_only);\n\tdump_cfg_fmtint(sPubkeyAuthentication, o->pubkey_authentication);\n#ifdef KRB5\n\tdump_cfg_fmtint(sKerberosAuthentication, o->kerberos_authentication);\n\tdump_cfg_fmtint(sKerberosOrLocalPasswd, o->kerberos_or_local_passwd);\n\tdump_cfg_fmtint(sKerberosTicketCleanup, o->kerberos_ticket_cleanup);\n# ifdef USE_AFS\n\tdump_cfg_fmtint(sKerberosGetAFSToken, o->kerberos_get_afs_token);\n# endif\n#endif\n#ifdef GSSAPI\n\tdump_cfg_fmtint(sGssAuthentication, o->gss_authentication);\n\tdump_cfg_fmtint(sGssCleanupCreds, o->gss_cleanup_creds);\n#endif\n\tdump_cfg_fmtint(sPasswordAuthentication, o->password_authentication);\n\tdump_cfg_fmtint(sKbdInteractiveAuthentication,\n\t    o->kbd_interactive_authentication);\n\tdump_cfg_fmtint(sChallengeResponseAuthentication,\n\t    o->challenge_response_authentication);\n\tdump_cfg_fmtint(sPrintMotd, o->print_motd);\n#ifndef DISABLE_LASTLOG\n\tdump_cfg_fmtint(sPrintLastLog, o->print_lastlog);\n#endif\n\tdump_cfg_fmtint(sX11Forwarding, o->x11_forwarding);\n\tdump_cfg_fmtint(sX11UseLocalhost, o->x11_use_localhost);\n\tdump_cfg_fmtint(sPermitTTY, o->permit_tty);\n\tdump_cfg_fmtint(sPermitUserRC, o->permit_user_rc);\n\tdump_cfg_fmtint(sStrictModes, o->strict_modes);\n\tdump_cfg_fmtint(sTCPKeepAlive, o->tcp_keep_alive);\n\tdump_cfg_fmtint(sEmptyPasswd, o->permit_empty_passwd);\n\tdump_cfg_fmtint(sCompression, o->compression);\n\tdump_cfg_fmtint(sGatewayPorts, o->fwd_opts.gateway_ports);\n\tdump_cfg_fmtint(sUseDNS, o->use_dns);\n\tdump_cfg_fmtint(sAllowTcpForwarding, o->allow_tcp_forwarding);\n\tdump_cfg_fmtint(sAllowAgentForwarding, o->allow_agent_forwarding);\n\tdump_cfg_fmtint(sDisableForwarding, o->disable_forwarding);\n\tdump_cfg_fmtint(sAllowStreamLocalForwarding, o->allow_streamlocal_forwarding);\n\tdump_cfg_fmtint(sStreamLocalBindUnlink, o->fwd_opts.streamlocal_bind_unlink);\n\tdump_cfg_fmtint(sFingerprintHash, o->fingerprint_hash);\n\tdump_cfg_fmtint(sExposeAuthInfo, o->expose_userauth_info);\n\n\t/* string arguments */\n\tdump_cfg_string(sPidFile, o->pid_file);\n\tdump_cfg_string(sXAuthLocation, o->xauth_location);\n\tdump_cfg_string(sCiphers, o->ciphers ? o->ciphers : KEX_SERVER_ENCRYPT);\n\tdump_cfg_string(sMacs, o->macs ? o->macs : KEX_SERVER_MAC);\n\tdump_cfg_string(sBanner, o->banner);\n\tdump_cfg_string(sForceCommand, o->adm_forced_command);\n\tdump_cfg_string(sChrootDirectory, o->chroot_directory);\n\tdump_cfg_string(sTrustedUserCAKeys, o->trusted_user_ca_keys);\n\tdump_cfg_string(sRevokedKeys, o->revoked_keys_file);\n\tdump_cfg_string(sAuthorizedPrincipalsFile,\n\t    o->authorized_principals_file);\n\tdump_cfg_string(sVersionAddendum, *o->version_addendum == '\\0'\n\t    ? \"none\" : o->version_addendum);\n\tdump_cfg_string(sAuthorizedKeysCommand, o->authorized_keys_command);\n\tdump_cfg_string(sAuthorizedKeysCommandUser, o->authorized_keys_command_user);\n\tdump_cfg_string(sAuthorizedPrincipalsCommand, o->authorized_principals_command);\n\tdump_cfg_string(sAuthorizedPrincipalsCommandUser, o->authorized_principals_command_user);\n\tdump_cfg_string(sHostKeyAgent, o->host_key_agent);\n\tdump_cfg_string(sKexAlgorithms,\n\t    o->kex_algorithms ? o->kex_algorithms : KEX_SERVER_KEX);\n\tdump_cfg_string(sCASignatureAlgorithms, o->ca_sign_algorithms ?\n\t    o->ca_sign_algorithms : SSH_ALLOWED_CA_SIGALGS);\n\tdump_cfg_string(sHostbasedAcceptedKeyTypes, o->hostbased_key_types ?\n\t    o->hostbased_key_types : KEX_DEFAULT_PK_ALG);\n\tdump_cfg_string(sHostKeyAlgorithms, o->hostkeyalgorithms ?\n\t    o->hostkeyalgorithms : KEX_DEFAULT_PK_ALG);\n\tdump_cfg_string(sPubkeyAcceptedKeyTypes, o->pubkey_key_types ?\n\t    o->pubkey_key_types : KEX_DEFAULT_PK_ALG);\n\tdump_cfg_string(sRDomain, o->routing_domain);\n\n\t/* string arguments requiring a lookup */\n\tdump_cfg_string(sLogLevel, log_level_name(o->log_level));\n\tdump_cfg_string(sLogFacility, log_facility_name(o->log_facility));\n\n\t/* string array arguments */\n\tdump_cfg_strarray_oneline(sAuthorizedKeysFile, o->num_authkeys_files,\n\t    o->authorized_keys_files);\n\tdump_cfg_strarray(sHostKeyFile, o->num_host_key_files,\n\t     o->host_key_files);\n\tdump_cfg_strarray(sHostCertificate, o->num_host_cert_files,\n\t     o->host_cert_files);\n\tdump_cfg_strarray(sAllowUsers, o->num_allow_users, o->allow_users);\n\tdump_cfg_strarray(sDenyUsers, o->num_deny_users, o->deny_users);\n\tdump_cfg_strarray(sAllowGroups, o->num_allow_groups, o->allow_groups);\n\tdump_cfg_strarray(sDenyGroups, o->num_deny_groups, o->deny_groups);\n\tdump_cfg_strarray(sAcceptEnv, o->num_accept_env, o->accept_env);\n\tdump_cfg_strarray(sSetEnv, o->num_setenv, o->setenv);\n\tdump_cfg_strarray_oneline(sAuthenticationMethods,\n\t    o->num_auth_methods, o->auth_methods);\n\n\t/* other arguments */\n\tfor (i = 0; i < o->num_subsystems; i++)\n\t\tprintf(\"subsystem %s %s\\n\", o->subsystem_name[i],\n\t\t    o->subsystem_args[i]);\n\n\tprintf(\"maxstartups %d:%d:%d\\n\", o->max_startups_begin,\n\t    o->max_startups_rate, o->max_startups);\n\n\ts = NULL;\n\tfor (i = 0; tunmode_desc[i].val != -1; i++) {\n\t\tif (tunmode_desc[i].val == o->permit_tun) {\n\t\t\ts = tunmode_desc[i].text;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdump_cfg_string(sPermitTunnel, s);\n\n\tprintf(\"ipqos %s \", iptos2str(o->ip_qos_interactive));\n\tprintf(\"%s\\n\", iptos2str(o->ip_qos_bulk));\n\n\tprintf(\"rekeylimit %llu %d\\n\", (unsigned long long)o->rekey_limit,\n\t    o->rekey_interval);\n\n\tprintf(\"permitopen\");\n\tif (o->num_permitted_opens == 0)\n\t\tprintf(\" any\");\n\telse {\n\t\tfor (i = 0; i < o->num_permitted_opens; i++)\n\t\t\tprintf(\" %s\", o->permitted_opens[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"permitlisten\");\n\tif (o->num_permitted_listens == 0)\n\t\tprintf(\" any\");\n\telse {\n\t\tfor (i = 0; i < o->num_permitted_listens; i++)\n\t\t\tprintf(\" %s\", o->permitted_listens[i]);\n\t}\n\tprintf(\"\\n\");\n\n\tif (o->permit_user_env_whitelist == NULL) {\n\t\tdump_cfg_fmtint(sPermitUserEnvironment, o->permit_user_env);\n\t} else {\n\t\tprintf(\"permituserenvironment %s\\n\",\n\t\t    o->permit_user_env_whitelist);\n\t}\n\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static struct {\n\tint val;\n\tchar *text;\n} tunmode_desc[] = {\n\t{ SSH_TUNMODE_NO, \"no\" },\n\t{ SSH_TUNMODE_POINTOPOINT, \"point-to-point\" },\n\t{ SSH_TUNMODE_ETHERNET, \"ethernet\" },\n\t{ SSH_TUNMODE_YES, \"yes\" },\n\t{ -1, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic struct {\n\tint val;\n\tchar *text;\n} tunmode_desc[] = {\n\t{ SSH_TUNMODE_NO, \"no\" },\n\t{ SSH_TUNMODE_POINTOPOINT, \"point-to-point\" },\n\t{ SSH_TUNMODE_ETHERNET, \"ethernet\" },\n\t{ SSH_TUNMODE_YES, \"yes\" },\n\t{ -1, NULL }\n};\n\nvoid\ndump_config(ServerOptions *o)\n{\n\tchar *s;\n\tu_int i;\n\n\t/* these are usually at the top of the config */\n\tfor (i = 0; i < o->num_ports; i++)\n\t\tprintf(\"port %d\\n\", o->ports[i]);\n\tdump_cfg_fmtint(sAddressFamily, o->address_family);\n\n\tfor (i = 0; i < o->num_listen_addrs; i++) {\n\t\ts = format_listen_addrs(&o->listen_addrs[i]);\n\t\tprintf(\"%s\", s);\n\t\tfree(s);\n\t}\n\n\t/* integer arguments */\n#ifdef USE_PAM\n\tdump_cfg_fmtint(sUsePAM, o->use_pam);\n#endif\n\tdump_cfg_int(sLoginGraceTime, o->login_grace_time);\n\tdump_cfg_int(sX11DisplayOffset, o->x11_display_offset);\n\tdump_cfg_int(sMaxAuthTries, o->max_authtries);\n\tdump_cfg_int(sMaxSessions, o->max_sessions);\n\tdump_cfg_int(sClientAliveInterval, o->client_alive_interval);\n\tdump_cfg_int(sClientAliveCountMax, o->client_alive_count_max);\n\tdump_cfg_oct(sStreamLocalBindMask, o->fwd_opts.streamlocal_bind_mask);\n\n\t/* formatted integer arguments */\n\tdump_cfg_fmtint(sPermitRootLogin, o->permit_root_login);\n\tdump_cfg_fmtint(sIgnoreRhosts, o->ignore_rhosts);\n\tdump_cfg_fmtint(sIgnoreUserKnownHosts, o->ignore_user_known_hosts);\n\tdump_cfg_fmtint(sHostbasedAuthentication, o->hostbased_authentication);\n\tdump_cfg_fmtint(sHostbasedUsesNameFromPacketOnly,\n\t    o->hostbased_uses_name_from_packet_only);\n\tdump_cfg_fmtint(sPubkeyAuthentication, o->pubkey_authentication);\n#ifdef KRB5\n\tdump_cfg_fmtint(sKerberosAuthentication, o->kerberos_authentication);\n\tdump_cfg_fmtint(sKerberosOrLocalPasswd, o->kerberos_or_local_passwd);\n\tdump_cfg_fmtint(sKerberosTicketCleanup, o->kerberos_ticket_cleanup);\n# ifdef USE_AFS\n\tdump_cfg_fmtint(sKerberosGetAFSToken, o->kerberos_get_afs_token);\n# endif\n#endif\n#ifdef GSSAPI\n\tdump_cfg_fmtint(sGssAuthentication, o->gss_authentication);\n\tdump_cfg_fmtint(sGssCleanupCreds, o->gss_cleanup_creds);\n#endif\n\tdump_cfg_fmtint(sPasswordAuthentication, o->password_authentication);\n\tdump_cfg_fmtint(sKbdInteractiveAuthentication,\n\t    o->kbd_interactive_authentication);\n\tdump_cfg_fmtint(sChallengeResponseAuthentication,\n\t    o->challenge_response_authentication);\n\tdump_cfg_fmtint(sPrintMotd, o->print_motd);\n#ifndef DISABLE_LASTLOG\n\tdump_cfg_fmtint(sPrintLastLog, o->print_lastlog);\n#endif\n\tdump_cfg_fmtint(sX11Forwarding, o->x11_forwarding);\n\tdump_cfg_fmtint(sX11UseLocalhost, o->x11_use_localhost);\n\tdump_cfg_fmtint(sPermitTTY, o->permit_tty);\n\tdump_cfg_fmtint(sPermitUserRC, o->permit_user_rc);\n\tdump_cfg_fmtint(sStrictModes, o->strict_modes);\n\tdump_cfg_fmtint(sTCPKeepAlive, o->tcp_keep_alive);\n\tdump_cfg_fmtint(sEmptyPasswd, o->permit_empty_passwd);\n\tdump_cfg_fmtint(sCompression, o->compression);\n\tdump_cfg_fmtint(sGatewayPorts, o->fwd_opts.gateway_ports);\n\tdump_cfg_fmtint(sUseDNS, o->use_dns);\n\tdump_cfg_fmtint(sAllowTcpForwarding, o->allow_tcp_forwarding);\n\tdump_cfg_fmtint(sAllowAgentForwarding, o->allow_agent_forwarding);\n\tdump_cfg_fmtint(sDisableForwarding, o->disable_forwarding);\n\tdump_cfg_fmtint(sAllowStreamLocalForwarding, o->allow_streamlocal_forwarding);\n\tdump_cfg_fmtint(sStreamLocalBindUnlink, o->fwd_opts.streamlocal_bind_unlink);\n\tdump_cfg_fmtint(sFingerprintHash, o->fingerprint_hash);\n\tdump_cfg_fmtint(sExposeAuthInfo, o->expose_userauth_info);\n\n\t/* string arguments */\n\tdump_cfg_string(sPidFile, o->pid_file);\n\tdump_cfg_string(sXAuthLocation, o->xauth_location);\n\tdump_cfg_string(sCiphers, o->ciphers ? o->ciphers : KEX_SERVER_ENCRYPT);\n\tdump_cfg_string(sMacs, o->macs ? o->macs : KEX_SERVER_MAC);\n\tdump_cfg_string(sBanner, o->banner);\n\tdump_cfg_string(sForceCommand, o->adm_forced_command);\n\tdump_cfg_string(sChrootDirectory, o->chroot_directory);\n\tdump_cfg_string(sTrustedUserCAKeys, o->trusted_user_ca_keys);\n\tdump_cfg_string(sRevokedKeys, o->revoked_keys_file);\n\tdump_cfg_string(sAuthorizedPrincipalsFile,\n\t    o->authorized_principals_file);\n\tdump_cfg_string(sVersionAddendum, *o->version_addendum == '\\0'\n\t    ? \"none\" : o->version_addendum);\n\tdump_cfg_string(sAuthorizedKeysCommand, o->authorized_keys_command);\n\tdump_cfg_string(sAuthorizedKeysCommandUser, o->authorized_keys_command_user);\n\tdump_cfg_string(sAuthorizedPrincipalsCommand, o->authorized_principals_command);\n\tdump_cfg_string(sAuthorizedPrincipalsCommandUser, o->authorized_principals_command_user);\n\tdump_cfg_string(sHostKeyAgent, o->host_key_agent);\n\tdump_cfg_string(sKexAlgorithms,\n\t    o->kex_algorithms ? o->kex_algorithms : KEX_SERVER_KEX);\n\tdump_cfg_string(sCASignatureAlgorithms, o->ca_sign_algorithms ?\n\t    o->ca_sign_algorithms : SSH_ALLOWED_CA_SIGALGS);\n\tdump_cfg_string(sHostbasedAcceptedKeyTypes, o->hostbased_key_types ?\n\t    o->hostbased_key_types : KEX_DEFAULT_PK_ALG);\n\tdump_cfg_string(sHostKeyAlgorithms, o->hostkeyalgorithms ?\n\t    o->hostkeyalgorithms : KEX_DEFAULT_PK_ALG);\n\tdump_cfg_string(sPubkeyAcceptedKeyTypes, o->pubkey_key_types ?\n\t    o->pubkey_key_types : KEX_DEFAULT_PK_ALG);\n\tdump_cfg_string(sRDomain, o->routing_domain);\n\n\t/* string arguments requiring a lookup */\n\tdump_cfg_string(sLogLevel, log_level_name(o->log_level));\n\tdump_cfg_string(sLogFacility, log_facility_name(o->log_facility));\n\n\t/* string array arguments */\n\tdump_cfg_strarray_oneline(sAuthorizedKeysFile, o->num_authkeys_files,\n\t    o->authorized_keys_files);\n\tdump_cfg_strarray(sHostKeyFile, o->num_host_key_files,\n\t     o->host_key_files);\n\tdump_cfg_strarray(sHostCertificate, o->num_host_cert_files,\n\t     o->host_cert_files);\n\tdump_cfg_strarray(sAllowUsers, o->num_allow_users, o->allow_users);\n\tdump_cfg_strarray(sDenyUsers, o->num_deny_users, o->deny_users);\n\tdump_cfg_strarray(sAllowGroups, o->num_allow_groups, o->allow_groups);\n\tdump_cfg_strarray(sDenyGroups, o->num_deny_groups, o->deny_groups);\n\tdump_cfg_strarray(sAcceptEnv, o->num_accept_env, o->accept_env);\n\tdump_cfg_strarray(sSetEnv, o->num_setenv, o->setenv);\n\tdump_cfg_strarray_oneline(sAuthenticationMethods,\n\t    o->num_auth_methods, o->auth_methods);\n\n\t/* other arguments */\n\tfor (i = 0; i < o->num_subsystems; i++)\n\t\tprintf(\"subsystem %s %s\\n\", o->subsystem_name[i],\n\t\t    o->subsystem_args[i]);\n\n\tprintf(\"maxstartups %d:%d:%d\\n\", o->max_startups_begin,\n\t    o->max_startups_rate, o->max_startups);\n\n\ts = NULL;\n\tfor (i = 0; tunmode_desc[i].val != -1; i++) {\n\t\tif (tunmode_desc[i].val == o->permit_tun) {\n\t\t\ts = tunmode_desc[i].text;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdump_cfg_string(sPermitTunnel, s);\n\n\tprintf(\"ipqos %s \", iptos2str(o->ip_qos_interactive));\n\tprintf(\"%s\\n\", iptos2str(o->ip_qos_bulk));\n\n\tprintf(\"rekeylimit %llu %d\\n\", (unsigned long long)o->rekey_limit,\n\t    o->rekey_interval);\n\n\tprintf(\"permitopen\");\n\tif (o->num_permitted_opens == 0)\n\t\tprintf(\" any\");\n\telse {\n\t\tfor (i = 0; i < o->num_permitted_opens; i++)\n\t\t\tprintf(\" %s\", o->permitted_opens[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"permitlisten\");\n\tif (o->num_permitted_listens == 0)\n\t\tprintf(\" any\");\n\telse {\n\t\tfor (i = 0; i < o->num_permitted_listens; i++)\n\t\t\tprintf(\" %s\", o->permitted_listens[i]);\n\t}\n\tprintf(\"\\n\");\n\n\tif (o->permit_user_env_whitelist == NULL) {\n\t\tdump_cfg_fmtint(sPermitUserEnvironment, o->permit_user_env);\n\t} else {\n\t\tprintf(\"permituserenvironment %s\\n\",\n\t\t    o->permit_user_env_whitelist);\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_server_match_config",
          "args": [
            "&options",
            "connection_info"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "parse_server_match_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2209-2218",
          "snippet": "void\nparse_server_match_config(ServerOptions *options,\n   struct connection_info *connectinfo)\n{\n\tServerOptions mo;\n\n\tinitialize_server_options(&mo);\n\tparse_server_config(&mo, \"reprocess config\", cfg, connectinfo);\n\tcopy_set_server_options(options, &mo, 0);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "extern struct sshbuf *cfg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nextern struct sshbuf *cfg;\n\nvoid\nparse_server_match_config(ServerOptions *options,\n   struct connection_info *connectinfo)\n{\n\tServerOptions mo;\n\n\tinitialize_server_options(&mo);\n\tparse_server_config(&mo, \"reprocess config\", cfg, connectinfo);\n\tcopy_set_server_options(options, &mo, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_connection_info",
          "args": [
            "0",
            "0"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "get_connection_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "911-925",
          "snippet": "struct connection_info *\nget_connection_info(int populate, int use_dns)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tstatic struct connection_info ci;\n\n\tif (!populate)\n\t\treturn &ci;\n\tci.host = auth_get_canonical_hostname(ssh, use_dns);\n\tci.address = ssh_remote_ipaddr(ssh);\n\tci.laddress = ssh_local_ipaddr(ssh);\n\tci.lport = ssh_local_port(ssh);\n\tci.rdomain = ssh_packet_rdomain_in(ssh);\n\treturn &ci;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct connection_info *\nget_connection_info(int populate, int use_dns)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tstatic struct connection_info ci;\n\n\tif (!populate)\n\t\treturn &ci;\n\tci.host = auth_get_canonical_hostname(ssh, use_dns);\n\tci.address = ssh_remote_ipaddr(ssh);\n\tci.laddress = ssh_local_ipaddr(ssh);\n\tci.lport = ssh_local_port(ssh);\n\tci.rdomain = ssh_packet_rdomain_in(ssh);\n\treturn &ci;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_ntsec",
          "args": [
            "_PATH_PRIVSEP_CHROOT_DIR"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "check_ntsec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-cygwin_util.c",
          "lines": "55-59",
          "snippet": "int\ncheck_ntsec(const char *filename)\n{\n\treturn (pathconf(filename, _PC_POSIX_PERMISSIONS));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ncheck_ntsec(const char *filename)\n{\n\treturn (pathconf(filename, _PC_POSIX_PERMISSIONS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "key"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "key"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_equal_public",
          "args": [
            "key",
            "sensitive_data.host_keys[j]"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "627-702",
          "snippet": "int\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n#if defined(WITH_OPENSSL)\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n# if defined(OPENSSL_HAS_ECC)\n\tBN_CTX *bnctx;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\n\tswitch (a->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\tif (a->rsa == NULL || b->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\t\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\t\treturn BN_cmp(rsa_e_a, rsa_e_b) == 0 &&\n\t\t    BN_cmp(rsa_n_a, rsa_n_b) == 0;\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\tif (a->dsa == NULL || b->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\t\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\t\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\t\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\t\treturn BN_cmp(dsa_p_a, dsa_p_b) == 0 &&\n\t\t    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&\n\t\t    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&\n\t\t    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\tif (a->ecdsa == NULL || b->ecdsa == NULL ||\n\t\t    EC_KEY_get0_public_key(a->ecdsa) == NULL ||\n\t\t    EC_KEY_get0_public_key(b->ecdsa) == NULL)\n\t\t\treturn 0;\n\t\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\t\treturn 0;\n\t\tif (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||\n\t\t    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn 0;\n\t\t}\n\t\tBN_CTX_free(bnctx);\n\t\treturn 1;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn a->ed25519_pk != NULL && b->ed25519_pk != NULL &&\n\t\t    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn a->xmss_pk != NULL && b->xmss_pk != NULL &&\n\t\t    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&\n\t\t    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n#if defined(WITH_OPENSSL)\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n# if defined(OPENSSL_HAS_ECC)\n\tBN_CTX *bnctx;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\n\tswitch (a->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\tif (a->rsa == NULL || b->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\t\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\t\treturn BN_cmp(rsa_e_a, rsa_e_b) == 0 &&\n\t\t    BN_cmp(rsa_n_a, rsa_n_b) == 0;\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\tif (a->dsa == NULL || b->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\t\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\t\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\t\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\t\treturn BN_cmp(dsa_p_a, dsa_p_b) == 0 &&\n\t\t    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&\n\t\t    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&\n\t\t    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\tif (a->ecdsa == NULL || b->ecdsa == NULL ||\n\t\t    EC_KEY_get0_public_key(a->ecdsa) == NULL ||\n\t\t    EC_KEY_get0_public_key(b->ecdsa) == NULL)\n\t\t\treturn 0;\n\t\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\t\treturn 0;\n\t\tif (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||\n\t\t    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn 0;\n\t\t}\n\t\tBN_CTX_free(bnctx);\n\t\treturn 1;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn a->ed25519_pk != NULL && b->ed25519_pk != NULL &&\n\t\t    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn a->xmss_pk != NULL && b->xmss_pk != NULL &&\n\t\t    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&\n\t\t    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "key"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_load_public",
          "args": [
            "options.host_cert_files[i]",
            "&key",
            "NULL"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "312-354",
          "snippet": "int\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"sshd: no hostkeys available -- exiting.\""
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "accumulate_host_timing_secret",
          "args": [
            "cfg",
            "NULL"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "accumulate_host_timing_secret",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "1426-1461",
          "snippet": "static void\naccumulate_host_timing_secret(struct sshbuf *server_cfg,\n    const struct sshkey *key)\n{\n\tstatic struct ssh_digest_ctx *ctx;\n\tu_char *hash;\n\tsize_t len;\n\tstruct sshbuf *buf;\n\tint r;\n\n\tif (ctx == NULL && (ctx = ssh_digest_start(SSH_DIGEST_SHA512)) == NULL)\n\t\tfatal(\"%s: ssh_digest_start\", __func__);\n\tif (key == NULL) { /* finalize */\n\t\t/* add server config in case we are using agent for host keys */\n\t\tif (ssh_digest_update(ctx, sshbuf_ptr(server_cfg),\n\t\t    sshbuf_len(server_cfg)) != 0)\n\t\t\tfatal(\"%s: ssh_digest_update\", __func__);\n\t\tlen = ssh_digest_bytes(SSH_DIGEST_SHA512);\n\t\thash = xmalloc(len);\n\t\tif (ssh_digest_final(ctx, hash, len) != 0)\n\t\t\tfatal(\"%s: ssh_digest_final\", __func__);\n\t\toptions.timing_secret = PEEK_U64(hash);\n\t\tfreezero(hash, len);\n\t\tssh_digest_free(ctx);\n\t\tctx = NULL;\n\t\treturn;\n\t}\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s could not allocate buffer\", __func__);\n\tif ((r = sshkey_private_serialize(key, buf)) != 0)\n\t\tfatal(\"sshkey_private_serialize: %s\", ssh_err(r));\n\tif (ssh_digest_update(ctx, sshbuf_ptr(buf), sshbuf_len(buf)) != 0)\n\t\tfatal(\"%s: ssh_digest_update\", __func__);\n\tsshbuf_reset(buf);\n\tsshbuf_free(buf);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\n\nstatic void\naccumulate_host_timing_secret(struct sshbuf *server_cfg,\n    const struct sshkey *key)\n{\n\tstatic struct ssh_digest_ctx *ctx;\n\tu_char *hash;\n\tsize_t len;\n\tstruct sshbuf *buf;\n\tint r;\n\n\tif (ctx == NULL && (ctx = ssh_digest_start(SSH_DIGEST_SHA512)) == NULL)\n\t\tfatal(\"%s: ssh_digest_start\", __func__);\n\tif (key == NULL) { /* finalize */\n\t\t/* add server config in case we are using agent for host keys */\n\t\tif (ssh_digest_update(ctx, sshbuf_ptr(server_cfg),\n\t\t    sshbuf_len(server_cfg)) != 0)\n\t\t\tfatal(\"%s: ssh_digest_update\", __func__);\n\t\tlen = ssh_digest_bytes(SSH_DIGEST_SHA512);\n\t\thash = xmalloc(len);\n\t\tif (ssh_digest_final(ctx, hash, len) != 0)\n\t\t\tfatal(\"%s: ssh_digest_final\", __func__);\n\t\toptions.timing_secret = PEEK_U64(hash);\n\t\tfreezero(hash, len);\n\t\tssh_digest_free(ctx);\n\t\tctx = NULL;\n\t\treturn;\n\t}\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s could not allocate buffer\", __func__);\n\tif ((r = sshkey_private_serialize(key, buf)) != 0)\n\t\tfatal(\"sshkey_private_serialize: %s\", ssh_err(r));\n\tif (ssh_digest_update(ctx, sshbuf_ptr(buf), sshbuf_len(buf)) != 0)\n\t\tfatal(\"%s: ssh_digest_update\", __func__);\n\tsshbuf_reset(buf);\n\tsshbuf_free(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "pubkey"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "pubkey",
            "options.fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_private",
          "args": [
            "key",
            "&pubkey"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1726-1868",
          "snippet": "int\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_load_private",
          "args": [
            "options.host_key_files[i]",
            "\"\"",
            "&key",
            "NULL"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "227-262",
          "snippet": "int\nsshkey_load_private(const char *filename, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r, fd;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((fd = open(filename, O_RDONLY)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif (sshkey_perm_ok(fd, filename) != 0) {\n\t\tr = SSH_ERR_KEY_BAD_PERMISSIONS;\n\t\tgoto out;\n\t}\n\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob(buffer, passphrase, keyp,\n\t    commentp)) != 0)\n\t\tgoto out;\n\tif (keyp && *keyp &&\n\t    (r = sshkey_set_filename(*keyp, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tclose(fd);\n\tsshbuf_free(buffer);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_private(const char *filename, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r, fd;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((fd = open(filename, O_RDONLY)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif (sshkey_perm_ok(fd, filename) != 0) {\n\t\tr = SSH_ERR_KEY_BAD_PERMISSIONS;\n\t\tgoto out;\n\t}\n\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob(buffer, passphrase, keyp,\n\t    commentp)) != 0)\n\t\tgoto out;\n\tif (keyp && *keyp &&\n\t    (r = sshkey_set_filename(*keyp, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tclose(fd);\n\tsshbuf_free(buffer);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "SSH_AUTHSOCKET_ENV_NAME",
            "options.host_key_agent",
            "1"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "setenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/setenv.c",
          "lines": "131-188",
          "snippet": "int\nsetenv(const char *name, const char *value, int rewrite)\n{\n\tchar *C, **P;\n\tconst char *np;\n\tint l_value, offset = 0;\n\n\tfor (np = name; *np && *np != '='; ++np)\n\t\t;\n#ifdef notyet\n\tif (*np) {\n\t\terrno = EINVAL;\n\t\treturn (-1);\t\t\t/* has `=' in name */\n\t}\n#endif\n\n\tl_value = strlen(value);\n\tif ((C = __findenv(name, (int)(np - name), &offset)) != NULL) {\n\t\tint tmpoff = offset + 1;\n\t\tif (!rewrite)\n\t\t\treturn (0);\n#if 0 /* XXX - existing entry may not be writable */\n\t\tif (strlen(C) >= l_value) {\t/* old larger; copy over */\n\t\t\twhile ((*C++ = *value++))\n\t\t\t\t;\n\t\t\treturn (0);\n\t\t}\n#endif\n\t\t/* could be set multiple times */\n\t\twhile (__findenv(name, (int)(np - name), &tmpoff)) {\n\t\t\tfor (P = &environ[tmpoff];; ++P)\n\t\t\t\tif (!(*P = *(P + 1)))\n\t\t\t\t\tbreak;\n\t\t}\n\t} else {\t\t\t\t\t/* create new slot */\n\t\tsize_t cnt;\n\n\t\tfor (P = environ; *P != NULL; P++)\n\t\t\t;\n\t\tcnt = P - environ;\n\t\tP = (char **)realloc(lastenv, sizeof(char *) * (cnt + 2));\n\t\tif (!P)\n\t\t\treturn (-1);\n\t\tif (lastenv != environ)\n\t\t\tmemcpy(P, environ, cnt * sizeof(char *));\n\t\tlastenv = environ = P;\n\t\toffset = cnt;\n\t\tenviron[cnt + 1] = NULL;\n\t}\n\tif (!(environ[offset] =\t\t\t/* name + `=' + value */\n\t    malloc((size_t)((int)(np - name) + l_value + 2))))\n\t\treturn (-1);\n\tfor (C = environ[offset]; (*C = *name++) && *C != '='; ++C)\n\t\t;\n\tfor (*C++ = '='; (*C++ = *value++); )\n\t\t;\n\treturn (0);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint\nsetenv(const char *name, const char *value, int rewrite)\n{\n\tchar *C, **P;\n\tconst char *np;\n\tint l_value, offset = 0;\n\n\tfor (np = name; *np && *np != '='; ++np)\n\t\t;\n#ifdef notyet\n\tif (*np) {\n\t\terrno = EINVAL;\n\t\treturn (-1);\t\t\t/* has `=' in name */\n\t}\n#endif\n\n\tl_value = strlen(value);\n\tif ((C = __findenv(name, (int)(np - name), &offset)) != NULL) {\n\t\tint tmpoff = offset + 1;\n\t\tif (!rewrite)\n\t\t\treturn (0);\n#if 0 /* XXX - existing entry may not be writable */\n\t\tif (strlen(C) >= l_value) {\t/* old larger; copy over */\n\t\t\twhile ((*C++ = *value++))\n\t\t\t\t;\n\t\t\treturn (0);\n\t\t}\n#endif\n\t\t/* could be set multiple times */\n\t\twhile (__findenv(name, (int)(np - name), &tmpoff)) {\n\t\t\tfor (P = &environ[tmpoff];; ++P)\n\t\t\t\tif (!(*P = *(P + 1)))\n\t\t\t\t\tbreak;\n\t\t}\n\t} else {\t\t\t\t\t/* create new slot */\n\t\tsize_t cnt;\n\n\t\tfor (P = environ; *P != NULL; P++)\n\t\t\t;\n\t\tcnt = P - environ;\n\t\tP = (char **)realloc(lastenv, sizeof(char *) * (cnt + 2));\n\t\tif (!P)\n\t\t\treturn (-1);\n\t\tif (lastenv != environ)\n\t\t\tmemcpy(P, environ, cnt * sizeof(char *));\n\t\tlastenv = environ = P;\n\t\toffset = cnt;\n\t\tenviron[cnt + 1] = NULL;\n\t}\n\tif (!(environ[offset] =\t\t\t/* name + `=' + value */\n\t    malloc((size_t)((int)(np - name) + l_value + 2))))\n\t\treturn (-1);\n\tfor (C = environ[offset]; (*C = *name++) && *C != '='; ++C)\n\t\t;\n\tfor (*C++ = '='; (*C++ = *value++); )\n\t\t;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "options.host_key_agent",
            "SSH_AUTHSOCKET_ENV_NAME"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "endpwent",
          "args": [],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezero",
          "args": [
            "privsep_pw->pw_passwd",
            "strlen(privsep_pw->pw_passwd)"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "freezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/freezero.c",
          "lines": "24-31",
          "snippet": "void\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "privsep_pw->pw_passwd"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwcopy",
          "args": [
            "privsep_pw"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "pwcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "302-326",
          "snippet": "struct passwd *\npwcopy(struct passwd *pw)\n{\n\tstruct passwd *copy = xcalloc(1, sizeof(*copy));\n\n\tcopy->pw_name = xstrdup(pw->pw_name);\n\tcopy->pw_passwd = xstrdup(pw->pw_passwd);\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n\tcopy->pw_gecos = xstrdup(pw->pw_gecos);\n#endif\n\tcopy->pw_uid = pw->pw_uid;\n\tcopy->pw_gid = pw->pw_gid;\n#ifdef HAVE_STRUCT_PASSWD_PW_EXPIRE\n\tcopy->pw_expire = pw->pw_expire;\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CHANGE\n\tcopy->pw_change = pw->pw_change;\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CLASS\n\tcopy->pw_class = xstrdup(pw->pw_class);\n#endif\n\tcopy->pw_dir = xstrdup(pw->pw_dir);\n\tcopy->pw_shell = xstrdup(pw->pw_shell);\n\treturn copy;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct passwd *\npwcopy(struct passwd *pw)\n{\n\tstruct passwd *copy = xcalloc(1, sizeof(*copy));\n\n\tcopy->pw_name = xstrdup(pw->pw_name);\n\tcopy->pw_passwd = xstrdup(pw->pw_passwd);\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n\tcopy->pw_gecos = xstrdup(pw->pw_gecos);\n#endif\n\tcopy->pw_uid = pw->pw_uid;\n\tcopy->pw_gid = pw->pw_gid;\n#ifdef HAVE_STRUCT_PASSWD_PW_EXPIRE\n\tcopy->pw_expire = pw->pw_expire;\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CHANGE\n\tcopy->pw_change = pw->pw_change;\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CLASS\n\tcopy->pw_class = xstrdup(pw->pw_class);\n#endif\n\tcopy->pw_dir = xstrdup(pw->pw_dir);\n\tcopy->pw_shell = xstrdup(pw->pw_shell);\n\treturn copy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpwnam",
          "args": [
            "SSH_PRIVSEP_USER"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "getpwnamallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "560-632",
          "snippet": "struct passwd *\ngetpwnamallow(const char *user)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n#ifdef HAVE_LOGIN_CAP\n\textern login_cap_t *lc;\n#ifdef BSD_AUTH\n\tauth_session_t *as;\n#endif\n#endif\n\tstruct passwd *pw;\n\tstruct connection_info *ci = get_connection_info(1, options.use_dns);\n\n\tci->user = user;\n\tparse_server_match_config(&options, ci);\n\tlog_change_level(options.log_level);\n\tprocess_permitopen(ssh, &options);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_setauthdb(user);\n#endif\n\n\tpw = getpwnam(user);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_restoreauthdb();\n#endif\n#ifdef HAVE_CYGWIN\n\t/*\n\t * Windows usernames are case-insensitive.  To avoid later problems\n\t * when trying to match the username, the user is only allowed to\n\t * login if the username is given in the same case as stored in the\n\t * user database.\n\t */\n\tif (pw != NULL && strcmp(user, pw->pw_name) != 0) {\n\t\tlogit(\"Login name %.100s does not match stored username %.100s\",\n\t\t    user, pw->pw_name);\n\t\tpw = NULL;\n\t}\n#endif\n\tif (pw == NULL) {\n\t\tlogit(\"Invalid user %.100s from %.100s port %d\",\n\t\t    user, ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n#ifdef CUSTOM_FAILED_LOGIN\n\t\trecord_failed_login(user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\t\taudit_event(SSH_INVALID_USER);\n#endif /* SSH_AUDIT_EVENTS */\n\t\treturn (NULL);\n\t}\n\tif (!allowed_user(pw))\n\t\treturn (NULL);\n#ifdef HAVE_LOGIN_CAP\n\tif ((lc = login_getclass(pw->pw_class)) == NULL) {\n\t\tdebug(\"unable to get login class: %s\", user);\n\t\treturn (NULL);\n\t}\n#ifdef BSD_AUTH\n\tif ((as = auth_open()) == NULL || auth_setpwd(as, pw) != 0 ||\n\t    auth_approval(as, lc, pw->pw_name, \"ssh\") <= 0) {\n\t\tdebug(\"Approval failure for %s\", user);\n\t\tpw = NULL;\n\t}\n\tif (as != NULL)\n\t\tauth_close(as);\n#endif\n#endif\n\tif (pw != NULL)\n\t\treturn (pwcopy(pw));\n\treturn (NULL);\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstruct passwd *\ngetpwnamallow(const char *user)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n#ifdef HAVE_LOGIN_CAP\n\textern login_cap_t *lc;\n#ifdef BSD_AUTH\n\tauth_session_t *as;\n#endif\n#endif\n\tstruct passwd *pw;\n\tstruct connection_info *ci = get_connection_info(1, options.use_dns);\n\n\tci->user = user;\n\tparse_server_match_config(&options, ci);\n\tlog_change_level(options.log_level);\n\tprocess_permitopen(ssh, &options);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_setauthdb(user);\n#endif\n\n\tpw = getpwnam(user);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_restoreauthdb();\n#endif\n#ifdef HAVE_CYGWIN\n\t/*\n\t * Windows usernames are case-insensitive.  To avoid later problems\n\t * when trying to match the username, the user is only allowed to\n\t * login if the username is given in the same case as stored in the\n\t * user database.\n\t */\n\tif (pw != NULL && strcmp(user, pw->pw_name) != 0) {\n\t\tlogit(\"Login name %.100s does not match stored username %.100s\",\n\t\t    user, pw->pw_name);\n\t\tpw = NULL;\n\t}\n#endif\n\tif (pw == NULL) {\n\t\tlogit(\"Invalid user %.100s from %.100s port %d\",\n\t\t    user, ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n#ifdef CUSTOM_FAILED_LOGIN\n\t\trecord_failed_login(user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\t\taudit_event(SSH_INVALID_USER);\n#endif /* SSH_AUDIT_EVENTS */\n\t\treturn (NULL);\n\t}\n\tif (!allowed_user(pw))\n\t\treturn (NULL);\n#ifdef HAVE_LOGIN_CAP\n\tif ((lc = login_getclass(pw->pw_class)) == NULL) {\n\t\tdebug(\"unable to get login class: %s\", user);\n\t\treturn (NULL);\n\t}\n#ifdef BSD_AUTH\n\tif ((as = auth_open()) == NULL || auth_setpwd(as, pw) != 0 ||\n\t    auth_approval(as, lc, pw->pw_name, \"ssh\") <= 0) {\n\t\tdebug(\"Approval failure for %s\", user);\n\t\tpw = NULL;\n\t}\n\tif (as != NULL)\n\t\tauth_close(as);\n#endif\n#endif\n\tif (pw != NULL)\n\t\treturn (pwcopy(pw));\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OpenSSL_version",
          "args": [
            "OPENSSL_VERSION"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Extra argument %s.\\n\"",
            "av[optind]"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth2_methods_valid",
          "args": [
            "options.auth_methods[i]",
            "1"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_methods_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "507-547",
          "snippet": "int\nauth2_methods_valid(const char *_methods, int need_enable)\n{\n\tchar *methods, *omethods, *method, *p;\n\tu_int i, found;\n\tint ret = -1;\n\n\tif (*_methods == '\\0') {\n\t\terror(\"empty authentication method list\");\n\t\treturn -1;\n\t}\n\tomethods = methods = xstrdup(_methods);\n\twhile ((method = strsep(&methods, \",\")) != NULL) {\n\t\tfor (found = i = 0; !found && authmethods[i] != NULL; i++) {\n\t\t\tif ((p = strchr(method, ':')) != NULL)\n\t\t\t\t*p = '\\0';\n\t\t\tif (strcmp(method, authmethods[i]->name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (need_enable) {\n\t\t\t\tif (authmethods[i]->enabled == NULL ||\n\t\t\t\t    *(authmethods[i]->enabled) == 0) {\n\t\t\t\t\terror(\"Disabled method \\\"%s\\\" in \"\n\t\t\t\t\t    \"AuthenticationMethods list \\\"%s\\\"\",\n\t\t\t\t\t    method, _methods);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!found) {\n\t\t\terror(\"Unknown authentication method \\\"%s\\\" in list\",\n\t\t\t    method);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\n out:\n\tfree(omethods);\n\treturn ret;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Authmethod *authmethods[] = {\n\t&method_none,\n\t&method_pubkey,\n#ifdef GSSAPI\n\t&method_gssapi,\n#endif\n\t&method_passwd,\n\t&method_kbdint,\n\t&method_hostbased,\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nAuthmethod *authmethods[] = {\n\t&method_none,\n\t&method_pubkey,\n#ifdef GSSAPI\n\t&method_gssapi,\n#endif\n\t&method_passwd,\n\t&method_kbdint,\n\t&method_hostbased,\n\tNULL\n};\n\nint\nauth2_methods_valid(const char *_methods, int need_enable)\n{\n\tchar *methods, *omethods, *method, *p;\n\tu_int i, found;\n\tint ret = -1;\n\n\tif (*_methods == '\\0') {\n\t\terror(\"empty authentication method list\");\n\t\treturn -1;\n\t}\n\tomethods = methods = xstrdup(_methods);\n\twhile ((method = strsep(&methods, \",\")) != NULL) {\n\t\tfor (found = i = 0; !found && authmethods[i] != NULL; i++) {\n\t\t\tif ((p = strchr(method, ':')) != NULL)\n\t\t\t\t*p = '\\0';\n\t\t\tif (strcmp(method, authmethods[i]->name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (need_enable) {\n\t\t\t\tif (authmethods[i]->enabled == NULL ||\n\t\t\t\t    *(authmethods[i]->enabled) == 0) {\n\t\t\t\t\terror(\"Disabled method \\\"%s\\\" in \"\n\t\t\t\t\t    \"AuthenticationMethods list \\\"%s\\\"\",\n\t\t\t\t\t    method, _methods);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!found) {\n\t\t\terror(\"Unknown authentication method \\\"%s\\\" in list\",\n\t\t\t    method);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\n out:\n\tfree(omethods);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "options.authorized_principals_command",
            "\"none\""
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "options.authorized_keys_command",
            "\"none\""
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_default_server_options",
          "args": [
            "&options"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "fill_default_server_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "258-460",
          "snippet": "void\nfill_default_server_options(ServerOptions *options)\n{\n\tu_int i;\n\n\t/* Portable-specific options */\n\tif (options->use_pam == -1)\n\t\toptions->use_pam = 0;\n\n\t/* Standard Options */\n\tif (options->num_host_key_files == 0) {\n\t\t/* fill default hostkeys for protocols */\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_RSA_KEY_FILE);\n#ifdef OPENSSL_HAS_ECC\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_ECDSA_KEY_FILE);\n#endif\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_ED25519_KEY_FILE);\n#ifdef WITH_XMSS\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_XMSS_KEY_FILE);\n#endif /* WITH_XMSS */\n\t}\n\t/* No certificates by default */\n\tif (options->num_ports == 0)\n\t\toptions->ports[options->num_ports++] = SSH_DEFAULT_PORT;\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\tif (options->listen_addrs == NULL)\n\t\tadd_listen_addr(options, NULL, NULL, 0);\n\tif (options->pid_file == NULL)\n\t\toptions->pid_file = xstrdup(_PATH_SSH_DAEMON_PID_FILE);\n\tif (options->login_grace_time == -1)\n\t\toptions->login_grace_time = 120;\n\tif (options->permit_root_login == PERMIT_NOT_SET)\n\t\toptions->permit_root_login = PERMIT_NO_PASSWD;\n\tif (options->ignore_rhosts == -1)\n\t\toptions->ignore_rhosts = 1;\n\tif (options->ignore_user_known_hosts == -1)\n\t\toptions->ignore_user_known_hosts = 0;\n\tif (options->print_motd == -1)\n\t\toptions->print_motd = 1;\n\tif (options->print_lastlog == -1)\n\t\toptions->print_lastlog = 1;\n\tif (options->x11_forwarding == -1)\n\t\toptions->x11_forwarding = 0;\n\tif (options->x11_display_offset == -1)\n\t\toptions->x11_display_offset = 10;\n\tif (options->x11_use_localhost == -1)\n\t\toptions->x11_use_localhost = 1;\n\tif (options->xauth_location == NULL)\n\t\toptions->xauth_location = xstrdup(_PATH_XAUTH);\n\tif (options->permit_tty == -1)\n\t\toptions->permit_tty = 1;\n\tif (options->permit_user_rc == -1)\n\t\toptions->permit_user_rc = 1;\n\tif (options->strict_modes == -1)\n\t\toptions->strict_modes = 1;\n\tif (options->tcp_keep_alive == -1)\n\t\toptions->tcp_keep_alive = 1;\n\tif (options->log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\toptions->log_facility = SYSLOG_FACILITY_AUTH;\n\tif (options->log_level == SYSLOG_LEVEL_NOT_SET)\n\t\toptions->log_level = SYSLOG_LEVEL_INFO;\n\tif (options->hostbased_authentication == -1)\n\t\toptions->hostbased_authentication = 0;\n\tif (options->hostbased_uses_name_from_packet_only == -1)\n\t\toptions->hostbased_uses_name_from_packet_only = 0;\n\tif (options->pubkey_authentication == -1)\n\t\toptions->pubkey_authentication = 1;\n\tif (options->kerberos_authentication == -1)\n\t\toptions->kerberos_authentication = 0;\n\tif (options->kerberos_or_local_passwd == -1)\n\t\toptions->kerberos_or_local_passwd = 1;\n\tif (options->kerberos_ticket_cleanup == -1)\n\t\toptions->kerberos_ticket_cleanup = 1;\n\tif (options->kerberos_get_afs_token == -1)\n\t\toptions->kerberos_get_afs_token = 0;\n\tif (options->gss_authentication == -1)\n\t\toptions->gss_authentication = 0;\n\tif (options->gss_cleanup_creds == -1)\n\t\toptions->gss_cleanup_creds = 1;\n\tif (options->gss_strict_acceptor == -1)\n\t\toptions->gss_strict_acceptor = 1;\n\tif (options->password_authentication == -1)\n\t\toptions->password_authentication = 1;\n\tif (options->kbd_interactive_authentication == -1)\n\t\toptions->kbd_interactive_authentication = 0;\n\tif (options->challenge_response_authentication == -1)\n\t\toptions->challenge_response_authentication = 1;\n\tif (options->permit_empty_passwd == -1)\n\t\toptions->permit_empty_passwd = 0;\n\tif (options->permit_user_env == -1) {\n\t\toptions->permit_user_env = 0;\n\t\toptions->permit_user_env_whitelist = NULL;\n\t}\n\tif (options->compression == -1)\n\t\toptions->compression = COMP_DELAYED;\n\tif (options->rekey_limit == -1)\n\t\toptions->rekey_limit = 0;\n\tif (options->rekey_interval == -1)\n\t\toptions->rekey_interval = 0;\n\tif (options->allow_tcp_forwarding == -1)\n\t\toptions->allow_tcp_forwarding = FORWARD_ALLOW;\n\tif (options->allow_streamlocal_forwarding == -1)\n\t\toptions->allow_streamlocal_forwarding = FORWARD_ALLOW;\n\tif (options->allow_agent_forwarding == -1)\n\t\toptions->allow_agent_forwarding = 1;\n\tif (options->fwd_opts.gateway_ports == -1)\n\t\toptions->fwd_opts.gateway_ports = 0;\n\tif (options->max_startups == -1)\n\t\toptions->max_startups = 100;\n\tif (options->max_startups_rate == -1)\n\t\toptions->max_startups_rate = 30;\t\t/* 30% */\n\tif (options->max_startups_begin == -1)\n\t\toptions->max_startups_begin = 10;\n\tif (options->max_authtries == -1)\n\t\toptions->max_authtries = DEFAULT_AUTH_FAIL_MAX;\n\tif (options->max_sessions == -1)\n\t\toptions->max_sessions = DEFAULT_SESSIONS_MAX;\n\tif (options->use_dns == -1)\n\t\toptions->use_dns = 0;\n\tif (options->client_alive_interval == -1)\n\t\toptions->client_alive_interval = 0;\n\tif (options->client_alive_count_max == -1)\n\t\toptions->client_alive_count_max = 3;\n\tif (options->num_authkeys_files == 0) {\n\t\tarray_append(\"[default]\", 0, \"AuthorizedKeysFiles\",\n\t\t    &options->authorized_keys_files,\n\t\t    &options->num_authkeys_files,\n\t\t    _PATH_SSH_USER_PERMITTED_KEYS);\n\t\tarray_append(\"[default]\", 0, \"AuthorizedKeysFiles\",\n\t\t    &options->authorized_keys_files,\n\t\t    &options->num_authkeys_files,\n\t\t    _PATH_SSH_USER_PERMITTED_KEYS2);\n\t}\n\tif (options->permit_tun == -1)\n\t\toptions->permit_tun = SSH_TUNMODE_NO;\n\tif (options->ip_qos_interactive == -1)\n\t\toptions->ip_qos_interactive = IPTOS_DSCP_AF21;\n\tif (options->ip_qos_bulk == -1)\n\t\toptions->ip_qos_bulk = IPTOS_DSCP_CS1;\n\tif (options->version_addendum == NULL)\n\t\toptions->version_addendum = xstrdup(\"\");\n\tif (options->fwd_opts.streamlocal_bind_mask == (mode_t)-1)\n\t\toptions->fwd_opts.streamlocal_bind_mask = 0177;\n\tif (options->fwd_opts.streamlocal_bind_unlink == -1)\n\t\toptions->fwd_opts.streamlocal_bind_unlink = 0;\n\tif (options->fingerprint_hash == -1)\n\t\toptions->fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\tif (options->disable_forwarding == -1)\n\t\toptions->disable_forwarding = 0;\n\tif (options->expose_userauth_info == -1)\n\t\toptions->expose_userauth_info = 0;\n\n\tassemble_algorithms(options);\n\n\t/* Turn privilege separation and sandboxing on by default */\n\tif (use_privsep == -1)\n\t\tuse_privsep = PRIVSEP_ON;\n\n#define CLEAR_ON_NONE(v) \\\n\tdo { \\\n\t\tif (option_clear_or_none(v)) { \\\n\t\t\tfree(v); \\\n\t\t\tv = NULL; \\\n\t\t} \\\n\t} while(0)\n\tCLEAR_ON_NONE(options->pid_file);\n\tCLEAR_ON_NONE(options->xauth_location);\n\tCLEAR_ON_NONE(options->banner);\n\tCLEAR_ON_NONE(options->trusted_user_ca_keys);\n\tCLEAR_ON_NONE(options->revoked_keys_file);\n\tCLEAR_ON_NONE(options->authorized_principals_file);\n\tCLEAR_ON_NONE(options->adm_forced_command);\n\tCLEAR_ON_NONE(options->chroot_directory);\n\tCLEAR_ON_NONE(options->routing_domain);\n\tfor (i = 0; i < options->num_host_key_files; i++)\n\t\tCLEAR_ON_NONE(options->host_key_files[i]);\n\tfor (i = 0; i < options->num_host_cert_files; i++)\n\t\tCLEAR_ON_NONE(options->host_cert_files[i]);\n#undef CLEAR_ON_NONE\n\n\t/* Similar handling for AuthenticationMethods=any */\n\tif (options->num_auth_methods == 1 &&\n\t    strcmp(options->auth_methods[0], \"any\") == 0) {\n\t\tfree(options->auth_methods[0]);\n\t\toptions->auth_methods[0] = NULL;\n\t\toptions->num_auth_methods = 0;\n\t}\n\n#ifndef HAVE_MMAP\n\tif (use_privsep && options->compression == 1) {\n\t\terror(\"This platform does not support both privilege \"\n\t\t    \"separation and compression\");\n\t\terror(\"Compression disabled\");\n\t\toptions->compression = 0;\n\t}\n#endif\n\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "extern int use_privsep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nextern int use_privsep;\n\nvoid\nfill_default_server_options(ServerOptions *options)\n{\n\tu_int i;\n\n\t/* Portable-specific options */\n\tif (options->use_pam == -1)\n\t\toptions->use_pam = 0;\n\n\t/* Standard Options */\n\tif (options->num_host_key_files == 0) {\n\t\t/* fill default hostkeys for protocols */\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_RSA_KEY_FILE);\n#ifdef OPENSSL_HAS_ECC\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_ECDSA_KEY_FILE);\n#endif\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_ED25519_KEY_FILE);\n#ifdef WITH_XMSS\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_XMSS_KEY_FILE);\n#endif /* WITH_XMSS */\n\t}\n\t/* No certificates by default */\n\tif (options->num_ports == 0)\n\t\toptions->ports[options->num_ports++] = SSH_DEFAULT_PORT;\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\tif (options->listen_addrs == NULL)\n\t\tadd_listen_addr(options, NULL, NULL, 0);\n\tif (options->pid_file == NULL)\n\t\toptions->pid_file = xstrdup(_PATH_SSH_DAEMON_PID_FILE);\n\tif (options->login_grace_time == -1)\n\t\toptions->login_grace_time = 120;\n\tif (options->permit_root_login == PERMIT_NOT_SET)\n\t\toptions->permit_root_login = PERMIT_NO_PASSWD;\n\tif (options->ignore_rhosts == -1)\n\t\toptions->ignore_rhosts = 1;\n\tif (options->ignore_user_known_hosts == -1)\n\t\toptions->ignore_user_known_hosts = 0;\n\tif (options->print_motd == -1)\n\t\toptions->print_motd = 1;\n\tif (options->print_lastlog == -1)\n\t\toptions->print_lastlog = 1;\n\tif (options->x11_forwarding == -1)\n\t\toptions->x11_forwarding = 0;\n\tif (options->x11_display_offset == -1)\n\t\toptions->x11_display_offset = 10;\n\tif (options->x11_use_localhost == -1)\n\t\toptions->x11_use_localhost = 1;\n\tif (options->xauth_location == NULL)\n\t\toptions->xauth_location = xstrdup(_PATH_XAUTH);\n\tif (options->permit_tty == -1)\n\t\toptions->permit_tty = 1;\n\tif (options->permit_user_rc == -1)\n\t\toptions->permit_user_rc = 1;\n\tif (options->strict_modes == -1)\n\t\toptions->strict_modes = 1;\n\tif (options->tcp_keep_alive == -1)\n\t\toptions->tcp_keep_alive = 1;\n\tif (options->log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\toptions->log_facility = SYSLOG_FACILITY_AUTH;\n\tif (options->log_level == SYSLOG_LEVEL_NOT_SET)\n\t\toptions->log_level = SYSLOG_LEVEL_INFO;\n\tif (options->hostbased_authentication == -1)\n\t\toptions->hostbased_authentication = 0;\n\tif (options->hostbased_uses_name_from_packet_only == -1)\n\t\toptions->hostbased_uses_name_from_packet_only = 0;\n\tif (options->pubkey_authentication == -1)\n\t\toptions->pubkey_authentication = 1;\n\tif (options->kerberos_authentication == -1)\n\t\toptions->kerberos_authentication = 0;\n\tif (options->kerberos_or_local_passwd == -1)\n\t\toptions->kerberos_or_local_passwd = 1;\n\tif (options->kerberos_ticket_cleanup == -1)\n\t\toptions->kerberos_ticket_cleanup = 1;\n\tif (options->kerberos_get_afs_token == -1)\n\t\toptions->kerberos_get_afs_token = 0;\n\tif (options->gss_authentication == -1)\n\t\toptions->gss_authentication = 0;\n\tif (options->gss_cleanup_creds == -1)\n\t\toptions->gss_cleanup_creds = 1;\n\tif (options->gss_strict_acceptor == -1)\n\t\toptions->gss_strict_acceptor = 1;\n\tif (options->password_authentication == -1)\n\t\toptions->password_authentication = 1;\n\tif (options->kbd_interactive_authentication == -1)\n\t\toptions->kbd_interactive_authentication = 0;\n\tif (options->challenge_response_authentication == -1)\n\t\toptions->challenge_response_authentication = 1;\n\tif (options->permit_empty_passwd == -1)\n\t\toptions->permit_empty_passwd = 0;\n\tif (options->permit_user_env == -1) {\n\t\toptions->permit_user_env = 0;\n\t\toptions->permit_user_env_whitelist = NULL;\n\t}\n\tif (options->compression == -1)\n\t\toptions->compression = COMP_DELAYED;\n\tif (options->rekey_limit == -1)\n\t\toptions->rekey_limit = 0;\n\tif (options->rekey_interval == -1)\n\t\toptions->rekey_interval = 0;\n\tif (options->allow_tcp_forwarding == -1)\n\t\toptions->allow_tcp_forwarding = FORWARD_ALLOW;\n\tif (options->allow_streamlocal_forwarding == -1)\n\t\toptions->allow_streamlocal_forwarding = FORWARD_ALLOW;\n\tif (options->allow_agent_forwarding == -1)\n\t\toptions->allow_agent_forwarding = 1;\n\tif (options->fwd_opts.gateway_ports == -1)\n\t\toptions->fwd_opts.gateway_ports = 0;\n\tif (options->max_startups == -1)\n\t\toptions->max_startups = 100;\n\tif (options->max_startups_rate == -1)\n\t\toptions->max_startups_rate = 30;\t\t/* 30% */\n\tif (options->max_startups_begin == -1)\n\t\toptions->max_startups_begin = 10;\n\tif (options->max_authtries == -1)\n\t\toptions->max_authtries = DEFAULT_AUTH_FAIL_MAX;\n\tif (options->max_sessions == -1)\n\t\toptions->max_sessions = DEFAULT_SESSIONS_MAX;\n\tif (options->use_dns == -1)\n\t\toptions->use_dns = 0;\n\tif (options->client_alive_interval == -1)\n\t\toptions->client_alive_interval = 0;\n\tif (options->client_alive_count_max == -1)\n\t\toptions->client_alive_count_max = 3;\n\tif (options->num_authkeys_files == 0) {\n\t\tarray_append(\"[default]\", 0, \"AuthorizedKeysFiles\",\n\t\t    &options->authorized_keys_files,\n\t\t    &options->num_authkeys_files,\n\t\t    _PATH_SSH_USER_PERMITTED_KEYS);\n\t\tarray_append(\"[default]\", 0, \"AuthorizedKeysFiles\",\n\t\t    &options->authorized_keys_files,\n\t\t    &options->num_authkeys_files,\n\t\t    _PATH_SSH_USER_PERMITTED_KEYS2);\n\t}\n\tif (options->permit_tun == -1)\n\t\toptions->permit_tun = SSH_TUNMODE_NO;\n\tif (options->ip_qos_interactive == -1)\n\t\toptions->ip_qos_interactive = IPTOS_DSCP_AF21;\n\tif (options->ip_qos_bulk == -1)\n\t\toptions->ip_qos_bulk = IPTOS_DSCP_CS1;\n\tif (options->version_addendum == NULL)\n\t\toptions->version_addendum = xstrdup(\"\");\n\tif (options->fwd_opts.streamlocal_bind_mask == (mode_t)-1)\n\t\toptions->fwd_opts.streamlocal_bind_mask = 0177;\n\tif (options->fwd_opts.streamlocal_bind_unlink == -1)\n\t\toptions->fwd_opts.streamlocal_bind_unlink = 0;\n\tif (options->fingerprint_hash == -1)\n\t\toptions->fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\tif (options->disable_forwarding == -1)\n\t\toptions->disable_forwarding = 0;\n\tif (options->expose_userauth_info == -1)\n\t\toptions->expose_userauth_info = 0;\n\n\tassemble_algorithms(options);\n\n\t/* Turn privilege separation and sandboxing on by default */\n\tif (use_privsep == -1)\n\t\tuse_privsep = PRIVSEP_ON;\n\n#define CLEAR_ON_NONE(v) \\\n\tdo { \\\n\t\tif (option_clear_or_none(v)) { \\\n\t\t\tfree(v); \\\n\t\t\tv = NULL; \\\n\t\t} \\\n\t} while(0)\n\tCLEAR_ON_NONE(options->pid_file);\n\tCLEAR_ON_NONE(options->xauth_location);\n\tCLEAR_ON_NONE(options->banner);\n\tCLEAR_ON_NONE(options->trusted_user_ca_keys);\n\tCLEAR_ON_NONE(options->revoked_keys_file);\n\tCLEAR_ON_NONE(options->authorized_principals_file);\n\tCLEAR_ON_NONE(options->adm_forced_command);\n\tCLEAR_ON_NONE(options->chroot_directory);\n\tCLEAR_ON_NONE(options->routing_domain);\n\tfor (i = 0; i < options->num_host_key_files; i++)\n\t\tCLEAR_ON_NONE(options->host_key_files[i]);\n\tfor (i = 0; i < options->num_host_cert_files; i++)\n\t\tCLEAR_ON_NONE(options->host_cert_files[i]);\n#undef CLEAR_ON_NONE\n\n\t/* Similar handling for AuthenticationMethods=any */\n\tif (options->num_auth_methods == 1 &&\n\t    strcmp(options->auth_methods[0], \"any\") == 0) {\n\t\tfree(options->auth_methods[0]);\n\t\toptions->auth_methods[0] = NULL;\n\t\toptions->num_auth_methods = 0;\n\t}\n\n#ifndef HAVE_MMAP\n\tif (use_privsep && options->compression == 1) {\n\t\terror(\"This platform does not support both privilege \"\n\t\t    \"separation and compression\");\n\t\terror(\"Compression disabled\");\n\t\toptions->compression = 0;\n\t}\n#endif\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "seed_rng",
          "args": [],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "seed_rng",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/entropy.c",
          "lines": "247-250",
          "snippet": "void\nseed_rng(void)\n{\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"xmalloc.h\"",
            "#include \"misc.h\"",
            "#include \"ssh.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/crypto.h>",
            "#include <openssl/rand.h>",
            "#include <stddef.h> /* for offsetof */",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"xmalloc.h\"\n#include \"misc.h\"\n#include \"ssh.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/crypto.h>\n#include <openssl/rand.h>\n#include <stddef.h> /* for offsetof */\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nseed_rng(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_server_config",
          "args": [
            "&options",
            "rexeced_flag ? \"rexec\" : config_file_name",
            "cfg",
            "NULL"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "parse_server_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2359-2382",
          "snippet": "void\nparse_server_config(ServerOptions *options, const char *filename,\n    struct sshbuf *conf, struct connection_info *connectinfo)\n{\n\tint active, linenum, bad_options = 0;\n\tchar *cp, *obuf, *cbuf;\n\n\tdebug2(\"%s: config %s len %zu\", __func__, filename, sshbuf_len(conf));\n\n\tif ((obuf = cbuf = sshbuf_dup_string(conf)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\tactive = connectinfo ? 0 : 1;\n\tlinenum = 1;\n\twhile ((cp = strsep(&cbuf, \"\\n\")) != NULL) {\n\t\tif (process_server_config_line(options, cp, filename,\n\t\t    linenum++, &active, connectinfo) != 0)\n\t\t\tbad_options++;\n\t}\n\tfree(obuf);\n\tif (bad_options > 0)\n\t\tfatal(\"%s: terminating, %d bad configuration options\",\n\t\t    filename, bad_options);\n\tprocess_queued_listen_addrs(options);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nparse_server_config(ServerOptions *options, const char *filename,\n    struct sshbuf *conf, struct connection_info *connectinfo)\n{\n\tint active, linenum, bad_options = 0;\n\tchar *cp, *obuf, *cbuf;\n\n\tdebug2(\"%s: config %s len %zu\", __func__, filename, sshbuf_len(conf));\n\n\tif ((obuf = cbuf = sshbuf_dup_string(conf)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\tactive = connectinfo ? 0 : 1;\n\tlinenum = 1;\n\twhile ((cp = strsep(&cbuf, \"\\n\")) != NULL) {\n\t\tif (process_server_config_line(options, cp, filename,\n\t\t    linenum++, &active, connectinfo) != 0)\n\t\t\tbad_options++;\n\t}\n\tfree(obuf);\n\tif (bad_options > 0)\n\t\tfatal(\"%s: terminating, %d bad configuration options\",\n\t\t    filename, bad_options);\n\tprocess_queued_listen_addrs(options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_server_config",
          "args": [
            "config_file_name",
            "cfg"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "load_server_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2175-2207",
          "snippet": "void\nload_server_config(const char *filename, struct sshbuf *conf)\n{\n\tchar *line = NULL, *cp;\n\tsize_t linesize = 0;\n\tFILE *f;\n\tint r, lineno = 0;\n\n\tdebug2(\"%s: filename %s\", __func__, filename);\n\tif ((f = fopen(filename, \"r\")) == NULL) {\n\t\tperror(filename);\n\t\texit(1);\n\t}\n\tsshbuf_reset(conf);\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlineno++;\n\t\t/*\n\t\t * Trim out comments and strip whitespace\n\t\t * NB - preserve newlines, they are needed to reproduce\n\t\t * line numbers later for error messages\n\t\t */\n\t\tif ((cp = strchr(line, '#')) != NULL)\n\t\t\tmemcpy(cp, \"\\n\", 2);\n\t\tcp = line + strspn(line, \" \\t\\r\");\n\t\tif ((r = sshbuf_put(conf, cp, strlen(cp))) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tfree(line);\n\tif ((r = sshbuf_put_u8(conf, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tfclose(f);\n\tdebug2(\"%s: done config len = %zu\", __func__, sshbuf_len(conf));\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nload_server_config(const char *filename, struct sshbuf *conf)\n{\n\tchar *line = NULL, *cp;\n\tsize_t linesize = 0;\n\tFILE *f;\n\tint r, lineno = 0;\n\n\tdebug2(\"%s: filename %s\", __func__, filename);\n\tif ((f = fopen(filename, \"r\")) == NULL) {\n\t\tperror(filename);\n\t\texit(1);\n\t}\n\tsshbuf_reset(conf);\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlineno++;\n\t\t/*\n\t\t * Trim out comments and strip whitespace\n\t\t * NB - preserve newlines, they are needed to reproduce\n\t\t * line numbers later for error messages\n\t\t */\n\t\tif ((cp = strchr(line, '#')) != NULL)\n\t\t\tmemcpy(cp, \"\\n\", 2);\n\t\tcp = line + strspn(line, \" \\t\\r\");\n\t\tif ((r = sshbuf_put(conf, cp, strlen(cp))) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tfree(line);\n\tif ((r = sshbuf_put_u8(conf, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tfclose(f);\n\tdebug2(\"%s: done config len = %zu\", __func__, sshbuf_len(conf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "config_file_name",
            "\"none\""
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsetenv",
          "args": [
            "\"KRB5CCNAME\""
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "unsetenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/setenv.c",
          "lines": "197-222",
          "snippet": "int\nunsetenv(const char *name)\n{\n\tchar **P;\n\tconst char *np;\n\tint offset = 0;\n\n\tif (!name || !*name) {\n\t\terrno = EINVAL;\n\t\treturn (-1);\n\t}\n\tfor (np = name; *np && *np != '='; ++np)\n\t\t;\n\tif (*np) {\n\t\terrno = EINVAL;\n\t\treturn (-1);\t\t\t/* has `=' in name */\n\t}\n\n\t/* could be set multiple times */\n\twhile (__findenv(name, (int)(np - name), &offset)) {\n\t\tfor (P = &environ[offset];; ++P)\n\t\t\tif (!(*P = *(P + 1)))\n\t\t\t\tbreak;\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint\nunsetenv(const char *name)\n{\n\tchar **P;\n\tconst char *np;\n\tint offset = 0;\n\n\tif (!name || !*name) {\n\t\terrno = EINVAL;\n\t\treturn (-1);\n\t}\n\tfor (np = name; *np && *np != '='; ++np)\n\t\t;\n\tif (*np) {\n\t\terrno = EINVAL;\n\t\treturn (-1);\t\t\t/* has `=' in name */\n\t}\n\n\t/* could be set multiple times */\n\twhile (__findenv(name, (int)(np - name), &offset)) {\n\t\tfor (P = &environ[offset];; ++P)\n\t\t\tif (!(*P = *(P + 1)))\n\t\t\t\tbreak;\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"KRB5CCNAME\""
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "pam_getenvlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "254-263",
          "snippet": "static char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_redirect_stderr_to",
          "args": [
            "logfile"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "log_redirect_stderr_to",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "368-379",
          "snippet": "void\nlog_redirect_stderr_to(const char *logfile)\n{\n\tint fd;\n\n\tif ((fd = open(logfile, O_WRONLY|O_CREAT|O_APPEND, 0600)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open logfile %s: %s\\n\", logfile,\n\t\t     strerror(errno));\n\t\texit(1);\n\t}\n\tlog_stderr_fd = fd;\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int log_stderr_fd = STDERR_FILENO;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int log_stderr_fd = STDERR_FILENO;\n\nvoid\nlog_redirect_stderr_to(const char *logfile)\n{\n\tint fd;\n\n\tif ((fd = open(logfile, O_WRONLY|O_CREAT|O_APPEND, 0600)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open logfile %s: %s\\n\", logfile,\n\t\t     strerror(errno));\n\t\texit(1);\n\t}\n\tlog_stderr_fd = fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OpenSSL_add_all_algorithms",
          "args": [],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_OpenSSL_add_all_algorithms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/openssl-compat.c",
          "lines": "70-85",
          "snippet": "void\nssh_OpenSSL_add_all_algorithms(void)\n{\n\tOpenSSL_add_all_algorithms();\n\n\t/* Enable use of crypto hardware */\n\tENGINE_load_builtin_engines();\n\tENGINE_register_all_complete();\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tOPENSSL_config(NULL);\n#else\n\tOPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS |\n\t    OPENSSL_INIT_ADD_ALL_DIGESTS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#endif\n}",
          "includes": [
            "#include \"openssl-compat.h\"",
            "#include \"log.h\"",
            "# include <openssl/conf.h>",
            "# include <openssl/engine.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openssl-compat.h\"\n#include \"log.h\"\n# include <openssl/conf.h>\n# include <openssl/engine.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nssh_OpenSSL_add_all_algorithms(void)\n{\n\tOpenSSL_add_all_algorithms();\n\n\t/* Enable use of crypto hardware */\n\tENGINE_load_builtin_engines();\n\tENGINE_register_all_complete();\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tOPENSSL_config(NULL);\n#else\n\tOPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS |\n\t    OPENSSL_INIT_ADD_ALL_DIGESTS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "closefrom",
          "args": [
            "REEXEC_DEVCRYPTO_RESERVED_FD"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "914-931",
          "snippet": "static void\nusage(void)\n{\n\tfprintf(stderr, \"%s, %s\\n\",\n\t    SSH_RELEASE,\n#ifdef WITH_OPENSSL\n\t    OpenSSL_version(OPENSSL_VERSION)\n#else\n\t    \"without OpenSSL\"\n#endif\n\t);\n\tfprintf(stderr,\n\"usage: sshd [-46DdeiqTt] [-C connection_spec] [-c host_cert_file]\\n\"\n\"            [-E log_file] [-f config_file] [-g login_grace_time]\\n\"\n\"            [-h host_key_file] [-o option] [-p port] [-u len]\\n\"\n\t);\n\texit(1);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr, \"%s, %s\\n\",\n\t    SSH_RELEASE,\n#ifdef WITH_OPENSSL\n\t    OpenSSL_version(OPENSSL_VERSION)\n#else\n\t    \"without OpenSSL\"\n#endif\n\t);\n\tfprintf(stderr,\n\"usage: sshd [-46DdeiqTt] [-C connection_spec] [-c host_cert_file]\\n\"\n\"            [-E log_file] [-f config_file] [-g login_grace_time]\\n\"\n\"            [-h host_key_file] [-o option] [-p port] [-u len]\\n\"\n\t);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_server_config_line",
          "args": [
            "&options",
            "line",
            "\"command-line\"",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "process_server_config_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "1199-2171",
          "snippet": "int\nprocess_server_config_line(ServerOptions *options, char *line,\n    const char *filename, int linenum, int *activep,\n    struct connection_info *connectinfo)\n{\n\tchar *cp, ***chararrayptr, **charptr, *arg, *arg2, *p;\n\tint cmdline = 0, *intptr, value, value2, n, port;\n\tSyslogFacility *log_facility_ptr;\n\tLogLevel *log_level_ptr;\n\tServerOpCodes opcode;\n\tu_int i, *uintptr, uvalue, flags = 0;\n\tsize_t len;\n\tlong long val64;\n\tconst struct multistate *multistate_ptr;\n\tconst char *errstr;\n\n\t/* Strip trailing whitespace. Allow \\f (form feed) at EOL only */\n\tif ((len = strlen(line)) == 0)\n\t\treturn 0;\n\tfor (len--; len > 0; len--) {\n\t\tif (strchr(WHITESPACE \"\\f\", line[len]) == NULL)\n\t\t\tbreak;\n\t\tline[len] = '\\0';\n\t}\n\n\tcp = line;\n\tif ((arg = strdelim(&cp)) == NULL)\n\t\treturn 0;\n\t/* Ignore leading whitespace */\n\tif (*arg == '\\0')\n\t\targ = strdelim(&cp);\n\tif (!arg || !*arg || *arg == '#')\n\t\treturn 0;\n\tintptr = NULL;\n\tcharptr = NULL;\n\topcode = parse_token(arg, filename, linenum, &flags);\n\n\tif (activep == NULL) { /* We are processing a command line directive */\n\t\tcmdline = 1;\n\t\tactivep = &cmdline;\n\t}\n\tif (*activep && opcode != sMatch)\n\t\tdebug3(\"%s:%d setting %s %s\", filename, linenum, arg, cp);\n\tif (*activep == 0 && !(flags & SSHCFG_MATCH)) {\n\t\tif (connectinfo == NULL) {\n\t\t\tfatal(\"%s line %d: Directive '%s' is not allowed \"\n\t\t\t    \"within a Match block\", filename, linenum, arg);\n\t\t} else { /* this is a directive we have already processed */\n\t\t\twhile (arg)\n\t\t\t\targ = strdelim(&cp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tswitch (opcode) {\n\t/* Portable-specific options */\n\tcase sUsePAM:\n\t\tintptr = &options->use_pam;\n\t\tgoto parse_flag;\n\n\t/* Standard Options */\n\tcase sBadOption:\n\t\treturn -1;\n\tcase sPort:\n\t\t/* ignore ports from configfile if cmdline specifies ports */\n\t\tif (options->ports_from_cmdline)\n\t\t\treturn 0;\n\t\tif (options->num_ports >= MAX_PORTS)\n\t\t\tfatal(\"%s line %d: too many ports.\",\n\t\t\t    filename, linenum);\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing port number.\",\n\t\t\t    filename, linenum);\n\t\toptions->ports[options->num_ports++] = a2port(arg);\n\t\tif (options->ports[options->num_ports-1] <= 0)\n\t\t\tfatal(\"%s line %d: Badly formatted port number.\",\n\t\t\t    filename, linenum);\n\t\tbreak;\n\n\tcase sLoginGraceTime:\n\t\tintptr = &options->login_grace_time;\n parse_time:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing time value.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = convtime(arg)) == -1)\n\t\t\tfatal(\"%s line %d: invalid time value.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sListenAddress:\n\t\targ = strdelim(&cp);\n\t\tif (arg == NULL || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing address\",\n\t\t\t    filename, linenum);\n\t\t/* check for bare IPv6 address: no \"[]\" and 2 or more \":\" */\n\t\tif (strchr(arg, '[') == NULL && (p = strchr(arg, ':')) != NULL\n\t\t    && strchr(p+1, ':') != NULL) {\n\t\t\tport = 0;\n\t\t\tp = arg;\n\t\t} else {\n\t\t\tp = hpdelim(&arg);\n\t\t\tif (p == NULL)\n\t\t\t\tfatal(\"%s line %d: bad address:port usage\",\n\t\t\t\t    filename, linenum);\n\t\t\tp = cleanhostname(p);\n\t\t\tif (arg == NULL)\n\t\t\t\tport = 0;\n\t\t\telse if ((port = a2port(arg)) <= 0)\n\t\t\t\tfatal(\"%s line %d: bad port number\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\t/* Optional routing table */\n\t\targ2 = NULL;\n\t\tif ((arg = strdelim(&cp)) != NULL) {\n\t\t\tif (strcmp(arg, \"rdomain\") != 0 ||\n\t\t\t    (arg2 = strdelim(&cp)) == NULL)\n\t\t\t\tfatal(\"%s line %d: bad ListenAddress syntax\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!valid_rdomain(arg2))\n\t\t\t\tfatal(\"%s line %d: bad routing domain\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\n\t\tqueue_listen_addr(options, p, arg2, port);\n\n\t\tbreak;\n\n\tcase sAddressFamily:\n\t\tintptr = &options->address_family;\n\t\tmultistate_ptr = multistate_addressfamily;\n parse_multistate:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; multistate_ptr[i].key != NULL; i++) {\n\t\t\tif (strcasecmp(arg, multistate_ptr[i].key) == 0) {\n\t\t\t\tvalue = multistate_ptr[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: unsupported option \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sHostKeyFile:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep)\n\t\t\tservconf_add_hostkey(filename, linenum, options, arg);\n\t\tbreak;\n\n\tcase sHostKeyAgent:\n\t\tcharptr = &options->host_key_agent;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing socket name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = !strcmp(arg, SSH_AUTHSOCKET_ENV_NAME) ?\n\t\t\t    xstrdup(arg) : derelativise_path(arg);\n\t\tbreak;\n\n\tcase sHostCertificate:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep)\n\t\t\tservconf_add_hostcert(filename, linenum, options, arg);\n\t\tbreak;\n\n\tcase sPidFile:\n\t\tcharptr = &options->pid_file;\n parse_filename:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL) {\n\t\t\t*charptr = derelativise_path(arg);\n\t\t\t/* increase optional counter */\n\t\t\tif (intptr != NULL)\n\t\t\t\t*intptr = *intptr + 1;\n\t\t}\n\t\tbreak;\n\n\tcase sPermitRootLogin:\n\t\tintptr = &options->permit_root_login;\n\t\tmultistate_ptr = multistate_permitrootlogin;\n\t\tgoto parse_multistate;\n\n\tcase sIgnoreRhosts:\n\t\tintptr = &options->ignore_rhosts;\n parse_flag:\n\t\tmultistate_ptr = multistate_flag;\n\t\tgoto parse_multistate;\n\n\tcase sIgnoreUserKnownHosts:\n\t\tintptr = &options->ignore_user_known_hosts;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedAuthentication:\n\t\tintptr = &options->hostbased_authentication;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedUsesNameFromPacketOnly:\n\t\tintptr = &options->hostbased_uses_name_from_packet_only;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedAcceptedKeyTypes:\n\t\tcharptr = &options->hostbased_key_types;\n parse_keytypes:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !sshkey_names_valid2(*arg == '+' ? arg + 1 : arg, 1))\n\t\t\tfatal(\"%s line %d: Bad key types '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sHostKeyAlgorithms:\n\t\tcharptr = &options->hostkeyalgorithms;\n\t\tgoto parse_keytypes;\n\n\tcase sCASignatureAlgorithms:\n\t\tcharptr = &options->ca_sign_algorithms;\n\t\tgoto parse_keytypes;\n\n\tcase sPubkeyAuthentication:\n\t\tintptr = &options->pubkey_authentication;\n\t\tgoto parse_flag;\n\n\tcase sPubkeyAcceptedKeyTypes:\n\t\tcharptr = &options->pubkey_key_types;\n\t\tgoto parse_keytypes;\n\n\tcase sKerberosAuthentication:\n\t\tintptr = &options->kerberos_authentication;\n\t\tgoto parse_flag;\n\n\tcase sKerberosOrLocalPasswd:\n\t\tintptr = &options->kerberos_or_local_passwd;\n\t\tgoto parse_flag;\n\n\tcase sKerberosTicketCleanup:\n\t\tintptr = &options->kerberos_ticket_cleanup;\n\t\tgoto parse_flag;\n\n\tcase sKerberosGetAFSToken:\n\t\tintptr = &options->kerberos_get_afs_token;\n\t\tgoto parse_flag;\n\n\tcase sGssAuthentication:\n\t\tintptr = &options->gss_authentication;\n\t\tgoto parse_flag;\n\n\tcase sGssCleanupCreds:\n\t\tintptr = &options->gss_cleanup_creds;\n\t\tgoto parse_flag;\n\n\tcase sGssStrictAcceptor:\n\t\tintptr = &options->gss_strict_acceptor;\n\t\tgoto parse_flag;\n\n\tcase sPasswordAuthentication:\n\t\tintptr = &options->password_authentication;\n\t\tgoto parse_flag;\n\n\tcase sKbdInteractiveAuthentication:\n\t\tintptr = &options->kbd_interactive_authentication;\n\t\tgoto parse_flag;\n\n\tcase sChallengeResponseAuthentication:\n\t\tintptr = &options->challenge_response_authentication;\n\t\tgoto parse_flag;\n\n\tcase sPrintMotd:\n\t\tintptr = &options->print_motd;\n\t\tgoto parse_flag;\n\n\tcase sPrintLastLog:\n\t\tintptr = &options->print_lastlog;\n\t\tgoto parse_flag;\n\n\tcase sX11Forwarding:\n\t\tintptr = &options->x11_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sX11DisplayOffset:\n\t\tintptr = &options->x11_display_offset;\n parse_int:\n\t\targ = strdelim(&cp);\n\t\tif ((errstr = atoi_err(arg, &value)) != NULL)\n\t\t\tfatal(\"%s line %d: integer value %s.\",\n\t\t\t    filename, linenum, errstr);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sX11UseLocalhost:\n\t\tintptr = &options->x11_use_localhost;\n\t\tgoto parse_flag;\n\n\tcase sXAuthLocation:\n\t\tcharptr = &options->xauth_location;\n\t\tgoto parse_filename;\n\n\tcase sPermitTTY:\n\t\tintptr = &options->permit_tty;\n\t\tgoto parse_flag;\n\n\tcase sPermitUserRC:\n\t\tintptr = &options->permit_user_rc;\n\t\tgoto parse_flag;\n\n\tcase sStrictModes:\n\t\tintptr = &options->strict_modes;\n\t\tgoto parse_flag;\n\n\tcase sTCPKeepAlive:\n\t\tintptr = &options->tcp_keep_alive;\n\t\tgoto parse_flag;\n\n\tcase sEmptyPasswd:\n\t\tintptr = &options->permit_empty_passwd;\n\t\tgoto parse_flag;\n\n\tcase sPermitUserEnvironment:\n\t\tintptr = &options->permit_user_env;\n\t\tcharptr = &options->permit_user_env_whitelist;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = 0;\n\t\tp = NULL;\n\t\tif (strcmp(arg, \"yes\") == 0)\n\t\t\tvalue = 1;\n\t\telse if (strcmp(arg, \"no\") == 0)\n\t\t\tvalue = 0;\n\t\telse {\n\t\t\t/* Pattern-list specified */\n\t\t\tvalue = 1;\n\t\t\tp = xstrdup(arg);\n\t\t}\n\t\tif (*activep && *intptr == -1) {\n\t\t\t*intptr = value;\n\t\t\t*charptr = p;\n\t\t\tp = NULL;\n\t\t}\n\t\tfree(p);\n\t\tbreak;\n\n\tcase sCompression:\n\t\tintptr = &options->compression;\n\t\tmultistate_ptr = multistate_compression;\n\t\tgoto parse_multistate;\n\n\tcase sRekeyLimit:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tif (strcmp(arg, \"default\") == 0) {\n\t\t\tval64 = 0;\n\t\t} else {\n\t\t\tif (scan_scaled(arg, &val64) == -1)\n\t\t\t\tfatal(\"%.200s line %d: Bad number '%s': %s\",\n\t\t\t\t    filename, linenum, arg, strerror(errno));\n\t\t\tif (val64 != 0 && val64 < 16)\n\t\t\t\tfatal(\"%.200s line %d: RekeyLimit too small\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\tif (*activep && options->rekey_limit == -1)\n\t\t\toptions->rekey_limit = val64;\n\t\tif (cp != NULL) { /* optional rekey interval present */\n\t\t\tif (strcmp(cp, \"none\") == 0) {\n\t\t\t\t(void)strdelim(&cp);\t/* discard */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tintptr = &options->rekey_interval;\n\t\t\tgoto parse_time;\n\t\t}\n\t\tbreak;\n\n\tcase sGatewayPorts:\n\t\tintptr = &options->fwd_opts.gateway_ports;\n\t\tmultistate_ptr = multistate_gatewayports;\n\t\tgoto parse_multistate;\n\n\tcase sUseDNS:\n\t\tintptr = &options->use_dns;\n\t\tgoto parse_flag;\n\n\tcase sLogFacility:\n\t\tlog_facility_ptr = &options->log_facility;\n\t\targ = strdelim(&cp);\n\t\tvalue = log_facility_number(arg);\n\t\tif (value == SYSLOG_FACILITY_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log facility '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*log_facility_ptr == -1)\n\t\t\t*log_facility_ptr = (SyslogFacility) value;\n\t\tbreak;\n\n\tcase sLogLevel:\n\t\tlog_level_ptr = &options->log_level;\n\t\targ = strdelim(&cp);\n\t\tvalue = log_level_number(arg);\n\t\tif (value == SYSLOG_LEVEL_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log level '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *log_level_ptr == -1)\n\t\t\t*log_level_ptr = (LogLevel) value;\n\t\tbreak;\n\n\tcase sAllowTcpForwarding:\n\t\tintptr = &options->allow_tcp_forwarding;\n\t\tmultistate_ptr = multistate_tcpfwd;\n\t\tgoto parse_multistate;\n\n\tcase sAllowStreamLocalForwarding:\n\t\tintptr = &options->allow_streamlocal_forwarding;\n\t\tmultistate_ptr = multistate_tcpfwd;\n\t\tgoto parse_multistate;\n\n\tcase sAllowAgentForwarding:\n\t\tintptr = &options->allow_agent_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sDisableForwarding:\n\t\tintptr = &options->disable_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sAllowUsers:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (match_user(NULL, NULL, NULL, arg) == -1)\n\t\t\t\tfatal(\"%s line %d: invalid AllowUsers pattern: \"\n\t\t\t\t    \"\\\"%.100s\\\"\", filename, linenum, arg);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"AllowUsers\",\n\t\t\t    &options->allow_users, &options->num_allow_users,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sDenyUsers:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (match_user(NULL, NULL, NULL, arg) == -1)\n\t\t\t\tfatal(\"%s line %d: invalid DenyUsers pattern: \"\n\t\t\t\t    \"\\\"%.100s\\\"\", filename, linenum, arg);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"DenyUsers\",\n\t\t\t    &options->deny_users, &options->num_deny_users,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sAllowGroups:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"AllowGroups\",\n\t\t\t    &options->allow_groups, &options->num_allow_groups,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sDenyGroups:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"DenyGroups\",\n\t\t\t    &options->deny_groups, &options->num_deny_groups,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sCiphers:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !ciphers_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 cipher spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->ciphers == NULL)\n\t\t\toptions->ciphers = xstrdup(arg);\n\t\tbreak;\n\n\tcase sMacs:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !mac_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 mac spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->macs == NULL)\n\t\t\toptions->macs = xstrdup(arg);\n\t\tbreak;\n\n\tcase sKexAlgorithms:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !kex_names_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 KexAlgorithms '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->kex_algorithms == NULL)\n\t\t\toptions->kex_algorithms = xstrdup(arg);\n\t\tbreak;\n\n\tcase sSubsystem:\n\t\tif (options->num_subsystems >= MAX_SUBSYSTEMS) {\n\t\t\tfatal(\"%s line %d: too many subsystems defined.\",\n\t\t\t    filename, linenum);\n\t\t}\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing subsystem name.\",\n\t\t\t    filename, linenum);\n\t\tif (!*activep) {\n\t\t\targ = strdelim(&cp);\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < options->num_subsystems; i++)\n\t\t\tif (strcmp(arg, options->subsystem_name[i]) == 0)\n\t\t\t\tfatal(\"%s line %d: Subsystem '%s' already defined.\",\n\t\t\t\t    filename, linenum, arg);\n\t\toptions->subsystem_name[options->num_subsystems] = xstrdup(arg);\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing subsystem command.\",\n\t\t\t    filename, linenum);\n\t\toptions->subsystem_command[options->num_subsystems] = xstrdup(arg);\n\n\t\t/* Collect arguments (separate to executable) */\n\t\tp = xstrdup(arg);\n\t\tlen = strlen(p) + 1;\n\t\twhile ((arg = strdelim(&cp)) != NULL && *arg != '\\0') {\n\t\t\tlen += 1 + strlen(arg);\n\t\t\tp = xreallocarray(p, 1, len);\n\t\t\tstrlcat(p, \" \", len);\n\t\t\tstrlcat(p, arg, len);\n\t\t}\n\t\toptions->subsystem_args[options->num_subsystems] = p;\n\t\toptions->num_subsystems++;\n\t\tbreak;\n\n\tcase sMaxStartups:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing MaxStartups spec.\",\n\t\t\t    filename, linenum);\n\t\tif ((n = sscanf(arg, \"%d:%d:%d\",\n\t\t    &options->max_startups_begin,\n\t\t    &options->max_startups_rate,\n\t\t    &options->max_startups)) == 3) {\n\t\t\tif (options->max_startups_begin >\n\t\t\t    options->max_startups ||\n\t\t\t    options->max_startups_rate > 100 ||\n\t\t\t    options->max_startups_rate < 1)\n\t\t\t\tfatal(\"%s line %d: Illegal MaxStartups spec.\",\n\t\t\t\t    filename, linenum);\n\t\t} else if (n != 1)\n\t\t\tfatal(\"%s line %d: Illegal MaxStartups spec.\",\n\t\t\t    filename, linenum);\n\t\telse\n\t\t\toptions->max_startups = options->max_startups_begin;\n\t\tbreak;\n\n\tcase sMaxAuthTries:\n\t\tintptr = &options->max_authtries;\n\t\tgoto parse_int;\n\n\tcase sMaxSessions:\n\t\tintptr = &options->max_sessions;\n\t\tgoto parse_int;\n\n\tcase sBanner:\n\t\tcharptr = &options->banner;\n\t\tgoto parse_filename;\n\n\t/*\n\t * These options can contain %X options expanded at\n\t * connect time, so that you can specify paths like:\n\t *\n\t * AuthorizedKeysFile\t/etc/ssh_keys/%u\n\t */\n\tcase sAuthorizedKeysFile:\n\t\tif (*activep && options->num_authkeys_files == 0) {\n\t\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\t\targ = tilde_expand_filename(arg, getuid());\n\t\t\t\tarray_append(filename, linenum,\n\t\t\t\t    \"AuthorizedKeysFile\",\n\t\t\t\t    &options->authorized_keys_files,\n\t\t\t\t    &options->num_authkeys_files, arg);\n\t\t\t\tfree(arg);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedPrincipalsFile:\n\t\tcharptr = &options->authorized_principals_file;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL) {\n\t\t\t*charptr = tilde_expand_filename(arg, getuid());\n\t\t\t/* increase optional counter */\n\t\t\tif (intptr != NULL)\n\t\t\t\t*intptr = *intptr + 1;\n\t\t}\n\t\tbreak;\n\n\tcase sClientAliveInterval:\n\t\tintptr = &options->client_alive_interval;\n\t\tgoto parse_time;\n\n\tcase sClientAliveCountMax:\n\t\tintptr = &options->client_alive_count_max;\n\t\tgoto parse_int;\n\n\tcase sAcceptEnv:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') != NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment name.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"AcceptEnv\",\n\t\t\t    &options->accept_env, &options->num_accept_env,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sSetEnv:\n\t\tuvalue = options->num_setenv;\n\t\twhile ((arg = strdelimw(&cp)) && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') == NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep || uvalue != 0)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"SetEnv\",\n\t\t\t    &options->setenv, &options->num_setenv, arg);\n\t\t}\n\t\tbreak;\n\n\tcase sPermitTunnel:\n\t\tintptr = &options->permit_tun;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing yes/point-to-point/\"\n\t\t\t    \"ethernet/no argument.\", filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; tunmode_desc[i].val != -1; i++)\n\t\t\tif (strcmp(tunmode_desc[i].text, arg) == 0) {\n\t\t\t\tvalue = tunmode_desc[i].val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: Bad yes/point-to-point/ethernet/\"\n\t\t\t    \"no argument: %s\", filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sMatch:\n\t\tif (cmdline)\n\t\t\tfatal(\"Match directive not supported as a command-line \"\n\t\t\t   \"option\");\n\t\tvalue = match_cfg_line(&cp, linenum, connectinfo);\n\t\tif (value < 0)\n\t\t\tfatal(\"%s line %d: Bad Match condition\", filename,\n\t\t\t    linenum);\n\t\t*activep = value;\n\t\tbreak;\n\n\tcase sPermitListen:\n\tcase sPermitOpen:\n\t\tif (opcode == sPermitListen) {\n\t\t\tuintptr = &options->num_permitted_listens;\n\t\t\tchararrayptr = &options->permitted_listens;\n\t\t} else {\n\t\t\tuintptr = &options->num_permitted_opens;\n\t\t\tchararrayptr = &options->permitted_opens;\n\t\t}\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing %s specification\",\n\t\t\t    filename, linenum, lookup_opcode_name(opcode));\n\t\tuvalue = *uintptr;\t/* modified later */\n\t\tif (strcmp(arg, \"any\") == 0 || strcmp(arg, \"none\") == 0) {\n\t\t\tif (*activep && uvalue == 0) {\n\t\t\t\t*uintptr = 1;\n\t\t\t\t*chararrayptr = xcalloc(1,\n\t\t\t\t    sizeof(**chararrayptr));\n\t\t\t\t(*chararrayptr)[0] = xstrdup(arg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfor (; arg != NULL && *arg != '\\0'; arg = strdelim(&cp)) {\n\t\t\tif (opcode == sPermitListen &&\n\t\t\t    strchr(arg, ':') == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Allow bare port number for PermitListen\n\t\t\t\t * to indicate a wildcard listen host.\n\t\t\t\t */\n\t\t\t\txasprintf(&arg2, \"*:%s\", arg);\n\t\t\t} else {\n\t\t\t\targ2 = xstrdup(arg);\n\t\t\t\tp = hpdelim(&arg);\n\t\t\t\tif (p == NULL) {\n\t\t\t\t\tfatal(\"%s line %d: missing host in %s\",\n\t\t\t\t\t    filename, linenum,\n\t\t\t\t\t    lookup_opcode_name(opcode));\n\t\t\t\t}\n\t\t\t\tp = cleanhostname(p);\n\t\t\t}\n\t\t\tif (arg == NULL ||\n\t\t\t    ((port = permitopen_port(arg)) < 0)) {\n\t\t\t\tfatal(\"%s line %d: bad port number in %s\",\n\t\t\t\t    filename, linenum,\n\t\t\t\t    lookup_opcode_name(opcode));\n\t\t\t}\n\t\t\tif (*activep && uvalue == 0) {\n\t\t\t\tarray_append(filename, linenum,\n\t\t\t\t    lookup_opcode_name(opcode),\n\t\t\t\t    chararrayptr, uintptr, arg2);\n\t\t\t}\n\t\t\tfree(arg2);\n\t\t}\n\t\tbreak;\n\n\tcase sForceCommand:\n\t\tif (cp == NULL || *cp == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep && options->adm_forced_command == NULL)\n\t\t\toptions->adm_forced_command = xstrdup(cp + len);\n\t\treturn 0;\n\n\tcase sChrootDirectory:\n\t\tcharptr = &options->chroot_directory;\n\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sTrustedUserCAKeys:\n\t\tcharptr = &options->trusted_user_ca_keys;\n\t\tgoto parse_filename;\n\n\tcase sRevokedKeys:\n\t\tcharptr = &options->revoked_keys_file;\n\t\tgoto parse_filename;\n\n\tcase sIPQoS:\n\t\targ = strdelim(&cp);\n\t\tif ((value = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\targ = strdelim(&cp);\n\t\tif (arg == NULL)\n\t\t\tvalue2 = value;\n\t\telse if ((value2 = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep) {\n\t\t\toptions->ip_qos_interactive = value;\n\t\t\toptions->ip_qos_bulk = value2;\n\t\t}\n\t\tbreak;\n\n\tcase sVersionAddendum:\n\t\tif (cp == NULL || *cp == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep && options->version_addendum == NULL) {\n\t\t\tif (strcasecmp(cp + len, \"none\") == 0)\n\t\t\t\toptions->version_addendum = xstrdup(\"\");\n\t\t\telse if (strchr(cp + len, '\\r') != NULL)\n\t\t\t\tfatal(\"%.200s line %d: Invalid argument\",\n\t\t\t\t    filename, linenum);\n\t\t\telse\n\t\t\t\toptions->version_addendum = xstrdup(cp + len);\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedKeysCommand:\n\t\tif (cp == NULL)\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep && options->authorized_keys_command == NULL) {\n\t\t\tif (cp[len] != '/' && strcasecmp(cp + len, \"none\") != 0)\n\t\t\t\tfatal(\"%.200s line %d: AuthorizedKeysCommand \"\n\t\t\t\t    \"must be an absolute path\",\n\t\t\t\t    filename, linenum);\n\t\t\toptions->authorized_keys_command = xstrdup(cp + len);\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedKeysCommandUser:\n\t\tcharptr = &options->authorized_keys_command_user;\n\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing AuthorizedKeysCommandUser \"\n\t\t\t    \"argument.\", filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sAuthorizedPrincipalsCommand:\n\t\tif (cp == NULL)\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep &&\n\t\t    options->authorized_principals_command == NULL) {\n\t\t\tif (cp[len] != '/' && strcasecmp(cp + len, \"none\") != 0)\n\t\t\t\tfatal(\"%.200s line %d: \"\n\t\t\t\t    \"AuthorizedPrincipalsCommand must be \"\n\t\t\t\t    \"an absolute path\", filename, linenum);\n\t\t\toptions->authorized_principals_command =\n\t\t\t    xstrdup(cp + len);\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedPrincipalsCommandUser:\n\t\tcharptr = &options->authorized_principals_command_user;\n\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing \"\n\t\t\t    \"AuthorizedPrincipalsCommandUser argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sAuthenticationMethods:\n\t\tif (options->num_auth_methods == 0) {\n\t\t\tvalue = 0; /* seen \"any\" pseudo-method */\n\t\t\tvalue2 = 0; /* successfully parsed any method */\n\t\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\t\tif (strcmp(arg, \"any\") == 0) {\n\t\t\t\t\tif (options->num_auth_methods > 0) {\n\t\t\t\t\t\tfatal(\"%s line %d: \\\"any\\\" \"\n\t\t\t\t\t\t    \"must appear alone in \"\n\t\t\t\t\t\t    \"AuthenticationMethods\",\n\t\t\t\t\t\t    filename, linenum);\n\t\t\t\t\t}\n\t\t\t\t\tvalue = 1;\n\t\t\t\t} else if (value) {\n\t\t\t\t\tfatal(\"%s line %d: \\\"any\\\" must appear \"\n\t\t\t\t\t    \"alone in AuthenticationMethods\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\t} else if (auth2_methods_valid(arg, 0) != 0) {\n\t\t\t\t\tfatal(\"%s line %d: invalid \"\n\t\t\t\t\t    \"authentication method list.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\t}\n\t\t\t\tvalue2 = 1;\n\t\t\t\tif (!*activep)\n\t\t\t\t\tcontinue;\n\t\t\t\tarray_append(filename, linenum,\n\t\t\t\t    \"AuthenticationMethods\",\n\t\t\t\t    &options->auth_methods,\n\t\t\t\t    &options->num_auth_methods, arg);\n\t\t\t}\n\t\t\tif (value2 == 0) {\n\t\t\t\tfatal(\"%s line %d: no AuthenticationMethods \"\n\t\t\t\t    \"specified\", filename, linenum);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase sStreamLocalBindMask:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing StreamLocalBindMask \"\n\t\t\t    \"argument.\", filename, linenum);\n\t\t/* Parse mode in octal format */\n\t\tvalue = strtol(arg, &p, 8);\n\t\tif (arg == p || value < 0 || value > 0777)\n\t\t\tfatal(\"%s line %d: Bad mask.\", filename, linenum);\n\t\tif (*activep)\n\t\t\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)value;\n\t\tbreak;\n\n\tcase sStreamLocalBindUnlink:\n\t\tintptr = &options->fwd_opts.streamlocal_bind_unlink;\n\t\tgoto parse_flag;\n\n\tcase sFingerprintHash:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = ssh_digest_alg_by_name(arg)) == -1)\n\t\t\tfatal(\"%.200s line %d: Invalid hash algorithm \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep)\n\t\t\toptions->fingerprint_hash = value;\n\t\tbreak;\n\n\tcase sExposeAuthInfo:\n\t\tintptr = &options->expose_userauth_info;\n\t\tgoto parse_flag;\n\n\tcase sRDomain:\n\t\tcharptr = &options->routing_domain;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (strcasecmp(arg, \"none\") != 0 && strcmp(arg, \"%D\") != 0 &&\n\t\t    !valid_rdomain(arg))\n\t\t\tfatal(\"%s line %d: bad routing domain\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sDeprecated:\n\tcase sIgnore:\n\tcase sUnsupported:\n\t\tdo_log2(opcode == sIgnore ?\n\t\t    SYSLOG_LEVEL_DEBUG2 : SYSLOG_LEVEL_INFO,\n\t\t    \"%s line %d: %s option %s\", filename, linenum,\n\t\t    opcode == sUnsupported ? \"Unsupported\" : \"Deprecated\", arg);\n\t\twhile (arg)\n\t\t    arg = strdelim(&cp);\n\t\tbreak;\n\n\tdefault:\n\t\tfatal(\"%s line %d: Missing handler for opcode %s (%d)\",\n\t\t    filename, linenum, arg, opcode);\n\t}\n\tif ((arg = strdelim(&cp)) != NULL && *arg != '\\0')\n\t\tfatal(\"%s line %d: garbage at end of line; \\\"%.200s\\\".\",\n\t\t    filename, linenum, arg);\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define WHITESPACE \" \\t\\r\\n\"",
            "#define SSHCFG_MATCH\t0x02\t/* allowed inside a Match section */"
          ],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static struct {\n\tint val;\n\tchar *text;\n} tunmode_desc[] = {\n\t{ SSH_TUNMODE_NO, \"no\" },\n\t{ SSH_TUNMODE_POINTOPOINT, \"point-to-point\" },\n\t{ SSH_TUNMODE_ETHERNET, \"ethernet\" },\n\t{ SSH_TUNMODE_YES, \"yes\" },\n\t{ -1, NULL }\n};",
            "static const struct multistate multistate_flag[] = {\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_permitrootlogin[] = {\n\t{ \"without-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"prohibit-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"forced-commands-only\",\tPERMIT_FORCED_ONLY },\n\t{ \"yes\",\t\t\tPERMIT_YES },\n\t{ \"no\",\t\t\t\tPERMIT_NO },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_compression[] = {\n\t{ \"yes\",\t\t\tCOMP_DELAYED },\n\t{ \"delayed\",\t\t\tCOMP_DELAYED },\n\t{ \"no\",\t\t\t\tCOMP_NONE },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_gatewayports[] = {\n\t{ \"clientspecified\",\t\t2 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_tcpfwd[] = {\n\t{ \"yes\",\t\t\tFORWARD_ALLOW },\n\t{ \"all\",\t\t\tFORWARD_ALLOW },\n\t{ \"no\",\t\t\t\tFORWARD_DENY },\n\t{ \"remote\",\t\t\tFORWARD_REMOTE },\n\t{ \"local\",\t\t\tFORWARD_LOCAL },\n\t{ NULL, -1 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define WHITESPACE \" \\t\\r\\n\"\n#define SSHCFG_MATCH\t0x02\t/* allowed inside a Match section */\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic struct {\n\tint val;\n\tchar *text;\n} tunmode_desc[] = {\n\t{ SSH_TUNMODE_NO, \"no\" },\n\t{ SSH_TUNMODE_POINTOPOINT, \"point-to-point\" },\n\t{ SSH_TUNMODE_ETHERNET, \"ethernet\" },\n\t{ SSH_TUNMODE_YES, \"yes\" },\n\t{ -1, NULL }\n};\nstatic const struct multistate multistate_flag[] = {\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_permitrootlogin[] = {\n\t{ \"without-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"prohibit-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"forced-commands-only\",\tPERMIT_FORCED_ONLY },\n\t{ \"yes\",\t\t\tPERMIT_YES },\n\t{ \"no\",\t\t\t\tPERMIT_NO },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_compression[] = {\n\t{ \"yes\",\t\t\tCOMP_DELAYED },\n\t{ \"delayed\",\t\t\tCOMP_DELAYED },\n\t{ \"no\",\t\t\t\tCOMP_NONE },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_gatewayports[] = {\n\t{ \"clientspecified\",\t\t2 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_tcpfwd[] = {\n\t{ \"yes\",\t\t\tFORWARD_ALLOW },\n\t{ \"all\",\t\t\tFORWARD_ALLOW },\n\t{ \"no\",\t\t\t\tFORWARD_DENY },\n\t{ \"remote\",\t\t\tFORWARD_REMOTE },\n\t{ \"local\",\t\t\tFORWARD_LOCAL },\n\t{ NULL, -1 }\n};\n\nint\nprocess_server_config_line(ServerOptions *options, char *line,\n    const char *filename, int linenum, int *activep,\n    struct connection_info *connectinfo)\n{\n\tchar *cp, ***chararrayptr, **charptr, *arg, *arg2, *p;\n\tint cmdline = 0, *intptr, value, value2, n, port;\n\tSyslogFacility *log_facility_ptr;\n\tLogLevel *log_level_ptr;\n\tServerOpCodes opcode;\n\tu_int i, *uintptr, uvalue, flags = 0;\n\tsize_t len;\n\tlong long val64;\n\tconst struct multistate *multistate_ptr;\n\tconst char *errstr;\n\n\t/* Strip trailing whitespace. Allow \\f (form feed) at EOL only */\n\tif ((len = strlen(line)) == 0)\n\t\treturn 0;\n\tfor (len--; len > 0; len--) {\n\t\tif (strchr(WHITESPACE \"\\f\", line[len]) == NULL)\n\t\t\tbreak;\n\t\tline[len] = '\\0';\n\t}\n\n\tcp = line;\n\tif ((arg = strdelim(&cp)) == NULL)\n\t\treturn 0;\n\t/* Ignore leading whitespace */\n\tif (*arg == '\\0')\n\t\targ = strdelim(&cp);\n\tif (!arg || !*arg || *arg == '#')\n\t\treturn 0;\n\tintptr = NULL;\n\tcharptr = NULL;\n\topcode = parse_token(arg, filename, linenum, &flags);\n\n\tif (activep == NULL) { /* We are processing a command line directive */\n\t\tcmdline = 1;\n\t\tactivep = &cmdline;\n\t}\n\tif (*activep && opcode != sMatch)\n\t\tdebug3(\"%s:%d setting %s %s\", filename, linenum, arg, cp);\n\tif (*activep == 0 && !(flags & SSHCFG_MATCH)) {\n\t\tif (connectinfo == NULL) {\n\t\t\tfatal(\"%s line %d: Directive '%s' is not allowed \"\n\t\t\t    \"within a Match block\", filename, linenum, arg);\n\t\t} else { /* this is a directive we have already processed */\n\t\t\twhile (arg)\n\t\t\t\targ = strdelim(&cp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tswitch (opcode) {\n\t/* Portable-specific options */\n\tcase sUsePAM:\n\t\tintptr = &options->use_pam;\n\t\tgoto parse_flag;\n\n\t/* Standard Options */\n\tcase sBadOption:\n\t\treturn -1;\n\tcase sPort:\n\t\t/* ignore ports from configfile if cmdline specifies ports */\n\t\tif (options->ports_from_cmdline)\n\t\t\treturn 0;\n\t\tif (options->num_ports >= MAX_PORTS)\n\t\t\tfatal(\"%s line %d: too many ports.\",\n\t\t\t    filename, linenum);\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing port number.\",\n\t\t\t    filename, linenum);\n\t\toptions->ports[options->num_ports++] = a2port(arg);\n\t\tif (options->ports[options->num_ports-1] <= 0)\n\t\t\tfatal(\"%s line %d: Badly formatted port number.\",\n\t\t\t    filename, linenum);\n\t\tbreak;\n\n\tcase sLoginGraceTime:\n\t\tintptr = &options->login_grace_time;\n parse_time:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing time value.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = convtime(arg)) == -1)\n\t\t\tfatal(\"%s line %d: invalid time value.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sListenAddress:\n\t\targ = strdelim(&cp);\n\t\tif (arg == NULL || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing address\",\n\t\t\t    filename, linenum);\n\t\t/* check for bare IPv6 address: no \"[]\" and 2 or more \":\" */\n\t\tif (strchr(arg, '[') == NULL && (p = strchr(arg, ':')) != NULL\n\t\t    && strchr(p+1, ':') != NULL) {\n\t\t\tport = 0;\n\t\t\tp = arg;\n\t\t} else {\n\t\t\tp = hpdelim(&arg);\n\t\t\tif (p == NULL)\n\t\t\t\tfatal(\"%s line %d: bad address:port usage\",\n\t\t\t\t    filename, linenum);\n\t\t\tp = cleanhostname(p);\n\t\t\tif (arg == NULL)\n\t\t\t\tport = 0;\n\t\t\telse if ((port = a2port(arg)) <= 0)\n\t\t\t\tfatal(\"%s line %d: bad port number\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\t/* Optional routing table */\n\t\targ2 = NULL;\n\t\tif ((arg = strdelim(&cp)) != NULL) {\n\t\t\tif (strcmp(arg, \"rdomain\") != 0 ||\n\t\t\t    (arg2 = strdelim(&cp)) == NULL)\n\t\t\t\tfatal(\"%s line %d: bad ListenAddress syntax\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!valid_rdomain(arg2))\n\t\t\t\tfatal(\"%s line %d: bad routing domain\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\n\t\tqueue_listen_addr(options, p, arg2, port);\n\n\t\tbreak;\n\n\tcase sAddressFamily:\n\t\tintptr = &options->address_family;\n\t\tmultistate_ptr = multistate_addressfamily;\n parse_multistate:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; multistate_ptr[i].key != NULL; i++) {\n\t\t\tif (strcasecmp(arg, multistate_ptr[i].key) == 0) {\n\t\t\t\tvalue = multistate_ptr[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: unsupported option \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sHostKeyFile:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep)\n\t\t\tservconf_add_hostkey(filename, linenum, options, arg);\n\t\tbreak;\n\n\tcase sHostKeyAgent:\n\t\tcharptr = &options->host_key_agent;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing socket name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = !strcmp(arg, SSH_AUTHSOCKET_ENV_NAME) ?\n\t\t\t    xstrdup(arg) : derelativise_path(arg);\n\t\tbreak;\n\n\tcase sHostCertificate:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep)\n\t\t\tservconf_add_hostcert(filename, linenum, options, arg);\n\t\tbreak;\n\n\tcase sPidFile:\n\t\tcharptr = &options->pid_file;\n parse_filename:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL) {\n\t\t\t*charptr = derelativise_path(arg);\n\t\t\t/* increase optional counter */\n\t\t\tif (intptr != NULL)\n\t\t\t\t*intptr = *intptr + 1;\n\t\t}\n\t\tbreak;\n\n\tcase sPermitRootLogin:\n\t\tintptr = &options->permit_root_login;\n\t\tmultistate_ptr = multistate_permitrootlogin;\n\t\tgoto parse_multistate;\n\n\tcase sIgnoreRhosts:\n\t\tintptr = &options->ignore_rhosts;\n parse_flag:\n\t\tmultistate_ptr = multistate_flag;\n\t\tgoto parse_multistate;\n\n\tcase sIgnoreUserKnownHosts:\n\t\tintptr = &options->ignore_user_known_hosts;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedAuthentication:\n\t\tintptr = &options->hostbased_authentication;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedUsesNameFromPacketOnly:\n\t\tintptr = &options->hostbased_uses_name_from_packet_only;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedAcceptedKeyTypes:\n\t\tcharptr = &options->hostbased_key_types;\n parse_keytypes:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !sshkey_names_valid2(*arg == '+' ? arg + 1 : arg, 1))\n\t\t\tfatal(\"%s line %d: Bad key types '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sHostKeyAlgorithms:\n\t\tcharptr = &options->hostkeyalgorithms;\n\t\tgoto parse_keytypes;\n\n\tcase sCASignatureAlgorithms:\n\t\tcharptr = &options->ca_sign_algorithms;\n\t\tgoto parse_keytypes;\n\n\tcase sPubkeyAuthentication:\n\t\tintptr = &options->pubkey_authentication;\n\t\tgoto parse_flag;\n\n\tcase sPubkeyAcceptedKeyTypes:\n\t\tcharptr = &options->pubkey_key_types;\n\t\tgoto parse_keytypes;\n\n\tcase sKerberosAuthentication:\n\t\tintptr = &options->kerberos_authentication;\n\t\tgoto parse_flag;\n\n\tcase sKerberosOrLocalPasswd:\n\t\tintptr = &options->kerberos_or_local_passwd;\n\t\tgoto parse_flag;\n\n\tcase sKerberosTicketCleanup:\n\t\tintptr = &options->kerberos_ticket_cleanup;\n\t\tgoto parse_flag;\n\n\tcase sKerberosGetAFSToken:\n\t\tintptr = &options->kerberos_get_afs_token;\n\t\tgoto parse_flag;\n\n\tcase sGssAuthentication:\n\t\tintptr = &options->gss_authentication;\n\t\tgoto parse_flag;\n\n\tcase sGssCleanupCreds:\n\t\tintptr = &options->gss_cleanup_creds;\n\t\tgoto parse_flag;\n\n\tcase sGssStrictAcceptor:\n\t\tintptr = &options->gss_strict_acceptor;\n\t\tgoto parse_flag;\n\n\tcase sPasswordAuthentication:\n\t\tintptr = &options->password_authentication;\n\t\tgoto parse_flag;\n\n\tcase sKbdInteractiveAuthentication:\n\t\tintptr = &options->kbd_interactive_authentication;\n\t\tgoto parse_flag;\n\n\tcase sChallengeResponseAuthentication:\n\t\tintptr = &options->challenge_response_authentication;\n\t\tgoto parse_flag;\n\n\tcase sPrintMotd:\n\t\tintptr = &options->print_motd;\n\t\tgoto parse_flag;\n\n\tcase sPrintLastLog:\n\t\tintptr = &options->print_lastlog;\n\t\tgoto parse_flag;\n\n\tcase sX11Forwarding:\n\t\tintptr = &options->x11_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sX11DisplayOffset:\n\t\tintptr = &options->x11_display_offset;\n parse_int:\n\t\targ = strdelim(&cp);\n\t\tif ((errstr = atoi_err(arg, &value)) != NULL)\n\t\t\tfatal(\"%s line %d: integer value %s.\",\n\t\t\t    filename, linenum, errstr);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sX11UseLocalhost:\n\t\tintptr = &options->x11_use_localhost;\n\t\tgoto parse_flag;\n\n\tcase sXAuthLocation:\n\t\tcharptr = &options->xauth_location;\n\t\tgoto parse_filename;\n\n\tcase sPermitTTY:\n\t\tintptr = &options->permit_tty;\n\t\tgoto parse_flag;\n\n\tcase sPermitUserRC:\n\t\tintptr = &options->permit_user_rc;\n\t\tgoto parse_flag;\n\n\tcase sStrictModes:\n\t\tintptr = &options->strict_modes;\n\t\tgoto parse_flag;\n\n\tcase sTCPKeepAlive:\n\t\tintptr = &options->tcp_keep_alive;\n\t\tgoto parse_flag;\n\n\tcase sEmptyPasswd:\n\t\tintptr = &options->permit_empty_passwd;\n\t\tgoto parse_flag;\n\n\tcase sPermitUserEnvironment:\n\t\tintptr = &options->permit_user_env;\n\t\tcharptr = &options->permit_user_env_whitelist;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = 0;\n\t\tp = NULL;\n\t\tif (strcmp(arg, \"yes\") == 0)\n\t\t\tvalue = 1;\n\t\telse if (strcmp(arg, \"no\") == 0)\n\t\t\tvalue = 0;\n\t\telse {\n\t\t\t/* Pattern-list specified */\n\t\t\tvalue = 1;\n\t\t\tp = xstrdup(arg);\n\t\t}\n\t\tif (*activep && *intptr == -1) {\n\t\t\t*intptr = value;\n\t\t\t*charptr = p;\n\t\t\tp = NULL;\n\t\t}\n\t\tfree(p);\n\t\tbreak;\n\n\tcase sCompression:\n\t\tintptr = &options->compression;\n\t\tmultistate_ptr = multistate_compression;\n\t\tgoto parse_multistate;\n\n\tcase sRekeyLimit:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tif (strcmp(arg, \"default\") == 0) {\n\t\t\tval64 = 0;\n\t\t} else {\n\t\t\tif (scan_scaled(arg, &val64) == -1)\n\t\t\t\tfatal(\"%.200s line %d: Bad number '%s': %s\",\n\t\t\t\t    filename, linenum, arg, strerror(errno));\n\t\t\tif (val64 != 0 && val64 < 16)\n\t\t\t\tfatal(\"%.200s line %d: RekeyLimit too small\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\tif (*activep && options->rekey_limit == -1)\n\t\t\toptions->rekey_limit = val64;\n\t\tif (cp != NULL) { /* optional rekey interval present */\n\t\t\tif (strcmp(cp, \"none\") == 0) {\n\t\t\t\t(void)strdelim(&cp);\t/* discard */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tintptr = &options->rekey_interval;\n\t\t\tgoto parse_time;\n\t\t}\n\t\tbreak;\n\n\tcase sGatewayPorts:\n\t\tintptr = &options->fwd_opts.gateway_ports;\n\t\tmultistate_ptr = multistate_gatewayports;\n\t\tgoto parse_multistate;\n\n\tcase sUseDNS:\n\t\tintptr = &options->use_dns;\n\t\tgoto parse_flag;\n\n\tcase sLogFacility:\n\t\tlog_facility_ptr = &options->log_facility;\n\t\targ = strdelim(&cp);\n\t\tvalue = log_facility_number(arg);\n\t\tif (value == SYSLOG_FACILITY_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log facility '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*log_facility_ptr == -1)\n\t\t\t*log_facility_ptr = (SyslogFacility) value;\n\t\tbreak;\n\n\tcase sLogLevel:\n\t\tlog_level_ptr = &options->log_level;\n\t\targ = strdelim(&cp);\n\t\tvalue = log_level_number(arg);\n\t\tif (value == SYSLOG_LEVEL_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log level '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *log_level_ptr == -1)\n\t\t\t*log_level_ptr = (LogLevel) value;\n\t\tbreak;\n\n\tcase sAllowTcpForwarding:\n\t\tintptr = &options->allow_tcp_forwarding;\n\t\tmultistate_ptr = multistate_tcpfwd;\n\t\tgoto parse_multistate;\n\n\tcase sAllowStreamLocalForwarding:\n\t\tintptr = &options->allow_streamlocal_forwarding;\n\t\tmultistate_ptr = multistate_tcpfwd;\n\t\tgoto parse_multistate;\n\n\tcase sAllowAgentForwarding:\n\t\tintptr = &options->allow_agent_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sDisableForwarding:\n\t\tintptr = &options->disable_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sAllowUsers:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (match_user(NULL, NULL, NULL, arg) == -1)\n\t\t\t\tfatal(\"%s line %d: invalid AllowUsers pattern: \"\n\t\t\t\t    \"\\\"%.100s\\\"\", filename, linenum, arg);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"AllowUsers\",\n\t\t\t    &options->allow_users, &options->num_allow_users,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sDenyUsers:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (match_user(NULL, NULL, NULL, arg) == -1)\n\t\t\t\tfatal(\"%s line %d: invalid DenyUsers pattern: \"\n\t\t\t\t    \"\\\"%.100s\\\"\", filename, linenum, arg);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"DenyUsers\",\n\t\t\t    &options->deny_users, &options->num_deny_users,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sAllowGroups:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"AllowGroups\",\n\t\t\t    &options->allow_groups, &options->num_allow_groups,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sDenyGroups:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"DenyGroups\",\n\t\t\t    &options->deny_groups, &options->num_deny_groups,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sCiphers:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !ciphers_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 cipher spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->ciphers == NULL)\n\t\t\toptions->ciphers = xstrdup(arg);\n\t\tbreak;\n\n\tcase sMacs:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !mac_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 mac spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->macs == NULL)\n\t\t\toptions->macs = xstrdup(arg);\n\t\tbreak;\n\n\tcase sKexAlgorithms:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !kex_names_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 KexAlgorithms '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->kex_algorithms == NULL)\n\t\t\toptions->kex_algorithms = xstrdup(arg);\n\t\tbreak;\n\n\tcase sSubsystem:\n\t\tif (options->num_subsystems >= MAX_SUBSYSTEMS) {\n\t\t\tfatal(\"%s line %d: too many subsystems defined.\",\n\t\t\t    filename, linenum);\n\t\t}\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing subsystem name.\",\n\t\t\t    filename, linenum);\n\t\tif (!*activep) {\n\t\t\targ = strdelim(&cp);\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < options->num_subsystems; i++)\n\t\t\tif (strcmp(arg, options->subsystem_name[i]) == 0)\n\t\t\t\tfatal(\"%s line %d: Subsystem '%s' already defined.\",\n\t\t\t\t    filename, linenum, arg);\n\t\toptions->subsystem_name[options->num_subsystems] = xstrdup(arg);\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing subsystem command.\",\n\t\t\t    filename, linenum);\n\t\toptions->subsystem_command[options->num_subsystems] = xstrdup(arg);\n\n\t\t/* Collect arguments (separate to executable) */\n\t\tp = xstrdup(arg);\n\t\tlen = strlen(p) + 1;\n\t\twhile ((arg = strdelim(&cp)) != NULL && *arg != '\\0') {\n\t\t\tlen += 1 + strlen(arg);\n\t\t\tp = xreallocarray(p, 1, len);\n\t\t\tstrlcat(p, \" \", len);\n\t\t\tstrlcat(p, arg, len);\n\t\t}\n\t\toptions->subsystem_args[options->num_subsystems] = p;\n\t\toptions->num_subsystems++;\n\t\tbreak;\n\n\tcase sMaxStartups:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing MaxStartups spec.\",\n\t\t\t    filename, linenum);\n\t\tif ((n = sscanf(arg, \"%d:%d:%d\",\n\t\t    &options->max_startups_begin,\n\t\t    &options->max_startups_rate,\n\t\t    &options->max_startups)) == 3) {\n\t\t\tif (options->max_startups_begin >\n\t\t\t    options->max_startups ||\n\t\t\t    options->max_startups_rate > 100 ||\n\t\t\t    options->max_startups_rate < 1)\n\t\t\t\tfatal(\"%s line %d: Illegal MaxStartups spec.\",\n\t\t\t\t    filename, linenum);\n\t\t} else if (n != 1)\n\t\t\tfatal(\"%s line %d: Illegal MaxStartups spec.\",\n\t\t\t    filename, linenum);\n\t\telse\n\t\t\toptions->max_startups = options->max_startups_begin;\n\t\tbreak;\n\n\tcase sMaxAuthTries:\n\t\tintptr = &options->max_authtries;\n\t\tgoto parse_int;\n\n\tcase sMaxSessions:\n\t\tintptr = &options->max_sessions;\n\t\tgoto parse_int;\n\n\tcase sBanner:\n\t\tcharptr = &options->banner;\n\t\tgoto parse_filename;\n\n\t/*\n\t * These options can contain %X options expanded at\n\t * connect time, so that you can specify paths like:\n\t *\n\t * AuthorizedKeysFile\t/etc/ssh_keys/%u\n\t */\n\tcase sAuthorizedKeysFile:\n\t\tif (*activep && options->num_authkeys_files == 0) {\n\t\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\t\targ = tilde_expand_filename(arg, getuid());\n\t\t\t\tarray_append(filename, linenum,\n\t\t\t\t    \"AuthorizedKeysFile\",\n\t\t\t\t    &options->authorized_keys_files,\n\t\t\t\t    &options->num_authkeys_files, arg);\n\t\t\t\tfree(arg);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedPrincipalsFile:\n\t\tcharptr = &options->authorized_principals_file;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL) {\n\t\t\t*charptr = tilde_expand_filename(arg, getuid());\n\t\t\t/* increase optional counter */\n\t\t\tif (intptr != NULL)\n\t\t\t\t*intptr = *intptr + 1;\n\t\t}\n\t\tbreak;\n\n\tcase sClientAliveInterval:\n\t\tintptr = &options->client_alive_interval;\n\t\tgoto parse_time;\n\n\tcase sClientAliveCountMax:\n\t\tintptr = &options->client_alive_count_max;\n\t\tgoto parse_int;\n\n\tcase sAcceptEnv:\n\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') != NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment name.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"AcceptEnv\",\n\t\t\t    &options->accept_env, &options->num_accept_env,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sSetEnv:\n\t\tuvalue = options->num_setenv;\n\t\twhile ((arg = strdelimw(&cp)) && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') == NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep || uvalue != 0)\n\t\t\t\tcontinue;\n\t\t\tarray_append(filename, linenum, \"SetEnv\",\n\t\t\t    &options->setenv, &options->num_setenv, arg);\n\t\t}\n\t\tbreak;\n\n\tcase sPermitTunnel:\n\t\tintptr = &options->permit_tun;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing yes/point-to-point/\"\n\t\t\t    \"ethernet/no argument.\", filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; tunmode_desc[i].val != -1; i++)\n\t\t\tif (strcmp(tunmode_desc[i].text, arg) == 0) {\n\t\t\t\tvalue = tunmode_desc[i].val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: Bad yes/point-to-point/ethernet/\"\n\t\t\t    \"no argument: %s\", filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sMatch:\n\t\tif (cmdline)\n\t\t\tfatal(\"Match directive not supported as a command-line \"\n\t\t\t   \"option\");\n\t\tvalue = match_cfg_line(&cp, linenum, connectinfo);\n\t\tif (value < 0)\n\t\t\tfatal(\"%s line %d: Bad Match condition\", filename,\n\t\t\t    linenum);\n\t\t*activep = value;\n\t\tbreak;\n\n\tcase sPermitListen:\n\tcase sPermitOpen:\n\t\tif (opcode == sPermitListen) {\n\t\t\tuintptr = &options->num_permitted_listens;\n\t\t\tchararrayptr = &options->permitted_listens;\n\t\t} else {\n\t\t\tuintptr = &options->num_permitted_opens;\n\t\t\tchararrayptr = &options->permitted_opens;\n\t\t}\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing %s specification\",\n\t\t\t    filename, linenum, lookup_opcode_name(opcode));\n\t\tuvalue = *uintptr;\t/* modified later */\n\t\tif (strcmp(arg, \"any\") == 0 || strcmp(arg, \"none\") == 0) {\n\t\t\tif (*activep && uvalue == 0) {\n\t\t\t\t*uintptr = 1;\n\t\t\t\t*chararrayptr = xcalloc(1,\n\t\t\t\t    sizeof(**chararrayptr));\n\t\t\t\t(*chararrayptr)[0] = xstrdup(arg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfor (; arg != NULL && *arg != '\\0'; arg = strdelim(&cp)) {\n\t\t\tif (opcode == sPermitListen &&\n\t\t\t    strchr(arg, ':') == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Allow bare port number for PermitListen\n\t\t\t\t * to indicate a wildcard listen host.\n\t\t\t\t */\n\t\t\t\txasprintf(&arg2, \"*:%s\", arg);\n\t\t\t} else {\n\t\t\t\targ2 = xstrdup(arg);\n\t\t\t\tp = hpdelim(&arg);\n\t\t\t\tif (p == NULL) {\n\t\t\t\t\tfatal(\"%s line %d: missing host in %s\",\n\t\t\t\t\t    filename, linenum,\n\t\t\t\t\t    lookup_opcode_name(opcode));\n\t\t\t\t}\n\t\t\t\tp = cleanhostname(p);\n\t\t\t}\n\t\t\tif (arg == NULL ||\n\t\t\t    ((port = permitopen_port(arg)) < 0)) {\n\t\t\t\tfatal(\"%s line %d: bad port number in %s\",\n\t\t\t\t    filename, linenum,\n\t\t\t\t    lookup_opcode_name(opcode));\n\t\t\t}\n\t\t\tif (*activep && uvalue == 0) {\n\t\t\t\tarray_append(filename, linenum,\n\t\t\t\t    lookup_opcode_name(opcode),\n\t\t\t\t    chararrayptr, uintptr, arg2);\n\t\t\t}\n\t\t\tfree(arg2);\n\t\t}\n\t\tbreak;\n\n\tcase sForceCommand:\n\t\tif (cp == NULL || *cp == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep && options->adm_forced_command == NULL)\n\t\t\toptions->adm_forced_command = xstrdup(cp + len);\n\t\treturn 0;\n\n\tcase sChrootDirectory:\n\t\tcharptr = &options->chroot_directory;\n\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sTrustedUserCAKeys:\n\t\tcharptr = &options->trusted_user_ca_keys;\n\t\tgoto parse_filename;\n\n\tcase sRevokedKeys:\n\t\tcharptr = &options->revoked_keys_file;\n\t\tgoto parse_filename;\n\n\tcase sIPQoS:\n\t\targ = strdelim(&cp);\n\t\tif ((value = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\targ = strdelim(&cp);\n\t\tif (arg == NULL)\n\t\t\tvalue2 = value;\n\t\telse if ((value2 = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep) {\n\t\t\toptions->ip_qos_interactive = value;\n\t\t\toptions->ip_qos_bulk = value2;\n\t\t}\n\t\tbreak;\n\n\tcase sVersionAddendum:\n\t\tif (cp == NULL || *cp == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep && options->version_addendum == NULL) {\n\t\t\tif (strcasecmp(cp + len, \"none\") == 0)\n\t\t\t\toptions->version_addendum = xstrdup(\"\");\n\t\t\telse if (strchr(cp + len, '\\r') != NULL)\n\t\t\t\tfatal(\"%.200s line %d: Invalid argument\",\n\t\t\t\t    filename, linenum);\n\t\t\telse\n\t\t\t\toptions->version_addendum = xstrdup(cp + len);\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedKeysCommand:\n\t\tif (cp == NULL)\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep && options->authorized_keys_command == NULL) {\n\t\t\tif (cp[len] != '/' && strcasecmp(cp + len, \"none\") != 0)\n\t\t\t\tfatal(\"%.200s line %d: AuthorizedKeysCommand \"\n\t\t\t\t    \"must be an absolute path\",\n\t\t\t\t    filename, linenum);\n\t\t\toptions->authorized_keys_command = xstrdup(cp + len);\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedKeysCommandUser:\n\t\tcharptr = &options->authorized_keys_command_user;\n\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing AuthorizedKeysCommandUser \"\n\t\t\t    \"argument.\", filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sAuthorizedPrincipalsCommand:\n\t\tif (cp == NULL)\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tlen = strspn(cp, WHITESPACE);\n\t\tif (*activep &&\n\t\t    options->authorized_principals_command == NULL) {\n\t\t\tif (cp[len] != '/' && strcasecmp(cp + len, \"none\") != 0)\n\t\t\t\tfatal(\"%.200s line %d: \"\n\t\t\t\t    \"AuthorizedPrincipalsCommand must be \"\n\t\t\t\t    \"an absolute path\", filename, linenum);\n\t\t\toptions->authorized_principals_command =\n\t\t\t    xstrdup(cp + len);\n\t\t}\n\t\treturn 0;\n\n\tcase sAuthorizedPrincipalsCommandUser:\n\t\tcharptr = &options->authorized_principals_command_user;\n\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing \"\n\t\t\t    \"AuthorizedPrincipalsCommandUser argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sAuthenticationMethods:\n\t\tif (options->num_auth_methods == 0) {\n\t\t\tvalue = 0; /* seen \"any\" pseudo-method */\n\t\t\tvalue2 = 0; /* successfully parsed any method */\n\t\t\twhile ((arg = strdelim(&cp)) && *arg != '\\0') {\n\t\t\t\tif (strcmp(arg, \"any\") == 0) {\n\t\t\t\t\tif (options->num_auth_methods > 0) {\n\t\t\t\t\t\tfatal(\"%s line %d: \\\"any\\\" \"\n\t\t\t\t\t\t    \"must appear alone in \"\n\t\t\t\t\t\t    \"AuthenticationMethods\",\n\t\t\t\t\t\t    filename, linenum);\n\t\t\t\t\t}\n\t\t\t\t\tvalue = 1;\n\t\t\t\t} else if (value) {\n\t\t\t\t\tfatal(\"%s line %d: \\\"any\\\" must appear \"\n\t\t\t\t\t    \"alone in AuthenticationMethods\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\t} else if (auth2_methods_valid(arg, 0) != 0) {\n\t\t\t\t\tfatal(\"%s line %d: invalid \"\n\t\t\t\t\t    \"authentication method list.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\t}\n\t\t\t\tvalue2 = 1;\n\t\t\t\tif (!*activep)\n\t\t\t\t\tcontinue;\n\t\t\t\tarray_append(filename, linenum,\n\t\t\t\t    \"AuthenticationMethods\",\n\t\t\t\t    &options->auth_methods,\n\t\t\t\t    &options->num_auth_methods, arg);\n\t\t\t}\n\t\t\tif (value2 == 0) {\n\t\t\t\tfatal(\"%s line %d: no AuthenticationMethods \"\n\t\t\t\t    \"specified\", filename, linenum);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase sStreamLocalBindMask:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing StreamLocalBindMask \"\n\t\t\t    \"argument.\", filename, linenum);\n\t\t/* Parse mode in octal format */\n\t\tvalue = strtol(arg, &p, 8);\n\t\tif (arg == p || value < 0 || value > 0777)\n\t\t\tfatal(\"%s line %d: Bad mask.\", filename, linenum);\n\t\tif (*activep)\n\t\t\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)value;\n\t\tbreak;\n\n\tcase sStreamLocalBindUnlink:\n\t\tintptr = &options->fwd_opts.streamlocal_bind_unlink;\n\t\tgoto parse_flag;\n\n\tcase sFingerprintHash:\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = ssh_digest_alg_by_name(arg)) == -1)\n\t\t\tfatal(\"%.200s line %d: Invalid hash algorithm \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep)\n\t\t\toptions->fingerprint_hash = value;\n\t\tbreak;\n\n\tcase sExposeAuthInfo:\n\t\tintptr = &options->expose_userauth_info;\n\t\tgoto parse_flag;\n\n\tcase sRDomain:\n\t\tcharptr = &options->routing_domain;\n\t\targ = strdelim(&cp);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (strcasecmp(arg, \"none\") != 0 && strcmp(arg, \"%D\") != 0 &&\n\t\t    !valid_rdomain(arg))\n\t\t\tfatal(\"%s line %d: bad routing domain\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sDeprecated:\n\tcase sIgnore:\n\tcase sUnsupported:\n\t\tdo_log2(opcode == sIgnore ?\n\t\t    SYSLOG_LEVEL_DEBUG2 : SYSLOG_LEVEL_INFO,\n\t\t    \"%s line %d: %s option %s\", filename, linenum,\n\t\t    opcode == sUnsupported ? \"Unsupported\" : \"Deprecated\", arg);\n\t\twhile (arg)\n\t\t    arg = strdelim(&cp);\n\t\tbreak;\n\n\tdefault:\n\t\tfatal(\"%s line %d: Missing handler for opcode %s (%d)\",\n\t\t    filename, linenum, arg, opcode);\n\t}\n\tif ((arg = strdelim(&cp)) != NULL && *arg != '\\0')\n\t\tfatal(\"%s line %d: garbage at end of line; \\\"%.200s\\\".\",\n\t\t    filename, linenum, arg);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid utmp length.\\n\""
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtonum",
          "args": [
            "optarg",
            "0",
            "HOST_NAME_MAX+1+1",
            "NULL"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "strtonum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtonum.c",
          "lines": "33-70",
          "snippet": "long long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define TOOLARGE \t3",
            "#define TOOSMALL \t2",
            "#define INVALID \t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\n#define TOOLARGE \t3\n#define TOOSMALL \t2\n#define INVALID \t1\n\nlong long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_server_match_testspec",
          "args": [
            "connection_info",
            "optarg"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "parse_server_match_testspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2220-2249",
          "snippet": "int parse_server_match_testspec(struct connection_info *ci, char *spec)\n{\n\tchar *p;\n\n\twhile ((p = strsep(&spec, \",\")) && *p != '\\0') {\n\t\tif (strncmp(p, \"addr=\", 5) == 0) {\n\t\t\tci->address = xstrdup(p + 5);\n\t\t} else if (strncmp(p, \"host=\", 5) == 0) {\n\t\t\tci->host = xstrdup(p + 5);\n\t\t} else if (strncmp(p, \"user=\", 5) == 0) {\n\t\t\tci->user = xstrdup(p + 5);\n\t\t} else if (strncmp(p, \"laddr=\", 6) == 0) {\n\t\t\tci->laddress = xstrdup(p + 6);\n\t\t} else if (strncmp(p, \"rdomain=\", 8) == 0) {\n\t\t\tci->rdomain = xstrdup(p + 8);\n\t\t} else if (strncmp(p, \"lport=\", 6) == 0) {\n\t\t\tci->lport = a2port(p + 6);\n\t\t\tif (ci->lport == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid port '%s' in test mode\"\n\t\t\t\t   \" specification %s\\n\", p+6, p);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Invalid test mode specification %s\\n\",\n\t\t\t   p);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint parse_server_match_testspec(struct connection_info *ci, char *spec)\n{\n\tchar *p;\n\n\twhile ((p = strsep(&spec, \",\")) && *p != '\\0') {\n\t\tif (strncmp(p, \"addr=\", 5) == 0) {\n\t\t\tci->address = xstrdup(p + 5);\n\t\t} else if (strncmp(p, \"host=\", 5) == 0) {\n\t\t\tci->host = xstrdup(p + 5);\n\t\t} else if (strncmp(p, \"user=\", 5) == 0) {\n\t\t\tci->user = xstrdup(p + 5);\n\t\t} else if (strncmp(p, \"laddr=\", 6) == 0) {\n\t\t\tci->laddress = xstrdup(p + 6);\n\t\t} else if (strncmp(p, \"rdomain=\", 8) == 0) {\n\t\t\tci->rdomain = xstrdup(p + 8);\n\t\t} else if (strncmp(p, \"lport=\", 6) == 0) {\n\t\t\tci->lport = a2port(p + 6);\n\t\t\tif (ci->lport == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid port '%s' in test mode\"\n\t\t\t\t   \" specification %s\\n\", p+6, p);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Invalid test mode specification %s\\n\",\n\t\t\t   p);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "servconf_add_hostkey",
          "args": [
            "\"[command-line]\"",
            "0",
            "&options",
            "optarg"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "servconf_add_hostkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "236-245",
          "snippet": "void\nservconf_add_hostkey(const char *file, const int line,\n    ServerOptions *options, const char *path)\n{\n\tchar *apath = derelativise_path(path);\n\n\tarray_append(file, line, \"HostKey\",\n\t    &options->host_key_files, &options->num_host_key_files, apath);\n\tfree(apath);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nservconf_add_hostkey(const char *file, const int line,\n    ServerOptions *options, const char *path)\n{\n\tchar *apath = derelativise_path(path);\n\n\tarray_append(file, line, \"HostKey\",\n\t    &options->host_key_files, &options->num_host_key_files, apath);\n\tfree(apath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid login grace time.\\n\""
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convtime",
          "args": [
            "optarg"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "convtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "406-465",
          "snippet": "long\nconvtime(const char *s)\n{\n\tlong total, secs, multiplier = 1;\n\tconst char *p;\n\tchar *endp;\n\n\terrno = 0;\n\ttotal = 0;\n\tp = s;\n\n\tif (p == NULL || *p == '\\0')\n\t\treturn -1;\n\n\twhile (*p) {\n\t\tsecs = strtol(p, &endp, 10);\n\t\tif (p == endp ||\n\t\t    (errno == ERANGE && (secs == LONG_MIN || secs == LONG_MAX)) ||\n\t\t    secs < 0)\n\t\t\treturn -1;\n\n\t\tswitch (*endp++) {\n\t\tcase '\\0':\n\t\t\tendp--;\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tbreak;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tmultiplier = MINUTES;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\tmultiplier = HOURS;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tmultiplier = DAYS;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\tcase 'W':\n\t\t\tmultiplier = WEEKS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (secs >= LONG_MAX / multiplier)\n\t\t\treturn -1;\n\t\tsecs *= multiplier;\n\t\tif  (total >= LONG_MAX - secs)\n\t\t\treturn -1;\n\t\ttotal += secs;\n\t\tif (total < 0)\n\t\t\treturn -1;\n\t\tp = endp;\n\t}\n\n\treturn total;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define WEEKS\t\t(DAYS * 7)",
            "#define DAYS\t\t(HOURS * 24)",
            "#define HOURS\t\t(MINUTES * 60)",
            "#define MINUTES\t\t(SECONDS * 60)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define WEEKS\t\t(DAYS * 7)\n#define DAYS\t\t(HOURS * 24)\n#define HOURS\t\t(MINUTES * 60)\n#define MINUTES\t\t(SECONDS * 60)\n\nlong\nconvtime(const char *s)\n{\n\tlong total, secs, multiplier = 1;\n\tconst char *p;\n\tchar *endp;\n\n\terrno = 0;\n\ttotal = 0;\n\tp = s;\n\n\tif (p == NULL || *p == '\\0')\n\t\treturn -1;\n\n\twhile (*p) {\n\t\tsecs = strtol(p, &endp, 10);\n\t\tif (p == endp ||\n\t\t    (errno == ERANGE && (secs == LONG_MIN || secs == LONG_MAX)) ||\n\t\t    secs < 0)\n\t\t\treturn -1;\n\n\t\tswitch (*endp++) {\n\t\tcase '\\0':\n\t\t\tendp--;\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tbreak;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tmultiplier = MINUTES;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\tmultiplier = HOURS;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tmultiplier = DAYS;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\tcase 'W':\n\t\t\tmultiplier = WEEKS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (secs >= LONG_MAX / multiplier)\n\t\t\treturn -1;\n\t\tsecs *= multiplier;\n\t\tif  (total >= LONG_MAX - secs)\n\t\t\treturn -1;\n\t\ttotal += secs;\n\t\tif (total < 0)\n\t\t\treturn -1;\n\t\tp = endp;\n\t}\n\n\treturn total;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Bad port number.\\n\""
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a2port",
          "args": [
            "optarg"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "a2port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "333-346",
          "snippet": "int\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"too many ports.\\n\""
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "servconf_add_hostcert",
          "args": [
            "\"[command-line]\"",
            "0",
            "&options",
            "optarg"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "servconf_add_hostcert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "247-256",
          "snippet": "void\nservconf_add_hostcert(const char *file, const int line,\n    ServerOptions *options, const char *path)\n{\n\tchar *apath = derelativise_path(path);\n\n\tarray_append(file, line, \"HostCertificate\",\n\t    &options->host_cert_files, &options->num_host_cert_files, apath);\n\tfree(apath);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nservconf_add_hostcert(const char *file, const int line,\n    ServerOptions *options, const char *path)\n{\n\tchar *apath = derelativise_path(path);\n\n\tarray_append(file, line, \"HostCertificate\",\n\t    &options->host_cert_files, &options->num_host_cert_files, apath);\n\tfree(apath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "ac",
            "av",
            "\"C:E:b:c:f:g:h:k:o:p:u:46DQRTdeiqrt\""
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "getopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "489-502",
          "snippet": "int\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_server_options",
          "args": [
            "&options"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_server_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "79-183",
          "snippet": "void\ninitialize_server_options(ServerOptions *options)\n{\n\tmemset(options, 0, sizeof(*options));\n\n\t/* Portable-specific options */\n\toptions->use_pam = -1;\n\n\t/* Standard Options */\n\toptions->num_ports = 0;\n\toptions->ports_from_cmdline = 0;\n\toptions->queued_listen_addrs = NULL;\n\toptions->num_queued_listens = 0;\n\toptions->listen_addrs = NULL;\n\toptions->num_listen_addrs = 0;\n\toptions->address_family = -1;\n\toptions->routing_domain = NULL;\n\toptions->num_host_key_files = 0;\n\toptions->num_host_cert_files = 0;\n\toptions->host_key_agent = NULL;\n\toptions->pid_file = NULL;\n\toptions->login_grace_time = -1;\n\toptions->permit_root_login = PERMIT_NOT_SET;\n\toptions->ignore_rhosts = -1;\n\toptions->ignore_user_known_hosts = -1;\n\toptions->print_motd = -1;\n\toptions->print_lastlog = -1;\n\toptions->x11_forwarding = -1;\n\toptions->x11_display_offset = -1;\n\toptions->x11_use_localhost = -1;\n\toptions->permit_tty = -1;\n\toptions->permit_user_rc = -1;\n\toptions->xauth_location = NULL;\n\toptions->strict_modes = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->hostbased_authentication = -1;\n\toptions->hostbased_uses_name_from_packet_only = -1;\n\toptions->hostbased_key_types = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->pubkey_authentication = -1;\n\toptions->pubkey_key_types = NULL;\n\toptions->kerberos_authentication = -1;\n\toptions->kerberos_or_local_passwd = -1;\n\toptions->kerberos_ticket_cleanup = -1;\n\toptions->kerberos_get_afs_token = -1;\n\toptions->gss_authentication=-1;\n\toptions->gss_cleanup_creds = -1;\n\toptions->gss_strict_acceptor = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->challenge_response_authentication = -1;\n\toptions->permit_empty_passwd = -1;\n\toptions->permit_user_env = -1;\n\toptions->permit_user_env_whitelist = NULL;\n\toptions->compression = -1;\n\toptions->rekey_limit = -1;\n\toptions->rekey_interval = -1;\n\toptions->allow_tcp_forwarding = -1;\n\toptions->allow_streamlocal_forwarding = -1;\n\toptions->allow_agent_forwarding = -1;\n\toptions->num_allow_users = 0;\n\toptions->num_deny_users = 0;\n\toptions->num_allow_groups = 0;\n\toptions->num_deny_groups = 0;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->ca_sign_algorithms = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->num_subsystems = 0;\n\toptions->max_startups_begin = -1;\n\toptions->max_startups_rate = -1;\n\toptions->max_startups = -1;\n\toptions->max_authtries = -1;\n\toptions->max_sessions = -1;\n\toptions->banner = NULL;\n\toptions->use_dns = -1;\n\toptions->client_alive_interval = -1;\n\toptions->client_alive_count_max = -1;\n\toptions->num_authkeys_files = 0;\n\toptions->num_accept_env = 0;\n\toptions->num_setenv = 0;\n\toptions->permit_tun = -1;\n\toptions->permitted_opens = NULL;\n\toptions->permitted_listens = NULL;\n\toptions->adm_forced_command = NULL;\n\toptions->chroot_directory = NULL;\n\toptions->authorized_keys_command = NULL;\n\toptions->authorized_keys_command_user = NULL;\n\toptions->revoked_keys_file = NULL;\n\toptions->trusted_user_ca_keys = NULL;\n\toptions->authorized_principals_file = NULL;\n\toptions->authorized_principals_command = NULL;\n\toptions->authorized_principals_command_user = NULL;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->version_addendum = NULL;\n\toptions->fingerprint_hash = -1;\n\toptions->disable_forwarding = -1;\n\toptions->expose_userauth_info = -1;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\ninitialize_server_options(ServerOptions *options)\n{\n\tmemset(options, 0, sizeof(*options));\n\n\t/* Portable-specific options */\n\toptions->use_pam = -1;\n\n\t/* Standard Options */\n\toptions->num_ports = 0;\n\toptions->ports_from_cmdline = 0;\n\toptions->queued_listen_addrs = NULL;\n\toptions->num_queued_listens = 0;\n\toptions->listen_addrs = NULL;\n\toptions->num_listen_addrs = 0;\n\toptions->address_family = -1;\n\toptions->routing_domain = NULL;\n\toptions->num_host_key_files = 0;\n\toptions->num_host_cert_files = 0;\n\toptions->host_key_agent = NULL;\n\toptions->pid_file = NULL;\n\toptions->login_grace_time = -1;\n\toptions->permit_root_login = PERMIT_NOT_SET;\n\toptions->ignore_rhosts = -1;\n\toptions->ignore_user_known_hosts = -1;\n\toptions->print_motd = -1;\n\toptions->print_lastlog = -1;\n\toptions->x11_forwarding = -1;\n\toptions->x11_display_offset = -1;\n\toptions->x11_use_localhost = -1;\n\toptions->permit_tty = -1;\n\toptions->permit_user_rc = -1;\n\toptions->xauth_location = NULL;\n\toptions->strict_modes = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->hostbased_authentication = -1;\n\toptions->hostbased_uses_name_from_packet_only = -1;\n\toptions->hostbased_key_types = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->pubkey_authentication = -1;\n\toptions->pubkey_key_types = NULL;\n\toptions->kerberos_authentication = -1;\n\toptions->kerberos_or_local_passwd = -1;\n\toptions->kerberos_ticket_cleanup = -1;\n\toptions->kerberos_get_afs_token = -1;\n\toptions->gss_authentication=-1;\n\toptions->gss_cleanup_creds = -1;\n\toptions->gss_strict_acceptor = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->challenge_response_authentication = -1;\n\toptions->permit_empty_passwd = -1;\n\toptions->permit_user_env = -1;\n\toptions->permit_user_env_whitelist = NULL;\n\toptions->compression = -1;\n\toptions->rekey_limit = -1;\n\toptions->rekey_interval = -1;\n\toptions->allow_tcp_forwarding = -1;\n\toptions->allow_streamlocal_forwarding = -1;\n\toptions->allow_agent_forwarding = -1;\n\toptions->num_allow_users = 0;\n\toptions->num_deny_users = 0;\n\toptions->num_allow_groups = 0;\n\toptions->num_deny_groups = 0;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->ca_sign_algorithms = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->num_subsystems = 0;\n\toptions->max_startups_begin = -1;\n\toptions->max_startups_rate = -1;\n\toptions->max_startups = -1;\n\toptions->max_authtries = -1;\n\toptions->max_sessions = -1;\n\toptions->banner = NULL;\n\toptions->use_dns = -1;\n\toptions->client_alive_interval = -1;\n\toptions->client_alive_count_max = -1;\n\toptions->num_authkeys_files = 0;\n\toptions->num_accept_env = 0;\n\toptions->num_setenv = 0;\n\toptions->permit_tun = -1;\n\toptions->permitted_opens = NULL;\n\toptions->permitted_listens = NULL;\n\toptions->adm_forced_command = NULL;\n\toptions->chroot_directory = NULL;\n\toptions->authorized_keys_command = NULL;\n\toptions->authorized_keys_command_user = NULL;\n\toptions->revoked_keys_file = NULL;\n\toptions->trusted_user_ca_keys = NULL;\n\toptions->authorized_principals_file = NULL;\n\toptions->authorized_principals_command = NULL;\n\toptions->authorized_principals_command_user = NULL;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->version_addendum = NULL;\n\toptions->fingerprint_hash = -1;\n\toptions->disable_forwarding = -1;\n\toptions->expose_userauth_info = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sanitise_stdfd",
          "args": [],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "sanitise_stdfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1109-1130",
          "snippet": "void\nsanitise_stdfd(void)\n{\n\tint nullfd, dupfd;\n\n\tif ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open /dev/null: %s\\n\",\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\twhile (++dupfd <= STDERR_FILENO) {\n\t\t/* Only populate closed fds. */\n\t\tif (fcntl(dupfd, F_GETFL) == -1 && errno == EBADF) {\n\t\t\tif (dup2(nullfd, dupfd) == -1) {\n\t\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (nullfd > STDERR_FILENO)\n\t\tclose(nullfd);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsanitise_stdfd(void)\n{\n\tint nullfd, dupfd;\n\n\tif ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open /dev/null: %s\\n\",\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\twhile (++dupfd <= STDERR_FILENO) {\n\t\t/* Only populate closed fds. */\n\t\tif (fcntl(dupfd, F_GETFL) == -1 && errno == EBADF) {\n\t\t\tif (dup2(nullfd, dupfd) == -1) {\n\t\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (nullfd > STDERR_FILENO)\n\t\tclose(nullfd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_init_setproctitle",
          "args": [
            "ac",
            "av"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "compat_init_setproctitle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/setproctitle.c",
          "lines": "67-119",
          "snippet": "void\ncompat_init_setproctitle(int argc, char *argv[])\n{\n#if !defined(HAVE_SETPROCTITLE) && \\\n    defined(SPT_TYPE) && SPT_TYPE == SPT_REUSEARGV\n\textern char **environ;\n\tchar *lastargv = NULL;\n\tchar **envp = environ;\n\tint i;\n\n\t/*\n\t * NB: This assumes that argv has already been copied out of the\n\t * way. This is true for sshd, but may not be true for other\n\t * programs. Beware.\n\t */\n\n\tif (argc == 0 || argv[0] == NULL)\n\t\treturn;\n\n\t/* Fail if we can't allocate room for the new environment */\n\tfor (i = 0; envp[i] != NULL; i++)\n\t\t;\n\tif ((environ = calloc(i + 1, sizeof(*environ))) == NULL) {\n\t\tenviron = envp;\t/* put it back */\n\t\treturn;\n\t}\n\n\t/*\n\t * Find the last argv string or environment variable within\n\t * our process memory area.\n\t */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (lastargv == NULL || lastargv + 1 == argv[i])\n\t\t\tlastargv = argv[i] + strlen(argv[i]);\n\t}\n\tfor (i = 0; envp[i] != NULL; i++) {\n\t\tif (lastargv + 1 == envp[i])\n\t\t\tlastargv = envp[i] + strlen(envp[i]);\n\t}\n\n\targv[1] = NULL;\n\targv_start = argv[0];\n\targv_env_len = lastargv - argv[0] - 1;\n\n\t/*\n\t * Copy environment\n\t * XXX - will truncate env on strdup fail\n\t */\n\tfor (i = 0; envp[i] != NULL; i++)\n\t\tenviron[i] = strdup(envp[i]);\n\tenviron[i] = NULL;\n#endif /* SPT_REUSEARGV */\n}",
          "includes": [
            "#include <vis.h>",
            "#include <string.h>",
            "#include <sys/pstat.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SPT_REUSEARGV\t2\t/* cover argv with title information */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vis.h>\n#include <string.h>\n#include <sys/pstat.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\n#define SPT_REUSEARGV\t2\t/* cover argv with title information */\n\nvoid\ncompat_init_setproctitle(int argc, char *argv[])\n{\n#if !defined(HAVE_SETPROCTITLE) && \\\n    defined(SPT_TYPE) && SPT_TYPE == SPT_REUSEARGV\n\textern char **environ;\n\tchar *lastargv = NULL;\n\tchar **envp = environ;\n\tint i;\n\n\t/*\n\t * NB: This assumes that argv has already been copied out of the\n\t * way. This is true for sshd, but may not be true for other\n\t * programs. Beware.\n\t */\n\n\tif (argc == 0 || argv[0] == NULL)\n\t\treturn;\n\n\t/* Fail if we can't allocate room for the new environment */\n\tfor (i = 0; envp[i] != NULL; i++)\n\t\t;\n\tif ((environ = calloc(i + 1, sizeof(*environ))) == NULL) {\n\t\tenviron = envp;\t/* put it back */\n\t\treturn;\n\t}\n\n\t/*\n\t * Find the last argv string or environment variable within\n\t * our process memory area.\n\t */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (lastargv == NULL || lastargv + 1 == argv[i])\n\t\t\tlastargv = argv[i] + strlen(argv[i]);\n\t}\n\tfor (i = 0; envp[i] != NULL; i++) {\n\t\tif (lastargv + 1 == envp[i])\n\t\t\tlastargv = envp[i] + strlen(envp[i]);\n\t}\n\n\targv[1] = NULL;\n\targv_start = argv[0];\n\targv_env_len = lastargv - argv[0] - 1;\n\n\t/*\n\t * Copy environment\n\t * XXX - will truncate env on strdup fail\n\t */\n\tfor (i = 0; envp[i] != NULL; i++)\n\t\tenviron[i] = strdup(envp[i]);\n\tenviron[i] = NULL;\n#endif /* SPT_REUSEARGV */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_get_progname",
          "args": [
            "av[0]"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_get_progname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "43-64",
          "snippet": "char *ssh_get_progname(char *argv0)\n{\n\tchar *p, *q;\n#ifdef HAVE___PROGNAME\n\textern char *__progname;\n\n\tp = __progname;\n#else\n\tif (argv0 == NULL)\n\t\treturn (\"unknown\");\t/* XXX */\n\tp = strrchr(argv0, '/');\n\tif (p == NULL)\n\t\tp = argv0;\n\telse\n\t\tp++;\n#endif\n\tif ((q = strdup(p)) == NULL) {\n\t\tperror(\"strdup\");\n\t\texit(1);\n\t}\n\treturn q;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *ssh_get_progname(char *argv0)\n{\n\tchar *p, *q;\n#ifdef HAVE___PROGNAME\n\textern char *__progname;\n\n\tp = __progname;\n#else\n\tif (argv0 == NULL)\n\t\treturn (\"unknown\");\t/* XXX */\n\tp = strrchr(argv0, '/');\n\tif (p == NULL)\n\t\tp = argv0;\n\telse\n\t\tp++;\n#endif\n\tif ((q = strdup(p)) == NULL) {\n\t\tperror(\"strdup\");\n\t\texit(1);\n\t}\n\treturn q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_auth_parameters",
          "args": [
            "ac",
            "av"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_malloc_init",
          "args": [],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_malloc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "29-37",
          "snippet": "void\nssh_malloc_init(void)\n{\n#if defined(__OpenBSD__)\n\textern char *malloc_options;\n\n\tmalloc_options = \"S\";\n#endif /* __OpenBSD__ */\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nssh_malloc_init(void)\n{\n#if defined(__OpenBSD__)\n\textern char *malloc_options;\n\n\tmalloc_options = \"S\";\n#endif /* __OpenBSD__ */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define REEXEC_MIN_FREE_FD\t\t(STDERR_FILENO + 4)\n#define REEXEC_CONFIG_PASS_FD\t\t(STDERR_FILENO + 3)\n#define REEXEC_STARTUP_PIPE_FD\t\t(STDERR_FILENO + 2)\n#define REEXEC_DEVCRYPTO_RESERVED_FD\t(STDERR_FILENO + 1)\n\nextern char *__progname;\nServerOptions options;\nchar *config_file_name = _PATH_SERVER_CONFIG_FILE;\nint debug_flag = 0;\nint test_flag = 0;\nint inetd_flag = 0;\nint no_daemon_flag = 0;\nint log_stderr = 0;\nchar **saved_argv;\nint saved_argc;\nint rexeced_flag = 0;\nint rexec_flag = 1;\nint rexec_argc = 0;\nchar **rexec_argv;\nint auth_sock = -1;\nint have_agent = 0;\nstruct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;\nu_int utmp_len = HOST_NAME_MAX+1;\nint startup_pipe;\nint use_privsep = -1;\nstruct monitor *pmonitor = NULL;\nstatic int privsep_chroot = 1;\nAuthctxt *the_authctxt = NULL;\nstruct sshauthopt *auth_opts = NULL;\nstruct sshbuf *cfg;\nstruct sshbuf *loginmsg;\nstruct passwd *privsep_pw = NULL;\nstatic void do_ssh2_kex(void);\n\nint\nmain(int ac, char **av)\n{\n\tstruct ssh *ssh = NULL;\n\textern char *optarg;\n\textern int optind;\n\tint r, opt, on = 1, already_daemon, remote_port;\n\tint sock_in = -1, sock_out = -1, newsock = -1;\n\tconst char *remote_ip, *rdomain;\n\tchar *fp, *line, *laddr, *logfile = NULL;\n\tint config_s[2] = { -1 , -1 };\n\tu_int i, j;\n\tu_int64_t ibytes, obytes;\n\tmode_t new_umask;\n\tstruct sshkey *key;\n\tstruct sshkey *pubkey;\n\tint keytype;\n\tAuthctxt *authctxt;\n\tstruct connection_info *connection_info = NULL;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\n#ifdef HAVE_SECUREWARE\n\t(void)set_auth_parameters(ac, av);\n#endif\n\t__progname = ssh_get_progname(av[0]);\n\n\t/* Save argv. Duplicate so setproctitle emulation doesn't clobber it */\n\tsaved_argc = ac;\n\trexec_argc = ac;\n\tsaved_argv = xcalloc(ac + 1, sizeof(*saved_argv));\n\tfor (i = 0; (int)i < ac; i++)\n\t\tsaved_argv[i] = xstrdup(av[i]);\n\tsaved_argv[i] = NULL;\n\n#ifndef HAVE_SETPROCTITLE\n\t/* Prepare for later setproctitle emulation */\n\tcompat_init_setproctitle(ac, av);\n\tav = saved_argv;\n#endif\n\n\tif (geteuid() == 0 && setgroups(0, NULL) == -1)\n\t\tdebug(\"setgroups(): %.200s\", strerror(errno));\n\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t/* Initialize configuration options to their default values. */\n\tinitialize_server_options(&options);\n\n\t/* Parse command-line arguments. */\n\twhile ((opt = getopt(ac, av,\n\t    \"C:E:b:c:f:g:h:k:o:p:u:46DQRTdeiqrt\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase '4':\n\t\t\toptions.address_family = AF_INET;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\toptions.address_family = AF_INET6;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tconfig_file_name = optarg;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tservconf_add_hostcert(\"[command-line]\", 0,\n\t\t\t    &options, optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (debug_flag == 0) {\n\t\t\t\tdebug_flag = 1;\n\t\t\t\toptions.log_level = SYSLOG_LEVEL_DEBUG1;\n\t\t\t} else if (options.log_level < SYSLOG_LEVEL_DEBUG3)\n\t\t\t\toptions.log_level++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tno_daemon_flag = 1;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tlogfile = optarg;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 'e':\n\t\t\tlog_stderr = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tinetd_flag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trexec_flag = 0;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trexeced_flag = 1;\n\t\t\tinetd_flag = 1;\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\t/* ignored */\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\toptions.log_level = SYSLOG_LEVEL_QUIET;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\t/* protocol 1, ignored */\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\toptions.ports_from_cmdline = 1;\n\t\t\tif (options.num_ports >= MAX_PORTS) {\n\t\t\t\tfprintf(stderr, \"too many ports.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\toptions.ports[options.num_ports++] = a2port(optarg);\n\t\t\tif (options.ports[options.num_ports-1] <= 0) {\n\t\t\t\tfprintf(stderr, \"Bad port number.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tif ((options.login_grace_time = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid login grace time.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\t/* protocol 1, ignored */\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tservconf_add_hostkey(\"[command-line]\", 0,\n\t\t\t    &options, optarg);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttest_flag = 1;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\ttest_flag = 2;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tconnection_info = get_connection_info(0, 0);\n\t\t\tif (parse_server_match_testspec(connection_info,\n\t\t\t    optarg) == -1)\n\t\t\t\texit(1);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tutmp_len = (u_int)strtonum(optarg, 0, HOST_NAME_MAX+1+1, NULL);\n\t\t\tif (utmp_len > HOST_NAME_MAX+1) {\n\t\t\t\tfprintf(stderr, \"Invalid utmp length.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tline = xstrdup(optarg);\n\t\t\tif (process_server_config_line(&options, line,\n\t\t\t    \"command-line\", 0, NULL, NULL) != 0)\n\t\t\t\texit(1);\n\t\t\tfree(line);\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rexeced_flag || inetd_flag)\n\t\trexec_flag = 0;\n\tif (!test_flag && (rexec_flag && (av[0] == NULL || *av[0] != '/')))\n\t\tfatal(\"sshd re-exec requires execution with an absolute path\");\n\tif (rexeced_flag)\n\t\tclosefrom(REEXEC_MIN_FREE_FD);\n\telse\n\t\tclosefrom(REEXEC_DEVCRYPTO_RESERVED_FD);\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n#endif\n\n\t/* If requested, redirect the logs to the specified logfile. */\n\tif (logfile != NULL)\n\t\tlog_redirect_stderr_to(logfile);\n\t/*\n\t * Force logging to stderr until we have loaded the private host\n\t * key (unless started from inetd)\n\t */\n\tlog_init(__progname,\n\t    options.log_level == SYSLOG_LEVEL_NOT_SET ?\n\t    SYSLOG_LEVEL_INFO : options.log_level,\n\t    options.log_facility == SYSLOG_FACILITY_NOT_SET ?\n\t    SYSLOG_FACILITY_AUTH : options.log_facility,\n\t    log_stderr || !inetd_flag);\n\n\t/*\n\t * Unset KRB5CCNAME, otherwise the user's session may inherit it from\n\t * root's environment\n\t */\n\tif (getenv(\"KRB5CCNAME\") != NULL)\n\t\t(void) unsetenv(\"KRB5CCNAME\");\n\n\tsensitive_data.have_ssh2_key = 0;\n\n\t/*\n\t * If we're not doing an extended test do not silently ignore connection\n\t * test params.\n\t */\n\tif (test_flag < 2 && connection_info != NULL)\n\t\tfatal(\"Config test connection parameter (-C) provided without \"\n\t\t   \"test mode (-T)\");\n\n\t/* Fetch our configuration */\n\tif ((cfg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif (rexeced_flag)\n\t\trecv_rexec_state(REEXEC_CONFIG_PASS_FD, cfg);\n\telse if (strcasecmp(config_file_name, \"none\") != 0)\n\t\tload_server_config(config_file_name, cfg);\n\n\tparse_server_config(&options, rexeced_flag ? \"rexec\" : config_file_name,\n\t    cfg, NULL);\n\n\tseed_rng();\n\n\t/* Fill in default values for those options not explicitly set. */\n\tfill_default_server_options(&options);\n\n\t/* challenge-response is implemented via keyboard interactive */\n\tif (options.challenge_response_authentication)\n\t\toptions.kbd_interactive_authentication = 1;\n\n\t/* Check that options are sensible */\n\tif (options.authorized_keys_command_user == NULL &&\n\t    (options.authorized_keys_command != NULL &&\n\t    strcasecmp(options.authorized_keys_command, \"none\") != 0))\n\t\tfatal(\"AuthorizedKeysCommand set without \"\n\t\t    \"AuthorizedKeysCommandUser\");\n\tif (options.authorized_principals_command_user == NULL &&\n\t    (options.authorized_principals_command != NULL &&\n\t    strcasecmp(options.authorized_principals_command, \"none\") != 0))\n\t\tfatal(\"AuthorizedPrincipalsCommand set without \"\n\t\t    \"AuthorizedPrincipalsCommandUser\");\n\n\t/*\n\t * Check whether there is any path through configured auth methods.\n\t * Unfortunately it is not possible to verify this generally before\n\t * daemonisation in the presence of Match block, but this catches\n\t * and warns for trivial misconfigurations that could break login.\n\t */\n\tif (options.num_auth_methods != 0) {\n\t\tfor (i = 0; i < options.num_auth_methods; i++) {\n\t\t\tif (auth2_methods_valid(options.auth_methods[i],\n\t\t\t    1) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= options.num_auth_methods)\n\t\t\tfatal(\"AuthenticationMethods cannot be satisfied by \"\n\t\t\t    \"enabled authentication methods\");\n\t}\n\n\t/* Check that there are no remaining arguments. */\n\tif (optind < ac) {\n\t\tfprintf(stderr, \"Extra argument %s.\\n\", av[optind]);\n\t\texit(1);\n\t}\n\n\tdebug(\"sshd version %s, %s\", SSH_VERSION,\n#ifdef WITH_OPENSSL\n\t    OpenSSL_version(OPENSSL_VERSION)\n#else\n\t    \"without OpenSSL\"\n#endif\n\t);\n\n\t/* Store privilege separation user for later use if required. */\n\tprivsep_chroot = use_privsep && (getuid() == 0 || geteuid() == 0);\n\tif ((privsep_pw = getpwnam(SSH_PRIVSEP_USER)) == NULL) {\n\t\tif (privsep_chroot || options.kerberos_authentication)\n\t\t\tfatal(\"Privilege separation user %s does not exist\",\n\t\t\t    SSH_PRIVSEP_USER);\n\t} else {\n\t\tprivsep_pw = pwcopy(privsep_pw);\n\t\tfreezero(privsep_pw->pw_passwd, strlen(privsep_pw->pw_passwd));\n\t\tprivsep_pw->pw_passwd = xstrdup(\"*\");\n\t}\n\tendpwent();\n\n\t/* load host keys */\n\tsensitive_data.host_keys = xcalloc(options.num_host_key_files,\n\t    sizeof(struct sshkey *));\n\tsensitive_data.host_pubkeys = xcalloc(options.num_host_key_files,\n\t    sizeof(struct sshkey *));\n\n\tif (options.host_key_agent) {\n\t\tif (strcmp(options.host_key_agent, SSH_AUTHSOCKET_ENV_NAME))\n\t\t\tsetenv(SSH_AUTHSOCKET_ENV_NAME,\n\t\t\t    options.host_key_agent, 1);\n\t\tif ((r = ssh_get_authentication_socket(NULL)) == 0)\n\t\t\thave_agent = 1;\n\t\telse\n\t\t\terror(\"Could not connect to agent \\\"%s\\\": %s\",\n\t\t\t    options.host_key_agent, ssh_err(r));\n\t}\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tif (options.host_key_files[i] == NULL)\n\t\t\tcontinue;\n\t\tif ((r = sshkey_load_private(options.host_key_files[i], \"\",\n\t\t    &key, NULL)) != 0 && r != SSH_ERR_SYSTEM_ERROR)\n\t\t\terror(\"Error loading host key \\\"%s\\\": %s\",\n\t\t\t    options.host_key_files[i], ssh_err(r));\n\t\tif ((r = sshkey_load_public(options.host_key_files[i],\n\t\t    &pubkey, NULL)) != 0 && r != SSH_ERR_SYSTEM_ERROR)\n\t\t\terror(\"Error loading host key \\\"%s\\\": %s\",\n\t\t\t    options.host_key_files[i], ssh_err(r));\n\t\tif (pubkey == NULL && key != NULL)\n\t\t\tif ((r = sshkey_from_private(key, &pubkey)) != 0)\n\t\t\t\tfatal(\"Could not demote key: \\\"%s\\\": %s\",\n\t\t\t\t    options.host_key_files[i], ssh_err(r));\n\t\tsensitive_data.host_keys[i] = key;\n\t\tsensitive_data.host_pubkeys[i] = pubkey;\n\n\t\tif (key == NULL && pubkey != NULL && have_agent) {\n\t\t\tdebug(\"will rely on agent for hostkey %s\",\n\t\t\t    options.host_key_files[i]);\n\t\t\tkeytype = pubkey->type;\n\t\t} else if (key != NULL) {\n\t\t\tkeytype = key->type;\n\t\t\taccumulate_host_timing_secret(cfg, key);\n\t\t} else {\n\t\t\terror(\"Could not load host key: %s\",\n\t\t\t    options.host_key_files[i]);\n\t\t\tsensitive_data.host_keys[i] = NULL;\n\t\t\tsensitive_data.host_pubkeys[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (keytype) {\n\t\tcase KEY_RSA:\n\t\tcase KEY_DSA:\n\t\tcase KEY_ECDSA:\n\t\tcase KEY_ED25519:\n\t\tcase KEY_XMSS:\n\t\t\tif (have_agent || key != NULL)\n\t\t\t\tsensitive_data.have_ssh2_key = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif ((fp = sshkey_fingerprint(pubkey, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal(\"sshkey_fingerprint failed\");\n\t\tdebug(\"%s host key #%d: %s %s\",\n\t\t    key ? \"private\" : \"agent\", i, sshkey_ssh_name(pubkey), fp);\n\t\tfree(fp);\n\t}\n\taccumulate_host_timing_secret(cfg, NULL);\n\tif (!sensitive_data.have_ssh2_key) {\n\t\tlogit(\"sshd: no hostkeys available -- exiting.\");\n\t\texit(1);\n\t}\n\n\t/*\n\t * Load certificates. They are stored in an array at identical\n\t * indices to the public keys that they relate to.\n\t */\n\tsensitive_data.host_certificates = xcalloc(options.num_host_key_files,\n\t    sizeof(struct sshkey *));\n\tfor (i = 0; i < options.num_host_key_files; i++)\n\t\tsensitive_data.host_certificates[i] = NULL;\n\n\tfor (i = 0; i < options.num_host_cert_files; i++) {\n\t\tif (options.host_cert_files[i] == NULL)\n\t\t\tcontinue;\n\t\tif ((r = sshkey_load_public(options.host_cert_files[i],\n\t\t    &key, NULL)) != 0) {\n\t\t\terror(\"Could not load host certificate \\\"%s\\\": %s\",\n\t\t\t    options.host_cert_files[i], ssh_err(r));\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sshkey_is_cert(key)) {\n\t\t\terror(\"Certificate file is not a certificate: %s\",\n\t\t\t    options.host_cert_files[i]);\n\t\t\tsshkey_free(key);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Find matching private key */\n\t\tfor (j = 0; j < options.num_host_key_files; j++) {\n\t\t\tif (sshkey_equal_public(key,\n\t\t\t    sensitive_data.host_keys[j])) {\n\t\t\t\tsensitive_data.host_certificates[j] = key;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= options.num_host_key_files) {\n\t\t\terror(\"No matching private key for certificate: %s\",\n\t\t\t    options.host_cert_files[i]);\n\t\t\tsshkey_free(key);\n\t\t\tcontinue;\n\t\t}\n\t\tsensitive_data.host_certificates[j] = key;\n\t\tdebug(\"host certificate: #%u type %d %s\", j, key->type,\n\t\t    sshkey_type(key));\n\t}\n\n\tif (privsep_chroot) {\n\t\tstruct stat st;\n\n\t\tif ((stat(_PATH_PRIVSEP_CHROOT_DIR, &st) == -1) ||\n\t\t    (S_ISDIR(st.st_mode) == 0))\n\t\t\tfatal(\"Missing privilege separation directory: %s\",\n\t\t\t    _PATH_PRIVSEP_CHROOT_DIR);\n\n#ifdef HAVE_CYGWIN\n\t\tif (check_ntsec(_PATH_PRIVSEP_CHROOT_DIR) &&\n\t\t    (st.st_uid != getuid () ||\n\t\t    (st.st_mode & (S_IWGRP|S_IWOTH)) != 0))\n#else\n\t\tif (st.st_uid != 0 || (st.st_mode & (S_IWGRP|S_IWOTH)) != 0)\n#endif\n\t\t\tfatal(\"%s must be owned by root and not group or \"\n\t\t\t    \"world-writable.\", _PATH_PRIVSEP_CHROOT_DIR);\n\t}\n\n\tif (test_flag > 1) {\n\t\t/*\n\t\t * If no connection info was provided by -C then use\n\t\t * use a blank one that will cause no predicate to match.\n\t\t */\n\t\tif (connection_info == NULL)\n\t\t\tconnection_info = get_connection_info(0, 0);\n\t\tparse_server_match_config(&options, connection_info);\n\t\tdump_config(&options);\n\t}\n\n\t/* Configuration looks good, so exit if in test mode. */\n\tif (test_flag)\n\t\texit(0);\n\n\t/*\n\t * Clear out any supplemental groups we may have inherited.  This\n\t * prevents inadvertent creation of files with bad modes (in the\n\t * portable version at least, it's certainly possible for PAM\n\t * to create a file, and we can't control the code in every\n\t * module which might be used).\n\t */\n\tif (setgroups(0, NULL) < 0)\n\t\tdebug(\"setgroups() failed: %.200s\", strerror(errno));\n\n\tif (rexec_flag) {\n\t\tif (rexec_argc < 0)\n\t\t\tfatal(\"rexec_argc %d < 0\", rexec_argc);\n\t\trexec_argv = xcalloc(rexec_argc + 2, sizeof(char *));\n\t\tfor (i = 0; i < (u_int)rexec_argc; i++) {\n\t\t\tdebug(\"rexec_argv[%d]='%s'\", i, saved_argv[i]);\n\t\t\trexec_argv[i] = saved_argv[i];\n\t\t}\n\t\trexec_argv[rexec_argc] = \"-R\";\n\t\trexec_argv[rexec_argc + 1] = NULL;\n\t}\n\n\t/* Ensure that umask disallows at least group and world write */\n\tnew_umask = umask(0077) | 0022;\n\t(void) umask(new_umask);\n\n\t/* Initialize the log (it is reinitialized below in case we forked). */\n\tif (debug_flag && (!inetd_flag || rexeced_flag))\n\t\tlog_stderr = 1;\n\tlog_init(__progname, options.log_level, options.log_facility, log_stderr);\n\n\t/*\n\t * If not in debugging mode, not started from inetd and not already\n\t * daemonized (eg re-exec via SIGHUP), disconnect from the controlling\n\t * terminal, and fork.  The original process exits.\n\t */\n\talready_daemon = daemonized();\n\tif (!(debug_flag || inetd_flag || no_daemon_flag || already_daemon)) {\n\n\t\tif (daemon(0, 0) < 0)\n\t\t\tfatal(\"daemon() failed: %.200s\", strerror(errno));\n\n\t\tdisconnect_controlling_tty();\n\t}\n\t/* Reinitialize the log (because of the fork above). */\n\tlog_init(__progname, options.log_level, options.log_facility, log_stderr);\n\n\t/* Chdir to the root directory so that the current disk can be\n\t   unmounted if desired. */\n\tif (chdir(\"/\") == -1)\n\t\terror(\"chdir(\\\"/\\\"): %s\", strerror(errno));\n\n\t/* ignore SIGPIPE */\n\tsignal(SIGPIPE, SIG_IGN);\n\n\t/* Get a connection, either from inetd or a listening TCP socket */\n\tif (inetd_flag) {\n\t\tserver_accept_inetd(&sock_in, &sock_out);\n\t} else {\n\t\tplatform_pre_listen();\n\t\tserver_listen();\n\n\t\tsignal(SIGHUP, sighup_handler);\n\t\tsignal(SIGCHLD, main_sigchld_handler);\n\t\tsignal(SIGTERM, sigterm_handler);\n\t\tsignal(SIGQUIT, sigterm_handler);\n\n\t\t/*\n\t\t * Write out the pid file after the sigterm handler\n\t\t * is setup and the listen sockets are bound\n\t\t */\n\t\tif (options.pid_file != NULL && !debug_flag) {\n\t\t\tFILE *f = fopen(options.pid_file, \"w\");\n\n\t\t\tif (f == NULL) {\n\t\t\t\terror(\"Couldn't create pid file \\\"%s\\\": %s\",\n\t\t\t\t    options.pid_file, strerror(errno));\n\t\t\t} else {\n\t\t\t\tfprintf(f, \"%ld\\n\", (long) getpid());\n\t\t\t\tfclose(f);\n\t\t\t}\n\t\t}\n\n\t\t/* Accept a connection and return in a forked child */\n\t\tserver_accept_loop(&sock_in, &sock_out,\n\t\t    &newsock, config_s);\n\t}\n\n\t/* This is the child processing a new connection. */\n\tsetproctitle(\"%s\", \"[accepted]\");\n\n\t/*\n\t * Create a new session and process group since the 4.4BSD\n\t * setlogin() affects the entire process group.  We don't\n\t * want the child to be able to affect the parent.\n\t */\n#if !defined(SSHD_ACQUIRES_CTTY)\n\t/*\n\t * If setsid is called, on some platforms sshd will later acquire a\n\t * controlling terminal which will result in \"could not set\n\t * controlling tty\" errors.\n\t */\n\tif (!debug_flag && !inetd_flag && setsid() < 0)\n\t\terror(\"setsid: %.100s\", strerror(errno));\n#endif\n\n\tif (rexec_flag) {\n\t\tint fd;\n\n\t\tdebug(\"rexec start in %d out %d newsock %d pipe %d sock %d\",\n\t\t    sock_in, sock_out, newsock, startup_pipe, config_s[0]);\n\t\tdup2(newsock, STDIN_FILENO);\n\t\tdup2(STDIN_FILENO, STDOUT_FILENO);\n\t\tif (startup_pipe == -1)\n\t\t\tclose(REEXEC_STARTUP_PIPE_FD);\n\t\telse if (startup_pipe != REEXEC_STARTUP_PIPE_FD) {\n\t\t\tdup2(startup_pipe, REEXEC_STARTUP_PIPE_FD);\n\t\t\tclose(startup_pipe);\n\t\t\tstartup_pipe = REEXEC_STARTUP_PIPE_FD;\n\t\t}\n\n\t\tdup2(config_s[1], REEXEC_CONFIG_PASS_FD);\n\t\tclose(config_s[1]);\n\n\t\texecv(rexec_argv[0], rexec_argv);\n\n\t\t/* Reexec has failed, fall back and continue */\n\t\terror(\"rexec of %s failed: %s\", rexec_argv[0], strerror(errno));\n\t\trecv_rexec_state(REEXEC_CONFIG_PASS_FD, NULL);\n\t\tlog_init(__progname, options.log_level,\n\t\t    options.log_facility, log_stderr);\n\n\t\t/* Clean up fds */\n\t\tclose(REEXEC_CONFIG_PASS_FD);\n\t\tnewsock = sock_out = sock_in = dup(STDIN_FILENO);\n\t\tif ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\t\tdup2(fd, STDIN_FILENO);\n\t\t\tdup2(fd, STDOUT_FILENO);\n\t\t\tif (fd > STDERR_FILENO)\n\t\t\t\tclose(fd);\n\t\t}\n\t\tdebug(\"rexec cleanup in %d out %d newsock %d pipe %d sock %d\",\n\t\t    sock_in, sock_out, newsock, startup_pipe, config_s[0]);\n\t}\n\n\t/* Executed child processes don't need these. */\n\tfcntl(sock_out, F_SETFD, FD_CLOEXEC);\n\tfcntl(sock_in, F_SETFD, FD_CLOEXEC);\n\n\t/*\n\t * Disable the key regeneration alarm.  We will not regenerate the\n\t * key since we are no longer in a position to give it to anyone. We\n\t * will not restart on SIGHUP since it no longer makes sense.\n\t */\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tsignal(SIGHUP, SIG_DFL);\n\tsignal(SIGTERM, SIG_DFL);\n\tsignal(SIGQUIT, SIG_DFL);\n\tsignal(SIGCHLD, SIG_DFL);\n\tsignal(SIGINT, SIG_DFL);\n\n\t/*\n\t * Register our connection.  This turns encryption off because we do\n\t * not have a key.\n\t */\n\tpacket_set_connection(sock_in, sock_out);\n\tpacket_set_server();\n\tssh = active_state; /* XXX */\n\n\tcheck_ip_options(ssh);\n\n\t/* Prepare the channels layer */\n\tchannel_init_channels(ssh);\n\tchannel_set_af(ssh, options.address_family);\n\tprocess_permitopen(ssh, &options);\n\n\t/* Set SO_KEEPALIVE if requested. */\n\tif (options.tcp_keep_alive && packet_connection_is_on_socket() &&\n\t    setsockopt(sock_in, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_KEEPALIVE: %.100s\", strerror(errno));\n\n\tif ((remote_port = ssh_remote_port(ssh)) < 0) {\n\t\tdebug(\"ssh_remote_port failed\");\n\t\tcleanup_exit(255);\n\t}\n\n\tif (options.routing_domain != NULL)\n\t\tset_process_rdomain(ssh, options.routing_domain);\n\n\t/*\n\t * The rest of the code depends on the fact that\n\t * ssh_remote_ipaddr() caches the remote ip, even if\n\t * the socket goes away.\n\t */\n\tremote_ip = ssh_remote_ipaddr(ssh);\n\n#ifdef SSH_AUDIT_EVENTS\n\taudit_connection_from(remote_ip, remote_port);\n#endif\n\n\trdomain = ssh_packet_rdomain_in(ssh);\n\n\t/* Log the connection. */\n\tladdr = get_local_ipaddr(sock_in);\n\tverbose(\"Connection from %s port %d on %s port %d%s%s%s\",\n\t    remote_ip, remote_port, laddr,  ssh_local_port(ssh),\n\t    rdomain == NULL ? \"\" : \" rdomain \\\"\",\n\t    rdomain == NULL ? \"\" : rdomain,\n\t    rdomain == NULL ? \"\" : \"\\\"\");\n\tfree(laddr);\n\n\t/*\n\t * We don't want to listen forever unless the other side\n\t * successfully authenticates itself.  So we set up an alarm which is\n\t * cleared after successful authentication.  A limit of zero\n\t * indicates no limit. Note that we don't set the alarm in debugging\n\t * mode; it is just annoying to have the server exit just when you\n\t * are about to discover the bug.\n\t */\n\tsignal(SIGALRM, grace_alarm_handler);\n\tif (!debug_flag)\n\t\talarm(options.login_grace_time);\n\n\tsshd_exchange_identification(ssh, sock_in, sock_out);\n\tpacket_set_nonblocking();\n\n\t/* allocate authentication context */\n\tauthctxt = xcalloc(1, sizeof(*authctxt));\n\n\tauthctxt->loginmsg = loginmsg;\n\n\t/* XXX global for cleanup, access from other modules */\n\tthe_authctxt = authctxt;\n\n\t/* Set default key authentication options */\n\tif ((auth_opts = sshauthopt_new_with_keys_defaults()) == NULL)\n\t\tfatal(\"allocation failed\");\n\n\t/* prepare buffer to collect messages to display to user after login */\n\tif ((loginmsg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tauth_debug_reset();\n\n\tif (use_privsep) {\n\t\tif (privsep_preauth(authctxt) == 1)\n\t\t\tgoto authenticated;\n\t} else if (have_agent) {\n\t\tif ((r = ssh_get_authentication_socket(&auth_sock)) != 0) {\n\t\t\terror(\"Unable to get agent socket: %s\", ssh_err(r));\n\t\t\thave_agent = 0;\n\t\t}\n\t}\n\n\t/* perform the key exchange */\n\t/* authenticate user and start session */\n\tdo_ssh2_kex();\n\tdo_authentication2(authctxt);\n\n\t/*\n\t * If we use privilege separation, the unprivileged child transfers\n\t * the current keystate and exits\n\t */\n\tif (use_privsep) {\n\t\tmm_send_keystate(pmonitor);\n\t\tpacket_clear_keys();\n\t\texit(0);\n\t}\n\n authenticated:\n\t/*\n\t * Cancel the alarm we set to limit the time taken for\n\t * authentication.\n\t */\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tauthctxt->authenticated = 1;\n\tif (startup_pipe != -1) {\n\t\tclose(startup_pipe);\n\t\tstartup_pipe = -1;\n\t}\n\n#ifdef SSH_AUDIT_EVENTS\n\taudit_event(SSH_AUTH_SUCCESS);\n#endif\n\n#ifdef GSSAPI\n\tif (options.gss_authentication) {\n\t\ttemporarily_use_uid(authctxt->pw);\n\t\tssh_gssapi_storecreds();\n\t\trestore_uid();\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam) {\n\t\tdo_pam_setcred(1);\n\t\tdo_pam_session(ssh);\n\t}\n#endif\n\n\t/*\n\t * In privilege separation, we fork another child and prepare\n\t * file descriptor passing.\n\t */\n\tif (use_privsep) {\n\t\tprivsep_postauth(authctxt);\n\t\t/* the monitor process [priv] will not return */\n\t}\n\n\tpacket_set_timeout(options.client_alive_interval,\n\t    options.client_alive_count_max);\n\n\t/* Try to send all our hostkeys to the client */\n\tnotify_hostkeys(ssh);\n\n\t/* Start session. */\n\tdo_authenticated(ssh, authctxt);\n\n\t/* The connection has been terminated. */\n\tpacket_get_bytes(&ibytes, &obytes);\n\tverbose(\"Transferred: sent %llu, received %llu bytes\",\n\t    (unsigned long long)obytes, (unsigned long long)ibytes);\n\n\tverbose(\"Closing connection to %.500s port %d\", remote_ip, remote_port);\n\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\tfinish_pam();\n#endif /* USE_PAM */\n\n#ifdef SSH_AUDIT_EVENTS\n\tPRIVSEP(audit_event(SSH_CONNECTION_CLOSE));\n#endif\n\n\tpacket_close();\n\n\tif (use_privsep)\n\t\tmm_terminate();\n\n\texit(0);\n}"
  },
  {
    "function_name": "accumulate_host_timing_secret",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "1426-1461",
    "snippet": "static void\naccumulate_host_timing_secret(struct sshbuf *server_cfg,\n    const struct sshkey *key)\n{\n\tstatic struct ssh_digest_ctx *ctx;\n\tu_char *hash;\n\tsize_t len;\n\tstruct sshbuf *buf;\n\tint r;\n\n\tif (ctx == NULL && (ctx = ssh_digest_start(SSH_DIGEST_SHA512)) == NULL)\n\t\tfatal(\"%s: ssh_digest_start\", __func__);\n\tif (key == NULL) { /* finalize */\n\t\t/* add server config in case we are using agent for host keys */\n\t\tif (ssh_digest_update(ctx, sshbuf_ptr(server_cfg),\n\t\t    sshbuf_len(server_cfg)) != 0)\n\t\t\tfatal(\"%s: ssh_digest_update\", __func__);\n\t\tlen = ssh_digest_bytes(SSH_DIGEST_SHA512);\n\t\thash = xmalloc(len);\n\t\tif (ssh_digest_final(ctx, hash, len) != 0)\n\t\t\tfatal(\"%s: ssh_digest_final\", __func__);\n\t\toptions.timing_secret = PEEK_U64(hash);\n\t\tfreezero(hash, len);\n\t\tssh_digest_free(ctx);\n\t\tctx = NULL;\n\t\treturn;\n\t}\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s could not allocate buffer\", __func__);\n\tif ((r = sshkey_private_serialize(key, buf)) != 0)\n\t\tfatal(\"sshkey_private_serialize: %s\", ssh_err(r));\n\tif (ssh_digest_update(ctx, sshbuf_ptr(buf), sshbuf_len(buf)) != 0)\n\t\tfatal(\"%s: ssh_digest_update\", __func__);\n\tsshbuf_reset(buf);\n\tsshbuf_free(buf);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "buf"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "buf"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: ssh_digest_update\"",
            "__func__"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_digest_update",
          "args": [
            "ctx",
            "sshbuf_ptr(buf)",
            "sshbuf_len(buf)"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "187-196",
          "snippet": "int\nssh_digest_update(struct ssh_digest_ctx *ctx, const void *m, size_t mlen)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(ctx->alg);\n\n\tif (digest == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tdigest->md_update(ctx->mdctx, m, mlen);\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_digest_update(struct ssh_digest_ctx *ctx, const void *m, size_t mlen)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(ctx->alg);\n\n\tif (digest == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tdigest->md_update(ctx->mdctx, m, mlen);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "buf"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "buf"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_private_serialize",
          "args": [
            "key",
            "buf"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_private_serialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2908-2913",
          "snippet": "int\nsshkey_private_serialize(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_private_serialize_opt(key, b,\n\t    SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_private_serialize(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_private_serialize_opt(key, b,\n\t    SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_digest_free",
          "args": [
            "ctx"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "219-233",
          "snippet": "void\nssh_digest_free(struct ssh_digest_ctx *ctx)\n{\n\tconst struct ssh_digest *digest;\n\n\tif (ctx != NULL) {\n\t\tdigest = ssh_digest_by_alg(ctx->alg);\n\t\tif (digest) {\n\t\t\texplicit_bzero(ctx->mdctx, digest->ctx_len);\n\t\t\tfree(ctx->mdctx);\n\t\t\texplicit_bzero(ctx, sizeof(*ctx));\n\t\t\tfree(ctx);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_digest_free(struct ssh_digest_ctx *ctx)\n{\n\tconst struct ssh_digest *digest;\n\n\tif (ctx != NULL) {\n\t\tdigest = ssh_digest_by_alg(ctx->alg);\n\t\tif (digest) {\n\t\t\texplicit_bzero(ctx->mdctx, digest->ctx_len);\n\t\t\tfree(ctx->mdctx);\n\t\t\texplicit_bzero(ctx, sizeof(*ctx));\n\t\t\tfree(ctx);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezero",
          "args": [
            "hash",
            "len"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "freezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/freezero.c",
          "lines": "24-31",
          "snippet": "void\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PEEK_U64",
          "args": [
            "hash"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_digest_final",
          "args": [
            "ctx",
            "hash",
            "len"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "204-217",
          "snippet": "int\nssh_digest_final(struct ssh_digest_ctx *ctx, u_char *d, size_t dlen)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(ctx->alg);\n\n\tif (digest == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (dlen > UINT_MAX)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (dlen < digest->digest_len) /* No truncation allowed */\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tdigest->md_final(d, ctx->mdctx);\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_digest_final(struct ssh_digest_ctx *ctx, u_char *d, size_t dlen)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(ctx->alg);\n\n\tif (digest == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (dlen > UINT_MAX)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (dlen < digest->digest_len) /* No truncation allowed */\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tdigest->md_final(d, ctx->mdctx);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "len"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_digest_bytes",
          "args": [
            "SSH_DIGEST_SHA512"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "143-149",
          "snippet": "size_t\nssh_digest_bytes(int alg)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(alg);\n\n\treturn digest == NULL ? 0 : digest->digest_len;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nssh_digest_bytes(int alg)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(alg);\n\n\treturn digest == NULL ? 0 : digest->digest_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_digest_start",
          "args": [
            "SSH_DIGEST_SHA512"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "159-174",
          "snippet": "struct ssh_digest_ctx *\nssh_digest_start(int alg)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(alg);\n\tstruct ssh_digest_ctx *ret;\n\n\tif (digest == NULL || (ret = calloc(1, sizeof(*ret))) == NULL)\n\t\treturn NULL;\n\tif ((ret->mdctx = calloc(1, digest->ctx_len)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tret->alg = alg;\n\tdigest->md_init(ret->mdctx);\n\treturn ret;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct ssh_digest_ctx *\nssh_digest_start(int alg)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(alg);\n\tstruct ssh_digest_ctx *ret;\n\n\tif (digest == NULL || (ret = calloc(1, sizeof(*ret))) == NULL)\n\t\treturn NULL;\n\tif ((ret->mdctx = calloc(1, digest->ctx_len)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tret->alg = alg;\n\tdigest->md_init(ret->mdctx);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\n\nstatic void\naccumulate_host_timing_secret(struct sshbuf *server_cfg,\n    const struct sshkey *key)\n{\n\tstatic struct ssh_digest_ctx *ctx;\n\tu_char *hash;\n\tsize_t len;\n\tstruct sshbuf *buf;\n\tint r;\n\n\tif (ctx == NULL && (ctx = ssh_digest_start(SSH_DIGEST_SHA512)) == NULL)\n\t\tfatal(\"%s: ssh_digest_start\", __func__);\n\tif (key == NULL) { /* finalize */\n\t\t/* add server config in case we are using agent for host keys */\n\t\tif (ssh_digest_update(ctx, sshbuf_ptr(server_cfg),\n\t\t    sshbuf_len(server_cfg)) != 0)\n\t\t\tfatal(\"%s: ssh_digest_update\", __func__);\n\t\tlen = ssh_digest_bytes(SSH_DIGEST_SHA512);\n\t\thash = xmalloc(len);\n\t\tif (ssh_digest_final(ctx, hash, len) != 0)\n\t\t\tfatal(\"%s: ssh_digest_final\", __func__);\n\t\toptions.timing_secret = PEEK_U64(hash);\n\t\tfreezero(hash, len);\n\t\tssh_digest_free(ctx);\n\t\tctx = NULL;\n\t\treturn;\n\t}\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s could not allocate buffer\", __func__);\n\tif ((r = sshkey_private_serialize(key, buf)) != 0)\n\t\tfatal(\"sshkey_private_serialize: %s\", ssh_err(r));\n\tif (ssh_digest_update(ctx, sshbuf_ptr(buf), sshbuf_len(buf)) != 0)\n\t\tfatal(\"%s: ssh_digest_update\", __func__);\n\tsshbuf_reset(buf);\n\tsshbuf_free(buf);\n}"
  },
  {
    "function_name": "set_process_rdomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "1387-1424",
    "snippet": "static void\nset_process_rdomain(struct ssh *ssh, const char *name)\n{\n#if defined(HAVE_SYS_SET_PROCESS_RDOMAIN)\n\tif (name == NULL)\n\t\treturn; /* default */\n\n\tif (strcmp(name, \"%D\") == 0) {\n\t\t/* \"expands\" to routing domain of connection */\n\t\tif ((name = ssh_packet_rdomain_in(ssh)) == NULL)\n\t\t\treturn;\n\t}\n\t/* NB. We don't pass 'ssh' to sys_set_process_rdomain() */\n\treturn sys_set_process_rdomain(name);\n#elif defined(__OpenBSD__)\n\tint rtable, ortable = getrtable();\n\tconst char *errstr;\n\n\tif (name == NULL)\n\t\treturn; /* default */\n\n\tif (strcmp(name, \"%D\") == 0) {\n\t\t/* \"expands\" to routing domain of connection */\n\t\tif ((name = ssh_packet_rdomain_in(ssh)) == NULL)\n\t\t\treturn;\n\t}\n\n\trtable = (int)strtonum(name, 0, 255, &errstr);\n\tif (errstr != NULL) /* Shouldn't happen */\n\t\tfatal(\"Invalid routing domain \\\"%s\\\": %s\", name, errstr);\n\tif (rtable != ortable && setrtable(rtable) != 0)\n\t\tfatal(\"Unable to set routing domain %d: %s\",\n\t\t    rtable, strerror(errno));\n\tdebug(\"%s: set routing domain %d (was %d)\", __func__, rtable, ortable);\n#else /* defined(__OpenBSD__) */\n\tfatal(\"Unable to set routing domain: not supported in this platform\");\n#endif\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Unable to set routing domain: not supported in this platform\""
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: set routing domain %d (was %d)\"",
            "__func__",
            "rtable",
            "ortable"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setrtable",
          "args": [
            "rtable"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtonum",
          "args": [
            "name",
            "0",
            "255",
            "&errstr"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "strtonum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtonum.c",
          "lines": "33-70",
          "snippet": "long long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define TOOLARGE \t3",
            "#define TOOSMALL \t2",
            "#define INVALID \t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\n#define TOOLARGE \t3\n#define TOOSMALL \t2\n#define INVALID \t1\n\nlong long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_rdomain_in",
          "args": [
            "ssh"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_rdomain_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "568-577",
          "snippet": "const char *\nssh_packet_rdomain_in(struct ssh *ssh)\n{\n\tif (ssh->rdomain_in != NULL)\n\t\treturn ssh->rdomain_in;\n\tif (!ssh_packet_connection_is_on_socket(ssh))\n\t\treturn NULL;\n\tssh->rdomain_in = get_rdomain(ssh->state->connection_in);\n\treturn ssh->rdomain_in;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_packet_rdomain_in(struct ssh *ssh)\n{\n\tif (ssh->rdomain_in != NULL)\n\t\treturn ssh->rdomain_in;\n\tif (!ssh_packet_connection_is_on_socket(ssh))\n\t\treturn NULL;\n\tssh->rdomain_in = get_rdomain(ssh->state->connection_in);\n\treturn ssh->rdomain_in;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"%D\""
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getrtable",
          "args": [],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sys_set_process_rdomain",
          "args": [
            "name"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "sys_set_process_rdomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-net.c",
          "lines": "116-120",
          "snippet": "void\nsys_set_process_rdomain(const char *name)\n{\n\tfatal(\"%s: not supported\", __func__);\n}",
          "includes": [
            "#include <net/if_tun.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <linux/if_tun.h>",
            "#include <linux/if.h>",
            "#include \"ssherr.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/if_tun.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <linux/if_tun.h>\n#include <linux/if.h>\n#include \"ssherr.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsys_set_process_rdomain(const char *name)\n{\n\tfatal(\"%s: not supported\", __func__);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nset_process_rdomain(struct ssh *ssh, const char *name)\n{\n#if defined(HAVE_SYS_SET_PROCESS_RDOMAIN)\n\tif (name == NULL)\n\t\treturn; /* default */\n\n\tif (strcmp(name, \"%D\") == 0) {\n\t\t/* \"expands\" to routing domain of connection */\n\t\tif ((name = ssh_packet_rdomain_in(ssh)) == NULL)\n\t\t\treturn;\n\t}\n\t/* NB. We don't pass 'ssh' to sys_set_process_rdomain() */\n\treturn sys_set_process_rdomain(name);\n#elif defined(__OpenBSD__)\n\tint rtable, ortable = getrtable();\n\tconst char *errstr;\n\n\tif (name == NULL)\n\t\treturn; /* default */\n\n\tif (strcmp(name, \"%D\") == 0) {\n\t\t/* \"expands\" to routing domain of connection */\n\t\tif ((name = ssh_packet_rdomain_in(ssh)) == NULL)\n\t\t\treturn;\n\t}\n\n\trtable = (int)strtonum(name, 0, 255, &errstr);\n\tif (errstr != NULL) /* Shouldn't happen */\n\t\tfatal(\"Invalid routing domain \\\"%s\\\": %s\", name, errstr);\n\tif (rtable != ortable && setrtable(rtable) != 0)\n\t\tfatal(\"Unable to set routing domain %d: %s\",\n\t\t    rtable, strerror(errno));\n\tdebug(\"%s: set routing domain %d (was %d)\", __func__, rtable, ortable);\n#else /* defined(__OpenBSD__) */\n\tfatal(\"Unable to set routing domain: not supported in this platform\");\n#endif\n}"
  },
  {
    "function_name": "check_ip_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "1355-1384",
    "snippet": "static void\ncheck_ip_options(struct ssh *ssh)\n{\n#ifdef IP_OPTIONS\n\tint sock_in = ssh_packet_get_connection_in(ssh);\n\tstruct sockaddr_storage from;\n\tu_char opts[200];\n\tsocklen_t i, option_size = sizeof(opts), fromlen = sizeof(from);\n\tchar text[sizeof(opts) * 3 + 1];\n\n\tmemset(&from, 0, sizeof(from));\n\tif (getpeername(sock_in, (struct sockaddr *)&from,\n\t    &fromlen) < 0)\n\t\treturn;\n\tif (from.ss_family != AF_INET)\n\t\treturn;\n\t/* XXX IPv6 options? */\n\n\tif (getsockopt(sock_in, IPPROTO_IP, IP_OPTIONS, opts,\n\t    &option_size) >= 0 && option_size != 0) {\n\t\ttext[0] = '\\0';\n\t\tfor (i = 0; i < option_size; i++)\n\t\t\tsnprintf(text + i*3, sizeof(text) - i*3,\n\t\t\t    \" %2.2x\", opts[i]);\n\t\tfatal(\"Connection from %.100s port %d with IP opts: %.800s\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh), text);\n\t}\n\treturn;\n#endif /* IP_OPTIONS */\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Connection from %.100s port %d with IP opts: %.800s\"",
            "ssh_remote_ipaddr(ssh)",
            "ssh_remote_port(ssh)",
            "text"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_port",
          "args": [
            "ssh"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "539-544",
          "snippet": "int\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "text + i*3",
            "sizeof(text) - i*3",
            "\" %2.2x\"",
            "opts[i]"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsockopt",
          "args": [
            "sock_in",
            "IPPROTO_IP",
            "IP_OPTIONS",
            "opts",
            "&option_size"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpeername",
          "args": [
            "sock_in",
            "(struct sockaddr *)&from",
            "&fromlen"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&from",
            "0",
            "sizeof(from)"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_packet_get_connection_in",
          "args": [
            "ssh"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_get_connection_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "495-499",
          "snippet": "int\nssh_packet_get_connection_in(struct ssh *ssh)\n{\n\treturn ssh->state->connection_in;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_get_connection_in(struct ssh *ssh)\n{\n\treturn ssh->state->connection_in;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\n\nstatic void\ncheck_ip_options(struct ssh *ssh)\n{\n#ifdef IP_OPTIONS\n\tint sock_in = ssh_packet_get_connection_in(ssh);\n\tstruct sockaddr_storage from;\n\tu_char opts[200];\n\tsocklen_t i, option_size = sizeof(opts), fromlen = sizeof(from);\n\tchar text[sizeof(opts) * 3 + 1];\n\n\tmemset(&from, 0, sizeof(from));\n\tif (getpeername(sock_in, (struct sockaddr *)&from,\n\t    &fromlen) < 0)\n\t\treturn;\n\tif (from.ss_family != AF_INET)\n\t\treturn;\n\t/* XXX IPv6 options? */\n\n\tif (getsockopt(sock_in, IPPROTO_IP, IP_OPTIONS, opts,\n\t    &option_size) >= 0 && option_size != 0) {\n\t\ttext[0] = '\\0';\n\t\tfor (i = 0; i < option_size; i++)\n\t\t\tsnprintf(text + i*3, sizeof(text) - i*3,\n\t\t\t    \" %2.2x\", opts[i]);\n\t\tfatal(\"Connection from %.100s port %d with IP opts: %.800s\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh), text);\n\t}\n\treturn;\n#endif /* IP_OPTIONS */\n}"
  },
  {
    "function_name": "server_accept_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "1129-1342",
    "snippet": "static void\nserver_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)\n{\n\tfd_set *fdset;\n\tint i, j, ret, maxfd;\n\tint startups = 0;\n\tint startup_p[2] = { -1 , -1 };\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen;\n\tpid_t pid;\n\tu_char rnd[256];\n\n\t/* setup fd set for accept */\n\tfdset = NULL;\n\tmaxfd = 0;\n\tfor (i = 0; i < num_listen_socks; i++)\n\t\tif (listen_socks[i] > maxfd)\n\t\t\tmaxfd = listen_socks[i];\n\t/* pipes connected to unauthenticated childs */\n\tstartup_pipes = xcalloc(options.max_startups, sizeof(int));\n\tfor (i = 0; i < options.max_startups; i++)\n\t\tstartup_pipes[i] = -1;\n\n\t/*\n\t * Stay listening for connections until the system crashes or\n\t * the daemon is killed with a signal.\n\t */\n\tfor (;;) {\n\t\tif (received_sighup)\n\t\t\tsighup_restart();\n\t\tfree(fdset);\n\t\tfdset = xcalloc(howmany(maxfd + 1, NFDBITS),\n\t\t    sizeof(fd_mask));\n\n\t\tfor (i = 0; i < num_listen_socks; i++)\n\t\t\tFD_SET(listen_socks[i], fdset);\n\t\tfor (i = 0; i < options.max_startups; i++)\n\t\t\tif (startup_pipes[i] != -1)\n\t\t\t\tFD_SET(startup_pipes[i], fdset);\n\n\t\t/* Wait in select until there is a connection. */\n\t\tret = select(maxfd+1, fdset, NULL, NULL, NULL);\n\t\tif (ret < 0 && errno != EINTR)\n\t\t\terror(\"select: %.100s\", strerror(errno));\n\t\tif (received_sigterm) {\n\t\t\tlogit(\"Received signal %d; terminating.\",\n\t\t\t    (int) received_sigterm);\n\t\t\tclose_listen_socks();\n\t\t\tif (options.pid_file != NULL)\n\t\t\t\tunlink(options.pid_file);\n\t\t\texit(received_sigterm == SIGTERM ? 0 : 255);\n\t\t}\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < options.max_startups; i++)\n\t\t\tif (startup_pipes[i] != -1 &&\n\t\t\t    FD_ISSET(startup_pipes[i], fdset)) {\n\t\t\t\t/*\n\t\t\t\t * the read end of the pipe is ready\n\t\t\t\t * if the child has closed the pipe\n\t\t\t\t * after successful authentication\n\t\t\t\t * or if the child has died\n\t\t\t\t */\n\t\t\t\tclose(startup_pipes[i]);\n\t\t\t\tstartup_pipes[i] = -1;\n\t\t\t\tstartups--;\n\t\t\t}\n\t\tfor (i = 0; i < num_listen_socks; i++) {\n\t\t\tif (!FD_ISSET(listen_socks[i], fdset))\n\t\t\t\tcontinue;\n\t\t\tfromlen = sizeof(from);\n\t\t\t*newsock = accept(listen_socks[i],\n\t\t\t    (struct sockaddr *)&from, &fromlen);\n\t\t\tif (*newsock < 0) {\n\t\t\t\tif (errno != EINTR && errno != EWOULDBLOCK &&\n\t\t\t\t    errno != ECONNABORTED && errno != EAGAIN)\n\t\t\t\t\terror(\"accept: %.100s\",\n\t\t\t\t\t    strerror(errno));\n\t\t\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (unset_nonblock(*newsock) == -1) {\n\t\t\t\tclose(*newsock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (drop_connection(startups) == 1) {\n\t\t\t\tchar *laddr = get_local_ipaddr(*newsock);\n\t\t\t\tchar *raddr = get_peer_ipaddr(*newsock);\n\n\t\t\t\tverbose(\"drop connection #%d from [%s]:%d \"\n\t\t\t\t    \"on [%s]:%d past MaxStartups\", startups,\n\t\t\t\t    raddr, get_peer_port(*newsock),\n\t\t\t\t    laddr, get_local_port(*newsock));\n\t\t\t\tfree(laddr);\n\t\t\t\tfree(raddr);\n\t\t\t\tclose(*newsock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pipe(startup_p) == -1) {\n\t\t\t\tclose(*newsock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rexec_flag && socketpair(AF_UNIX,\n\t\t\t    SOCK_STREAM, 0, config_s) == -1) {\n\t\t\t\terror(\"reexec socketpair: %s\",\n\t\t\t\t    strerror(errno));\n\t\t\t\tclose(*newsock);\n\t\t\t\tclose(startup_p[0]);\n\t\t\t\tclose(startup_p[1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < options.max_startups; j++)\n\t\t\t\tif (startup_pipes[j] == -1) {\n\t\t\t\t\tstartup_pipes[j] = startup_p[0];\n\t\t\t\t\tif (maxfd < startup_p[0])\n\t\t\t\t\t\tmaxfd = startup_p[0];\n\t\t\t\t\tstartups++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/*\n\t\t\t * Got connection.  Fork a child to handle it, unless\n\t\t\t * we are in debugging mode.\n\t\t\t */\n\t\t\tif (debug_flag) {\n\t\t\t\t/*\n\t\t\t\t * In debugging mode.  Close the listening\n\t\t\t\t * socket, and start processing the\n\t\t\t\t * connection without forking.\n\t\t\t\t */\n\t\t\t\tdebug(\"Server will not fork when running in debugging mode.\");\n\t\t\t\tclose_listen_socks();\n\t\t\t\t*sock_in = *newsock;\n\t\t\t\t*sock_out = *newsock;\n\t\t\t\tclose(startup_p[0]);\n\t\t\t\tclose(startup_p[1]);\n\t\t\t\tstartup_pipe = -1;\n\t\t\t\tpid = getpid();\n\t\t\t\tif (rexec_flag) {\n\t\t\t\t\tsend_rexec_state(config_s[0], cfg);\n\t\t\t\t\tclose(config_s[0]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Normal production daemon.  Fork, and have\n\t\t\t * the child process the connection. The\n\t\t\t * parent continues listening.\n\t\t\t */\n\t\t\tplatform_pre_fork();\n\t\t\tif ((pid = fork()) == 0) {\n\t\t\t\t/*\n\t\t\t\t * Child.  Close the listening and\n\t\t\t\t * max_startup sockets.  Start using\n\t\t\t\t * the accepted socket. Reinitialize\n\t\t\t\t * logging (since our pid has changed).\n\t\t\t\t * We break out of the loop to handle\n\t\t\t\t * the connection.\n\t\t\t\t */\n\t\t\t\tplatform_post_fork_child();\n\t\t\t\tstartup_pipe = startup_p[1];\n\t\t\t\tclose_startup_pipes();\n\t\t\t\tclose_listen_socks();\n\t\t\t\t*sock_in = *newsock;\n\t\t\t\t*sock_out = *newsock;\n\t\t\t\tlog_init(__progname,\n\t\t\t\t    options.log_level,\n\t\t\t\t    options.log_facility,\n\t\t\t\t    log_stderr);\n\t\t\t\tif (rexec_flag)\n\t\t\t\t\tclose(config_s[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Parent.  Stay in the loop. */\n\t\t\tplatform_post_fork_parent(pid);\n\t\t\tif (pid < 0)\n\t\t\t\terror(\"fork: %.100s\", strerror(errno));\n\t\t\telse\n\t\t\t\tdebug(\"Forked child %ld.\", (long)pid);\n\n\t\t\tclose(startup_p[1]);\n\n\t\t\tif (rexec_flag) {\n\t\t\t\tsend_rexec_state(config_s[0], cfg);\n\t\t\t\tclose(config_s[0]);\n\t\t\t\tclose(config_s[1]);\n\t\t\t}\n\t\t\tclose(*newsock);\n\n\t\t\t/*\n\t\t\t * Ensure that our random state differs\n\t\t\t * from that of the child\n\t\t\t */\n\t\t\tarc4random_stir();\n\t\t\tarc4random_buf(rnd, sizeof(rnd));\n#ifdef WITH_OPENSSL\n\t\t\tRAND_seed(rnd, sizeof(rnd));\n\t\t\tif ((RAND_bytes((u_char *)rnd, 1)) != 1)\n\t\t\t\tfatal(\"%s: RAND_bytes failed\", __func__);\n#endif\n\t\t\texplicit_bzero(rnd, sizeof(rnd));\n\t\t}\n\n\t\t/* child process check (or debug mode) */\n\t\tif (num_listen_socks < 0)\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *__progname;",
      "ServerOptions options;",
      "int debug_flag = 0;",
      "int log_stderr = 0;",
      "int rexec_flag = 1;",
      "int listen_socks[MAX_LISTEN_SOCKS];",
      "int num_listen_socks = 0;",
      "static volatile sig_atomic_t received_sighup = 0;",
      "static volatile sig_atomic_t received_sigterm = 0;",
      "int *startup_pipes = NULL;",
      "int startup_pipe;",
      "struct sshbuf *cfg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "rnd",
            "sizeof(rnd)"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: RAND_bytes failed\"",
            "__func__"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAND_bytes",
          "args": [
            "(u_char *)rnd",
            "1"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_seed",
          "args": [
            "rnd",
            "sizeof(rnd)"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arc4random_buf",
          "args": [
            "rnd",
            "sizeof(rnd)"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "263-277",
          "snippet": "void\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "arc4random_stir",
          "args": [],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random_stir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "210-216",
          "snippet": "void\narc4random_stir(void)\n{\n\t_ARC4_LOCK();\n\t_rs_stir();\n\t_ARC4_UNLOCK();\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\narc4random_stir(void)\n{\n\t_ARC4_LOCK();\n\t_rs_stir();\n\t_ARC4_UNLOCK();\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "*newsock"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_rexec_state",
          "args": [
            "config_s[0]",
            "cfg"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "send_rexec_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "933-962",
          "snippet": "static void\nsend_rexec_state(int fd, struct sshbuf *conf)\n{\n\tstruct sshbuf *m;\n\tint r;\n\n\tdebug3(\"%s: entering fd = %d config len %zu\", __func__, fd,\n\t    sshbuf_len(conf));\n\n\t/*\n\t * Protocol from reexec master to child:\n\t *\tstring\tconfiguration\n\t *\tstring rngseed\t\t(only if OpenSSL is not self-seeded)\n\t */\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_stringb(m, conf)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n#if defined(WITH_OPENSSL) && !defined(OPENSSL_PRNG_ONLY)\n\trexec_send_rng_seed(m);\n#endif\n\n\tif (ssh_msg_send(fd, 0, m) == -1)\n\t\tfatal(\"%s: ssh_msg_send failed\", __func__);\n\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done\", __func__);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_rexec_state(int fd, struct sshbuf *conf)\n{\n\tstruct sshbuf *m;\n\tint r;\n\n\tdebug3(\"%s: entering fd = %d config len %zu\", __func__, fd,\n\t    sshbuf_len(conf));\n\n\t/*\n\t * Protocol from reexec master to child:\n\t *\tstring\tconfiguration\n\t *\tstring rngseed\t\t(only if OpenSSL is not self-seeded)\n\t */\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_stringb(m, conf)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n#if defined(WITH_OPENSSL) && !defined(OPENSSL_PRNG_ONLY)\n\trexec_send_rng_seed(m);\n#endif\n\n\tif (ssh_msg_send(fd, 0, m) == -1)\n\t\tfatal(\"%s: ssh_msg_send failed\", __func__);\n\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Forked child %ld.\"",
            "(long)pid"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"fork: %.100s\"",
            "strerror(errno)"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_post_fork_parent",
          "args": [
            "pid"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "61-67",
          "snippet": "void\nplatform_post_fork_parent(pid_t child_pid)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_parent(child_pid);\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_parent(pid_t child_pid)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_parent(child_pid);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_init",
          "args": [
            "__progname",
            "options.log_level",
            "options.log_facility",
            "log_stderr"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "log_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "256-336",
          "snippet": "void\nlog_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)\n{\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\tstruct syslog_data sdata = SYSLOG_DATA_INIT;\n#endif\n\n\targv0 = av0;\n\n\tif (log_change_level(level) != 0) {\n\t\tfprintf(stderr, \"Unrecognized internal syslog level code %d\\n\",\n\t\t    (int) level);\n\t\texit(1);\n\t}\n\n\tlog_handler = NULL;\n\tlog_handler_ctx = NULL;\n\n\tlog_on_stderr = on_stderr;\n\tif (on_stderr)\n\t\treturn;\n\n\tswitch (facility) {\n\tcase SYSLOG_FACILITY_DAEMON:\n\t\tlog_facility = LOG_DAEMON;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_USER:\n\t\tlog_facility = LOG_USER;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_AUTH:\n\t\tlog_facility = LOG_AUTH;\n\t\tbreak;\n#ifdef LOG_AUTHPRIV\n\tcase SYSLOG_FACILITY_AUTHPRIV:\n\t\tlog_facility = LOG_AUTHPRIV;\n\t\tbreak;\n#endif\n\tcase SYSLOG_FACILITY_LOCAL0:\n\t\tlog_facility = LOG_LOCAL0;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL1:\n\t\tlog_facility = LOG_LOCAL1;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL2:\n\t\tlog_facility = LOG_LOCAL2;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL3:\n\t\tlog_facility = LOG_LOCAL3;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL4:\n\t\tlog_facility = LOG_LOCAL4;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL5:\n\t\tlog_facility = LOG_LOCAL5;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL6:\n\t\tlog_facility = LOG_LOCAL6;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL7:\n\t\tlog_facility = LOG_LOCAL7;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t    \"Unrecognized internal syslog facility code %d\\n\",\n\t\t    (int) facility);\n\t\texit(1);\n\t}\n\n\t/*\n\t * If an external library (eg libwrap) attempts to use syslog\n\t * immediately after reexec, syslog may be pointing to the wrong\n\t * facility, so we force an open/close of syslog here.\n\t */\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\topenlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);\n\tcloselog_r(&sdata);\n#else\n\topenlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);\n\tcloselog();\n#endif\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int log_on_stderr = 1;",
            "static int log_facility = LOG_AUTH;",
            "static char *argv0;",
            "static log_handler_fn *log_handler;",
            "static void *log_handler_ctx;",
            "extern char *__progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int log_on_stderr = 1;\nstatic int log_facility = LOG_AUTH;\nstatic char *argv0;\nstatic log_handler_fn *log_handler;\nstatic void *log_handler_ctx;\nextern char *__progname;\n\nvoid\nlog_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)\n{\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\tstruct syslog_data sdata = SYSLOG_DATA_INIT;\n#endif\n\n\targv0 = av0;\n\n\tif (log_change_level(level) != 0) {\n\t\tfprintf(stderr, \"Unrecognized internal syslog level code %d\\n\",\n\t\t    (int) level);\n\t\texit(1);\n\t}\n\n\tlog_handler = NULL;\n\tlog_handler_ctx = NULL;\n\n\tlog_on_stderr = on_stderr;\n\tif (on_stderr)\n\t\treturn;\n\n\tswitch (facility) {\n\tcase SYSLOG_FACILITY_DAEMON:\n\t\tlog_facility = LOG_DAEMON;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_USER:\n\t\tlog_facility = LOG_USER;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_AUTH:\n\t\tlog_facility = LOG_AUTH;\n\t\tbreak;\n#ifdef LOG_AUTHPRIV\n\tcase SYSLOG_FACILITY_AUTHPRIV:\n\t\tlog_facility = LOG_AUTHPRIV;\n\t\tbreak;\n#endif\n\tcase SYSLOG_FACILITY_LOCAL0:\n\t\tlog_facility = LOG_LOCAL0;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL1:\n\t\tlog_facility = LOG_LOCAL1;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL2:\n\t\tlog_facility = LOG_LOCAL2;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL3:\n\t\tlog_facility = LOG_LOCAL3;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL4:\n\t\tlog_facility = LOG_LOCAL4;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL5:\n\t\tlog_facility = LOG_LOCAL5;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL6:\n\t\tlog_facility = LOG_LOCAL6;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL7:\n\t\tlog_facility = LOG_LOCAL7;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t    \"Unrecognized internal syslog facility code %d\\n\",\n\t\t    (int) facility);\n\t\texit(1);\n\t}\n\n\t/*\n\t * If an external library (eg libwrap) attempts to use syslog\n\t * immediately after reexec, syslog may be pointing to the wrong\n\t * facility, so we force an open/close of syslog here.\n\t */\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\topenlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);\n\tcloselog_r(&sdata);\n#else\n\topenlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);\n\tcloselog();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "close_listen_socks",
          "args": [],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "close_listen_socks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "256-264",
          "snippet": "static void\nclose_listen_socks(void)\n{\n\tint i;\n\n\tfor (i = 0; i < num_listen_socks; i++)\n\t\tclose(listen_socks[i]);\n\tnum_listen_socks = -1;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int listen_socks[MAX_LISTEN_SOCKS];",
            "int num_listen_socks = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint listen_socks[MAX_LISTEN_SOCKS];\nint num_listen_socks = 0;\n\nstatic void\nclose_listen_socks(void)\n{\n\tint i;\n\n\tfor (i = 0; i < num_listen_socks; i++)\n\t\tclose(listen_socks[i]);\n\tnum_listen_socks = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close_startup_pipes",
          "args": [],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "close_startup_pipes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "266-275",
          "snippet": "static void\nclose_startup_pipes(void)\n{\n\tint i;\n\n\tif (startup_pipes)\n\t\tfor (i = 0; i < options.max_startups; i++)\n\t\t\tif (startup_pipes[i] != -1)\n\t\t\t\tclose(startup_pipes[i]);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;",
            "int *startup_pipes = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nint *startup_pipes = NULL;\n\nstatic void\nclose_startup_pipes(void)\n{\n\tint i;\n\n\tif (startup_pipes)\n\t\tfor (i = 0; i < options.max_startups; i++)\n\t\t\tif (startup_pipes[i] != -1)\n\t\t\t\tclose(startup_pipes[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_post_fork_child",
          "args": [],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "69-78",
          "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_pre_fork",
          "args": [],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "platform_pre_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "45-51",
          "snippet": "void\nplatform_pre_fork(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_pre_fork();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_pre_fork(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_pre_fork();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0",
            "config_s"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "startup_p"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "raddr"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"drop connection #%d from [%s]:%d \"\n\t\t\t\t    \"on [%s]:%d past MaxStartups\"",
            "startups",
            "raddr",
            "get_peer_port(*newsock)",
            "laddr",
            "get_local_port(*newsock)"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_local_port",
          "args": [
            "*newsock"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "get_local_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "200-204",
          "snippet": "int\nget_local_port(int sock)\n{\n\treturn get_sock_port(sock, 1);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nget_local_port(int sock)\n{\n\treturn get_sock_port(sock, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_peer_port",
          "args": [
            "*newsock"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "get_peer_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "194-198",
          "snippet": "int\nget_peer_port(int sock)\n{\n\treturn get_sock_port(sock, 0);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nget_peer_port(int sock)\n{\n\treturn get_sock_port(sock, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_peer_ipaddr",
          "args": [
            "*newsock"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "get_peer_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "113-121",
          "snippet": "char *\nget_peer_ipaddr(int sock)\n{\n\tchar *p;\n\n\tif ((p = get_socket_address(sock, 1, NI_NUMERICHOST)) != NULL)\n\t\treturn p;\n\treturn xstrdup(\"UNKNOWN\");\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nget_peer_ipaddr(int sock)\n{\n\tchar *p;\n\n\tif ((p = get_socket_address(sock, 1, NI_NUMERICHOST)) != NULL)\n\t\treturn p;\n\treturn xstrdup(\"UNKNOWN\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_local_ipaddr",
          "args": [
            "*newsock"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "get_local_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "123-131",
          "snippet": "char *\nget_local_ipaddr(int sock)\n{\n\tchar *p;\n\n\tif ((p = get_socket_address(sock, 0, NI_NUMERICHOST)) != NULL)\n\t\treturn p;\n\treturn xstrdup(\"UNKNOWN\");\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nget_local_ipaddr(int sock)\n{\n\tchar *p;\n\n\tif ((p = get_socket_address(sock, 0, NI_NUMERICHOST)) != NULL)\n\t\treturn p;\n\treturn xstrdup(\"UNKNOWN\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_connection",
          "args": [
            "startups"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "drop_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "892-912",
          "snippet": "static int\ndrop_connection(int startups)\n{\n\tint p, r;\n\n\tif (startups < options.max_startups_begin)\n\t\treturn 0;\n\tif (startups >= options.max_startups)\n\t\treturn 1;\n\tif (options.max_startups_rate == 100)\n\t\treturn 1;\n\n\tp  = 100 - options.max_startups_rate;\n\tp *= startups - options.max_startups_begin;\n\tp /= options.max_startups - options.max_startups_begin;\n\tp += options.max_startups_rate;\n\tr = arc4random_uniform(100);\n\n\tdebug(\"drop_connection: p %d, r %d\", p, r);\n\treturn (r < p) ? 1 : 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\n\nstatic int\ndrop_connection(int startups)\n{\n\tint p, r;\n\n\tif (startups < options.max_startups_begin)\n\t\treturn 0;\n\tif (startups >= options.max_startups)\n\t\treturn 1;\n\tif (options.max_startups_rate == 100)\n\t\treturn 1;\n\n\tp  = 100 - options.max_startups_rate;\n\tp *= startups - options.max_startups_begin;\n\tp /= options.max_startups - options.max_startups_begin;\n\tp += options.max_startups_rate;\n\tr = arc4random_uniform(100);\n\n\tdebug(\"drop_connection: p %d, r %d\", p, r);\n\treturn (r < p) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unset_nonblock",
          "args": [
            "*newsock"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "unset_nonblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "116-138",
          "snippet": "int\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "100 * 1000"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "usleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "171-178",
          "snippet": "int usleep(unsigned int useconds)\n{\n\tstruct timespec ts;\n\n\tts.tv_sec = useconds / 1000000;\n\tts.tv_nsec = (useconds % 1000000) * 1000;\n\treturn nanosleep(&ts, NULL);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint usleep(unsigned int useconds)\n{\n\tstruct timespec ts;\n\n\tts.tv_sec = useconds / 1000000;\n\tts.tv_nsec = (useconds % 1000000) * 1000;\n\treturn nanosleep(&ts, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "listen_socks[i]",
            "(struct sockaddr *)&from",
            "&fromlen"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "input_userauth_service_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "419-449",
          "snippet": "int\ninput_userauth_service_accept(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r;\n\n\tif (ssh_packet_remaining(ssh) > 0) {\n\t\tchar *reply;\n\n\t\tif ((r = sshpkt_get_cstring(ssh, &reply, NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"service_accept: %s\", reply);\n\t\tfree(reply);\n\t} else {\n\t\tdebug2(\"buggy server: service_accept w/o service\");\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tdebug(\"SSH2_MSG_SERVICE_ACCEPT received\");\n\n\t/* initial userauth request */\n\tuserauth_none(authctxt);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);\n\tr = 0;\n out:\n\treturn r;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\n\nint\ninput_userauth_service_accept(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r;\n\n\tif (ssh_packet_remaining(ssh) > 0) {\n\t\tchar *reply;\n\n\t\tif ((r = sshpkt_get_cstring(ssh, &reply, NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"service_accept: %s\", reply);\n\t\tfree(reply);\n\t} else {\n\t\tdebug2(\"buggy server: service_accept w/o service\");\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tdebug(\"SSH2_MSG_SERVICE_ACCEPT received\");\n\n\t/* initial userauth request */\n\tuserauth_none(authctxt);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);\n\tr = 0;\n out:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "listen_socks[i]",
            "fdset"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_ISSET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "22-24",
          "snippet": "int kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nint kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "received_sigterm == SIGTERM ? 0 : 255"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "2331-2353",
          "snippet": "void\ncleanup_exit(int i)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (the_authctxt) {\n\t\tdo_cleanup(ssh, the_authctxt);\n\t\tif (use_privsep && privsep_is_preauth &&\n\t\t    pmonitor != NULL && pmonitor->m_pid > 1) {\n\t\t\tdebug(\"Killing privsep child %d\", pmonitor->m_pid);\n\t\t\tif (kill(pmonitor->m_pid, SIGKILL) != 0 &&\n\t\t\t    errno != ESRCH)\n\t\t\t\terror(\"%s: kill(%d): %s\", __func__,\n\t\t\t\t    pmonitor->m_pid, strerror(errno));\n\t\t}\n\t}\n#ifdef SSH_AUDIT_EVENTS\n\t/* done after do_cleanup so it can cancel the PAM auth 'thread' */\n\tif (!use_privsep || mm_is_monitor())\n\t\taudit_event(SSH_CONNECTION_ABANDON);\n#endif\n\t_exit(i);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int use_privsep = -1;",
            "struct monitor *pmonitor = NULL;",
            "int privsep_is_preauth = 1;",
            "Authctxt *the_authctxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint use_privsep = -1;\nstruct monitor *pmonitor = NULL;\nint privsep_is_preauth = 1;\nAuthctxt *the_authctxt = NULL;\n\nvoid\ncleanup_exit(int i)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (the_authctxt) {\n\t\tdo_cleanup(ssh, the_authctxt);\n\t\tif (use_privsep && privsep_is_preauth &&\n\t\t    pmonitor != NULL && pmonitor->m_pid > 1) {\n\t\t\tdebug(\"Killing privsep child %d\", pmonitor->m_pid);\n\t\t\tif (kill(pmonitor->m_pid, SIGKILL) != 0 &&\n\t\t\t    errno != ESRCH)\n\t\t\t\terror(\"%s: kill(%d): %s\", __func__,\n\t\t\t\t    pmonitor->m_pid, strerror(errno));\n\t\t}\n\t}\n#ifdef SSH_AUDIT_EVENTS\n\t/* done after do_cleanup so it can cancel the PAM auth 'thread' */\n\tif (!use_privsep || mm_is_monitor())\n\t\taudit_event(SSH_CONNECTION_ABANDON);\n#endif\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "options.pid_file"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Received signal %d; terminating.\"",
            "(int) received_sigterm"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "maxfd+1",
            "fdset",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "110-122",
          "snippet": "static void select(unsigned int p[64],unsigned int q[64],const unsigned int r[64],const unsigned int s[64],unsigned int b)\n{\n  unsigned int j;\n  unsigned int t;\n  unsigned int bminus1;\n\n  bminus1 = b - 1;\n  for (j = 0;j < 64;++j) {\n    t = bminus1 & (r[j] ^ s[j]);\n    p[j] = s[j] ^ t;\n    q[j] = r[j] ^ t;\n  }\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void select(unsigned int p[64],unsigned int q[64],const unsigned int r[64],const unsigned int s[64],unsigned int b)\n{\n  unsigned int j;\n  unsigned int t;\n  unsigned int bminus1;\n\n  bminus1 = b - 1;\n  for (j = 0;j < 64;++j) {\n    t = bminus1 & (r[j] ^ s[j]);\n    p[j] = s[j] ^ t;\n    q[j] = r[j] ^ t;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "startup_pipes[i]",
            "fdset"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_SET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "19-21",
          "snippet": "void kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nvoid kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "howmany(maxfd + 1, NFDBITS)",
            "sizeof(fd_mask)"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "howmany",
          "args": [
            "maxfd + 1",
            "NFDBITS"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sighup_restart",
          "args": [],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "sighup_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "297-312",
          "snippet": "static void\nsighup_restart(void)\n{\n\tlogit(\"Received SIGHUP; restarting.\");\n\tif (options.pid_file != NULL)\n\t\tunlink(options.pid_file);\n\tplatform_pre_restart();\n\tclose_listen_socks();\n\tclose_startup_pipes();\n\talarm(0);  /* alarm timer persists across exec */\n\tsignal(SIGHUP, SIG_IGN); /* will be restored after exec */\n\texecv(saved_argv[0], saved_argv);\n\tlogit(\"RESTART FAILED: av[0]='%.100s', error: %.100s.\", saved_argv[0],\n\t    strerror(errno));\n\texit(1);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;",
            "char **saved_argv;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nchar **saved_argv;\n\nstatic void\nsighup_restart(void)\n{\n\tlogit(\"Received SIGHUP; restarting.\");\n\tif (options.pid_file != NULL)\n\t\tunlink(options.pid_file);\n\tplatform_pre_restart();\n\tclose_listen_socks();\n\tclose_startup_pipes();\n\talarm(0);  /* alarm timer persists across exec */\n\tsignal(SIGHUP, SIG_IGN); /* will be restored after exec */\n\texecv(saved_argv[0], saved_argv);\n\tlogit(\"RESTART FAILED: av[0]='%.100s', error: %.100s.\", saved_argv[0],\n\t    strerror(errno));\n\texit(1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern char *__progname;\nServerOptions options;\nint debug_flag = 0;\nint log_stderr = 0;\nint rexec_flag = 1;\nint listen_socks[MAX_LISTEN_SOCKS];\nint num_listen_socks = 0;\nstatic volatile sig_atomic_t received_sighup = 0;\nstatic volatile sig_atomic_t received_sigterm = 0;\nint *startup_pipes = NULL;\nint startup_pipe;\nstruct sshbuf *cfg;\n\nstatic void\nserver_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)\n{\n\tfd_set *fdset;\n\tint i, j, ret, maxfd;\n\tint startups = 0;\n\tint startup_p[2] = { -1 , -1 };\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen;\n\tpid_t pid;\n\tu_char rnd[256];\n\n\t/* setup fd set for accept */\n\tfdset = NULL;\n\tmaxfd = 0;\n\tfor (i = 0; i < num_listen_socks; i++)\n\t\tif (listen_socks[i] > maxfd)\n\t\t\tmaxfd = listen_socks[i];\n\t/* pipes connected to unauthenticated childs */\n\tstartup_pipes = xcalloc(options.max_startups, sizeof(int));\n\tfor (i = 0; i < options.max_startups; i++)\n\t\tstartup_pipes[i] = -1;\n\n\t/*\n\t * Stay listening for connections until the system crashes or\n\t * the daemon is killed with a signal.\n\t */\n\tfor (;;) {\n\t\tif (received_sighup)\n\t\t\tsighup_restart();\n\t\tfree(fdset);\n\t\tfdset = xcalloc(howmany(maxfd + 1, NFDBITS),\n\t\t    sizeof(fd_mask));\n\n\t\tfor (i = 0; i < num_listen_socks; i++)\n\t\t\tFD_SET(listen_socks[i], fdset);\n\t\tfor (i = 0; i < options.max_startups; i++)\n\t\t\tif (startup_pipes[i] != -1)\n\t\t\t\tFD_SET(startup_pipes[i], fdset);\n\n\t\t/* Wait in select until there is a connection. */\n\t\tret = select(maxfd+1, fdset, NULL, NULL, NULL);\n\t\tif (ret < 0 && errno != EINTR)\n\t\t\terror(\"select: %.100s\", strerror(errno));\n\t\tif (received_sigterm) {\n\t\t\tlogit(\"Received signal %d; terminating.\",\n\t\t\t    (int) received_sigterm);\n\t\t\tclose_listen_socks();\n\t\t\tif (options.pid_file != NULL)\n\t\t\t\tunlink(options.pid_file);\n\t\t\texit(received_sigterm == SIGTERM ? 0 : 255);\n\t\t}\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < options.max_startups; i++)\n\t\t\tif (startup_pipes[i] != -1 &&\n\t\t\t    FD_ISSET(startup_pipes[i], fdset)) {\n\t\t\t\t/*\n\t\t\t\t * the read end of the pipe is ready\n\t\t\t\t * if the child has closed the pipe\n\t\t\t\t * after successful authentication\n\t\t\t\t * or if the child has died\n\t\t\t\t */\n\t\t\t\tclose(startup_pipes[i]);\n\t\t\t\tstartup_pipes[i] = -1;\n\t\t\t\tstartups--;\n\t\t\t}\n\t\tfor (i = 0; i < num_listen_socks; i++) {\n\t\t\tif (!FD_ISSET(listen_socks[i], fdset))\n\t\t\t\tcontinue;\n\t\t\tfromlen = sizeof(from);\n\t\t\t*newsock = accept(listen_socks[i],\n\t\t\t    (struct sockaddr *)&from, &fromlen);\n\t\t\tif (*newsock < 0) {\n\t\t\t\tif (errno != EINTR && errno != EWOULDBLOCK &&\n\t\t\t\t    errno != ECONNABORTED && errno != EAGAIN)\n\t\t\t\t\terror(\"accept: %.100s\",\n\t\t\t\t\t    strerror(errno));\n\t\t\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (unset_nonblock(*newsock) == -1) {\n\t\t\t\tclose(*newsock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (drop_connection(startups) == 1) {\n\t\t\t\tchar *laddr = get_local_ipaddr(*newsock);\n\t\t\t\tchar *raddr = get_peer_ipaddr(*newsock);\n\n\t\t\t\tverbose(\"drop connection #%d from [%s]:%d \"\n\t\t\t\t    \"on [%s]:%d past MaxStartups\", startups,\n\t\t\t\t    raddr, get_peer_port(*newsock),\n\t\t\t\t    laddr, get_local_port(*newsock));\n\t\t\t\tfree(laddr);\n\t\t\t\tfree(raddr);\n\t\t\t\tclose(*newsock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pipe(startup_p) == -1) {\n\t\t\t\tclose(*newsock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rexec_flag && socketpair(AF_UNIX,\n\t\t\t    SOCK_STREAM, 0, config_s) == -1) {\n\t\t\t\terror(\"reexec socketpair: %s\",\n\t\t\t\t    strerror(errno));\n\t\t\t\tclose(*newsock);\n\t\t\t\tclose(startup_p[0]);\n\t\t\t\tclose(startup_p[1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < options.max_startups; j++)\n\t\t\t\tif (startup_pipes[j] == -1) {\n\t\t\t\t\tstartup_pipes[j] = startup_p[0];\n\t\t\t\t\tif (maxfd < startup_p[0])\n\t\t\t\t\t\tmaxfd = startup_p[0];\n\t\t\t\t\tstartups++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/*\n\t\t\t * Got connection.  Fork a child to handle it, unless\n\t\t\t * we are in debugging mode.\n\t\t\t */\n\t\t\tif (debug_flag) {\n\t\t\t\t/*\n\t\t\t\t * In debugging mode.  Close the listening\n\t\t\t\t * socket, and start processing the\n\t\t\t\t * connection without forking.\n\t\t\t\t */\n\t\t\t\tdebug(\"Server will not fork when running in debugging mode.\");\n\t\t\t\tclose_listen_socks();\n\t\t\t\t*sock_in = *newsock;\n\t\t\t\t*sock_out = *newsock;\n\t\t\t\tclose(startup_p[0]);\n\t\t\t\tclose(startup_p[1]);\n\t\t\t\tstartup_pipe = -1;\n\t\t\t\tpid = getpid();\n\t\t\t\tif (rexec_flag) {\n\t\t\t\t\tsend_rexec_state(config_s[0], cfg);\n\t\t\t\t\tclose(config_s[0]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Normal production daemon.  Fork, and have\n\t\t\t * the child process the connection. The\n\t\t\t * parent continues listening.\n\t\t\t */\n\t\t\tplatform_pre_fork();\n\t\t\tif ((pid = fork()) == 0) {\n\t\t\t\t/*\n\t\t\t\t * Child.  Close the listening and\n\t\t\t\t * max_startup sockets.  Start using\n\t\t\t\t * the accepted socket. Reinitialize\n\t\t\t\t * logging (since our pid has changed).\n\t\t\t\t * We break out of the loop to handle\n\t\t\t\t * the connection.\n\t\t\t\t */\n\t\t\t\tplatform_post_fork_child();\n\t\t\t\tstartup_pipe = startup_p[1];\n\t\t\t\tclose_startup_pipes();\n\t\t\t\tclose_listen_socks();\n\t\t\t\t*sock_in = *newsock;\n\t\t\t\t*sock_out = *newsock;\n\t\t\t\tlog_init(__progname,\n\t\t\t\t    options.log_level,\n\t\t\t\t    options.log_facility,\n\t\t\t\t    log_stderr);\n\t\t\t\tif (rexec_flag)\n\t\t\t\t\tclose(config_s[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Parent.  Stay in the loop. */\n\t\t\tplatform_post_fork_parent(pid);\n\t\t\tif (pid < 0)\n\t\t\t\terror(\"fork: %.100s\", strerror(errno));\n\t\t\telse\n\t\t\t\tdebug(\"Forked child %ld.\", (long)pid);\n\n\t\t\tclose(startup_p[1]);\n\n\t\t\tif (rexec_flag) {\n\t\t\t\tsend_rexec_state(config_s[0], cfg);\n\t\t\t\tclose(config_s[0]);\n\t\t\t\tclose(config_s[1]);\n\t\t\t}\n\t\t\tclose(*newsock);\n\n\t\t\t/*\n\t\t\t * Ensure that our random state differs\n\t\t\t * from that of the child\n\t\t\t */\n\t\t\tarc4random_stir();\n\t\t\tarc4random_buf(rnd, sizeof(rnd));\n#ifdef WITH_OPENSSL\n\t\t\tRAND_seed(rnd, sizeof(rnd));\n\t\t\tif ((RAND_bytes((u_char *)rnd, 1)) != 1)\n\t\t\t\tfatal(\"%s: RAND_bytes failed\", __func__);\n#endif\n\t\t\texplicit_bzero(rnd, sizeof(rnd));\n\t\t}\n\n\t\t/* child process check (or debug mode) */\n\t\tif (num_listen_socks < 0)\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "server_listen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "1105-1123",
    "snippet": "static void\nserver_listen(void)\n{\n\tu_int i;\n\n\tfor (i = 0; i < options.num_listen_addrs; i++) {\n\t\tlisten_on_addrs(&options.listen_addrs[i]);\n\t\tfreeaddrinfo(options.listen_addrs[i].addrs);\n\t\tfree(options.listen_addrs[i].rdomain);\n\t\tmemset(&options.listen_addrs[i], 0,\n\t\t    sizeof(options.listen_addrs[i]));\n\t}\n\tfree(options.listen_addrs);\n\toptions.listen_addrs = NULL;\n\toptions.num_listen_addrs = 0;\n\n\tif (!num_listen_socks)\n\t\tfatal(\"Cannot bind any address.\");\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ServerOptions options;",
      "int num_listen_socks = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Cannot bind any address.\""
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "options.listen_addrs"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&options.listen_addrs[i]",
            "0",
            "sizeof(options.listen_addrs[i])"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "options.listen_addrs[i].addrs"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "listen_on_addrs",
          "args": [
            "&options.listen_addrs[i]"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "listen_on_addrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "1033-1103",
          "snippet": "static void\nlisten_on_addrs(struct listenaddr *la)\n{\n\tint ret, listen_sock;\n\tstruct addrinfo *ai;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\n\tfor (ai = la->addrs; ai; ai = ai->ai_next) {\n\t\tif (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)\n\t\t\tcontinue;\n\t\tif (num_listen_socks >= MAX_LISTEN_SOCKS)\n\t\t\tfatal(\"Too many listen sockets. \"\n\t\t\t    \"Enlarge MAX_LISTEN_SOCKS\");\n\t\tif ((ret = getnameinfo(ai->ai_addr, ai->ai_addrlen,\n\t\t    ntop, sizeof(ntop), strport, sizeof(strport),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {\n\t\t\terror(\"getnameinfo failed: %.100s\",\n\t\t\t    ssh_gai_strerror(ret));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Create socket for listening. */\n\t\tlisten_sock = socket(ai->ai_family, ai->ai_socktype,\n\t\t    ai->ai_protocol);\n\t\tif (listen_sock < 0) {\n\t\t\t/* kernel may not support ipv6 */\n\t\t\tverbose(\"socket: %.100s\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\tif (set_nonblock(listen_sock) == -1) {\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (fcntl(listen_sock, F_SETFD, FD_CLOEXEC) == -1) {\n\t\t\tverbose(\"socket: CLOEXEC: %s\", strerror(errno));\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Socket options */\n\t\tset_reuseaddr(listen_sock);\n\t\tif (la->rdomain != NULL &&\n\t\t    set_rdomain(listen_sock, la->rdomain) == -1) {\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Only communicate in IPv6 over AF_INET6 sockets. */\n\t\tif (ai->ai_family == AF_INET6)\n\t\t\tsock_set_v6only(listen_sock);\n\n\t\tdebug(\"Bind to port %s on %s.\", strport, ntop);\n\n\t\t/* Bind the socket to the desired port. */\n\t\tif (bind(listen_sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\terror(\"Bind to port %s on %s failed: %.200s.\",\n\t\t\t    strport, ntop, strerror(errno));\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\t\tlisten_socks[num_listen_socks] = listen_sock;\n\t\tnum_listen_socks++;\n\n\t\t/* Start listening on the port. */\n\t\tif (listen(listen_sock, SSH_LISTEN_BACKLOG) < 0)\n\t\t\tfatal(\"listen on [%s]:%s: %.100s\",\n\t\t\t    ntop, strport, strerror(errno));\n\t\tlogit(\"Server listening on %s port %s%s%s.\",\n\t\t    ntop, strport,\n\t\t    la->rdomain == NULL ? \"\" : \" rdomain \",\n\t\t    la->rdomain == NULL ? \"\" : la->rdomain);\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tMAX_LISTEN_SOCKS\t16"
          ],
          "globals_used": [
            "ServerOptions options;",
            "int listen_socks[MAX_LISTEN_SOCKS];",
            "int num_listen_socks = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tMAX_LISTEN_SOCKS\t16\n\nServerOptions options;\nint listen_socks[MAX_LISTEN_SOCKS];\nint num_listen_socks = 0;\n\nstatic void\nlisten_on_addrs(struct listenaddr *la)\n{\n\tint ret, listen_sock;\n\tstruct addrinfo *ai;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\n\tfor (ai = la->addrs; ai; ai = ai->ai_next) {\n\t\tif (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)\n\t\t\tcontinue;\n\t\tif (num_listen_socks >= MAX_LISTEN_SOCKS)\n\t\t\tfatal(\"Too many listen sockets. \"\n\t\t\t    \"Enlarge MAX_LISTEN_SOCKS\");\n\t\tif ((ret = getnameinfo(ai->ai_addr, ai->ai_addrlen,\n\t\t    ntop, sizeof(ntop), strport, sizeof(strport),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {\n\t\t\terror(\"getnameinfo failed: %.100s\",\n\t\t\t    ssh_gai_strerror(ret));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Create socket for listening. */\n\t\tlisten_sock = socket(ai->ai_family, ai->ai_socktype,\n\t\t    ai->ai_protocol);\n\t\tif (listen_sock < 0) {\n\t\t\t/* kernel may not support ipv6 */\n\t\t\tverbose(\"socket: %.100s\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\tif (set_nonblock(listen_sock) == -1) {\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (fcntl(listen_sock, F_SETFD, FD_CLOEXEC) == -1) {\n\t\t\tverbose(\"socket: CLOEXEC: %s\", strerror(errno));\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Socket options */\n\t\tset_reuseaddr(listen_sock);\n\t\tif (la->rdomain != NULL &&\n\t\t    set_rdomain(listen_sock, la->rdomain) == -1) {\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Only communicate in IPv6 over AF_INET6 sockets. */\n\t\tif (ai->ai_family == AF_INET6)\n\t\t\tsock_set_v6only(listen_sock);\n\n\t\tdebug(\"Bind to port %s on %s.\", strport, ntop);\n\n\t\t/* Bind the socket to the desired port. */\n\t\tif (bind(listen_sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\terror(\"Bind to port %s on %s failed: %.200s.\",\n\t\t\t    strport, ntop, strerror(errno));\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\t\tlisten_socks[num_listen_socks] = listen_sock;\n\t\tnum_listen_socks++;\n\n\t\t/* Start listening on the port. */\n\t\tif (listen(listen_sock, SSH_LISTEN_BACKLOG) < 0)\n\t\t\tfatal(\"listen on [%s]:%s: %.100s\",\n\t\t\t    ntop, strport, strerror(errno));\n\t\tlogit(\"Server listening on %s port %s%s%s.\",\n\t\t    ntop, strport,\n\t\t    la->rdomain == NULL ? \"\" : \" rdomain \",\n\t\t    la->rdomain == NULL ? \"\" : la->rdomain);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nint num_listen_socks = 0;\n\nstatic void\nserver_listen(void)\n{\n\tu_int i;\n\n\tfor (i = 0; i < options.num_listen_addrs; i++) {\n\t\tlisten_on_addrs(&options.listen_addrs[i]);\n\t\tfreeaddrinfo(options.listen_addrs[i].addrs);\n\t\tfree(options.listen_addrs[i].rdomain);\n\t\tmemset(&options.listen_addrs[i], 0,\n\t\t    sizeof(options.listen_addrs[i]));\n\t}\n\tfree(options.listen_addrs);\n\toptions.listen_addrs = NULL;\n\toptions.num_listen_addrs = 0;\n\n\tif (!num_listen_socks)\n\t\tfatal(\"Cannot bind any address.\");\n}"
  },
  {
    "function_name": "listen_on_addrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "1033-1103",
    "snippet": "static void\nlisten_on_addrs(struct listenaddr *la)\n{\n\tint ret, listen_sock;\n\tstruct addrinfo *ai;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\n\tfor (ai = la->addrs; ai; ai = ai->ai_next) {\n\t\tif (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)\n\t\t\tcontinue;\n\t\tif (num_listen_socks >= MAX_LISTEN_SOCKS)\n\t\t\tfatal(\"Too many listen sockets. \"\n\t\t\t    \"Enlarge MAX_LISTEN_SOCKS\");\n\t\tif ((ret = getnameinfo(ai->ai_addr, ai->ai_addrlen,\n\t\t    ntop, sizeof(ntop), strport, sizeof(strport),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {\n\t\t\terror(\"getnameinfo failed: %.100s\",\n\t\t\t    ssh_gai_strerror(ret));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Create socket for listening. */\n\t\tlisten_sock = socket(ai->ai_family, ai->ai_socktype,\n\t\t    ai->ai_protocol);\n\t\tif (listen_sock < 0) {\n\t\t\t/* kernel may not support ipv6 */\n\t\t\tverbose(\"socket: %.100s\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\tif (set_nonblock(listen_sock) == -1) {\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (fcntl(listen_sock, F_SETFD, FD_CLOEXEC) == -1) {\n\t\t\tverbose(\"socket: CLOEXEC: %s\", strerror(errno));\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Socket options */\n\t\tset_reuseaddr(listen_sock);\n\t\tif (la->rdomain != NULL &&\n\t\t    set_rdomain(listen_sock, la->rdomain) == -1) {\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Only communicate in IPv6 over AF_INET6 sockets. */\n\t\tif (ai->ai_family == AF_INET6)\n\t\t\tsock_set_v6only(listen_sock);\n\n\t\tdebug(\"Bind to port %s on %s.\", strport, ntop);\n\n\t\t/* Bind the socket to the desired port. */\n\t\tif (bind(listen_sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\terror(\"Bind to port %s on %s failed: %.200s.\",\n\t\t\t    strport, ntop, strerror(errno));\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\t\tlisten_socks[num_listen_socks] = listen_sock;\n\t\tnum_listen_socks++;\n\n\t\t/* Start listening on the port. */\n\t\tif (listen(listen_sock, SSH_LISTEN_BACKLOG) < 0)\n\t\t\tfatal(\"listen on [%s]:%s: %.100s\",\n\t\t\t    ntop, strport, strerror(errno));\n\t\tlogit(\"Server listening on %s port %s%s%s.\",\n\t\t    ntop, strport,\n\t\t    la->rdomain == NULL ? \"\" : \" rdomain \",\n\t\t    la->rdomain == NULL ? \"\" : la->rdomain);\n\t}\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tMAX_LISTEN_SOCKS\t16"
    ],
    "globals_used": [
      "ServerOptions options;",
      "int listen_socks[MAX_LISTEN_SOCKS];",
      "int num_listen_socks = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Server listening on %s port %s%s%s.\"",
            "ntop",
            "strport",
            "la->rdomain == NULL ? \"\" : \" rdomain \"",
            "la->rdomain == NULL ? \"\" : la->rdomain"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"listen on [%s]:%s: %.100s\"",
            "ntop",
            "strport",
            "strerror(errno)"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "listen_sock",
            "SSH_LISTEN_BACKLOG"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "open_listen_match_streamlocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3931-3943",
          "snippet": "static int\nopen_listen_match_streamlocal(struct permission *allowed_open,\n    const char *requestedpath)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != PORT_STREAMLOCAL)\n\t\treturn 0;\n\tif (allowed_open->listen_path == NULL ||\n\t    strcmp(allowed_open->listen_path, requestedpath) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nopen_listen_match_streamlocal(struct permission *allowed_open,\n    const char *requestedpath)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != PORT_STREAMLOCAL)\n\t\treturn 0;\n\tif (allowed_open->listen_path == NULL ||\n\t    strcmp(allowed_open->listen_path, requestedpath) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "listen_sock"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Bind to port %s on %s failed: %.200s.\"",
            "strport",
            "ntop",
            "strerror(errno)"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "listen_sock",
            "ai->ai_addr",
            "ai->ai_addrlen"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Bind to port %s on %s.\"",
            "strport",
            "ntop"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_set_v6only",
          "args": [
            "listen_sock"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "sock_set_v6only",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1534-1544",
          "snippet": "void\nsock_set_v6only(int s)\n{\n#if defined(IPV6_V6ONLY) && !defined(__OpenBSD__)\n\tint on = 1;\n\n\tdebug3(\"%s: set socket %d IPV6_V6ONLY\", __func__, s);\n\tif (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &on, sizeof(on)) == -1)\n\t\terror(\"setsockopt IPV6_V6ONLY: %s\", strerror(errno));\n#endif\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsock_set_v6only(int s)\n{\n#if defined(IPV6_V6ONLY) && !defined(__OpenBSD__)\n\tint on = 1;\n\n\tdebug3(\"%s: set socket %d IPV6_V6ONLY\", __func__, s);\n\tif (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &on, sizeof(on)) == -1)\n\t\terror(\"setsockopt IPV6_V6ONLY: %s\", strerror(errno));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_rdomain",
          "args": [
            "listen_sock",
            "la->rdomain"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "set_rdomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "206-235",
          "snippet": "int\nset_rdomain(int fd, const char *name)\n{\n#if defined(HAVE_SYS_SET_RDOMAIN)\n\treturn sys_set_rdomain(fd, name);\n#elif defined(__OpenBSD__)\n\tint rtable;\n\tconst char *errstr;\n\n\tif (name == NULL)\n\t\treturn 0; /* default table */\n\n\trtable = (int)strtonum(name, 0, 255, &errstr);\n\tif (errstr != NULL) {\n\t\t/* Shouldn't happen */\n\t\terror(\"Invalid routing domain \\\"%s\\\": %s\", name, errstr);\n\t\treturn -1;\n\t}\n\tif (setsockopt(fd, SOL_SOCKET, SO_RTABLE,\n\t    &rtable, sizeof(rtable)) == -1) {\n\t\terror(\"Failed to set routing domain %d on fd %d: %s\",\n\t\t    rtable, fd, strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n#else /* defined(__OpenBSD__) */\n\terror(\"Setting routing domain is not supported on this platform\");\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nset_rdomain(int fd, const char *name)\n{\n#if defined(HAVE_SYS_SET_RDOMAIN)\n\treturn sys_set_rdomain(fd, name);\n#elif defined(__OpenBSD__)\n\tint rtable;\n\tconst char *errstr;\n\n\tif (name == NULL)\n\t\treturn 0; /* default table */\n\n\trtable = (int)strtonum(name, 0, 255, &errstr);\n\tif (errstr != NULL) {\n\t\t/* Shouldn't happen */\n\t\terror(\"Invalid routing domain \\\"%s\\\": %s\", name, errstr);\n\t\treturn -1;\n\t}\n\tif (setsockopt(fd, SOL_SOCKET, SO_RTABLE,\n\t    &rtable, sizeof(rtable)) == -1) {\n\t\terror(\"Failed to set routing domain %d on fd %d: %s\",\n\t\t    rtable, fd, strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n#else /* defined(__OpenBSD__) */\n\terror(\"Setting routing domain is not supported on this platform\");\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_reuseaddr",
          "args": [
            "listen_sock"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "set_reuseaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "171-181",
          "snippet": "int\nset_reuseaddr(int fd)\n{\n\tint on = 1;\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {\n\t\terror(\"setsockopt SO_REUSEADDR fd %d: %s\", fd, strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nset_reuseaddr(int fd)\n{\n\tint on = 1;\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {\n\t\terror(\"setsockopt SO_REUSEADDR fd %d: %s\", fd, strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"socket: CLOEXEC: %s\"",
            "strerror(errno)"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "listen_sock",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nonblock",
          "args": [
            "listen_sock"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "unset_nonblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "116-138",
          "snippet": "int\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "ai->ai_family",
            "ai->ai_socktype",
            "ai->ai_protocol"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "67-111",
          "snippet": "static char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "ai->ai_addr",
            "ai->ai_addrlen",
            "ntop",
            "sizeof(ntop)",
            "strport",
            "sizeof(strport)",
            "NI_NUMERICHOST|NI_NUMERICSERV"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "sshaix_getnameinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "415-434",
          "snippet": "int\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tMAX_LISTEN_SOCKS\t16\n\nServerOptions options;\nint listen_socks[MAX_LISTEN_SOCKS];\nint num_listen_socks = 0;\n\nstatic void\nlisten_on_addrs(struct listenaddr *la)\n{\n\tint ret, listen_sock;\n\tstruct addrinfo *ai;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\n\tfor (ai = la->addrs; ai; ai = ai->ai_next) {\n\t\tif (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)\n\t\t\tcontinue;\n\t\tif (num_listen_socks >= MAX_LISTEN_SOCKS)\n\t\t\tfatal(\"Too many listen sockets. \"\n\t\t\t    \"Enlarge MAX_LISTEN_SOCKS\");\n\t\tif ((ret = getnameinfo(ai->ai_addr, ai->ai_addrlen,\n\t\t    ntop, sizeof(ntop), strport, sizeof(strport),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {\n\t\t\terror(\"getnameinfo failed: %.100s\",\n\t\t\t    ssh_gai_strerror(ret));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Create socket for listening. */\n\t\tlisten_sock = socket(ai->ai_family, ai->ai_socktype,\n\t\t    ai->ai_protocol);\n\t\tif (listen_sock < 0) {\n\t\t\t/* kernel may not support ipv6 */\n\t\t\tverbose(\"socket: %.100s\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\tif (set_nonblock(listen_sock) == -1) {\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (fcntl(listen_sock, F_SETFD, FD_CLOEXEC) == -1) {\n\t\t\tverbose(\"socket: CLOEXEC: %s\", strerror(errno));\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Socket options */\n\t\tset_reuseaddr(listen_sock);\n\t\tif (la->rdomain != NULL &&\n\t\t    set_rdomain(listen_sock, la->rdomain) == -1) {\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Only communicate in IPv6 over AF_INET6 sockets. */\n\t\tif (ai->ai_family == AF_INET6)\n\t\t\tsock_set_v6only(listen_sock);\n\n\t\tdebug(\"Bind to port %s on %s.\", strport, ntop);\n\n\t\t/* Bind the socket to the desired port. */\n\t\tif (bind(listen_sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\terror(\"Bind to port %s on %s failed: %.200s.\",\n\t\t\t    strport, ntop, strerror(errno));\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\t\tlisten_socks[num_listen_socks] = listen_sock;\n\t\tnum_listen_socks++;\n\n\t\t/* Start listening on the port. */\n\t\tif (listen(listen_sock, SSH_LISTEN_BACKLOG) < 0)\n\t\t\tfatal(\"listen on [%s]:%s: %.100s\",\n\t\t\t    ntop, strport, strerror(errno));\n\t\tlogit(\"Server listening on %s port %s%s%s.\",\n\t\t    ntop, strport,\n\t\t    la->rdomain == NULL ? \"\" : \" rdomain \",\n\t\t    la->rdomain == NULL ? \"\" : la->rdomain);\n\t}\n}"
  },
  {
    "function_name": "server_accept_inetd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "997-1028",
    "snippet": "static void\nserver_accept_inetd(int *sock_in, int *sock_out)\n{\n\tint fd;\n\n\tstartup_pipe = -1;\n\tif (rexeced_flag) {\n\t\tclose(REEXEC_CONFIG_PASS_FD);\n\t\t*sock_in = *sock_out = dup(STDIN_FILENO);\n\t\tif (!debug_flag) {\n\t\t\tstartup_pipe = dup(REEXEC_STARTUP_PIPE_FD);\n\t\t\tclose(REEXEC_STARTUP_PIPE_FD);\n\t\t}\n\t} else {\n\t\t*sock_in = dup(STDIN_FILENO);\n\t\t*sock_out = dup(STDOUT_FILENO);\n\t}\n\t/*\n\t * We intentionally do not close the descriptors 0, 1, and 2\n\t * as our code for setting the descriptors won't work if\n\t * ttyfd happens to be one of those.\n\t */\n\tif ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\tdup2(fd, STDIN_FILENO);\n\t\tdup2(fd, STDOUT_FILENO);\n\t\tif (!log_stderr)\n\t\t\tdup2(fd, STDERR_FILENO);\n\t\tif (fd > (log_stderr ? STDERR_FILENO : STDOUT_FILENO))\n\t\t\tclose(fd);\n\t}\n\tdebug(\"inetd sockets after dupping: %d, %d\", *sock_in, *sock_out);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define REEXEC_CONFIG_PASS_FD\t\t(STDERR_FILENO + 3)",
      "#define REEXEC_STARTUP_PIPE_FD\t\t(STDERR_FILENO + 2)"
    ],
    "globals_used": [
      "int debug_flag = 0;",
      "int log_stderr = 0;",
      "int rexeced_flag = 0;",
      "int startup_pipe;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"inetd sockets after dupping: %d, %d\"",
            "*sock_in",
            "*sock_out"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "STDERR_FILENO"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "STDOUT_FILENO"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "STDIN_FILENO"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_DEVNULL",
            "O_RDWR",
            "0"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "lastlog_openseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/loginrec.c",
          "lines": "1471-1514",
          "snippet": "static int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "# include <util.h>",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"canohost.h\"",
            "#include \"packet.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"loginrec.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int utmp_write_entry(struct logininfo *li);",
            "int utmpx_write_entry(struct logininfo *li);",
            "int wtmp_write_entry(struct logininfo *li);",
            "int wtmpx_write_entry(struct logininfo *li);",
            "int lastlog_write_entry(struct logininfo *li);",
            "int syslogin_write_entry(struct logininfo *li);",
            "int getlast_entry(struct logininfo *li);",
            "int lastlog_get_entry(struct logininfo *li);",
            "int utmpx_get_entry(struct logininfo *li);",
            "int wtmp_get_entry(struct logininfo *li);",
            "int wtmpx_get_entry(struct logininfo *li);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <util.h>\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"canohost.h\"\n#include \"packet.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"loginrec.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint utmp_write_entry(struct logininfo *li);\nint utmpx_write_entry(struct logininfo *li);\nint wtmp_write_entry(struct logininfo *li);\nint wtmpx_write_entry(struct logininfo *li);\nint lastlog_write_entry(struct logininfo *li);\nint syslogin_write_entry(struct logininfo *li);\nint getlast_entry(struct logininfo *li);\nint lastlog_get_entry(struct logininfo *li);\nint utmpx_get_entry(struct logininfo *li);\nint wtmp_get_entry(struct logininfo *li);\nint wtmpx_get_entry(struct logininfo *li);\n\nstatic int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define REEXEC_CONFIG_PASS_FD\t\t(STDERR_FILENO + 3)\n#define REEXEC_STARTUP_PIPE_FD\t\t(STDERR_FILENO + 2)\n\nint debug_flag = 0;\nint log_stderr = 0;\nint rexeced_flag = 0;\nint startup_pipe;\n\nstatic void\nserver_accept_inetd(int *sock_in, int *sock_out)\n{\n\tint fd;\n\n\tstartup_pipe = -1;\n\tif (rexeced_flag) {\n\t\tclose(REEXEC_CONFIG_PASS_FD);\n\t\t*sock_in = *sock_out = dup(STDIN_FILENO);\n\t\tif (!debug_flag) {\n\t\t\tstartup_pipe = dup(REEXEC_STARTUP_PIPE_FD);\n\t\t\tclose(REEXEC_STARTUP_PIPE_FD);\n\t\t}\n\t} else {\n\t\t*sock_in = dup(STDIN_FILENO);\n\t\t*sock_out = dup(STDOUT_FILENO);\n\t}\n\t/*\n\t * We intentionally do not close the descriptors 0, 1, and 2\n\t * as our code for setting the descriptors won't work if\n\t * ttyfd happens to be one of those.\n\t */\n\tif ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\tdup2(fd, STDIN_FILENO);\n\t\tdup2(fd, STDOUT_FILENO);\n\t\tif (!log_stderr)\n\t\t\tdup2(fd, STDERR_FILENO);\n\t\tif (fd > (log_stderr ? STDERR_FILENO : STDOUT_FILENO))\n\t\t\tclose(fd);\n\t}\n\tdebug(\"inetd sockets after dupping: %d, %d\", *sock_in, *sock_out);\n}"
  },
  {
    "function_name": "recv_rexec_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "964-994",
    "snippet": "static void\nrecv_rexec_state(int fd, struct sshbuf *conf)\n{\n\tstruct sshbuf *m;\n\tu_char *cp, ver;\n\tsize_t len;\n\tint r;\n\n\tdebug3(\"%s: entering fd = %d\", __func__, fd);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif (ssh_msg_recv(fd, m) == -1)\n\t\tfatal(\"%s: ssh_msg_recv failed\", __func__);\n\tif ((r = sshbuf_get_u8(m, &ver)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (ver != 0)\n\t\tfatal(\"%s: rexec version mismatch\", __func__);\n\tif ((r = sshbuf_get_string(m, &cp, &len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (conf != NULL && (r = sshbuf_put(conf, cp, len)))\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n#if defined(WITH_OPENSSL) && !defined(OPENSSL_PRNG_ONLY)\n\trexec_recv_rng_seed(m);\n#endif\n\n\tfree(cp);\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done\", __func__);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: done\"",
            "__func__"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "m"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cp"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rexec_recv_rng_seed",
          "args": [
            "m"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "rexec_recv_rng_seed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/entropy.c",
          "lines": "201-213",
          "snippet": "void\nrexec_recv_rng_seed(struct sshbuf *m)\n{\n\tu_char *buf = NULL;\n\tsize_t len = 0;\n\tint r;\n\n\tif ((r = sshbuf_get_string_direct(m, &buf, &len)) != 0\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"rexec_recv_rng_seed: seeding rng with %u bytes\", len);\n\tRAND_add(buf, len, len);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"xmalloc.h\"",
            "#include \"misc.h\"",
            "#include \"ssh.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/crypto.h>",
            "#include <openssl/rand.h>",
            "#include <stddef.h> /* for offsetof */",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"xmalloc.h\"\n#include \"misc.h\"\n#include \"ssh.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/crypto.h>\n#include <openssl/rand.h>\n#include <stddef.h> /* for offsetof */\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nrexec_recv_rng_seed(struct sshbuf *m)\n{\n\tu_char *buf = NULL;\n\tsize_t len = 0;\n\tint r;\n\n\tif ((r = sshbuf_get_string_direct(m, &buf, &len)) != 0\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"rexec_recv_rng_seed: seeding rng with %u bytes\", len);\n\tRAND_add(buf, len, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "conf",
            "cp",
            "len"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "m",
            "&cp",
            "&len"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: rexec version mismatch\"",
            "__func__"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "m",
            "&ver"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_msg_recv",
          "args": [
            "fd",
            "m"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_msg_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/msg.c",
          "lines": "65-94",
          "snippet": "int\nssh_msg_recv(int fd, struct sshbuf *m)\n{\n\tu_char buf[4], *p;\n\tu_int msg_len;\n\tint r;\n\n\tdebug3(\"ssh_msg_recv entering\");\n\n\tif (atomicio(read, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\tif (errno != EPIPE)\n\t\t\terror(\"ssh_msg_recv: read: header\");\n\t\treturn (-1);\n\t}\n\tmsg_len = get_u32(buf);\n\tif (msg_len > 256 * 1024) {\n\t\terror(\"ssh_msg_recv: read: bad msg_len %u\", msg_len);\n\t\treturn (-1);\n\t}\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_reserve(m, msg_len, &p)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\treturn -1;\n\t}\n\tif (atomicio(read, fd, p, msg_len) != msg_len) {\n\t\terror(\"ssh_msg_recv: read: %s\", strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"msg.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"msg.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_msg_recv(int fd, struct sshbuf *m)\n{\n\tu_char buf[4], *p;\n\tu_int msg_len;\n\tint r;\n\n\tdebug3(\"ssh_msg_recv entering\");\n\n\tif (atomicio(read, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\tif (errno != EPIPE)\n\t\t\terror(\"ssh_msg_recv: read: header\");\n\t\treturn (-1);\n\t}\n\tmsg_len = get_u32(buf);\n\tif (msg_len > 256 * 1024) {\n\t\terror(\"ssh_msg_recv: read: bad msg_len %u\", msg_len);\n\t\treturn (-1);\n\t}\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_reserve(m, msg_len, &p)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\treturn -1;\n\t}\n\tif (atomicio(read, fd, p, msg_len) != msg_len) {\n\t\terror(\"ssh_msg_recv: read: %s\", strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nrecv_rexec_state(int fd, struct sshbuf *conf)\n{\n\tstruct sshbuf *m;\n\tu_char *cp, ver;\n\tsize_t len;\n\tint r;\n\n\tdebug3(\"%s: entering fd = %d\", __func__, fd);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif (ssh_msg_recv(fd, m) == -1)\n\t\tfatal(\"%s: ssh_msg_recv failed\", __func__);\n\tif ((r = sshbuf_get_u8(m, &ver)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (ver != 0)\n\t\tfatal(\"%s: rexec version mismatch\", __func__);\n\tif ((r = sshbuf_get_string(m, &cp, &len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (conf != NULL && (r = sshbuf_put(conf, cp, len)))\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n#if defined(WITH_OPENSSL) && !defined(OPENSSL_PRNG_ONLY)\n\trexec_recv_rng_seed(m);\n#endif\n\n\tfree(cp);\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done\", __func__);\n}"
  },
  {
    "function_name": "send_rexec_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "933-962",
    "snippet": "static void\nsend_rexec_state(int fd, struct sshbuf *conf)\n{\n\tstruct sshbuf *m;\n\tint r;\n\n\tdebug3(\"%s: entering fd = %d config len %zu\", __func__, fd,\n\t    sshbuf_len(conf));\n\n\t/*\n\t * Protocol from reexec master to child:\n\t *\tstring\tconfiguration\n\t *\tstring rngseed\t\t(only if OpenSSL is not self-seeded)\n\t */\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_stringb(m, conf)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n#if defined(WITH_OPENSSL) && !defined(OPENSSL_PRNG_ONLY)\n\trexec_send_rng_seed(m);\n#endif\n\n\tif (ssh_msg_send(fd, 0, m) == -1)\n\t\tfatal(\"%s: ssh_msg_send failed\", __func__);\n\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done\", __func__);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: done\"",
            "__func__"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "m"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: ssh_msg_send failed\"",
            "__func__"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_msg_send",
          "args": [
            "fd",
            "0",
            "m"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_msg_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/msg.c",
          "lines": "44-63",
          "snippet": "int\nssh_msg_send(int fd, u_char type, struct sshbuf *m)\n{\n\tu_char buf[5];\n\tu_int mlen = sshbuf_len(m);\n\n\tdebug3(\"ssh_msg_send: type %u\", (unsigned int)type & 0xff);\n\n\tput_u32(buf, mlen + 1);\n\tbuf[4] = type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\terror(\"ssh_msg_send: write\");\n\t\treturn (-1);\n\t}\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(m), mlen) != mlen) {\n\t\terror(\"ssh_msg_send: write\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"msg.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"msg.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_msg_send(int fd, u_char type, struct sshbuf *m)\n{\n\tu_char buf[5];\n\tu_int mlen = sshbuf_len(m);\n\n\tdebug3(\"ssh_msg_send: type %u\", (unsigned int)type & 0xff);\n\n\tput_u32(buf, mlen + 1);\n\tbuf[4] = type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\terror(\"ssh_msg_send: write\");\n\t\treturn (-1);\n\t}\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(m), mlen) != mlen) {\n\t\terror(\"ssh_msg_send: write\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rexec_send_rng_seed",
          "args": [
            "m"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "rexec_send_rng_seed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/entropy.c",
          "lines": "184-199",
          "snippet": "void\nrexec_send_rng_seed(struct sshbuf *m)\n{\n\tu_char buf[RANDOM_SEED_SIZE];\n\tsize_t len = sizeof(buf);\n\tint r;\n\n\tif (RAND_bytes(buf, sizeof(buf)) <= 0) {\n\t\terror(\"Couldn't obtain random bytes (error %ld)\",\n\t\t    ERR_get_error());\n\t\tlen = 0;\n\t}\n\tif ((r = sshbuf_put_string(m, buf, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\texplicit_bzero(buf, sizeof(buf));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"xmalloc.h\"",
            "#include \"misc.h\"",
            "#include \"ssh.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/crypto.h>",
            "#include <openssl/rand.h>",
            "#include <stddef.h> /* for offsetof */",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define RANDOM_SEED_SIZE 48"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"xmalloc.h\"\n#include \"misc.h\"\n#include \"ssh.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/crypto.h>\n#include <openssl/rand.h>\n#include <stddef.h> /* for offsetof */\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define RANDOM_SEED_SIZE 48\n\nvoid\nrexec_send_rng_seed(struct sshbuf *m)\n{\n\tu_char buf[RANDOM_SEED_SIZE];\n\tsize_t len = sizeof(buf);\n\tint r;\n\n\tif (RAND_bytes(buf, sizeof(buf)) <= 0) {\n\t\terror(\"Couldn't obtain random bytes (error %ld)\",\n\t\t    ERR_get_error());\n\t\tlen = 0;\n\t}\n\tif ((r = sshbuf_put_string(m, buf, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\texplicit_bzero(buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "m",
            "conf"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "conf"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_rexec_state(int fd, struct sshbuf *conf)\n{\n\tstruct sshbuf *m;\n\tint r;\n\n\tdebug3(\"%s: entering fd = %d config len %zu\", __func__, fd,\n\t    sshbuf_len(conf));\n\n\t/*\n\t * Protocol from reexec master to child:\n\t *\tstring\tconfiguration\n\t *\tstring rngseed\t\t(only if OpenSSL is not self-seeded)\n\t */\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_stringb(m, conf)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n#if defined(WITH_OPENSSL) && !defined(OPENSSL_PRNG_ONLY)\n\trexec_send_rng_seed(m);\n#endif\n\n\tif (ssh_msg_send(fd, 0, m) == -1)\n\t\tfatal(\"%s: ssh_msg_send failed\", __func__);\n\n\tsshbuf_free(m);\n\n\tdebug3(\"%s: done\", __func__);\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "914-931",
    "snippet": "static void\nusage(void)\n{\n\tfprintf(stderr, \"%s, %s\\n\",\n\t    SSH_RELEASE,\n#ifdef WITH_OPENSSL\n\t    OpenSSL_version(OPENSSL_VERSION)\n#else\n\t    \"without OpenSSL\"\n#endif\n\t);\n\tfprintf(stderr,\n\"usage: sshd [-46DdeiqTt] [-C connection_spec] [-c host_cert_file]\\n\"\n\"            [-E log_file] [-f config_file] [-g login_grace_time]\\n\"\n\"            [-h host_key_file] [-o option] [-p port] [-u len]\\n\"\n\t);\n\texit(1);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "2331-2353",
          "snippet": "void\ncleanup_exit(int i)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (the_authctxt) {\n\t\tdo_cleanup(ssh, the_authctxt);\n\t\tif (use_privsep && privsep_is_preauth &&\n\t\t    pmonitor != NULL && pmonitor->m_pid > 1) {\n\t\t\tdebug(\"Killing privsep child %d\", pmonitor->m_pid);\n\t\t\tif (kill(pmonitor->m_pid, SIGKILL) != 0 &&\n\t\t\t    errno != ESRCH)\n\t\t\t\terror(\"%s: kill(%d): %s\", __func__,\n\t\t\t\t    pmonitor->m_pid, strerror(errno));\n\t\t}\n\t}\n#ifdef SSH_AUDIT_EVENTS\n\t/* done after do_cleanup so it can cancel the PAM auth 'thread' */\n\tif (!use_privsep || mm_is_monitor())\n\t\taudit_event(SSH_CONNECTION_ABANDON);\n#endif\n\t_exit(i);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int use_privsep = -1;",
            "struct monitor *pmonitor = NULL;",
            "int privsep_is_preauth = 1;",
            "Authctxt *the_authctxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint use_privsep = -1;\nstruct monitor *pmonitor = NULL;\nint privsep_is_preauth = 1;\nAuthctxt *the_authctxt = NULL;\n\nvoid\ncleanup_exit(int i)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (the_authctxt) {\n\t\tdo_cleanup(ssh, the_authctxt);\n\t\tif (use_privsep && privsep_is_preauth &&\n\t\t    pmonitor != NULL && pmonitor->m_pid > 1) {\n\t\t\tdebug(\"Killing privsep child %d\", pmonitor->m_pid);\n\t\t\tif (kill(pmonitor->m_pid, SIGKILL) != 0 &&\n\t\t\t    errno != ESRCH)\n\t\t\t\terror(\"%s: kill(%d): %s\", __func__,\n\t\t\t\t    pmonitor->m_pid, strerror(errno));\n\t\t}\n\t}\n#ifdef SSH_AUDIT_EVENTS\n\t/* done after do_cleanup so it can cancel the PAM auth 'thread' */\n\tif (!use_privsep || mm_is_monitor())\n\t\taudit_event(SSH_CONNECTION_ABANDON);\n#endif\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"usage: sshd [-46DdeiqTt] [-C connection_spec] [-c host_cert_file]\\n\"\n\"            [-E log_file] [-f config_file] [-g login_grace_time]\\n\"\n\"            [-h host_key_file] [-o option] [-p port] [-u len]\\n\""
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s, %s\\n\"",
            "SSH_RELEASE",
            "#ifdef WITH_OPENSSL\n\t    OpenSSL_version(OPENSSL_VERSION)\n#else\"without OpenSSL\"#endif"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OpenSSL_version",
          "args": [
            "OPENSSL_VERSION"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr, \"%s, %s\\n\",\n\t    SSH_RELEASE,\n#ifdef WITH_OPENSSL\n\t    OpenSSL_version(OPENSSL_VERSION)\n#else\n\t    \"without OpenSSL\"\n#endif\n\t);\n\tfprintf(stderr,\n\"usage: sshd [-46DdeiqTt] [-C connection_spec] [-c host_cert_file]\\n\"\n\"            [-E log_file] [-f config_file] [-g login_grace_time]\\n\"\n\"            [-h host_key_file] [-o option] [-p port] [-u len]\\n\"\n\t);\n\texit(1);\n}"
  },
  {
    "function_name": "drop_connection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "892-912",
    "snippet": "static int\ndrop_connection(int startups)\n{\n\tint p, r;\n\n\tif (startups < options.max_startups_begin)\n\t\treturn 0;\n\tif (startups >= options.max_startups)\n\t\treturn 1;\n\tif (options.max_startups_rate == 100)\n\t\treturn 1;\n\n\tp  = 100 - options.max_startups_rate;\n\tp *= startups - options.max_startups_begin;\n\tp /= options.max_startups - options.max_startups_begin;\n\tp += options.max_startups_rate;\n\tr = arc4random_uniform(100);\n\n\tdebug(\"drop_connection: p %d, r %d\", p, r);\n\treturn (r < p) ? 1 : 0;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"drop_connection: p %d, r %d\"",
            "p",
            "r"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arc4random_uniform",
          "args": [
            "100"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random_uniform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "291-315",
          "snippet": "u_int32_t\narc4random_uniform(u_int32_t upper_bound)\n{\n\tu_int32_t r, min;\n\n\tif (upper_bound < 2)\n\t\treturn 0;\n\n\t/* 2**32 % x == (2**32 - x) % x */\n\tmin = -upper_bound % upper_bound;\n\n\t/*\n\t * This could theoretically loop forever but each retry has\n\t * p > 0.5 (worst case, usually far better) of selecting a\n\t * number inside the range we need, so it should rarely need\n\t * to re-roll.\n\t */\n\tfor (;;) {\n\t\tr = arc4random();\n\t\tif (r >= min)\n\t\t\tbreak;\n\t}\n\n\treturn r % upper_bound;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t\narc4random_uniform(u_int32_t upper_bound)\n{\n\tu_int32_t r, min;\n\n\tif (upper_bound < 2)\n\t\treturn 0;\n\n\t/* 2**32 % x == (2**32 - x) % x */\n\tmin = -upper_bound % upper_bound;\n\n\t/*\n\t * This could theoretically loop forever but each retry has\n\t * p > 0.5 (worst case, usually far better) of selecting a\n\t * number inside the range we need, so it should rarely need\n\t * to re-roll.\n\t */\n\tfor (;;) {\n\t\tr = arc4random();\n\t\tif (r >= min)\n\t\t\tbreak;\n\t}\n\n\treturn r % upper_bound;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\n\nstatic int\ndrop_connection(int startups)\n{\n\tint p, r;\n\n\tif (startups < options.max_startups_begin)\n\t\treturn 0;\n\tif (startups >= options.max_startups)\n\t\treturn 1;\n\tif (options.max_startups_rate == 100)\n\t\treturn 1;\n\n\tp  = 100 - options.max_startups_rate;\n\tp *= startups - options.max_startups_begin;\n\tp /= options.max_startups - options.max_startups_begin;\n\tp += options.max_startups_rate;\n\tr = arc4random_uniform(100);\n\n\tdebug(\"drop_connection: p %d, r %d\", p, r);\n\treturn (r < p) ? 1 : 0;\n}"
  },
  {
    "function_name": "notify_hostkeys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "842-884",
    "snippet": "static void\nnotify_hostkeys(struct ssh *ssh)\n{\n\tstruct sshbuf *buf;\n\tstruct sshkey *key;\n\tu_int i, nkeys;\n\tint r;\n\tchar *fp;\n\n\t/* Some clients cannot cope with the hostkeys message, skip those. */\n\tif (datafellows & SSH_BUG_HOSTKEYS)\n\t\treturn;\n\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tfor (i = nkeys = 0; i < options.num_host_key_files; i++) {\n\t\tkey = get_hostkey_public_by_index(i, ssh);\n\t\tif (key == NULL || key->type == KEY_UNSPEC ||\n\t\t    sshkey_is_cert(key))\n\t\t\tcontinue;\n\t\tfp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\tdebug3(\"%s: key %d: %s %s\", __func__, i,\n\t\t    sshkey_ssh_name(key), fp);\n\t\tfree(fp);\n\t\tif (nkeys == 0) {\n\t\t\tpacket_start(SSH2_MSG_GLOBAL_REQUEST);\n\t\t\tpacket_put_cstring(\"hostkeys-00@openssh.com\");\n\t\t\tpacket_put_char(0); /* want-reply */\n\t\t}\n\t\tsshbuf_reset(buf);\n\t\tif ((r = sshkey_putb(key, buf)) != 0)\n\t\t\tfatal(\"%s: couldn't put hostkey %d: %s\",\n\t\t\t    __func__, i, ssh_err(r));\n\t\tpacket_put_string(sshbuf_ptr(buf), sshbuf_len(buf));\n\t\tnkeys++;\n\t}\n\tdebug3(\"%s: sent %u hostkeys\", __func__, nkeys);\n\tif (nkeys == 0)\n\t\tfatal(\"%s: no hostkeys\", __func__);\n\tpacket_send();\n\tsshbuf_free(buf);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "buf"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: no hostkeys\"",
            "__func__"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: sent %u hostkeys\"",
            "__func__",
            "nkeys"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_put_string",
          "args": [
            "sshbuf_ptr(buf)",
            "sshbuf_len(buf)"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "buf"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "buf"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: couldn't put hostkey %d: %s\"",
            "__func__",
            "i",
            "ssh_err(r)"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_putb",
          "args": [
            "key",
            "buf"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_putb_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "842-846",
          "snippet": "int\nsshkey_putb_plain(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn to_blob_buf(key, b, 1, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_putb_plain(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn to_blob_buf(key, b, 1, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "buf"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_put_char",
          "args": [
            "0"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "\"hostkeys-00@openssh.com\""
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_start",
          "args": [
            "SSH2_MSG_GLOBAL_REQUEST"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fp"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "key"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "key",
            "options.fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "key"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hostkey_public_by_index",
          "args": [
            "i",
            "ssh"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "get_hostkey_public_by_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "807-813",
          "snippet": "struct sshkey *\nget_hostkey_public_by_index(int ind, struct ssh *ssh)\n{\n\tif (ind < 0 || (u_int)ind >= options.num_host_key_files)\n\t\treturn (NULL);\n\treturn (sensitive_data.host_pubkeys[ind]);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;",
            "struct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nstruct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;\n\nstruct sshkey *\nget_hostkey_public_by_index(int ind, struct ssh *ssh)\n{\n\tif (ind < 0 || (u_int)ind >= options.num_host_key_files)\n\t\treturn (NULL);\n\treturn (sensitive_data.host_pubkeys[ind]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\n\nstatic void\nnotify_hostkeys(struct ssh *ssh)\n{\n\tstruct sshbuf *buf;\n\tstruct sshkey *key;\n\tu_int i, nkeys;\n\tint r;\n\tchar *fp;\n\n\t/* Some clients cannot cope with the hostkeys message, skip those. */\n\tif (datafellows & SSH_BUG_HOSTKEYS)\n\t\treturn;\n\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tfor (i = nkeys = 0; i < options.num_host_key_files; i++) {\n\t\tkey = get_hostkey_public_by_index(i, ssh);\n\t\tif (key == NULL || key->type == KEY_UNSPEC ||\n\t\t    sshkey_is_cert(key))\n\t\t\tcontinue;\n\t\tfp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\tdebug3(\"%s: key %d: %s %s\", __func__, i,\n\t\t    sshkey_ssh_name(key), fp);\n\t\tfree(fp);\n\t\tif (nkeys == 0) {\n\t\t\tpacket_start(SSH2_MSG_GLOBAL_REQUEST);\n\t\t\tpacket_put_cstring(\"hostkeys-00@openssh.com\");\n\t\t\tpacket_put_char(0); /* want-reply */\n\t\t}\n\t\tsshbuf_reset(buf);\n\t\tif ((r = sshkey_putb(key, buf)) != 0)\n\t\t\tfatal(\"%s: couldn't put hostkey %d: %s\",\n\t\t\t    __func__, i, ssh_err(r));\n\t\tpacket_put_string(sshbuf_ptr(buf), sshbuf_len(buf));\n\t\tnkeys++;\n\t}\n\tdebug3(\"%s: sent %u hostkeys\", __func__, nkeys);\n\tif (nkeys == 0)\n\t\tfatal(\"%s: no hostkeys\", __func__);\n\tpacket_send();\n\tsshbuf_free(buf);\n}"
  },
  {
    "function_name": "get_hostkey_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "815-839",
    "snippet": "int\nget_hostkey_index(struct sshkey *key, int compare, struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tif (sshkey_is_cert(key)) {\n\t\t\tif (key == sensitive_data.host_certificates[i] ||\n\t\t\t    (compare && sensitive_data.host_certificates[i] &&\n\t\t\t    sshkey_equal(key,\n\t\t\t    sensitive_data.host_certificates[i])))\n\t\t\t\treturn (i);\n\t\t} else {\n\t\t\tif (key == sensitive_data.host_keys[i] ||\n\t\t\t    (compare && sensitive_data.host_keys[i] &&\n\t\t\t    sshkey_equal(key, sensitive_data.host_keys[i])))\n\t\t\t\treturn (i);\n\t\t\tif (key == sensitive_data.host_pubkeys[i] ||\n\t\t\t    (compare && sensitive_data.host_pubkeys[i] &&\n\t\t\t    sshkey_equal(key, sensitive_data.host_pubkeys[i])))\n\t\t\t\treturn (i);\n\t\t}\n\t}\n\treturn (-1);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ServerOptions options;",
      "struct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_equal",
          "args": [
            "key",
            "sensitive_data.host_pubkeys[i]"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "704-714",
          "snippet": "int\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "key"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nstruct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;\n\nint\nget_hostkey_index(struct sshkey *key, int compare, struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tif (sshkey_is_cert(key)) {\n\t\t\tif (key == sensitive_data.host_certificates[i] ||\n\t\t\t    (compare && sensitive_data.host_certificates[i] &&\n\t\t\t    sshkey_equal(key,\n\t\t\t    sensitive_data.host_certificates[i])))\n\t\t\t\treturn (i);\n\t\t} else {\n\t\t\tif (key == sensitive_data.host_keys[i] ||\n\t\t\t    (compare && sensitive_data.host_keys[i] &&\n\t\t\t    sshkey_equal(key, sensitive_data.host_keys[i])))\n\t\t\t\treturn (i);\n\t\t\tif (key == sensitive_data.host_pubkeys[i] ||\n\t\t\t    (compare && sensitive_data.host_pubkeys[i] &&\n\t\t\t    sshkey_equal(key, sensitive_data.host_pubkeys[i])))\n\t\t\t\treturn (i);\n\t\t}\n\t}\n\treturn (-1);\n}"
  },
  {
    "function_name": "get_hostkey_public_by_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "807-813",
    "snippet": "struct sshkey *\nget_hostkey_public_by_index(int ind, struct ssh *ssh)\n{\n\tif (ind < 0 || (u_int)ind >= options.num_host_key_files)\n\t\treturn (NULL);\n\treturn (sensitive_data.host_pubkeys[ind]);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ServerOptions options;",
      "struct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nstruct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;\n\nstruct sshkey *\nget_hostkey_public_by_index(int ind, struct ssh *ssh)\n{\n\tif (ind < 0 || (u_int)ind >= options.num_host_key_files)\n\t\treturn (NULL);\n\treturn (sensitive_data.host_pubkeys[ind]);\n}"
  },
  {
    "function_name": "get_hostkey_by_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "799-805",
    "snippet": "struct sshkey *\nget_hostkey_by_index(int ind)\n{\n\tif (ind < 0 || (u_int)ind >= options.num_host_key_files)\n\t\treturn (NULL);\n\treturn (sensitive_data.host_keys[ind]);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ServerOptions options;",
      "struct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nstruct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;\n\nstruct sshkey *\nget_hostkey_by_index(int ind)\n{\n\tif (ind < 0 || (u_int)ind >= options.num_host_key_files)\n\t\treturn (NULL);\n\treturn (sensitive_data.host_keys[ind]);\n}"
  },
  {
    "function_name": "get_hostkey_private_by_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "793-797",
    "snippet": "struct sshkey *\nget_hostkey_private_by_type(int type, int nid, struct ssh *ssh)\n{\n\treturn get_hostkey_by_type(type, nid, 1, ssh);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_hostkey_by_type",
          "args": [
            "type",
            "nid",
            "1",
            "ssh"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "get_hostkey_by_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "758-785",
          "snippet": "static struct sshkey *\nget_hostkey_by_type(int type, int nid, int need_private, struct ssh *ssh)\n{\n\tu_int i;\n\tstruct sshkey *key;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tswitch (type) {\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ED25519_CERT:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tkey = sensitive_data.host_certificates[i];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tkey = sensitive_data.host_keys[i];\n\t\t\tif (key == NULL && !need_private)\n\t\t\t\tkey = sensitive_data.host_pubkeys[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (key != NULL && key->type == type &&\n\t\t    (key->type != KEY_ECDSA || key->ecdsa_nid == nid))\n\t\t\treturn need_private ?\n\t\t\t    sensitive_data.host_keys[i] : key;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;",
            "struct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nstruct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;\n\nstatic struct sshkey *\nget_hostkey_by_type(int type, int nid, int need_private, struct ssh *ssh)\n{\n\tu_int i;\n\tstruct sshkey *key;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tswitch (type) {\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ED25519_CERT:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tkey = sensitive_data.host_certificates[i];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tkey = sensitive_data.host_keys[i];\n\t\t\tif (key == NULL && !need_private)\n\t\t\t\tkey = sensitive_data.host_pubkeys[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (key != NULL && key->type == type &&\n\t\t    (key->type != KEY_ECDSA || key->ecdsa_nid == nid))\n\t\t\treturn need_private ?\n\t\t\t    sensitive_data.host_keys[i] : key;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshkey *\nget_hostkey_private_by_type(int type, int nid, struct ssh *ssh)\n{\n\treturn get_hostkey_by_type(type, nid, 1, ssh);\n}"
  },
  {
    "function_name": "get_hostkey_public_by_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "787-791",
    "snippet": "struct sshkey *\nget_hostkey_public_by_type(int type, int nid, struct ssh *ssh)\n{\n\treturn get_hostkey_by_type(type, nid, 0, ssh);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_hostkey_by_type",
          "args": [
            "type",
            "nid",
            "0",
            "ssh"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "get_hostkey_by_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "758-785",
          "snippet": "static struct sshkey *\nget_hostkey_by_type(int type, int nid, int need_private, struct ssh *ssh)\n{\n\tu_int i;\n\tstruct sshkey *key;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tswitch (type) {\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ED25519_CERT:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tkey = sensitive_data.host_certificates[i];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tkey = sensitive_data.host_keys[i];\n\t\t\tif (key == NULL && !need_private)\n\t\t\t\tkey = sensitive_data.host_pubkeys[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (key != NULL && key->type == type &&\n\t\t    (key->type != KEY_ECDSA || key->ecdsa_nid == nid))\n\t\t\treturn need_private ?\n\t\t\t    sensitive_data.host_keys[i] : key;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;",
            "struct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nstruct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;\n\nstatic struct sshkey *\nget_hostkey_by_type(int type, int nid, int need_private, struct ssh *ssh)\n{\n\tu_int i;\n\tstruct sshkey *key;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tswitch (type) {\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ED25519_CERT:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tkey = sensitive_data.host_certificates[i];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tkey = sensitive_data.host_keys[i];\n\t\t\tif (key == NULL && !need_private)\n\t\t\t\tkey = sensitive_data.host_pubkeys[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (key != NULL && key->type == type &&\n\t\t    (key->type != KEY_ECDSA || key->ecdsa_nid == nid))\n\t\t\treturn need_private ?\n\t\t\t    sensitive_data.host_keys[i] : key;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshkey *\nget_hostkey_public_by_type(int type, int nid, struct ssh *ssh)\n{\n\treturn get_hostkey_by_type(type, nid, 0, ssh);\n}"
  },
  {
    "function_name": "get_hostkey_by_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "758-785",
    "snippet": "static struct sshkey *\nget_hostkey_by_type(int type, int nid, int need_private, struct ssh *ssh)\n{\n\tu_int i;\n\tstruct sshkey *key;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tswitch (type) {\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ED25519_CERT:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tkey = sensitive_data.host_certificates[i];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tkey = sensitive_data.host_keys[i];\n\t\t\tif (key == NULL && !need_private)\n\t\t\t\tkey = sensitive_data.host_pubkeys[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (key != NULL && key->type == type &&\n\t\t    (key->type != KEY_ECDSA || key->ecdsa_nid == nid))\n\t\t\treturn need_private ?\n\t\t\t    sensitive_data.host_keys[i] : key;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ServerOptions options;",
      "struct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nstruct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;\n\nstatic struct sshkey *\nget_hostkey_by_type(int type, int nid, int need_private, struct ssh *ssh)\n{\n\tu_int i;\n\tstruct sshkey *key;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tswitch (type) {\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ED25519_CERT:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tkey = sensitive_data.host_certificates[i];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tkey = sensitive_data.host_keys[i];\n\t\t\tif (key == NULL && !need_private)\n\t\t\t\tkey = sensitive_data.host_pubkeys[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (key != NULL && key->type == type &&\n\t\t    (key->type != KEY_ECDSA || key->ecdsa_nid == nid))\n\t\t\treturn need_private ?\n\t\t\t    sensitive_data.host_keys[i] : key;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "list_hostkey_types",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "702-756",
    "snippet": "static char *\nlist_hostkey_types(void)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *key;\n\tchar *ret;\n\tu_int i;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tkey = sensitive_data.host_keys[i];\n\t\tif (key == NULL)\n\t\t\tkey = sensitive_data.host_pubkeys[i];\n\t\tif (key == NULL)\n\t\t\tcontinue;\n\t\tswitch (key->type) {\n\t\tcase KEY_RSA:\n\t\t\t/* for RSA we also support SHA2 signatures */\n\t\t\tappend_hostkey_type(b, \"rsa-sha2-512\");\n\t\t\tappend_hostkey_type(b, \"rsa-sha2-256\");\n\t\t\t/* FALLTHROUGH */\n\t\tcase KEY_DSA:\n\t\tcase KEY_ECDSA:\n\t\tcase KEY_ED25519:\n\t\tcase KEY_XMSS:\n\t\t\tappend_hostkey_type(b, sshkey_ssh_name(key));\n\t\t\tbreak;\n\t\t}\n\t\t/* If the private key has a cert peer, then list that too */\n\t\tkey = sensitive_data.host_certificates[i];\n\t\tif (key == NULL)\n\t\t\tcontinue;\n\t\tswitch (key->type) {\n\t\tcase KEY_RSA_CERT:\n\t\t\t/* for RSA we also support SHA2 signatures */\n\t\t\tappend_hostkey_type(b,\n\t\t\t    \"rsa-sha2-512-cert-v01@openssh.com\");\n\t\t\tappend_hostkey_type(b,\n\t\t\t    \"rsa-sha2-256-cert-v01@openssh.com\");\n\t\t\t/* FALLTHROUGH */\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ED25519_CERT:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tappend_hostkey_type(b, sshkey_ssh_name(key));\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((ret = sshbuf_dup_string(b)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\tsshbuf_free(b);\n\tdebug(\"%s: %s\", __func__, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ServerOptions options;",
      "struct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "ret"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_dup_string failed\"",
            "__func__"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_dup_string",
          "args": [
            "b"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_dup_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
          "lines": "139-160",
          "snippet": "char *\nsshbuf_dup_string(struct sshbuf *buf)\n{\n\tconst u_char *p = NULL, *s = sshbuf_ptr(buf);\n\tsize_t l = sshbuf_len(buf);\n\tchar *r;\n\n\tif (s == NULL || l > SIZE_MAX)\n\t\treturn NULL;\n\t/* accept a nul only as the last character in the buffer */\n\tif (l > 0 && (p = memchr(s, '\\0', l)) != NULL) {\n\t\tif (p != s + l - 1)\n\t\t\treturn NULL;\n\t\tl--; /* the nul is put back below */\n\t}\n\tif ((r = malloc(l + 1)) == NULL)\n\t\treturn NULL;\n\tif (l > 0)\n\t\tmemcpy(r, s, l);\n\tr[l] = '\\0';\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <ctype.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshbuf_dup_string(struct sshbuf *buf)\n{\n\tconst u_char *p = NULL, *s = sshbuf_ptr(buf);\n\tsize_t l = sshbuf_len(buf);\n\tchar *r;\n\n\tif (s == NULL || l > SIZE_MAX)\n\t\treturn NULL;\n\t/* accept a nul only as the last character in the buffer */\n\tif (l > 0 && (p = memchr(s, '\\0', l)) != NULL) {\n\t\tif (p != s + l - 1)\n\t\t\treturn NULL;\n\t\tl--; /* the nul is put back below */\n\t}\n\tif ((r = malloc(l + 1)) == NULL)\n\t\treturn NULL;\n\tif (l > 0)\n\t\tmemcpy(r, s, l);\n\tr[l] = '\\0';\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_hostkey_type",
          "args": [
            "b",
            "sshkey_ssh_name(key)"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "append_hostkey_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "688-700",
          "snippet": "static void\nappend_hostkey_type(struct sshbuf *b, const char *s)\n{\n\tint r;\n\n\tif (match_pattern_list(s, options.hostkeyalgorithms, 0) != 1) {\n\t\tdebug3(\"%s: %s key not permitted by HostkeyAlgorithms\",\n\t\t    __func__, s);\n\t\treturn;\n\t}\n\tif ((r = sshbuf_putf(b, \"%s%s\", sshbuf_len(b) > 0 ? \",\" : \"\", s)) != 0)\n\t\tfatal(\"%s: sshbuf_putf: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\n\nstatic void\nappend_hostkey_type(struct sshbuf *b, const char *s)\n{\n\tint r;\n\n\tif (match_pattern_list(s, options.hostkeyalgorithms, 0) != 1) {\n\t\tdebug3(\"%s: %s key not permitted by HostkeyAlgorithms\",\n\t\t    __func__, s);\n\t\treturn;\n\t}\n\tif ((r = sshbuf_putf(b, \"%s%s\", sshbuf_len(b) > 0 ? \",\" : \"\", s)) != 0)\n\t\tfatal(\"%s: sshbuf_putf: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "key"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nstruct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;\n\nstatic char *\nlist_hostkey_types(void)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *key;\n\tchar *ret;\n\tu_int i;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tkey = sensitive_data.host_keys[i];\n\t\tif (key == NULL)\n\t\t\tkey = sensitive_data.host_pubkeys[i];\n\t\tif (key == NULL)\n\t\t\tcontinue;\n\t\tswitch (key->type) {\n\t\tcase KEY_RSA:\n\t\t\t/* for RSA we also support SHA2 signatures */\n\t\t\tappend_hostkey_type(b, \"rsa-sha2-512\");\n\t\t\tappend_hostkey_type(b, \"rsa-sha2-256\");\n\t\t\t/* FALLTHROUGH */\n\t\tcase KEY_DSA:\n\t\tcase KEY_ECDSA:\n\t\tcase KEY_ED25519:\n\t\tcase KEY_XMSS:\n\t\t\tappend_hostkey_type(b, sshkey_ssh_name(key));\n\t\t\tbreak;\n\t\t}\n\t\t/* If the private key has a cert peer, then list that too */\n\t\tkey = sensitive_data.host_certificates[i];\n\t\tif (key == NULL)\n\t\t\tcontinue;\n\t\tswitch (key->type) {\n\t\tcase KEY_RSA_CERT:\n\t\t\t/* for RSA we also support SHA2 signatures */\n\t\t\tappend_hostkey_type(b,\n\t\t\t    \"rsa-sha2-512-cert-v01@openssh.com\");\n\t\t\tappend_hostkey_type(b,\n\t\t\t    \"rsa-sha2-256-cert-v01@openssh.com\");\n\t\t\t/* FALLTHROUGH */\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ED25519_CERT:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tappend_hostkey_type(b, sshkey_ssh_name(key));\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((ret = sshbuf_dup_string(b)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\tsshbuf_free(b);\n\tdebug(\"%s: %s\", __func__, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "append_hostkey_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "688-700",
    "snippet": "static void\nappend_hostkey_type(struct sshbuf *b, const char *s)\n{\n\tint r;\n\n\tif (match_pattern_list(s, options.hostkeyalgorithms, 0) != 1) {\n\t\tdebug3(\"%s: %s key not permitted by HostkeyAlgorithms\",\n\t\t    __func__, s);\n\t\treturn;\n\t}\n\tif ((r = sshbuf_putf(b, \"%s%s\", sshbuf_len(b) > 0 ? \",\" : \"\", s)) != 0)\n\t\tfatal(\"%s: sshbuf_putf: %s\", __func__, ssh_err(r));\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_putf: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_putf",
          "args": [
            "b",
            "\"%s%s\"",
            "sshbuf_len(b) > 0 ? \",\" : \"\"",
            "s"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: %s key not permitted by HostkeyAlgorithms\"",
            "__func__",
            "s"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_pattern_list",
          "args": [
            "s",
            "options.hostkeyalgorithms",
            "0"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "120-171",
          "snippet": "int\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\n\nstatic void\nappend_hostkey_type(struct sshbuf *b, const char *s)\n{\n\tint r;\n\n\tif (match_pattern_list(s, options.hostkeyalgorithms, 0) != 1) {\n\t\tdebug3(\"%s: %s key not permitted by HostkeyAlgorithms\",\n\t\t    __func__, s);\n\t\treturn;\n\t}\n\tif ((r = sshbuf_putf(b, \"%s%s\", sshbuf_len(b) > 0 ? \",\" : \"\", s)) != 0)\n\t\tfatal(\"%s: sshbuf_putf: %s\", __func__, ssh_err(r));\n}"
  },
  {
    "function_name": "privsep_preauth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "566-633",
    "snippet": "static int\nprivsep_preauth(Authctxt *authctxt)\n{\n\tint status, r;\n\tpid_t pid;\n\tstruct ssh_sandbox *box = NULL;\n\n\t/* Set up unprivileged child process to deal with network data */\n\tpmonitor = monitor_init();\n\t/* Store a pointer to the kex for later rekeying */\n\tpmonitor->m_pkex = &active_state->kex;\n\n\tif (use_privsep == PRIVSEP_ON)\n\t\tbox = ssh_sandbox_init(pmonitor);\n\tpid = fork();\n\tif (pid == -1) {\n\t\tfatal(\"fork of unprivileged child failed\");\n\t} else if (pid != 0) {\n\t\tdebug2(\"Network child is on pid %ld\", (long)pid);\n\n\t\tpmonitor->m_pid = pid;\n\t\tif (have_agent) {\n\t\t\tr = ssh_get_authentication_socket(&auth_sock);\n\t\t\tif (r != 0) {\n\t\t\t\terror(\"Could not get agent socket: %s\",\n\t\t\t\t    ssh_err(r));\n\t\t\t\thave_agent = 0;\n\t\t\t}\n\t\t}\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_preauth(box, pid);\n\t\tmonitor_child_preauth(authctxt, pmonitor);\n\n\t\t/* Wait for the child's exit status */\n\t\twhile (waitpid(pid, &status, 0) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tpmonitor->m_pid = -1;\n\t\t\tfatal(\"%s: waitpid: %s\", __func__, strerror(errno));\n\t\t}\n\t\tprivsep_is_preauth = 0;\n\t\tpmonitor->m_pid = -1;\n\t\tif (WIFEXITED(status)) {\n\t\t\tif (WEXITSTATUS(status) != 0)\n\t\t\t\tfatal(\"%s: preauth child exited with status %d\",\n\t\t\t\t    __func__, WEXITSTATUS(status));\n\t\t} else if (WIFSIGNALED(status))\n\t\t\tfatal(\"%s: preauth child terminated by signal %d\",\n\t\t\t    __func__, WTERMSIG(status));\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_finish(box);\n\t\treturn 1;\n\t} else {\n\t\t/* child */\n\t\tclose(pmonitor->m_sendfd);\n\t\tclose(pmonitor->m_log_recvfd);\n\n\t\t/* Arrange for logging to be sent to the monitor */\n\t\tset_log_handler(mm_log_handler, pmonitor);\n\n\t\tprivsep_preauth_child();\n\t\tsetproctitle(\"%s\", \"[net]\");\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_child(box);\n\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int auth_sock = -1;",
      "int have_agent = 0;",
      "int use_privsep = -1;",
      "struct monitor *pmonitor = NULL;",
      "int privsep_is_preauth = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_sandbox_child",
          "args": [
            "box"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_sandbox_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sandbox-solaris.c",
          "lines": "91-98",
          "snippet": "void\nssh_sandbox_child(struct ssh_sandbox *box)\n{\n\tif (setppriv(PRIV_SET, PRIV_PERMITTED, box->pset) != 0 ||\n\t    setppriv(PRIV_SET, PRIV_LIMIT, box->pset) != 0 ||\n\t    setppriv(PRIV_SET, PRIV_INHERITABLE, box->pset) != 0)\n\t\tfatal(\"setppriv: %s\", strerror(errno));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"log.h\"",
            "# include <priv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"ssh-sandbox.h\"\n#include \"log.h\"\n# include <priv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_sandbox_child(struct ssh_sandbox *box)\n{\n\tif (setppriv(PRIV_SET, PRIV_PERMITTED, box->pset) != 0 ||\n\t    setppriv(PRIV_SET, PRIV_LIMIT, box->pset) != 0 ||\n\t    setppriv(PRIV_SET, PRIV_INHERITABLE, box->pset) != 0)\n\t\tfatal(\"setppriv: %s\", strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "setproctitle",
          "args": [
            "\"%s\"",
            "\"[net]\""
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "setproctitle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/setproctitle.c",
          "lines": "122-167",
          "snippet": "void\nsetproctitle(const char *fmt, ...)\n{\n#if SPT_TYPE != SPT_NONE\n\tva_list ap;\n\tchar buf[1024], ptitle[1024];\n\tsize_t len = 0;\n\tint r;\n\textern char *__progname;\n#if SPT_TYPE == SPT_PSTAT\n\tunion pstun pst;\n#endif\n\n#if SPT_TYPE == SPT_REUSEARGV\n\tif (argv_env_len <= 0)\n\t\treturn;\n#endif\n\n\tstrlcpy(buf, __progname, sizeof(buf));\n\n\tr = -1;\n\tva_start(ap, fmt);\n\tif (fmt != NULL) {\n\t\tlen = strlcat(buf, \": \", sizeof(buf));\n\t\tif (len < sizeof(buf))\n\t\t\tr = vsnprintf(buf + len, sizeof(buf) - len , fmt, ap);\n\t}\n\tva_end(ap);\n\tif (r == -1 || (size_t)r >= sizeof(buf) - len)\n\t\treturn;\n\tstrnvis(ptitle, buf, sizeof(ptitle),\n\t    VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL);\n\n#if SPT_TYPE == SPT_PSTAT\n\tpst.pst_command = ptitle;\n\tpstat(PSTAT_SETCMD, pst, strlen(ptitle), 0, 0);\n#elif SPT_TYPE == SPT_REUSEARGV\n/*\tdebug(\"setproctitle: copy \\\"%s\\\" into len %d\",\n\t    buf, argv_env_len); */\n\tlen = strlcpy(argv_start, ptitle, argv_env_len);\n\tfor(; len < argv_env_len; len++)\n\t\targv_start[len] = SPT_PADCHAR;\n#endif\n\n#endif /* SPT_NONE */\n}",
          "includes": [
            "#include <vis.h>",
            "#include <string.h>",
            "#include <sys/pstat.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SPT_REUSEARGV\t2\t/* cover argv with title information */",
            "#define SPT_PSTAT\t1\t/* use pstat(PSTAT_SETCMD, ...) */",
            "#define SPT_NONE\t0\t/* don't use it at all */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vis.h>\n#include <string.h>\n#include <sys/pstat.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\n#define SPT_REUSEARGV\t2\t/* cover argv with title information */\n#define SPT_PSTAT\t1\t/* use pstat(PSTAT_SETCMD, ...) */\n#define SPT_NONE\t0\t/* don't use it at all */\n\nvoid\nsetproctitle(const char *fmt, ...)\n{\n#if SPT_TYPE != SPT_NONE\n\tva_list ap;\n\tchar buf[1024], ptitle[1024];\n\tsize_t len = 0;\n\tint r;\n\textern char *__progname;\n#if SPT_TYPE == SPT_PSTAT\n\tunion pstun pst;\n#endif\n\n#if SPT_TYPE == SPT_REUSEARGV\n\tif (argv_env_len <= 0)\n\t\treturn;\n#endif\n\n\tstrlcpy(buf, __progname, sizeof(buf));\n\n\tr = -1;\n\tva_start(ap, fmt);\n\tif (fmt != NULL) {\n\t\tlen = strlcat(buf, \": \", sizeof(buf));\n\t\tif (len < sizeof(buf))\n\t\t\tr = vsnprintf(buf + len, sizeof(buf) - len , fmt, ap);\n\t}\n\tva_end(ap);\n\tif (r == -1 || (size_t)r >= sizeof(buf) - len)\n\t\treturn;\n\tstrnvis(ptitle, buf, sizeof(ptitle),\n\t    VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL);\n\n#if SPT_TYPE == SPT_PSTAT\n\tpst.pst_command = ptitle;\n\tpstat(PSTAT_SETCMD, pst, strlen(ptitle), 0, 0);\n#elif SPT_TYPE == SPT_REUSEARGV\n/*\tdebug(\"setproctitle: copy \\\"%s\\\" into len %d\",\n\t    buf, argv_env_len); */\n\tlen = strlcpy(argv_start, ptitle, argv_env_len);\n\tfor(; len < argv_env_len; len++)\n\t\targv_start[len] = SPT_PADCHAR;\n#endif\n\n#endif /* SPT_NONE */\n}"
        }
      },
      {
        "call_info": {
          "callee": "privsep_preauth_child",
          "args": [],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "privsep_preauth_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "529-564",
          "snippet": "static void\nprivsep_preauth_child(void)\n{\n\tgid_t gidset[1];\n\n\t/* Enable challenge-response authentication for privilege separation */\n\tprivsep_challenge_enable();\n\n#ifdef GSSAPI\n\t/* Cache supported mechanism OIDs for later use */\n\tssh_gssapi_prepare_supported_oids();\n#endif\n\n\treseed_prngs();\n\n\t/* Demote the private keys to public keys. */\n\tdemote_sensitive_data();\n\n\t/* Demote the child */\n\tif (privsep_chroot) {\n\t\t/* Change our root directory */\n\t\tif (chroot(_PATH_PRIVSEP_CHROOT_DIR) == -1)\n\t\t\tfatal(\"chroot(\\\"%s\\\"): %s\", _PATH_PRIVSEP_CHROOT_DIR,\n\t\t\t    strerror(errno));\n\t\tif (chdir(\"/\") == -1)\n\t\t\tfatal(\"chdir(\\\"/\\\"): %s\", strerror(errno));\n\n\t\t/* Drop our privileges */\n\t\tdebug3(\"privsep user:group %u:%u\", (u_int)privsep_pw->pw_uid,\n\t\t    (u_int)privsep_pw->pw_gid);\n\t\tgidset[0] = privsep_pw->pw_gid;\n\t\tif (setgroups(1, gidset) < 0)\n\t\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\t\tpermanently_set_uid(privsep_pw);\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int privsep_chroot = 1;",
            "struct passwd *privsep_pw = NULL;",
            "void demote_sensitive_data(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int privsep_chroot = 1;\nstruct passwd *privsep_pw = NULL;\nvoid demote_sensitive_data(void);\n\nstatic void\nprivsep_preauth_child(void)\n{\n\tgid_t gidset[1];\n\n\t/* Enable challenge-response authentication for privilege separation */\n\tprivsep_challenge_enable();\n\n#ifdef GSSAPI\n\t/* Cache supported mechanism OIDs for later use */\n\tssh_gssapi_prepare_supported_oids();\n#endif\n\n\treseed_prngs();\n\n\t/* Demote the private keys to public keys. */\n\tdemote_sensitive_data();\n\n\t/* Demote the child */\n\tif (privsep_chroot) {\n\t\t/* Change our root directory */\n\t\tif (chroot(_PATH_PRIVSEP_CHROOT_DIR) == -1)\n\t\t\tfatal(\"chroot(\\\"%s\\\"): %s\", _PATH_PRIVSEP_CHROOT_DIR,\n\t\t\t    strerror(errno));\n\t\tif (chdir(\"/\") == -1)\n\t\t\tfatal(\"chdir(\\\"/\\\"): %s\", strerror(errno));\n\n\t\t/* Drop our privileges */\n\t\tdebug3(\"privsep user:group %u:%u\", (u_int)privsep_pw->pw_uid,\n\t\t    (u_int)privsep_pw->pw_gid);\n\t\tgidset[0] = privsep_pw->pw_gid;\n\t\tif (setgroups(1, gidset) < 0)\n\t\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\t\tpermanently_set_uid(privsep_pw);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_log_handler",
          "args": [
            "mm_log_handler",
            "pmonitor"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "set_log_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "383-388",
          "snippet": "void\nset_log_handler(log_handler_fn *handler, void *ctx)\n{\n\tlog_handler = handler;\n\tlog_handler_ctx = ctx;\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static log_handler_fn *log_handler;",
            "static void *log_handler_ctx;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic log_handler_fn *log_handler;\nstatic void *log_handler_ctx;\n\nvoid\nset_log_handler(log_handler_fn *handler, void *ctx)\n{\n\tlog_handler = handler;\n\tlog_handler_ctx = ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pmonitor->m_log_recvfd"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_sandbox_parent_finish",
          "args": [
            "box"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_sandbox_parent_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sandbox-solaris.c",
          "lines": "100-106",
          "snippet": "void\nssh_sandbox_parent_finish(struct ssh_sandbox *box)\n{\n\tpriv_freeset(box->pset);\n\tbox->pset = NULL;\n\tfree(box);\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"log.h\"",
            "# include <priv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"ssh-sandbox.h\"\n#include \"log.h\"\n# include <priv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_sandbox_parent_finish(struct ssh_sandbox *box)\n{\n\tpriv_freeset(box->pset);\n\tbox->pset = NULL;\n\tfree(box);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: preauth child terminated by signal %d\"",
            "__func__",
            "WTERMSIG(status)"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor_child_preauth",
          "args": [
            "authctxt",
            "pmonitor"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_child_preauth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "267-370",
          "snippet": "void\nmonitor_child_preauth(Authctxt *_authctxt, struct monitor *pmonitor)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tstruct mon_table *ent;\n\tint authenticated = 0, partial = 0;\n\n\tdebug3(\"preauth child monitor started\");\n\n\tif (pmonitor->m_recvfd >= 0)\n\t\tclose(pmonitor->m_recvfd);\n\tif (pmonitor->m_log_sendfd >= 0)\n\t\tclose(pmonitor->m_log_sendfd);\n\tpmonitor->m_log_sendfd = pmonitor->m_recvfd = -1;\n\n\tauthctxt = _authctxt;\n\tmemset(authctxt, 0, sizeof(*authctxt));\n\tssh->authctxt = authctxt;\n\n\tauthctxt->loginmsg = loginmsg;\n\n\tmon_dispatch = mon_dispatch_proto20;\n\t/* Permit requests for moduli and signatures */\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_MODULI, 1);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_SIGN, 1);\n\n\t/* The first few requests do not require asynchronous access */\n\twhile (!authenticated) {\n\t\tpartial = 0;\n\t\tauth_method = \"unknown\";\n\t\tauth_submethod = NULL;\n\t\tauth2_authctxt_reset_info(authctxt);\n\n\t\tauthenticated = (monitor_read(pmonitor, mon_dispatch, &ent) == 1);\n\n\t\t/* Special handling for multiple required authentications */\n\t\tif (options.num_auth_methods != 0) {\n\t\t\tif (authenticated &&\n\t\t\t    !auth2_update_methods_lists(authctxt,\n\t\t\t    auth_method, auth_submethod)) {\n\t\t\t\tdebug3(\"%s: method %s: partial\", __func__,\n\t\t\t\t    auth_method);\n\t\t\t\tauthenticated = 0;\n\t\t\t\tpartial = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (authenticated) {\n\t\t\tif (!(ent->flags & MON_AUTHDECIDE))\n\t\t\t\tfatal(\"%s: unexpected authentication from %d\",\n\t\t\t\t    __func__, ent->type);\n\t\t\tif (authctxt->pw->pw_uid == 0 &&\n\t\t\t    !auth_root_allowed(ssh, auth_method))\n\t\t\t\tauthenticated = 0;\n#ifdef USE_PAM\n\t\t\t/* PAM needs to perform account checks after auth */\n\t\t\tif (options.use_pam && authenticated) {\n\t\t\t\tstruct sshbuf *m;\n\n\t\t\t\tif ((m = sshbuf_new()) == NULL)\n\t\t\t\t\tfatal(\"%s: sshbuf_new failed\",\n\t\t\t\t\t    __func__);\n\t\t\t\tmm_request_receive_expect(pmonitor->m_sendfd,\n\t\t\t\t    MONITOR_REQ_PAM_ACCOUNT, m);\n\t\t\t\tauthenticated = mm_answer_pam_account(\n\t\t\t\t    pmonitor->m_sendfd, m);\n\t\t\t\tsshbuf_free(m);\n\t\t\t}\n#endif\n\t\t}\n\t\tif (ent->flags & (MON_AUTHDECIDE|MON_ALOG)) {\n\t\t\tauth_log(authctxt, authenticated, partial,\n\t\t\t    auth_method, auth_submethod);\n\t\t\tif (!partial && !authenticated)\n\t\t\t\tauthctxt->failures++;\n\t\t\tif (authenticated || partial) {\n\t\t\t\tauth2_update_session_info(authctxt,\n\t\t\t\t    auth_method, auth_submethod);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!authctxt->valid)\n\t\tfatal(\"%s: authenticated invalid user\", __func__);\n\tif (strcmp(auth_method, \"unknown\") == 0)\n\t\tfatal(\"%s: authentication method name unknown\", __func__);\n\n\tdebug(\"%s: %s has been authenticated by privileged process\",\n\t    __func__, authctxt->user);\n\tssh->authctxt = NULL;\n\tssh_packet_set_log_preamble(ssh, \"user %s\", authctxt->user);\n\n\tmm_get_keystate(pmonitor);\n\n\t/* Drain any buffered messages from the child */\n\twhile (pmonitor->m_log_recvfd != -1 && monitor_read_log(pmonitor) == 0)\n\t\t;\n\n\tif (pmonitor->m_recvfd >= 0)\n\t\tclose(pmonitor->m_recvfd);\n\tif (pmonitor->m_log_sendfd >= 0)\n\t\tclose(pmonitor->m_log_sendfd);\n\tpmonitor->m_sendfd = pmonitor->m_log_recvfd = -1;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MON_ALOG\t0x0020\t/* Log auth attempt without authenticating */",
            "#define MON_AUTHDECIDE\t0x0008\t/* Decides Authentication */"
          ],
          "globals_used": [
            "extern ServerOptions options;",
            "extern struct sshbuf *loginmsg;",
            "int mm_answer_moduli(int, struct sshbuf *);",
            "int mm_answer_sign(int, struct sshbuf *);",
            "int mm_answer_pwnamallow(int, struct sshbuf *);",
            "int mm_answer_auth2_read_banner(int, struct sshbuf *);",
            "int mm_answer_authserv(int, struct sshbuf *);",
            "int mm_answer_authpassword(int, struct sshbuf *);",
            "int mm_answer_bsdauthquery(int, struct sshbuf *);",
            "int mm_answer_bsdauthrespond(int, struct sshbuf *);",
            "int mm_answer_keyallowed(int, struct sshbuf *);",
            "int mm_answer_keyverify(int, struct sshbuf *);",
            "int mm_answer_pty(int, struct sshbuf *);",
            "int mm_answer_pty_cleanup(int, struct sshbuf *);",
            "int mm_answer_term(int, struct sshbuf *);",
            "int mm_answer_rsa_keyallowed(int, struct sshbuf *);",
            "int mm_answer_rsa_challenge(int, struct sshbuf *);",
            "int mm_answer_rsa_response(int, struct sshbuf *);",
            "int mm_answer_sesskey(int, struct sshbuf *);",
            "int mm_answer_sessid(int, struct sshbuf *);",
            "static int monitor_read_log(struct monitor *);",
            "static Authctxt *authctxt;",
            "static char *auth_method = \"unknown\";",
            "static char *auth_submethod = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MON_ALOG\t0x0020\t/* Log auth attempt without authenticating */\n#define MON_AUTHDECIDE\t0x0008\t/* Decides Authentication */\n\nextern ServerOptions options;\nextern struct sshbuf *loginmsg;\nint mm_answer_moduli(int, struct sshbuf *);\nint mm_answer_sign(int, struct sshbuf *);\nint mm_answer_pwnamallow(int, struct sshbuf *);\nint mm_answer_auth2_read_banner(int, struct sshbuf *);\nint mm_answer_authserv(int, struct sshbuf *);\nint mm_answer_authpassword(int, struct sshbuf *);\nint mm_answer_bsdauthquery(int, struct sshbuf *);\nint mm_answer_bsdauthrespond(int, struct sshbuf *);\nint mm_answer_keyallowed(int, struct sshbuf *);\nint mm_answer_keyverify(int, struct sshbuf *);\nint mm_answer_pty(int, struct sshbuf *);\nint mm_answer_pty_cleanup(int, struct sshbuf *);\nint mm_answer_term(int, struct sshbuf *);\nint mm_answer_rsa_keyallowed(int, struct sshbuf *);\nint mm_answer_rsa_challenge(int, struct sshbuf *);\nint mm_answer_rsa_response(int, struct sshbuf *);\nint mm_answer_sesskey(int, struct sshbuf *);\nint mm_answer_sessid(int, struct sshbuf *);\nstatic int monitor_read_log(struct monitor *);\nstatic Authctxt *authctxt;\nstatic char *auth_method = \"unknown\";\nstatic char *auth_submethod = NULL;\n\nvoid\nmonitor_child_preauth(Authctxt *_authctxt, struct monitor *pmonitor)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tstruct mon_table *ent;\n\tint authenticated = 0, partial = 0;\n\n\tdebug3(\"preauth child monitor started\");\n\n\tif (pmonitor->m_recvfd >= 0)\n\t\tclose(pmonitor->m_recvfd);\n\tif (pmonitor->m_log_sendfd >= 0)\n\t\tclose(pmonitor->m_log_sendfd);\n\tpmonitor->m_log_sendfd = pmonitor->m_recvfd = -1;\n\n\tauthctxt = _authctxt;\n\tmemset(authctxt, 0, sizeof(*authctxt));\n\tssh->authctxt = authctxt;\n\n\tauthctxt->loginmsg = loginmsg;\n\n\tmon_dispatch = mon_dispatch_proto20;\n\t/* Permit requests for moduli and signatures */\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_MODULI, 1);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_SIGN, 1);\n\n\t/* The first few requests do not require asynchronous access */\n\twhile (!authenticated) {\n\t\tpartial = 0;\n\t\tauth_method = \"unknown\";\n\t\tauth_submethod = NULL;\n\t\tauth2_authctxt_reset_info(authctxt);\n\n\t\tauthenticated = (monitor_read(pmonitor, mon_dispatch, &ent) == 1);\n\n\t\t/* Special handling for multiple required authentications */\n\t\tif (options.num_auth_methods != 0) {\n\t\t\tif (authenticated &&\n\t\t\t    !auth2_update_methods_lists(authctxt,\n\t\t\t    auth_method, auth_submethod)) {\n\t\t\t\tdebug3(\"%s: method %s: partial\", __func__,\n\t\t\t\t    auth_method);\n\t\t\t\tauthenticated = 0;\n\t\t\t\tpartial = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (authenticated) {\n\t\t\tif (!(ent->flags & MON_AUTHDECIDE))\n\t\t\t\tfatal(\"%s: unexpected authentication from %d\",\n\t\t\t\t    __func__, ent->type);\n\t\t\tif (authctxt->pw->pw_uid == 0 &&\n\t\t\t    !auth_root_allowed(ssh, auth_method))\n\t\t\t\tauthenticated = 0;\n#ifdef USE_PAM\n\t\t\t/* PAM needs to perform account checks after auth */\n\t\t\tif (options.use_pam && authenticated) {\n\t\t\t\tstruct sshbuf *m;\n\n\t\t\t\tif ((m = sshbuf_new()) == NULL)\n\t\t\t\t\tfatal(\"%s: sshbuf_new failed\",\n\t\t\t\t\t    __func__);\n\t\t\t\tmm_request_receive_expect(pmonitor->m_sendfd,\n\t\t\t\t    MONITOR_REQ_PAM_ACCOUNT, m);\n\t\t\t\tauthenticated = mm_answer_pam_account(\n\t\t\t\t    pmonitor->m_sendfd, m);\n\t\t\t\tsshbuf_free(m);\n\t\t\t}\n#endif\n\t\t}\n\t\tif (ent->flags & (MON_AUTHDECIDE|MON_ALOG)) {\n\t\t\tauth_log(authctxt, authenticated, partial,\n\t\t\t    auth_method, auth_submethod);\n\t\t\tif (!partial && !authenticated)\n\t\t\t\tauthctxt->failures++;\n\t\t\tif (authenticated || partial) {\n\t\t\t\tauth2_update_session_info(authctxt,\n\t\t\t\t    auth_method, auth_submethod);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!authctxt->valid)\n\t\tfatal(\"%s: authenticated invalid user\", __func__);\n\tif (strcmp(auth_method, \"unknown\") == 0)\n\t\tfatal(\"%s: authentication method name unknown\", __func__);\n\n\tdebug(\"%s: %s has been authenticated by privileged process\",\n\t    __func__, authctxt->user);\n\tssh->authctxt = NULL;\n\tssh_packet_set_log_preamble(ssh, \"user %s\", authctxt->user);\n\n\tmm_get_keystate(pmonitor);\n\n\t/* Drain any buffered messages from the child */\n\twhile (pmonitor->m_log_recvfd != -1 && monitor_read_log(pmonitor) == 0)\n\t\t;\n\n\tif (pmonitor->m_recvfd >= 0)\n\t\tclose(pmonitor->m_recvfd);\n\tif (pmonitor->m_log_sendfd >= 0)\n\t\tclose(pmonitor->m_log_sendfd);\n\tpmonitor->m_sendfd = pmonitor->m_log_recvfd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_sandbox_parent_preauth",
          "args": [
            "box",
            "pid"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_sandbox_parent_preauth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sandbox-solaris.c",
          "lines": "108-112",
          "snippet": "void\nssh_sandbox_parent_preauth(struct ssh_sandbox *box, pid_t child_pid)\n{\n\t/* Nothing to do here */\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"log.h\"",
            "# include <priv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"ssh-sandbox.h\"\n#include \"log.h\"\n# include <priv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_sandbox_parent_preauth(struct ssh_sandbox *box, pid_t child_pid)\n{\n\t/* Nothing to do here */\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Could not get agent socket: %s\"",
            "ssh_err(r)"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_get_authentication_socket",
          "args": [
            "&auth_sock"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_get_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "86-120",
          "snippet": "int\nssh_get_authentication_socket(int *fdp)\n{\n\tconst char *authsocket;\n\tint sock, oerrno;\n\tstruct sockaddr_un sunaddr;\n\n\tif (fdp != NULL)\n\t\t*fdp = -1;\n\n\tauthsocket = getenv(SSH_AUTHSOCKET_ENV_NAME);\n\tif (!authsocket)\n\t\treturn SSH_ERR_AGENT_NOT_PRESENT;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tstrlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));\n\n\tif ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\t/* close on exec */\n\tif (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1 ||\n\t    connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\toerrno = errno;\n\t\tclose(sock);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (fdp != NULL)\n\t\t*fdp = sock;\n\telse\n\t\tclose(sock);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_get_authentication_socket(int *fdp)\n{\n\tconst char *authsocket;\n\tint sock, oerrno;\n\tstruct sockaddr_un sunaddr;\n\n\tif (fdp != NULL)\n\t\t*fdp = -1;\n\n\tauthsocket = getenv(SSH_AUTHSOCKET_ENV_NAME);\n\tif (!authsocket)\n\t\treturn SSH_ERR_AGENT_NOT_PRESENT;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tstrlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));\n\n\tif ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\t/* close on exec */\n\tif (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1 ||\n\t    connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\toerrno = errno;\n\t\tclose(sock);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (fdp != NULL)\n\t\t*fdp = sock;\n\telse\n\t\tclose(sock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"Network child is on pid %ld\"",
            "(long)pid"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "69-78",
          "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_sandbox_init",
          "args": [
            "pmonitor"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_sandbox_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sandbox-solaris.c",
          "lines": "45-89",
          "snippet": "struct ssh_sandbox *\nssh_sandbox_init(struct monitor *monitor)\n{\n\tstruct ssh_sandbox *box = NULL;\n\n\tbox = xcalloc(1, sizeof(*box));\n\n\t/* Start with \"basic\" and drop everything we don't need. */\n\tbox->pset = solaris_basic_privset();\n\n\tif (box->pset == NULL) {\n\t\tfree(box);\n\t\treturn NULL;\n\t}\n\n\t/* Drop everything except the ability to use already-opened files */\n\tif (priv_delset(box->pset, PRIV_FILE_LINK_ANY) != 0 ||\n#ifdef PRIV_NET_ACCESS\n\t    priv_delset(box->pset, PRIV_NET_ACCESS) != 0 ||\n#endif\n#ifdef PRIV_DAX_ACCESS\n\t    priv_delset(box->pset, PRIV_DAX_ACCESS) != 0 ||\n#endif\n#ifdef PRIV_SYS_IB_INFO\n\t    priv_delset(box->pset, PRIV_SYS_IB_INFO) != 0 ||\n#endif\n\t    priv_delset(box->pset, PRIV_PROC_EXEC) != 0 ||\n\t    priv_delset(box->pset, PRIV_PROC_FORK) != 0 ||\n\t    priv_delset(box->pset, PRIV_PROC_INFO) != 0 ||\n\t    priv_delset(box->pset, PRIV_PROC_SESSION) != 0) {\n\t\tfree(box);\n\t\treturn NULL;\n\t}\n\n\t/* These may not be available on older Solaris-es */\n# if defined(PRIV_FILE_READ) && defined(PRIV_FILE_WRITE)\n\tif (priv_delset(box->pset, PRIV_FILE_READ) != 0 ||\n\t    priv_delset(box->pset, PRIV_FILE_WRITE) != 0) {\n\t\tfree(box);\n\t\treturn NULL;\n\t}\n# endif\n\n\treturn box;\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"log.h\"",
            "# include <priv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"ssh-sandbox.h\"\n#include \"log.h\"\n# include <priv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct ssh_sandbox *\nssh_sandbox_init(struct monitor *monitor)\n{\n\tstruct ssh_sandbox *box = NULL;\n\n\tbox = xcalloc(1, sizeof(*box));\n\n\t/* Start with \"basic\" and drop everything we don't need. */\n\tbox->pset = solaris_basic_privset();\n\n\tif (box->pset == NULL) {\n\t\tfree(box);\n\t\treturn NULL;\n\t}\n\n\t/* Drop everything except the ability to use already-opened files */\n\tif (priv_delset(box->pset, PRIV_FILE_LINK_ANY) != 0 ||\n#ifdef PRIV_NET_ACCESS\n\t    priv_delset(box->pset, PRIV_NET_ACCESS) != 0 ||\n#endif\n#ifdef PRIV_DAX_ACCESS\n\t    priv_delset(box->pset, PRIV_DAX_ACCESS) != 0 ||\n#endif\n#ifdef PRIV_SYS_IB_INFO\n\t    priv_delset(box->pset, PRIV_SYS_IB_INFO) != 0 ||\n#endif\n\t    priv_delset(box->pset, PRIV_PROC_EXEC) != 0 ||\n\t    priv_delset(box->pset, PRIV_PROC_FORK) != 0 ||\n\t    priv_delset(box->pset, PRIV_PROC_INFO) != 0 ||\n\t    priv_delset(box->pset, PRIV_PROC_SESSION) != 0) {\n\t\tfree(box);\n\t\treturn NULL;\n\t}\n\n\t/* These may not be available on older Solaris-es */\n# if defined(PRIV_FILE_READ) && defined(PRIV_FILE_WRITE)\n\tif (priv_delset(box->pset, PRIV_FILE_READ) != 0 ||\n\t    priv_delset(box->pset, PRIV_FILE_WRITE) != 0) {\n\t\tfree(box);\n\t\treturn NULL;\n\t}\n# endif\n\n\treturn box;\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor_init",
          "args": [],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor.c",
          "lines": "1761-1770",
          "snippet": "struct monitor *\nmonitor_init(void)\n{\n\tstruct monitor *mon;\n\n\tmon = xcalloc(1, sizeof(*mon));\n\tmonitor_openfds(mon, 1);\n\n\treturn mon;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"match.h\"",
            "#include \"authfd.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"sshlogin.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"auth-pam.h\"",
            "#include \"dh.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "#include <openssl/dh.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int monitor_read_log(struct monitor *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"match.h\"\n#include \"authfd.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"monitor_fdpass.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"sshlogin.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"auth-pam.h\"\n#include \"dh.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n#include <openssl/dh.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int monitor_read_log(struct monitor *);\n\nstruct monitor *\nmonitor_init(void)\n{\n\tstruct monitor *mon;\n\n\tmon = xcalloc(1, sizeof(*mon));\n\tmonitor_openfds(mon, 1);\n\n\treturn mon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint auth_sock = -1;\nint have_agent = 0;\nint use_privsep = -1;\nstruct monitor *pmonitor = NULL;\nint privsep_is_preauth = 1;\n\nstatic int\nprivsep_preauth(Authctxt *authctxt)\n{\n\tint status, r;\n\tpid_t pid;\n\tstruct ssh_sandbox *box = NULL;\n\n\t/* Set up unprivileged child process to deal with network data */\n\tpmonitor = monitor_init();\n\t/* Store a pointer to the kex for later rekeying */\n\tpmonitor->m_pkex = &active_state->kex;\n\n\tif (use_privsep == PRIVSEP_ON)\n\t\tbox = ssh_sandbox_init(pmonitor);\n\tpid = fork();\n\tif (pid == -1) {\n\t\tfatal(\"fork of unprivileged child failed\");\n\t} else if (pid != 0) {\n\t\tdebug2(\"Network child is on pid %ld\", (long)pid);\n\n\t\tpmonitor->m_pid = pid;\n\t\tif (have_agent) {\n\t\t\tr = ssh_get_authentication_socket(&auth_sock);\n\t\t\tif (r != 0) {\n\t\t\t\terror(\"Could not get agent socket: %s\",\n\t\t\t\t    ssh_err(r));\n\t\t\t\thave_agent = 0;\n\t\t\t}\n\t\t}\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_preauth(box, pid);\n\t\tmonitor_child_preauth(authctxt, pmonitor);\n\n\t\t/* Wait for the child's exit status */\n\t\twhile (waitpid(pid, &status, 0) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tpmonitor->m_pid = -1;\n\t\t\tfatal(\"%s: waitpid: %s\", __func__, strerror(errno));\n\t\t}\n\t\tprivsep_is_preauth = 0;\n\t\tpmonitor->m_pid = -1;\n\t\tif (WIFEXITED(status)) {\n\t\t\tif (WEXITSTATUS(status) != 0)\n\t\t\t\tfatal(\"%s: preauth child exited with status %d\",\n\t\t\t\t    __func__, WEXITSTATUS(status));\n\t\t} else if (WIFSIGNALED(status))\n\t\t\tfatal(\"%s: preauth child terminated by signal %d\",\n\t\t\t    __func__, WTERMSIG(status));\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_finish(box);\n\t\treturn 1;\n\t} else {\n\t\t/* child */\n\t\tclose(pmonitor->m_sendfd);\n\t\tclose(pmonitor->m_log_recvfd);\n\n\t\t/* Arrange for logging to be sent to the monitor */\n\t\tset_log_handler(mm_log_handler, pmonitor);\n\n\t\tprivsep_preauth_child();\n\t\tsetproctitle(\"%s\", \"[net]\");\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_child(box);\n\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "privsep_preauth_child",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "529-564",
    "snippet": "static void\nprivsep_preauth_child(void)\n{\n\tgid_t gidset[1];\n\n\t/* Enable challenge-response authentication for privilege separation */\n\tprivsep_challenge_enable();\n\n#ifdef GSSAPI\n\t/* Cache supported mechanism OIDs for later use */\n\tssh_gssapi_prepare_supported_oids();\n#endif\n\n\treseed_prngs();\n\n\t/* Demote the private keys to public keys. */\n\tdemote_sensitive_data();\n\n\t/* Demote the child */\n\tif (privsep_chroot) {\n\t\t/* Change our root directory */\n\t\tif (chroot(_PATH_PRIVSEP_CHROOT_DIR) == -1)\n\t\t\tfatal(\"chroot(\\\"%s\\\"): %s\", _PATH_PRIVSEP_CHROOT_DIR,\n\t\t\t    strerror(errno));\n\t\tif (chdir(\"/\") == -1)\n\t\t\tfatal(\"chdir(\\\"/\\\"): %s\", strerror(errno));\n\n\t\t/* Drop our privileges */\n\t\tdebug3(\"privsep user:group %u:%u\", (u_int)privsep_pw->pw_uid,\n\t\t    (u_int)privsep_pw->pw_gid);\n\t\tgidset[0] = privsep_pw->pw_gid;\n\t\tif (setgroups(1, gidset) < 0)\n\t\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\t\tpermanently_set_uid(privsep_pw);\n\t}\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int privsep_chroot = 1;",
      "struct passwd *privsep_pw = NULL;",
      "void demote_sensitive_data(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "permanently_set_uid",
          "args": [
            "privsep_pw"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "permanently_set_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "178-236",
          "snippet": "void\npermanently_set_uid(struct passwd *pw)\n{\n#ifndef NO_UID_RESTORATION_TEST\n\tuid_t old_uid = getuid();\n\tgid_t old_gid = getgid();\n#endif\n\n\tif (pw == NULL)\n\t\tfatal(\"permanently_set_uid: no user given\");\n\tif (temporarily_use_uid_effective)\n\t\tfatal(\"permanently_set_uid: temporarily_use_uid effective\");\n\tdebug(\"permanently_set_uid: %u/%u\", (u_int)pw->pw_uid,\n\t    (u_int)pw->pw_gid);\n\n\tif (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) < 0)\n\t\tfatal(\"setresgid %u: %.100s\", (u_int)pw->pw_gid, strerror(errno));\n\n#ifdef __APPLE__\n\t/*\n\t * OS X requires initgroups after setgid to opt back into\n\t * memberd support for >16 supplemental groups.\n\t */\n\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\tfatal(\"initgroups %.100s %u: %.100s\",\n\t\t    pw->pw_name, (u_int)pw->pw_gid, strerror(errno));\n#endif\n\n\tif (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) < 0)\n\t\tfatal(\"setresuid %u: %.100s\", (u_int)pw->pw_uid, strerror(errno));\n\n#ifndef NO_UID_RESTORATION_TEST\n\t/* Try restoration of GID if changed (test clearing of saved gid) */\n\tif (old_gid != pw->pw_gid && pw->pw_uid != 0 &&\n\t    (setgid(old_gid) != -1 || setegid(old_gid) != -1))\n\t\tfatal(\"%s: was able to restore old [e]gid\", __func__);\n#endif\n\n\t/* Verify GID drop was successful */\n\tif (getgid() != pw->pw_gid || getegid() != pw->pw_gid) {\n\t\tfatal(\"%s: egid incorrect gid:%u egid:%u (should be %u)\",\n\t\t    __func__, (u_int)getgid(), (u_int)getegid(),\n\t\t    (u_int)pw->pw_gid);\n\t}\n\n#ifndef NO_UID_RESTORATION_TEST\n\t/* Try restoration of UID if changed (test clearing of saved uid) */\n\tif (old_uid != pw->pw_uid &&\n\t    (setuid(old_uid) != -1 || seteuid(old_uid) != -1))\n\t\tfatal(\"%s: was able to restore old [e]uid\", __func__);\n#endif\n\n\t/* Verify UID drop was successful */\n\tif (getuid() != pw->pw_uid || geteuid() != pw->pw_uid) {\n\t\tfatal(\"%s: euid incorrect uid:%u euid:%u (should be %u)\",\n\t\t    __func__, (u_int)getuid(), (u_int)geteuid(),\n\t\t    (u_int)pw->pw_uid);\n\t}\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttemporarily_use_uid_effective = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\nstatic int\ttemporarily_use_uid_effective = 0;\n\nvoid\npermanently_set_uid(struct passwd *pw)\n{\n#ifndef NO_UID_RESTORATION_TEST\n\tuid_t old_uid = getuid();\n\tgid_t old_gid = getgid();\n#endif\n\n\tif (pw == NULL)\n\t\tfatal(\"permanently_set_uid: no user given\");\n\tif (temporarily_use_uid_effective)\n\t\tfatal(\"permanently_set_uid: temporarily_use_uid effective\");\n\tdebug(\"permanently_set_uid: %u/%u\", (u_int)pw->pw_uid,\n\t    (u_int)pw->pw_gid);\n\n\tif (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) < 0)\n\t\tfatal(\"setresgid %u: %.100s\", (u_int)pw->pw_gid, strerror(errno));\n\n#ifdef __APPLE__\n\t/*\n\t * OS X requires initgroups after setgid to opt back into\n\t * memberd support for >16 supplemental groups.\n\t */\n\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\tfatal(\"initgroups %.100s %u: %.100s\",\n\t\t    pw->pw_name, (u_int)pw->pw_gid, strerror(errno));\n#endif\n\n\tif (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) < 0)\n\t\tfatal(\"setresuid %u: %.100s\", (u_int)pw->pw_uid, strerror(errno));\n\n#ifndef NO_UID_RESTORATION_TEST\n\t/* Try restoration of GID if changed (test clearing of saved gid) */\n\tif (old_gid != pw->pw_gid && pw->pw_uid != 0 &&\n\t    (setgid(old_gid) != -1 || setegid(old_gid) != -1))\n\t\tfatal(\"%s: was able to restore old [e]gid\", __func__);\n#endif\n\n\t/* Verify GID drop was successful */\n\tif (getgid() != pw->pw_gid || getegid() != pw->pw_gid) {\n\t\tfatal(\"%s: egid incorrect gid:%u egid:%u (should be %u)\",\n\t\t    __func__, (u_int)getgid(), (u_int)getegid(),\n\t\t    (u_int)pw->pw_gid);\n\t}\n\n#ifndef NO_UID_RESTORATION_TEST\n\t/* Try restoration of UID if changed (test clearing of saved uid) */\n\tif (old_uid != pw->pw_uid &&\n\t    (setuid(old_uid) != -1 || seteuid(old_uid) != -1))\n\t\tfatal(\"%s: was able to restore old [e]uid\", __func__);\n#endif\n\n\t/* Verify UID drop was successful */\n\tif (getuid() != pw->pw_uid || geteuid() != pw->pw_uid) {\n\t\tfatal(\"%s: euid incorrect uid:%u euid:%u (should be %u)\",\n\t\t    __func__, (u_int)getuid(), (u_int)geteuid(),\n\t\t    (u_int)pw->pw_uid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"setgroups: %.100s\"",
            "strerror(errno)"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "1",
            "gidset"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"privsep user:group %u:%u\"",
            "(u_int)privsep_pw->pw_uid",
            "(u_int)privsep_pw->pw_gid"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"chroot(\\\"%s\\\"): %s\"",
            "_PATH_PRIVSEP_CHROOT_DIR",
            "strerror(errno)"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chroot",
          "args": [
            "_PATH_PRIVSEP_CHROOT_DIR"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "demote_sensitive_data",
          "args": [],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "demote_sensitive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "487-506",
          "snippet": "void\ndemote_sensitive_data(void)\n{\n\tstruct sshkey *tmp;\n\tu_int i;\n\tint r;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tif (sensitive_data.host_keys[i]) {\n\t\t\tif ((r = sshkey_from_private(\n\t\t\t    sensitive_data.host_keys[i], &tmp)) != 0)\n\t\t\t\tfatal(\"could not demote host %s key: %s\",\n\t\t\t\t    sshkey_type(sensitive_data.host_keys[i]),\n\t\t\t\t    ssh_err(r));\n\t\t\tsshkey_free(sensitive_data.host_keys[i]);\n\t\t\tsensitive_data.host_keys[i] = tmp;\n\t\t}\n\t\t/* Certs do not need demotion */\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;",
            "struct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;",
            "void demote_sensitive_data(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nstruct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;\nvoid demote_sensitive_data(void);\n\nvoid\ndemote_sensitive_data(void)\n{\n\tstruct sshkey *tmp;\n\tu_int i;\n\tint r;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tif (sensitive_data.host_keys[i]) {\n\t\t\tif ((r = sshkey_from_private(\n\t\t\t    sensitive_data.host_keys[i], &tmp)) != 0)\n\t\t\t\tfatal(\"could not demote host %s key: %s\",\n\t\t\t\t    sshkey_type(sensitive_data.host_keys[i]),\n\t\t\t\t    ssh_err(r));\n\t\t\tsshkey_free(sensitive_data.host_keys[i]);\n\t\t\tsensitive_data.host_keys[i] = tmp;\n\t\t}\n\t\t/* Certs do not need demotion */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reseed_prngs",
          "args": [],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "reseed_prngs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "508-527",
          "snippet": "static void\nreseed_prngs(void)\n{\n\tu_int32_t rnd[256];\n\n#ifdef WITH_OPENSSL\n\tRAND_poll();\n#endif\n\tarc4random_stir(); /* noop on recent arc4random() implementations */\n\tarc4random_buf(rnd, sizeof(rnd)); /* let arc4random notice PID change */\n\n#ifdef WITH_OPENSSL\n\tRAND_seed(rnd, sizeof(rnd));\n\t/* give libcrypto a chance to notice the PID change */\n\tif ((RAND_bytes((u_char *)rnd, 1)) != 1)\n\t\tfatal(\"%s: RAND_bytes failed\", __func__);\n#endif\n\n\texplicit_bzero(rnd, sizeof(rnd));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nreseed_prngs(void)\n{\n\tu_int32_t rnd[256];\n\n#ifdef WITH_OPENSSL\n\tRAND_poll();\n#endif\n\tarc4random_stir(); /* noop on recent arc4random() implementations */\n\tarc4random_buf(rnd, sizeof(rnd)); /* let arc4random notice PID change */\n\n#ifdef WITH_OPENSSL\n\tRAND_seed(rnd, sizeof(rnd));\n\t/* give libcrypto a chance to notice the PID change */\n\tif ((RAND_bytes((u_char *)rnd, 1)) != 1)\n\t\tfatal(\"%s: RAND_bytes failed\", __func__);\n#endif\n\n\texplicit_bzero(rnd, sizeof(rnd));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_prepare_supported_oids",
          "args": [],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_prepare_supported_oids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-serv.c",
          "lines": "76-80",
          "snippet": "void\nssh_gssapi_prepare_supported_oids(void)\n{\n\tssh_gssapi_supported_oids(&supported_oids);\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_gssapi_prepare_supported_oids(void)\n{\n\tssh_gssapi_supported_oids(&supported_oids);\n}"
        }
      },
      {
        "call_info": {
          "callee": "privsep_challenge_enable",
          "args": [],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "privsep_challenge_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
          "lines": "363-383",
          "snippet": "void\nprivsep_challenge_enable(void)\n{\n#if defined(BSD_AUTH) || defined(USE_PAM)\n\tint n = 0;\n#endif\n#ifdef BSD_AUTH\n\textern KbdintDevice mm_bsdauth_device;\n#endif\n#ifdef USE_PAM\n\textern KbdintDevice mm_sshpam_device;\n#endif\n\n#ifdef BSD_AUTH\n\tdevices[n++] = &mm_bsdauth_device;\n#else\n#ifdef USE_PAM\n\tdevices[n++] = &mm_sshpam_device;\n#endif\n#endif\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "KbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nKbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};\n\nvoid\nprivsep_challenge_enable(void)\n{\n#if defined(BSD_AUTH) || defined(USE_PAM)\n\tint n = 0;\n#endif\n#ifdef BSD_AUTH\n\textern KbdintDevice mm_bsdauth_device;\n#endif\n#ifdef USE_PAM\n\textern KbdintDevice mm_sshpam_device;\n#endif\n\n#ifdef BSD_AUTH\n\tdevices[n++] = &mm_bsdauth_device;\n#else\n#ifdef USE_PAM\n\tdevices[n++] = &mm_sshpam_device;\n#endif\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int privsep_chroot = 1;\nstruct passwd *privsep_pw = NULL;\nvoid demote_sensitive_data(void);\n\nstatic void\nprivsep_preauth_child(void)\n{\n\tgid_t gidset[1];\n\n\t/* Enable challenge-response authentication for privilege separation */\n\tprivsep_challenge_enable();\n\n#ifdef GSSAPI\n\t/* Cache supported mechanism OIDs for later use */\n\tssh_gssapi_prepare_supported_oids();\n#endif\n\n\treseed_prngs();\n\n\t/* Demote the private keys to public keys. */\n\tdemote_sensitive_data();\n\n\t/* Demote the child */\n\tif (privsep_chroot) {\n\t\t/* Change our root directory */\n\t\tif (chroot(_PATH_PRIVSEP_CHROOT_DIR) == -1)\n\t\t\tfatal(\"chroot(\\\"%s\\\"): %s\", _PATH_PRIVSEP_CHROOT_DIR,\n\t\t\t    strerror(errno));\n\t\tif (chdir(\"/\") == -1)\n\t\t\tfatal(\"chdir(\\\"/\\\"): %s\", strerror(errno));\n\n\t\t/* Drop our privileges */\n\t\tdebug3(\"privsep user:group %u:%u\", (u_int)privsep_pw->pw_uid,\n\t\t    (u_int)privsep_pw->pw_gid);\n\t\tgidset[0] = privsep_pw->pw_gid;\n\t\tif (setgroups(1, gidset) < 0)\n\t\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\t\tpermanently_set_uid(privsep_pw);\n\t}\n}"
  },
  {
    "function_name": "reseed_prngs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "508-527",
    "snippet": "static void\nreseed_prngs(void)\n{\n\tu_int32_t rnd[256];\n\n#ifdef WITH_OPENSSL\n\tRAND_poll();\n#endif\n\tarc4random_stir(); /* noop on recent arc4random() implementations */\n\tarc4random_buf(rnd, sizeof(rnd)); /* let arc4random notice PID change */\n\n#ifdef WITH_OPENSSL\n\tRAND_seed(rnd, sizeof(rnd));\n\t/* give libcrypto a chance to notice the PID change */\n\tif ((RAND_bytes((u_char *)rnd, 1)) != 1)\n\t\tfatal(\"%s: RAND_bytes failed\", __func__);\n#endif\n\n\texplicit_bzero(rnd, sizeof(rnd));\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "rnd",
            "sizeof(rnd)"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: RAND_bytes failed\"",
            "__func__"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAND_bytes",
          "args": [
            "(u_char *)rnd",
            "1"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_seed",
          "args": [
            "rnd",
            "sizeof(rnd)"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arc4random_buf",
          "args": [
            "rnd",
            "sizeof(rnd)"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "263-277",
          "snippet": "void\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "arc4random_stir",
          "args": [],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random_stir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "210-216",
          "snippet": "void\narc4random_stir(void)\n{\n\t_ARC4_LOCK();\n\t_rs_stir();\n\t_ARC4_UNLOCK();\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\narc4random_stir(void)\n{\n\t_ARC4_LOCK();\n\t_rs_stir();\n\t_ARC4_UNLOCK();\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAND_poll",
          "args": [],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nreseed_prngs(void)\n{\n\tu_int32_t rnd[256];\n\n#ifdef WITH_OPENSSL\n\tRAND_poll();\n#endif\n\tarc4random_stir(); /* noop on recent arc4random() implementations */\n\tarc4random_buf(rnd, sizeof(rnd)); /* let arc4random notice PID change */\n\n#ifdef WITH_OPENSSL\n\tRAND_seed(rnd, sizeof(rnd));\n\t/* give libcrypto a chance to notice the PID change */\n\tif ((RAND_bytes((u_char *)rnd, 1)) != 1)\n\t\tfatal(\"%s: RAND_bytes failed\", __func__);\n#endif\n\n\texplicit_bzero(rnd, sizeof(rnd));\n}"
  },
  {
    "function_name": "demote_sensitive_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "487-506",
    "snippet": "void\ndemote_sensitive_data(void)\n{\n\tstruct sshkey *tmp;\n\tu_int i;\n\tint r;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tif (sensitive_data.host_keys[i]) {\n\t\t\tif ((r = sshkey_from_private(\n\t\t\t    sensitive_data.host_keys[i], &tmp)) != 0)\n\t\t\t\tfatal(\"could not demote host %s key: %s\",\n\t\t\t\t    sshkey_type(sensitive_data.host_keys[i]),\n\t\t\t\t    ssh_err(r));\n\t\t\tsshkey_free(sensitive_data.host_keys[i]);\n\t\t\tsensitive_data.host_keys[i] = tmp;\n\t\t}\n\t\t/* Certs do not need demotion */\n\t}\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ServerOptions options;",
      "struct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;",
      "void demote_sensitive_data(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "sensitive_data.host_keys[i]"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"could not demote host %s key: %s\"",
            "sshkey_type(sensitive_data.host_keys[i])",
            "ssh_err(r)"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "sensitive_data.host_keys[i]"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_private",
          "args": [
            "sensitive_data.host_keys[i]",
            "&tmp"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1726-1868",
          "snippet": "int\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nstruct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;\nvoid demote_sensitive_data(void);\n\nvoid\ndemote_sensitive_data(void)\n{\n\tstruct sshkey *tmp;\n\tu_int i;\n\tint r;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tif (sensitive_data.host_keys[i]) {\n\t\t\tif ((r = sshkey_from_private(\n\t\t\t    sensitive_data.host_keys[i], &tmp)) != 0)\n\t\t\t\tfatal(\"could not demote host %s key: %s\",\n\t\t\t\t    sshkey_type(sensitive_data.host_keys[i]),\n\t\t\t\t    ssh_err(r));\n\t\t\tsshkey_free(sensitive_data.host_keys[i]);\n\t\t\tsensitive_data.host_keys[i] = tmp;\n\t\t}\n\t\t/* Certs do not need demotion */\n\t}\n}"
  },
  {
    "function_name": "destroy_sensitive_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "469-484",
    "snippet": "void\ndestroy_sensitive_data(void)\n{\n\tu_int i;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tif (sensitive_data.host_keys[i]) {\n\t\t\tsshkey_free(sensitive_data.host_keys[i]);\n\t\t\tsensitive_data.host_keys[i] = NULL;\n\t\t}\n\t\tif (sensitive_data.host_certificates[i]) {\n\t\t\tsshkey_free(sensitive_data.host_certificates[i]);\n\t\t\tsensitive_data.host_certificates[i] = NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ServerOptions options;",
      "struct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;",
      "void destroy_sensitive_data(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "sensitive_data.host_certificates[i]"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nstruct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;\nvoid destroy_sensitive_data(void);\n\nvoid\ndestroy_sensitive_data(void)\n{\n\tu_int i;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tif (sensitive_data.host_keys[i]) {\n\t\t\tsshkey_free(sensitive_data.host_keys[i]);\n\t\t\tsensitive_data.host_keys[i] = NULL;\n\t\t}\n\t\tif (sensitive_data.host_certificates[i]) {\n\t\t\tsshkey_free(sensitive_data.host_certificates[i]);\n\t\t\tsensitive_data.host_certificates[i] = NULL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "sshd_exchange_identification",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "366-466",
    "snippet": "static void\nsshd_exchange_identification(struct ssh *ssh, int sock_in, int sock_out)\n{\n\tu_int i;\n\tint remote_major, remote_minor;\n\tchar *s;\n\tchar buf[256];\t\t\t/* Must not be larger than remote_version. */\n\tchar remote_version[256];\t/* Must be at least as big as buf. */\n\n\txasprintf(&server_version_string, \"SSH-%d.%d-%.100s%s%s\\r\\n\",\n\t    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_VERSION,\n\t    *options.version_addendum == '\\0' ? \"\" : \" \",\n\t    options.version_addendum);\n\n\t/* Send our protocol version identification. */\n\tif (atomicio(vwrite, sock_out, server_version_string,\n\t    strlen(server_version_string))\n\t    != strlen(server_version_string)) {\n\t\tlogit(\"Could not write ident string to %s port %d\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\tcleanup_exit(255);\n\t}\n\n\t/* Read other sides version identification. */\n\tmemset(buf, 0, sizeof(buf));\n\tfor (i = 0; i < sizeof(buf) - 1; i++) {\n\t\tif (atomicio(read, sock_in, &buf[i], 1) != 1) {\n\t\t\tlogit(\"Did not receive identification string \"\n\t\t\t    \"from %s port %d\",\n\t\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\t\tcleanup_exit(255);\n\t\t}\n\t\tif (buf[i] == '\\r') {\n\t\t\tbuf[i] = 0;\n\t\t\t/* Kludge for F-Secure Macintosh < 1.0.2 */\n\t\t\tif (i == 12 &&\n\t\t\t    strncmp(buf, \"SSH-1.5-W1.0\", 12) == 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[i] == '\\n') {\n\t\t\tbuf[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbuf[sizeof(buf) - 1] = 0;\n\tclient_version_string = xstrdup(buf);\n\n\t/*\n\t * Check that the versions match.  In future this might accept\n\t * several versions and set appropriate flags to handle them.\n\t */\n\tif (sscanf(client_version_string, \"SSH-%d.%d-%[^\\n]\\n\",\n\t    &remote_major, &remote_minor, remote_version) != 3) {\n\t\ts = \"Protocol mismatch.\\n\";\n\t\t(void) atomicio(vwrite, sock_out, s, strlen(s));\n\t\tlogit(\"Bad protocol version identification '%.100s' \"\n\t\t    \"from %s port %d\", client_version_string,\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\tclose(sock_in);\n\t\tclose(sock_out);\n\t\tcleanup_exit(255);\n\t}\n\tdebug(\"Client protocol version %d.%d; client software version %.100s\",\n\t    remote_major, remote_minor, remote_version);\n\n\tssh->compat = compat_datafellows(remote_version);\n\n\tif ((ssh->compat & SSH_BUG_PROBE) != 0) {\n\t\tlogit(\"probed from %s port %d with %s.  Don't panic.\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    client_version_string);\n\t\tcleanup_exit(255);\n\t}\n\tif ((ssh->compat & SSH_BUG_SCANNER) != 0) {\n\t\tlogit(\"scanned from %s port %d with %s.  Don't panic.\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    client_version_string);\n\t\tcleanup_exit(255);\n\t}\n\tif ((ssh->compat & SSH_BUG_RSASIGMD5) != 0) {\n\t\tlogit(\"Client version \\\"%.100s\\\" uses unsafe RSA signature \"\n\t\t    \"scheme; disabling use of RSA keys\", remote_version);\n\t}\n\n\tchop(server_version_string);\n\tdebug(\"Local version string %.200s\", server_version_string);\n\n\tif (remote_major != 2 &&\n\t    !(remote_major == 1 && remote_minor == 99)) {\n\t\ts = \"Protocol major versions differ.\\n\";\n\t\t(void) atomicio(vwrite, sock_out, s, strlen(s));\n\t\tclose(sock_in);\n\t\tclose(sock_out);\n\t\tlogit(\"Protocol major versions differ for %s port %d: \"\n\t\t    \"%.200s vs. %.200s\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    server_version_string, client_version_string);\n\t\tcleanup_exit(255);\n\t}\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ServerOptions options;",
      "char *client_version_string = NULL;",
      "char *server_version_string = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_exit",
          "args": [
            "255"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "2331-2353",
          "snippet": "void\ncleanup_exit(int i)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (the_authctxt) {\n\t\tdo_cleanup(ssh, the_authctxt);\n\t\tif (use_privsep && privsep_is_preauth &&\n\t\t    pmonitor != NULL && pmonitor->m_pid > 1) {\n\t\t\tdebug(\"Killing privsep child %d\", pmonitor->m_pid);\n\t\t\tif (kill(pmonitor->m_pid, SIGKILL) != 0 &&\n\t\t\t    errno != ESRCH)\n\t\t\t\terror(\"%s: kill(%d): %s\", __func__,\n\t\t\t\t    pmonitor->m_pid, strerror(errno));\n\t\t}\n\t}\n#ifdef SSH_AUDIT_EVENTS\n\t/* done after do_cleanup so it can cancel the PAM auth 'thread' */\n\tif (!use_privsep || mm_is_monitor())\n\t\taudit_event(SSH_CONNECTION_ABANDON);\n#endif\n\t_exit(i);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int use_privsep = -1;",
            "struct monitor *pmonitor = NULL;",
            "int privsep_is_preauth = 1;",
            "Authctxt *the_authctxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint use_privsep = -1;\nstruct monitor *pmonitor = NULL;\nint privsep_is_preauth = 1;\nAuthctxt *the_authctxt = NULL;\n\nvoid\ncleanup_exit(int i)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (the_authctxt) {\n\t\tdo_cleanup(ssh, the_authctxt);\n\t\tif (use_privsep && privsep_is_preauth &&\n\t\t    pmonitor != NULL && pmonitor->m_pid > 1) {\n\t\t\tdebug(\"Killing privsep child %d\", pmonitor->m_pid);\n\t\t\tif (kill(pmonitor->m_pid, SIGKILL) != 0 &&\n\t\t\t    errno != ESRCH)\n\t\t\t\terror(\"%s: kill(%d): %s\", __func__,\n\t\t\t\t    pmonitor->m_pid, strerror(errno));\n\t\t}\n\t}\n#ifdef SSH_AUDIT_EVENTS\n\t/* done after do_cleanup so it can cancel the PAM auth 'thread' */\n\tif (!use_privsep || mm_is_monitor())\n\t\taudit_event(SSH_CONNECTION_ABANDON);\n#endif\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Protocol major versions differ for %s port %d: \"\n\t\t    \"%.200s vs. %.200s\"",
            "ssh_remote_ipaddr(ssh)",
            "ssh_remote_port(ssh)",
            "server_version_string",
            "client_version_string"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_port",
          "args": [
            "ssh"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "539-544",
          "snippet": "int\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock_out"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "vwrite",
            "sock_out",
            "s",
            "strlen(s)"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Local version string %.200s\"",
            "server_version_string"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chop",
          "args": [
            "server_version_string"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "chop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "76-89",
          "snippet": "char *\nchop(char *s)\n{\n\tchar *t = s;\n\twhile (*t) {\n\t\tif (*t == '\\n' || *t == '\\r') {\n\t\t\t*t = '\\0';\n\t\t\treturn s;\n\t\t}\n\t\tt++;\n\t}\n\treturn s;\n\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nchop(char *s)\n{\n\tchar *t = s;\n\twhile (*t) {\n\t\tif (*t == '\\n' || *t == '\\r') {\n\t\t\t*t = '\\0';\n\t\t\treturn s;\n\t\t}\n\t\tt++;\n\t}\n\treturn s;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_datafellows",
          "args": [
            "remote_version"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "compat_datafellows",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/compat.c",
          "lines": "44-158",
          "snippet": "u_int\ncompat_datafellows(const char *version)\n{\n\tint i;\n\tstatic struct {\n\t\tchar\t*pat;\n\t\tint\tbugs;\n\t} check[] = {\n\t\t{ \"OpenSSH_2.*,\"\n\t\t  \"OpenSSH_3.0*,\"\n\t\t  \"OpenSSH_3.1*\",\tSSH_BUG_EXTEOF|SSH_OLD_FORWARD_ADDR|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_3.*\",\tSSH_OLD_FORWARD_ADDR|SSH_BUG_SIGTYPE },\n\t\t{ \"Sun_SSH_1.0*\",\tSSH_BUG_NOREKEY|SSH_BUG_EXTEOF|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_2*,\"\n\t\t  \"OpenSSH_3*,\"\n\t\t  \"OpenSSH_4*\",\t\tSSH_BUG_SIGTYPE },\n\t\t{ \"OpenSSH_5*\",\t\tSSH_NEW_OPENSSH|SSH_BUG_DYNAMIC_RPORT|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_6.6.1*\",\tSSH_NEW_OPENSSH|SSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_6.5*,\"\n\t\t  \"OpenSSH_6.6*\",\tSSH_NEW_OPENSSH|SSH_BUG_CURVE25519PAD|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_7.0*,\"\n\t\t  \"OpenSSH_7.1*,\"\n\t\t  \"OpenSSH_7.2*,\"\n\t\t  \"OpenSSH_7.3*,\"\n\t\t  \"OpenSSH_7.4*,\"\n\t\t  \"OpenSSH_7.5*,\"\n\t\t  \"OpenSSH_7.6*,\"\n\t\t  \"OpenSSH_7.7*\",\tSSH_NEW_OPENSSH|SSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH*\",\t\tSSH_NEW_OPENSSH },\n\t\t{ \"*MindTerm*\",\t\t0 },\n\t\t{ \"3.0.*\",\t\tSSH_BUG_DEBUG },\n\t\t{ \"3.0 SecureCRT*\",\tSSH_OLD_SESSIONID },\n\t\t{ \"1.7 SecureFX*\",\tSSH_OLD_SESSIONID },\n\t\t{ \"1.2.18*,\"\n\t\t  \"1.2.19*,\"\n\t\t  \"1.2.20*,\"\n\t\t  \"1.2.21*,\"\n\t\t  \"1.2.22*\",\t\tSSH_BUG_IGNOREMSG },\n\t\t{ \"1.3.2*\",\t\t/* F-Secure */\n\t\t\t\t\tSSH_BUG_IGNOREMSG },\n\t\t{ \"Cisco-1.*\",\t\tSSH_BUG_DHGEX_LARGE|\n\t\t\t\t\tSSH_BUG_HOSTKEYS },\n\t\t{ \"*SSH Compatible Server*\",\t\t\t/* Netscreen */\n\t\t\t\t\tSSH_BUG_PASSWORDPAD },\n\t\t{ \"*OSU_0*,\"\n\t\t  \"OSU_1.0*,\"\n\t\t  \"OSU_1.1*,\"\n\t\t  \"OSU_1.2*,\"\n\t\t  \"OSU_1.3*,\"\n\t\t  \"OSU_1.4*,\"\n\t\t  \"OSU_1.5alpha1*,\"\n\t\t  \"OSU_1.5alpha2*,\"\n\t\t  \"OSU_1.5alpha3*\",\tSSH_BUG_PASSWORDPAD },\n\t\t{ \"*SSH_Version_Mapper*\",\n\t\t\t\t\tSSH_BUG_SCANNER },\n\t\t{ \"PuTTY_Local:*,\"\t/* dev versions < Sep 2014 */\n\t\t  \"PuTTY-Release-0.5*,\" /* 0.50-0.57, DH-GEX in >=0.52 */\n\t\t  \"PuTTY_Release_0.5*,\"\t/* 0.58-0.59 */\n\t\t  \"PuTTY_Release_0.60*,\"\n\t\t  \"PuTTY_Release_0.61*,\"\n\t\t  \"PuTTY_Release_0.62*,\"\n\t\t  \"PuTTY_Release_0.63*,\"\n\t\t  \"PuTTY_Release_0.64*\",\n\t\t\t\t\tSSH_OLD_DHGEX },\n\t\t{ \"FuTTY*\",\t\tSSH_OLD_DHGEX }, /* Putty Fork */\n\t\t{ \"Probe-*\",\n\t\t\t\t\tSSH_BUG_PROBE },\n\t\t{ \"TeraTerm SSH*,\"\n\t\t  \"TTSSH/1.5.*,\"\n\t\t  \"TTSSH/2.1*,\"\n\t\t  \"TTSSH/2.2*,\"\n\t\t  \"TTSSH/2.3*,\"\n\t\t  \"TTSSH/2.4*,\"\n\t\t  \"TTSSH/2.5*,\"\n\t\t  \"TTSSH/2.6*,\"\n\t\t  \"TTSSH/2.70*,\"\n\t\t  \"TTSSH/2.71*,\"\n\t\t  \"TTSSH/2.72*\",\tSSH_BUG_HOSTKEYS },\n\t\t{ \"WinSCP_release_4*,\"\n\t\t  \"WinSCP_release_5.0*,\"\n\t\t  \"WinSCP_release_5.1,\"\n\t\t  \"WinSCP_release_5.1.*,\"\n\t\t  \"WinSCP_release_5.5,\"\n\t\t  \"WinSCP_release_5.5.*,\"\n\t\t  \"WinSCP_release_5.6,\"\n\t\t  \"WinSCP_release_5.6.*,\"\n\t\t  \"WinSCP_release_5.7,\"\n\t\t  \"WinSCP_release_5.7.1,\"\n\t\t  \"WinSCP_release_5.7.2,\"\n\t\t  \"WinSCP_release_5.7.3,\"\n\t\t  \"WinSCP_release_5.7.4\",\n\t\t\t\t\tSSH_OLD_DHGEX },\n\t\t{ \"ConfD-*\",\n\t\t\t\t\tSSH_BUG_UTF8TTYMODE },\n\t\t{ \"Twisted_*\",\t\t0 },\n\t\t{ \"Twisted*\",\t\tSSH_BUG_DEBUG },\n\t\t{ NULL,\t\t\t0 }\n\t};\n\n\t/* process table, return first match */\n\tfor (i = 0; check[i].pat; i++) {\n\t\tif (match_pattern_list(version, check[i].pat, 0) == 1) {\n\t\t\tdebug(\"match: %s pat %s compat 0x%08x\",\n\t\t\t    version, check[i].pat, check[i].bugs);\n\t\t\tdatafellows = check[i].bugs;\t/* XXX for now */\n\t\t\treturn check[i].bugs;\n\t\t}\n\t}\n\tdebug(\"no match: %s\", version);\n\treturn 0;\n}",
          "includes": [
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int datafellows = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kex.h\"\n#include \"match.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint datafellows = 0;\n\nu_int\ncompat_datafellows(const char *version)\n{\n\tint i;\n\tstatic struct {\n\t\tchar\t*pat;\n\t\tint\tbugs;\n\t} check[] = {\n\t\t{ \"OpenSSH_2.*,\"\n\t\t  \"OpenSSH_3.0*,\"\n\t\t  \"OpenSSH_3.1*\",\tSSH_BUG_EXTEOF|SSH_OLD_FORWARD_ADDR|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_3.*\",\tSSH_OLD_FORWARD_ADDR|SSH_BUG_SIGTYPE },\n\t\t{ \"Sun_SSH_1.0*\",\tSSH_BUG_NOREKEY|SSH_BUG_EXTEOF|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_2*,\"\n\t\t  \"OpenSSH_3*,\"\n\t\t  \"OpenSSH_4*\",\t\tSSH_BUG_SIGTYPE },\n\t\t{ \"OpenSSH_5*\",\t\tSSH_NEW_OPENSSH|SSH_BUG_DYNAMIC_RPORT|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_6.6.1*\",\tSSH_NEW_OPENSSH|SSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_6.5*,\"\n\t\t  \"OpenSSH_6.6*\",\tSSH_NEW_OPENSSH|SSH_BUG_CURVE25519PAD|\n\t\t\t\t\tSSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH_7.0*,\"\n\t\t  \"OpenSSH_7.1*,\"\n\t\t  \"OpenSSH_7.2*,\"\n\t\t  \"OpenSSH_7.3*,\"\n\t\t  \"OpenSSH_7.4*,\"\n\t\t  \"OpenSSH_7.5*,\"\n\t\t  \"OpenSSH_7.6*,\"\n\t\t  \"OpenSSH_7.7*\",\tSSH_NEW_OPENSSH|SSH_BUG_SIGTYPE},\n\t\t{ \"OpenSSH*\",\t\tSSH_NEW_OPENSSH },\n\t\t{ \"*MindTerm*\",\t\t0 },\n\t\t{ \"3.0.*\",\t\tSSH_BUG_DEBUG },\n\t\t{ \"3.0 SecureCRT*\",\tSSH_OLD_SESSIONID },\n\t\t{ \"1.7 SecureFX*\",\tSSH_OLD_SESSIONID },\n\t\t{ \"1.2.18*,\"\n\t\t  \"1.2.19*,\"\n\t\t  \"1.2.20*,\"\n\t\t  \"1.2.21*,\"\n\t\t  \"1.2.22*\",\t\tSSH_BUG_IGNOREMSG },\n\t\t{ \"1.3.2*\",\t\t/* F-Secure */\n\t\t\t\t\tSSH_BUG_IGNOREMSG },\n\t\t{ \"Cisco-1.*\",\t\tSSH_BUG_DHGEX_LARGE|\n\t\t\t\t\tSSH_BUG_HOSTKEYS },\n\t\t{ \"*SSH Compatible Server*\",\t\t\t/* Netscreen */\n\t\t\t\t\tSSH_BUG_PASSWORDPAD },\n\t\t{ \"*OSU_0*,\"\n\t\t  \"OSU_1.0*,\"\n\t\t  \"OSU_1.1*,\"\n\t\t  \"OSU_1.2*,\"\n\t\t  \"OSU_1.3*,\"\n\t\t  \"OSU_1.4*,\"\n\t\t  \"OSU_1.5alpha1*,\"\n\t\t  \"OSU_1.5alpha2*,\"\n\t\t  \"OSU_1.5alpha3*\",\tSSH_BUG_PASSWORDPAD },\n\t\t{ \"*SSH_Version_Mapper*\",\n\t\t\t\t\tSSH_BUG_SCANNER },\n\t\t{ \"PuTTY_Local:*,\"\t/* dev versions < Sep 2014 */\n\t\t  \"PuTTY-Release-0.5*,\" /* 0.50-0.57, DH-GEX in >=0.52 */\n\t\t  \"PuTTY_Release_0.5*,\"\t/* 0.58-0.59 */\n\t\t  \"PuTTY_Release_0.60*,\"\n\t\t  \"PuTTY_Release_0.61*,\"\n\t\t  \"PuTTY_Release_0.62*,\"\n\t\t  \"PuTTY_Release_0.63*,\"\n\t\t  \"PuTTY_Release_0.64*\",\n\t\t\t\t\tSSH_OLD_DHGEX },\n\t\t{ \"FuTTY*\",\t\tSSH_OLD_DHGEX }, /* Putty Fork */\n\t\t{ \"Probe-*\",\n\t\t\t\t\tSSH_BUG_PROBE },\n\t\t{ \"TeraTerm SSH*,\"\n\t\t  \"TTSSH/1.5.*,\"\n\t\t  \"TTSSH/2.1*,\"\n\t\t  \"TTSSH/2.2*,\"\n\t\t  \"TTSSH/2.3*,\"\n\t\t  \"TTSSH/2.4*,\"\n\t\t  \"TTSSH/2.5*,\"\n\t\t  \"TTSSH/2.6*,\"\n\t\t  \"TTSSH/2.70*,\"\n\t\t  \"TTSSH/2.71*,\"\n\t\t  \"TTSSH/2.72*\",\tSSH_BUG_HOSTKEYS },\n\t\t{ \"WinSCP_release_4*,\"\n\t\t  \"WinSCP_release_5.0*,\"\n\t\t  \"WinSCP_release_5.1,\"\n\t\t  \"WinSCP_release_5.1.*,\"\n\t\t  \"WinSCP_release_5.5,\"\n\t\t  \"WinSCP_release_5.5.*,\"\n\t\t  \"WinSCP_release_5.6,\"\n\t\t  \"WinSCP_release_5.6.*,\"\n\t\t  \"WinSCP_release_5.7,\"\n\t\t  \"WinSCP_release_5.7.1,\"\n\t\t  \"WinSCP_release_5.7.2,\"\n\t\t  \"WinSCP_release_5.7.3,\"\n\t\t  \"WinSCP_release_5.7.4\",\n\t\t\t\t\tSSH_OLD_DHGEX },\n\t\t{ \"ConfD-*\",\n\t\t\t\t\tSSH_BUG_UTF8TTYMODE },\n\t\t{ \"Twisted_*\",\t\t0 },\n\t\t{ \"Twisted*\",\t\tSSH_BUG_DEBUG },\n\t\t{ NULL,\t\t\t0 }\n\t};\n\n\t/* process table, return first match */\n\tfor (i = 0; check[i].pat; i++) {\n\t\tif (match_pattern_list(version, check[i].pat, 0) == 1) {\n\t\t\tdebug(\"match: %s pat %s compat 0x%08x\",\n\t\t\t    version, check[i].pat, check[i].bugs);\n\t\t\tdatafellows = check[i].bugs;\t/* XXX for now */\n\t\t\treturn check[i].bugs;\n\t\t}\n\t}\n\tdebug(\"no match: %s\", version);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "client_version_string",
            "\"SSH-%d.%d-%[^\\n]\\n\"",
            "&remote_major",
            "&remote_minor",
            "remote_version"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "buf"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"SSH-1.5-W1.0\"",
            "12"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "sizeof(buf)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "server_version_string"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "server_version_string"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&server_version_string",
            "\"SSH-%d.%d-%.100s%s%s\\r\\n\"",
            "PROTOCOL_MAJOR_2",
            "PROTOCOL_MINOR_2",
            "SSH_VERSION",
            "*options.version_addendum == '\\0' ? \"\" : \" \"",
            "options.version_addendum"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nchar *client_version_string = NULL;\nchar *server_version_string = NULL;\n\nstatic void\nsshd_exchange_identification(struct ssh *ssh, int sock_in, int sock_out)\n{\n\tu_int i;\n\tint remote_major, remote_minor;\n\tchar *s;\n\tchar buf[256];\t\t\t/* Must not be larger than remote_version. */\n\tchar remote_version[256];\t/* Must be at least as big as buf. */\n\n\txasprintf(&server_version_string, \"SSH-%d.%d-%.100s%s%s\\r\\n\",\n\t    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_VERSION,\n\t    *options.version_addendum == '\\0' ? \"\" : \" \",\n\t    options.version_addendum);\n\n\t/* Send our protocol version identification. */\n\tif (atomicio(vwrite, sock_out, server_version_string,\n\t    strlen(server_version_string))\n\t    != strlen(server_version_string)) {\n\t\tlogit(\"Could not write ident string to %s port %d\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\tcleanup_exit(255);\n\t}\n\n\t/* Read other sides version identification. */\n\tmemset(buf, 0, sizeof(buf));\n\tfor (i = 0; i < sizeof(buf) - 1; i++) {\n\t\tif (atomicio(read, sock_in, &buf[i], 1) != 1) {\n\t\t\tlogit(\"Did not receive identification string \"\n\t\t\t    \"from %s port %d\",\n\t\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\t\tcleanup_exit(255);\n\t\t}\n\t\tif (buf[i] == '\\r') {\n\t\t\tbuf[i] = 0;\n\t\t\t/* Kludge for F-Secure Macintosh < 1.0.2 */\n\t\t\tif (i == 12 &&\n\t\t\t    strncmp(buf, \"SSH-1.5-W1.0\", 12) == 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[i] == '\\n') {\n\t\t\tbuf[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbuf[sizeof(buf) - 1] = 0;\n\tclient_version_string = xstrdup(buf);\n\n\t/*\n\t * Check that the versions match.  In future this might accept\n\t * several versions and set appropriate flags to handle them.\n\t */\n\tif (sscanf(client_version_string, \"SSH-%d.%d-%[^\\n]\\n\",\n\t    &remote_major, &remote_minor, remote_version) != 3) {\n\t\ts = \"Protocol mismatch.\\n\";\n\t\t(void) atomicio(vwrite, sock_out, s, strlen(s));\n\t\tlogit(\"Bad protocol version identification '%.100s' \"\n\t\t    \"from %s port %d\", client_version_string,\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\tclose(sock_in);\n\t\tclose(sock_out);\n\t\tcleanup_exit(255);\n\t}\n\tdebug(\"Client protocol version %d.%d; client software version %.100s\",\n\t    remote_major, remote_minor, remote_version);\n\n\tssh->compat = compat_datafellows(remote_version);\n\n\tif ((ssh->compat & SSH_BUG_PROBE) != 0) {\n\t\tlogit(\"probed from %s port %d with %s.  Don't panic.\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    client_version_string);\n\t\tcleanup_exit(255);\n\t}\n\tif ((ssh->compat & SSH_BUG_SCANNER) != 0) {\n\t\tlogit(\"scanned from %s port %d with %s.  Don't panic.\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    client_version_string);\n\t\tcleanup_exit(255);\n\t}\n\tif ((ssh->compat & SSH_BUG_RSASIGMD5) != 0) {\n\t\tlogit(\"Client version \\\"%.100s\\\" uses unsafe RSA signature \"\n\t\t    \"scheme; disabling use of RSA keys\", remote_version);\n\t}\n\n\tchop(server_version_string);\n\tdebug(\"Local version string %.200s\", server_version_string);\n\n\tif (remote_major != 2 &&\n\t    !(remote_major == 1 && remote_minor == 99)) {\n\t\ts = \"Protocol major versions differ.\\n\";\n\t\t(void) atomicio(vwrite, sock_out, s, strlen(s));\n\t\tclose(sock_in);\n\t\tclose(sock_out);\n\t\tlogit(\"Protocol major versions differ for %s port %d: \"\n\t\t    \"%.200s vs. %.200s\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    server_version_string, client_version_string);\n\t\tcleanup_exit(255);\n\t}\n}"
  },
  {
    "function_name": "grace_alarm_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "346-364",
    "snippet": "static void\ngrace_alarm_handler(int sig)\n{\n\tif (use_privsep && pmonitor != NULL && pmonitor->m_pid > 0)\n\t\tkill(pmonitor->m_pid, SIGALRM);\n\n\t/*\n\t * Try to kill any processes that we have spawned, E.g. authorized\n\t * keys command helpers.\n\t */\n\tif (getpgid(0) == getpid()) {\n\t\tsignal(SIGTERM, SIG_IGN);\n\t\tkill(0, SIGTERM);\n\t}\n\n\t/* Log error and exit. */\n\tsigdie(\"Timeout before authentication for %s port %d\",\n\t    ssh_remote_ipaddr(active_state), ssh_remote_port(active_state));\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int use_privsep = -1;",
      "struct monitor *pmonitor = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigdie",
          "args": [
            "\"Timeout before authentication for %s port %d\"",
            "ssh_remote_ipaddr(active_state)",
            "ssh_remote_port(active_state)"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "sigdie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "172-183",
          "snippet": "void\nsigdie(const char *fmt,...)\n{\n#ifdef DO_LOG_SAFE_IN_SIGHAND\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n#endif\n\t_exit(1);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsigdie(const char *fmt,...)\n{\n#ifdef DO_LOG_SAFE_IN_SIGHAND\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n#endif\n\t_exit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_port",
          "args": [
            "active_state"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "539-544",
          "snippet": "int\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "active_state"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "0",
            "SIGTERM"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "SIG_IGN"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpgid",
          "args": [
            "0"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "getpgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "239-251",
          "snippet": "pid_t\ngetpgid(pid_t pid)\n{\n#if defined(HAVE_GETPGRP) && !defined(GETPGRP_VOID) && GETPGRP_VOID == 0\n\treturn getpgrp(pid);\n#elif defined(HAVE_GETPGRP)\n\tif (pid == 0)\n\t\treturn getpgrp();\n#endif\n\n\terrno = ESRCH;\n\treturn -1;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\npid_t\ngetpgid(pid_t pid)\n{\n#if defined(HAVE_GETPGRP) && !defined(GETPGRP_VOID) && GETPGRP_VOID == 0\n\treturn getpgrp(pid);\n#elif defined(HAVE_GETPGRP)\n\tif (pid == 0)\n\t\treturn getpgrp();\n#endif\n\n\terrno = ESRCH;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "pmonitor->m_pid",
            "SIGALRM"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint use_privsep = -1;\nstruct monitor *pmonitor = NULL;\n\nstatic void\ngrace_alarm_handler(int sig)\n{\n\tif (use_privsep && pmonitor != NULL && pmonitor->m_pid > 0)\n\t\tkill(pmonitor->m_pid, SIGALRM);\n\n\t/*\n\t * Try to kill any processes that we have spawned, E.g. authorized\n\t * keys command helpers.\n\t */\n\tif (getpgid(0) == getpid()) {\n\t\tsignal(SIGTERM, SIG_IGN);\n\t\tkill(0, SIGTERM);\n\t}\n\n\t/* Log error and exit. */\n\tsigdie(\"Timeout before authentication for %s port %d\",\n\t    ssh_remote_ipaddr(active_state), ssh_remote_port(active_state));\n}"
  },
  {
    "function_name": "main_sigchld_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "329-340",
    "snippet": "static void\nmain_sigchld_handler(int sig)\n{\n\tint save_errno = errno;\n\tpid_t pid;\n\tint status;\n\n\twhile ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||\n\t    (pid < 0 && errno == EINTR))\n\t\t;\n\terrno = save_errno;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "-1",
            "&status",
            "WNOHANG"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmain_sigchld_handler(int sig)\n{\n\tint save_errno = errno;\n\tpid_t pid;\n\tint status;\n\n\twhile ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||\n\t    (pid < 0 && errno == EINTR))\n\t\t;\n\terrno = save_errno;\n}"
  },
  {
    "function_name": "sigterm_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "318-322",
    "snippet": "static void\nsigterm_handler(int sig)\n{\n\treceived_sigterm = sig;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile sig_atomic_t received_sigterm = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t received_sigterm = 0;\n\nstatic void\nsigterm_handler(int sig)\n{\n\treceived_sigterm = sig;\n}"
  },
  {
    "function_name": "sighup_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "297-312",
    "snippet": "static void\nsighup_restart(void)\n{\n\tlogit(\"Received SIGHUP; restarting.\");\n\tif (options.pid_file != NULL)\n\t\tunlink(options.pid_file);\n\tplatform_pre_restart();\n\tclose_listen_socks();\n\tclose_startup_pipes();\n\talarm(0);  /* alarm timer persists across exec */\n\tsignal(SIGHUP, SIG_IGN); /* will be restored after exec */\n\texecv(saved_argv[0], saved_argv);\n\tlogit(\"RESTART FAILED: av[0]='%.100s', error: %.100s.\", saved_argv[0],\n\t    strerror(errno));\n\texit(1);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ServerOptions options;",
      "char **saved_argv;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "2331-2353",
          "snippet": "void\ncleanup_exit(int i)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (the_authctxt) {\n\t\tdo_cleanup(ssh, the_authctxt);\n\t\tif (use_privsep && privsep_is_preauth &&\n\t\t    pmonitor != NULL && pmonitor->m_pid > 1) {\n\t\t\tdebug(\"Killing privsep child %d\", pmonitor->m_pid);\n\t\t\tif (kill(pmonitor->m_pid, SIGKILL) != 0 &&\n\t\t\t    errno != ESRCH)\n\t\t\t\terror(\"%s: kill(%d): %s\", __func__,\n\t\t\t\t    pmonitor->m_pid, strerror(errno));\n\t\t}\n\t}\n#ifdef SSH_AUDIT_EVENTS\n\t/* done after do_cleanup so it can cancel the PAM auth 'thread' */\n\tif (!use_privsep || mm_is_monitor())\n\t\taudit_event(SSH_CONNECTION_ABANDON);\n#endif\n\t_exit(i);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int use_privsep = -1;",
            "struct monitor *pmonitor = NULL;",
            "int privsep_is_preauth = 1;",
            "Authctxt *the_authctxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint use_privsep = -1;\nstruct monitor *pmonitor = NULL;\nint privsep_is_preauth = 1;\nAuthctxt *the_authctxt = NULL;\n\nvoid\ncleanup_exit(int i)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (the_authctxt) {\n\t\tdo_cleanup(ssh, the_authctxt);\n\t\tif (use_privsep && privsep_is_preauth &&\n\t\t    pmonitor != NULL && pmonitor->m_pid > 1) {\n\t\t\tdebug(\"Killing privsep child %d\", pmonitor->m_pid);\n\t\t\tif (kill(pmonitor->m_pid, SIGKILL) != 0 &&\n\t\t\t    errno != ESRCH)\n\t\t\t\terror(\"%s: kill(%d): %s\", __func__,\n\t\t\t\t    pmonitor->m_pid, strerror(errno));\n\t\t}\n\t}\n#ifdef SSH_AUDIT_EVENTS\n\t/* done after do_cleanup so it can cancel the PAM auth 'thread' */\n\tif (!use_privsep || mm_is_monitor())\n\t\taudit_event(SSH_CONNECTION_ABANDON);\n#endif\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"RESTART FAILED: av[0]='%.100s', error: %.100s.\"",
            "saved_argv[0]",
            "strerror(errno)"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "execv",
          "args": [
            "saved_argv[0]",
            "saved_argv"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGHUP",
            "SIG_IGN"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarm",
          "args": [
            "0"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "grace_alarm_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "346-364",
          "snippet": "static void\ngrace_alarm_handler(int sig)\n{\n\tif (use_privsep && pmonitor != NULL && pmonitor->m_pid > 0)\n\t\tkill(pmonitor->m_pid, SIGALRM);\n\n\t/*\n\t * Try to kill any processes that we have spawned, E.g. authorized\n\t * keys command helpers.\n\t */\n\tif (getpgid(0) == getpid()) {\n\t\tsignal(SIGTERM, SIG_IGN);\n\t\tkill(0, SIGTERM);\n\t}\n\n\t/* Log error and exit. */\n\tsigdie(\"Timeout before authentication for %s port %d\",\n\t    ssh_remote_ipaddr(active_state), ssh_remote_port(active_state));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int use_privsep = -1;",
            "struct monitor *pmonitor = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint use_privsep = -1;\nstruct monitor *pmonitor = NULL;\n\nstatic void\ngrace_alarm_handler(int sig)\n{\n\tif (use_privsep && pmonitor != NULL && pmonitor->m_pid > 0)\n\t\tkill(pmonitor->m_pid, SIGALRM);\n\n\t/*\n\t * Try to kill any processes that we have spawned, E.g. authorized\n\t * keys command helpers.\n\t */\n\tif (getpgid(0) == getpid()) {\n\t\tsignal(SIGTERM, SIG_IGN);\n\t\tkill(0, SIGTERM);\n\t}\n\n\t/* Log error and exit. */\n\tsigdie(\"Timeout before authentication for %s port %d\",\n\t    ssh_remote_ipaddr(active_state), ssh_remote_port(active_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "close_startup_pipes",
          "args": [],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "close_startup_pipes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "266-275",
          "snippet": "static void\nclose_startup_pipes(void)\n{\n\tint i;\n\n\tif (startup_pipes)\n\t\tfor (i = 0; i < options.max_startups; i++)\n\t\t\tif (startup_pipes[i] != -1)\n\t\t\t\tclose(startup_pipes[i]);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;",
            "int *startup_pipes = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nint *startup_pipes = NULL;\n\nstatic void\nclose_startup_pipes(void)\n{\n\tint i;\n\n\tif (startup_pipes)\n\t\tfor (i = 0; i < options.max_startups; i++)\n\t\t\tif (startup_pipes[i] != -1)\n\t\t\t\tclose(startup_pipes[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close_listen_socks",
          "args": [],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "close_listen_socks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "256-264",
          "snippet": "static void\nclose_listen_socks(void)\n{\n\tint i;\n\n\tfor (i = 0; i < num_listen_socks; i++)\n\t\tclose(listen_socks[i]);\n\tnum_listen_socks = -1;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int listen_socks[MAX_LISTEN_SOCKS];",
            "int num_listen_socks = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint listen_socks[MAX_LISTEN_SOCKS];\nint num_listen_socks = 0;\n\nstatic void\nclose_listen_socks(void)\n{\n\tint i;\n\n\tfor (i = 0; i < num_listen_socks; i++)\n\t\tclose(listen_socks[i]);\n\tnum_listen_socks = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_pre_restart",
          "args": [],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "platform_pre_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "53-59",
          "snippet": "void\nplatform_pre_restart(void)\n{\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_pre_restart(void)\n{\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "options.pid_file"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nchar **saved_argv;\n\nstatic void\nsighup_restart(void)\n{\n\tlogit(\"Received SIGHUP; restarting.\");\n\tif (options.pid_file != NULL)\n\t\tunlink(options.pid_file);\n\tplatform_pre_restart();\n\tclose_listen_socks();\n\tclose_startup_pipes();\n\talarm(0);  /* alarm timer persists across exec */\n\tsignal(SIGHUP, SIG_IGN); /* will be restored after exec */\n\texecv(saved_argv[0], saved_argv);\n\tlogit(\"RESTART FAILED: av[0]='%.100s', error: %.100s.\", saved_argv[0],\n\t    strerror(errno));\n\texit(1);\n}"
  },
  {
    "function_name": "sighup_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "284-291",
    "snippet": "static void\nsighup_handler(int sig)\n{\n\tint save_errno = errno;\n\n\treceived_sighup = 1;\n\terrno = save_errno;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile sig_atomic_t received_sighup = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic volatile sig_atomic_t received_sighup = 0;\n\nstatic void\nsighup_handler(int sig)\n{\n\tint save_errno = errno;\n\n\treceived_sighup = 1;\n\terrno = save_errno;\n}"
  },
  {
    "function_name": "close_startup_pipes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "266-275",
    "snippet": "static void\nclose_startup_pipes(void)\n{\n\tint i;\n\n\tif (startup_pipes)\n\t\tfor (i = 0; i < options.max_startups; i++)\n\t\t\tif (startup_pipes[i] != -1)\n\t\t\t\tclose(startup_pipes[i]);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ServerOptions options;",
      "int *startup_pipes = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "startup_pipes[i]"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nint *startup_pipes = NULL;\n\nstatic void\nclose_startup_pipes(void)\n{\n\tint i;\n\n\tif (startup_pipes)\n\t\tfor (i = 0; i < options.max_startups; i++)\n\t\t\tif (startup_pipes[i] != -1)\n\t\t\t\tclose(startup_pipes[i]);\n}"
  },
  {
    "function_name": "close_listen_socks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
    "lines": "256-264",
    "snippet": "static void\nclose_listen_socks(void)\n{\n\tint i;\n\n\tfor (i = 0; i < num_listen_socks; i++)\n\t\tclose(listen_socks[i]);\n\tnum_listen_socks = -1;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"version.h\"",
      "#include \"auth-options.h\"",
      "#include \"ssh-sandbox.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"monitor.h\"",
      "#include \"session.h\"",
      "#include \"channels.h\"",
      "#include \"dispatch.h\"",
      "#include \"msg.h\"",
      "#include \"authfd.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"canohost.h\"",
      "#include \"atomicio.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"digest.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"match.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <prot.h>",
      "#include <sys/security.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rand.h>",
      "#include <openssl/bn.h>",
      "#include <openssl/dh.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include \"openbsd-compat/sys-tree.h\"",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int listen_socks[MAX_LISTEN_SOCKS];",
      "int num_listen_socks = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "listen_socks[i]"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint listen_socks[MAX_LISTEN_SOCKS];\nint num_listen_socks = 0;\n\nstatic void\nclose_listen_socks(void)\n{\n\tint i;\n\n\tfor (i = 0; i < num_listen_socks; i++)\n\t\tclose(listen_socks[i]);\n\tnum_listen_socks = -1;\n}"
  }
]