[
  {
    "function_name": "shadow_pw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/xcrypt.c",
    "lines": "135-163",
    "snippet": "char *\nshadow_pw(struct passwd *pw)\n{\n\tchar *pw_password = pw->pw_passwd;\n\n# if defined(HAVE_SHADOW_H) && !defined(DISABLE_SHADOW)\n\tstruct spwd *spw = getspnam(pw->pw_name);\n\n\tif (spw != NULL)\n\t\tpw_password = spw->sp_pwdp;\n# endif\n\n#ifdef USE_LIBIAF\n\treturn(get_iaf_password(pw));\n#endif\n\n# if defined(HAVE_GETPWANAM) && !defined(DISABLE_SHADOW)\n\tstruct passwd_adjunct *spw;\n\tif (issecure() && (spw = getpwanam(pw->pw_name)) != NULL)\n\t\tpw_password = spw->pwa_passwd;\n# elif defined(HAVE_SECUREWARE)\n\tstruct pr_passwd *spw = getprpwnam(pw->pw_name);\n\n\tif (spw != NULL)\n\t\tpw_password = spw->ufld.fd_encrypt;\n# endif\n\n\treturn pw_password;\n}",
    "includes": [
      "#  include <openssl/des.h>",
      "#  include \"md5crypt.h\"",
      "#  include <pwdadj.h>",
      "#  include <sys/audit.h>",
      "#  include <sys/label.h>",
      "#  include <shadow.h>",
      "#  include <prot.h>",
      "#  include <sys/audit.h>",
      "#  include <sys/security.h>",
      "#  include <prot.h>",
      "#  include <hpsecurity.h>",
      "#  include <crypt.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getprpwnam",
          "args": [
            "pw->pw_name"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwanam",
          "args": [
            "pw->pw_name"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "issecure",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_iaf_password",
          "args": [
            "pw"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "get_iaf_password",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-uw.c",
          "lines": "135-150",
          "snippet": "char *\nget_iaf_password(struct passwd *pw)\n{\n\tchar *pw_password = NULL;\n\n\tuinfo_t uinfo;\n\tif (!ia_openinfo(pw->pw_name,&uinfo)) {\n\t\tia_get_logpwd(uinfo, &pw_password);\n\t\tif (pw_password == NULL)\n\t\t\tfatal(\"ia_get_logpwd: Unable to get the shadow passwd\");\n\t\tia_closeinfo(uinfo);\n\t \treturn pw_password;\n\t}\n\telse\n\t\tfatal(\"ia_openinfo: Unable to open the shadow passwd file\");\n}",
          "includes": [
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"\t/* servconf.h needs misc.h for struct ForwardOptions */",
            "#include \"log.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <crypt.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\t/* servconf.h needs misc.h for struct ForwardOptions */\n#include \"log.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <crypt.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nget_iaf_password(struct passwd *pw)\n{\n\tchar *pw_password = NULL;\n\n\tuinfo_t uinfo;\n\tif (!ia_openinfo(pw->pw_name,&uinfo)) {\n\t\tia_get_logpwd(uinfo, &pw_password);\n\t\tif (pw_password == NULL)\n\t\t\tfatal(\"ia_get_logpwd: Unable to get the shadow passwd\");\n\t\tia_closeinfo(uinfo);\n\t \treturn pw_password;\n\t}\n\telse\n\t\tfatal(\"ia_openinfo: Unable to open the shadow passwd file\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "getspnam",
          "args": [
            "pw->pw_name"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <openssl/des.h>\n#  include \"md5crypt.h\"\n#  include <pwdadj.h>\n#  include <sys/audit.h>\n#  include <sys/label.h>\n#  include <shadow.h>\n#  include <prot.h>\n#  include <sys/audit.h>\n#  include <sys/security.h>\n#  include <prot.h>\n#  include <hpsecurity.h>\n#  include <crypt.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nshadow_pw(struct passwd *pw)\n{\n\tchar *pw_password = pw->pw_passwd;\n\n# if defined(HAVE_SHADOW_H) && !defined(DISABLE_SHADOW)\n\tstruct spwd *spw = getspnam(pw->pw_name);\n\n\tif (spw != NULL)\n\t\tpw_password = spw->sp_pwdp;\n# endif\n\n#ifdef USE_LIBIAF\n\treturn(get_iaf_password(pw));\n#endif\n\n# if defined(HAVE_GETPWANAM) && !defined(DISABLE_SHADOW)\n\tstruct passwd_adjunct *spw;\n\tif (issecure() && (spw = getpwanam(pw->pw_name)) != NULL)\n\t\tpw_password = spw->pwa_passwd;\n# elif defined(HAVE_SECUREWARE)\n\tstruct pr_passwd *spw = getprpwnam(pw->pw_name);\n\n\tif (spw != NULL)\n\t\tpw_password = spw->ufld.fd_encrypt;\n# endif\n\n\treturn pw_password;\n}"
  },
  {
    "function_name": "xcrypt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/xcrypt.c",
    "lines": "99-128",
    "snippet": "char *\nxcrypt(const char *password, const char *salt)\n{\n\tchar *crypted;\n\n\t/*\n\t * If we don't have a salt we are encrypting a fake password for\n\t * for timing purposes.  Pick an appropriate salt.\n\t */\n\tif (salt == NULL)\n\t\tsalt = pick_salt();\n\n# ifdef HAVE_MD5_PASSWORDS\n\tif (is_md5_salt(salt))\n\t\tcrypted = md5_crypt(password, salt);\n\telse\n\t\tcrypted = crypt(password, salt);\n# elif defined(__hpux) && !defined(HAVE_SECUREWARE)\n\tif (iscomsec())\n\t\tcrypted = bigcrypt(password, salt);\n\telse\n\t\tcrypted = crypt(password, salt);\n# elif defined(HAVE_SECUREWARE)\n\tcrypted = bigcrypt(password, salt);\n# else\n\tcrypted = crypt(password, salt);\n# endif\n\n\treturn crypted;\n}",
    "includes": [
      "#  include <openssl/des.h>",
      "#  include \"md5crypt.h\"",
      "#  include <pwdadj.h>",
      "#  include <sys/audit.h>",
      "#  include <sys/label.h>",
      "#  include <shadow.h>",
      "#  include <prot.h>",
      "#  include <sys/audit.h>",
      "#  include <sys/security.h>",
      "#  include <prot.h>",
      "#  include <hpsecurity.h>",
      "#  include <crypt.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypt",
          "args": [
            "password",
            "salt"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "xcrypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/xcrypt.c",
          "lines": "99-128",
          "snippet": "char *\nxcrypt(const char *password, const char *salt)\n{\n\tchar *crypted;\n\n\t/*\n\t * If we don't have a salt we are encrypting a fake password for\n\t * for timing purposes.  Pick an appropriate salt.\n\t */\n\tif (salt == NULL)\n\t\tsalt = pick_salt();\n\n# ifdef HAVE_MD5_PASSWORDS\n\tif (is_md5_salt(salt))\n\t\tcrypted = md5_crypt(password, salt);\n\telse\n\t\tcrypted = crypt(password, salt);\n# elif defined(__hpux) && !defined(HAVE_SECUREWARE)\n\tif (iscomsec())\n\t\tcrypted = bigcrypt(password, salt);\n\telse\n\t\tcrypted = crypt(password, salt);\n# elif defined(HAVE_SECUREWARE)\n\tcrypted = bigcrypt(password, salt);\n# else\n\tcrypted = crypt(password, salt);\n# endif\n\n\treturn crypted;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "bigcrypt",
          "args": [
            "password",
            "salt"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bigcrypt",
          "args": [
            "password",
            "salt"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscomsec",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "md5_crypt",
          "args": [
            "password",
            "salt"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "md5_crypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/md5crypt.c",
          "lines": "50-163",
          "snippet": "char *\nmd5_crypt(const char *pw, const char *salt)\n{\n\tstatic char passwd[120], salt_copy[9];\n\tstatic const char *sp, *ep;\n\tunsigned char final[16];\n\tint sl, pl, i, j;\n\tMD5_CTX\tctx, ctx1;\n\tunsigned long l;\n\n\t/* Refine the Salt first */\n\tsp = salt;\n\n\t/* If it starts with the magic string, then skip that */\n\tif(strncmp(sp, magic, strlen(magic)) == 0)\n\t\tsp += strlen(magic);\n\n\t/* It stops at the first '$', max 8 chars */\n\tfor (ep = sp; *ep != '$'; ep++) {\n\t\tif (*ep == '\\0' || ep >= (sp + 8))\n\t\t\treturn (NULL);\n\t}\n\n\t/* get the length of the true salt */\n\tsl = ep - sp;\n\n\t/* Stash the salt */\n\tmemcpy(salt_copy, sp, sl);\n\tsalt_copy[sl] = '\\0';\n\n\tMD5_Init(&ctx);\n\n\t/* The password first, since that is what is most unknown */\n\tMD5_Update(&ctx, pw, strlen(pw));\n\n\t/* Then our magic string */\n\tMD5_Update(&ctx, magic, strlen(magic));\n\n\t/* Then the raw salt */\n\tMD5_Update(&ctx, sp, sl);\n\n\t/* Then just as many characters of the MD5(pw, salt, pw) */\n\tMD5_Init(&ctx1);\n\tMD5_Update(&ctx1, pw, strlen(pw));\n\tMD5_Update(&ctx1, sp, sl);\n\tMD5_Update(&ctx1, pw, strlen(pw));\n\tMD5_Final(final, &ctx1);\n\n\tfor(pl = strlen(pw); pl > 0; pl -= 16)\n\t\tMD5_Update(&ctx, final, pl > 16 ? 16 : pl);\n\n\t/* Don't leave anything around in vm they could use. */\n\tmemset(final, '\\0', sizeof final);\n\n\t/* Then something really weird... */\n\tfor (j = 0, i = strlen(pw); i != 0; i >>= 1)\n\t\tif (i & 1)\n\t\t\tMD5_Update(&ctx, final + j, 1);\n\t\telse\n\t\t\tMD5_Update(&ctx, pw + j, 1);\n\n\t/* Now make the output string */\n\tsnprintf(passwd, sizeof(passwd), \"%s%s$\", magic, salt_copy);\n\n\tMD5_Final(final, &ctx);\n\n\t/*\n\t * and now, just to make sure things don't run too fast\n\t * On a 60 Mhz Pentium this takes 34 msec, so you would\n\t * need 30 seconds to build a 1000 entry dictionary...\n\t */\n\tfor(i = 0; i < 1000; i++) {\n\t\tMD5_Init(&ctx1);\n\t\tif (i & 1)\n\t\t\tMD5_Update(&ctx1, pw, strlen(pw));\n\t\telse\n\t\t\tMD5_Update(&ctx1, final, 16);\n\n\t\tif (i % 3)\n\t\t\tMD5_Update(&ctx1, sp, sl);\n\n\t\tif (i % 7)\n\t\t\tMD5_Update(&ctx1, pw, strlen(pw));\n\n\t\tif (i & 1)\n\t\t\tMD5_Update(&ctx1, final, 16);\n\t\telse\n\t\t\tMD5_Update(&ctx1, pw, strlen(pw));\n\n\t\tMD5_Final(final, &ctx1);\n\t}\n\n\tl = (final[ 0]<<16) | (final[ 6]<<8) | final[12];\n\tstrlcat(passwd, to64(l, 4), sizeof(passwd));\n\tl = (final[ 1]<<16) | (final[ 7]<<8) | final[13];\n\tstrlcat(passwd, to64(l, 4), sizeof(passwd));\n\tl = (final[ 2]<<16) | (final[ 8]<<8) | final[14];\n\tstrlcat(passwd, to64(l, 4), sizeof(passwd));\n\tl = (final[ 3]<<16) | (final[ 9]<<8) | final[15];\n\tstrlcat(passwd, to64(l, 4), sizeof(passwd));\n\tl = (final[ 4]<<16) | (final[10]<<8) | final[ 5];\n\tstrlcat(passwd, to64(l, 4), sizeof(passwd));\n\tl =                    final[11]                ;\n\tstrlcat(passwd, to64(l, 2), sizeof(passwd));\n\n\t/* Don't leave anything around in vm they could use. */\n\tmemset(final, 0, sizeof(final));\n\tmemset(salt_copy, 0, sizeof(salt_copy));\n\tmemset(&ctx, 0, sizeof(ctx));\n\tmemset(&ctx1, 0, sizeof(ctx1));\n\t(void)to64(0, 4);\n\n\treturn (passwd);\n}",
          "includes": [
            "#include <openssl/md5.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/md5.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nmd5_crypt(const char *pw, const char *salt)\n{\n\tstatic char passwd[120], salt_copy[9];\n\tstatic const char *sp, *ep;\n\tunsigned char final[16];\n\tint sl, pl, i, j;\n\tMD5_CTX\tctx, ctx1;\n\tunsigned long l;\n\n\t/* Refine the Salt first */\n\tsp = salt;\n\n\t/* If it starts with the magic string, then skip that */\n\tif(strncmp(sp, magic, strlen(magic)) == 0)\n\t\tsp += strlen(magic);\n\n\t/* It stops at the first '$', max 8 chars */\n\tfor (ep = sp; *ep != '$'; ep++) {\n\t\tif (*ep == '\\0' || ep >= (sp + 8))\n\t\t\treturn (NULL);\n\t}\n\n\t/* get the length of the true salt */\n\tsl = ep - sp;\n\n\t/* Stash the salt */\n\tmemcpy(salt_copy, sp, sl);\n\tsalt_copy[sl] = '\\0';\n\n\tMD5_Init(&ctx);\n\n\t/* The password first, since that is what is most unknown */\n\tMD5_Update(&ctx, pw, strlen(pw));\n\n\t/* Then our magic string */\n\tMD5_Update(&ctx, magic, strlen(magic));\n\n\t/* Then the raw salt */\n\tMD5_Update(&ctx, sp, sl);\n\n\t/* Then just as many characters of the MD5(pw, salt, pw) */\n\tMD5_Init(&ctx1);\n\tMD5_Update(&ctx1, pw, strlen(pw));\n\tMD5_Update(&ctx1, sp, sl);\n\tMD5_Update(&ctx1, pw, strlen(pw));\n\tMD5_Final(final, &ctx1);\n\n\tfor(pl = strlen(pw); pl > 0; pl -= 16)\n\t\tMD5_Update(&ctx, final, pl > 16 ? 16 : pl);\n\n\t/* Don't leave anything around in vm they could use. */\n\tmemset(final, '\\0', sizeof final);\n\n\t/* Then something really weird... */\n\tfor (j = 0, i = strlen(pw); i != 0; i >>= 1)\n\t\tif (i & 1)\n\t\t\tMD5_Update(&ctx, final + j, 1);\n\t\telse\n\t\t\tMD5_Update(&ctx, pw + j, 1);\n\n\t/* Now make the output string */\n\tsnprintf(passwd, sizeof(passwd), \"%s%s$\", magic, salt_copy);\n\n\tMD5_Final(final, &ctx);\n\n\t/*\n\t * and now, just to make sure things don't run too fast\n\t * On a 60 Mhz Pentium this takes 34 msec, so you would\n\t * need 30 seconds to build a 1000 entry dictionary...\n\t */\n\tfor(i = 0; i < 1000; i++) {\n\t\tMD5_Init(&ctx1);\n\t\tif (i & 1)\n\t\t\tMD5_Update(&ctx1, pw, strlen(pw));\n\t\telse\n\t\t\tMD5_Update(&ctx1, final, 16);\n\n\t\tif (i % 3)\n\t\t\tMD5_Update(&ctx1, sp, sl);\n\n\t\tif (i % 7)\n\t\t\tMD5_Update(&ctx1, pw, strlen(pw));\n\n\t\tif (i & 1)\n\t\t\tMD5_Update(&ctx1, final, 16);\n\t\telse\n\t\t\tMD5_Update(&ctx1, pw, strlen(pw));\n\n\t\tMD5_Final(final, &ctx1);\n\t}\n\n\tl = (final[ 0]<<16) | (final[ 6]<<8) | final[12];\n\tstrlcat(passwd, to64(l, 4), sizeof(passwd));\n\tl = (final[ 1]<<16) | (final[ 7]<<8) | final[13];\n\tstrlcat(passwd, to64(l, 4), sizeof(passwd));\n\tl = (final[ 2]<<16) | (final[ 8]<<8) | final[14];\n\tstrlcat(passwd, to64(l, 4), sizeof(passwd));\n\tl = (final[ 3]<<16) | (final[ 9]<<8) | final[15];\n\tstrlcat(passwd, to64(l, 4), sizeof(passwd));\n\tl = (final[ 4]<<16) | (final[10]<<8) | final[ 5];\n\tstrlcat(passwd, to64(l, 4), sizeof(passwd));\n\tl =                    final[11]                ;\n\tstrlcat(passwd, to64(l, 2), sizeof(passwd));\n\n\t/* Don't leave anything around in vm they could use. */\n\tmemset(final, 0, sizeof(final));\n\tmemset(salt_copy, 0, sizeof(salt_copy));\n\tmemset(&ctx, 0, sizeof(ctx));\n\tmemset(&ctx1, 0, sizeof(ctx1));\n\t(void)to64(0, 4);\n\n\treturn (passwd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_md5_salt",
          "args": [
            "salt"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "is_md5_salt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/md5crypt.c",
          "lines": "44-48",
          "snippet": "int\nis_md5_salt(const char *salt)\n{\n\treturn (strncmp(salt, magic, strlen(magic)) == 0);\n}",
          "includes": [
            "#include <openssl/md5.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/md5.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nis_md5_salt(const char *salt)\n{\n\treturn (strncmp(salt, magic, strlen(magic)) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pick_salt",
          "args": [],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "pick_salt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/xcrypt.c",
          "lines": "72-97",
          "snippet": "static const char *\npick_salt(void)\n{\n\tstruct passwd *pw;\n\tchar *passwd, *p;\n\tsize_t typelen;\n\tstatic char salt[32];\n\n\tif (salt[0] != '\\0')\n\t\treturn salt;\n\tstrlcpy(salt, \"xx\", sizeof(salt));\n\tsetpwent();\n\twhile ((pw = getpwent()) != NULL) {\n\t\tif ((passwd = shadow_pw(pw)) == NULL)\n\t\t\tcontinue;\n\t\tif (passwd[0] == '$' && (p = strrchr(passwd+1, '$')) != NULL) {\n\t\t\ttypelen = p - passwd + 1;\n\t\t\tstrlcpy(salt, passwd, MIN(typelen, sizeof(salt)));\n\t\t\texplicit_bzero(passwd, strlen(passwd));\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\tendpwent();\n\treturn salt;\n}",
          "includes": [
            "#  include <openssl/des.h>",
            "#  include \"md5crypt.h\"",
            "#  include <pwdadj.h>",
            "#  include <sys/audit.h>",
            "#  include <sys/label.h>",
            "#  include <shadow.h>",
            "#  include <prot.h>",
            "#  include <sys/audit.h>",
            "#  include <sys/security.h>",
            "#  include <prot.h>",
            "#  include <hpsecurity.h>",
            "#  include <crypt.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <openssl/des.h>\n#  include \"md5crypt.h\"\n#  include <pwdadj.h>\n#  include <sys/audit.h>\n#  include <sys/label.h>\n#  include <shadow.h>\n#  include <prot.h>\n#  include <sys/audit.h>\n#  include <sys/security.h>\n#  include <prot.h>\n#  include <hpsecurity.h>\n#  include <crypt.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\npick_salt(void)\n{\n\tstruct passwd *pw;\n\tchar *passwd, *p;\n\tsize_t typelen;\n\tstatic char salt[32];\n\n\tif (salt[0] != '\\0')\n\t\treturn salt;\n\tstrlcpy(salt, \"xx\", sizeof(salt));\n\tsetpwent();\n\twhile ((pw = getpwent()) != NULL) {\n\t\tif ((passwd = shadow_pw(pw)) == NULL)\n\t\t\tcontinue;\n\t\tif (passwd[0] == '$' && (p = strrchr(passwd+1, '$')) != NULL) {\n\t\t\ttypelen = p - passwd + 1;\n\t\t\tstrlcpy(salt, passwd, MIN(typelen, sizeof(salt)));\n\t\t\texplicit_bzero(passwd, strlen(passwd));\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\tendpwent();\n\treturn salt;\n}"
        }
      }
    ],
    "contextual_snippet": "#  include <openssl/des.h>\n#  include \"md5crypt.h\"\n#  include <pwdadj.h>\n#  include <sys/audit.h>\n#  include <sys/label.h>\n#  include <shadow.h>\n#  include <prot.h>\n#  include <sys/audit.h>\n#  include <sys/security.h>\n#  include <prot.h>\n#  include <hpsecurity.h>\n#  include <crypt.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nxcrypt(const char *password, const char *salt)\n{\n\tchar *crypted;\n\n\t/*\n\t * If we don't have a salt we are encrypting a fake password for\n\t * for timing purposes.  Pick an appropriate salt.\n\t */\n\tif (salt == NULL)\n\t\tsalt = pick_salt();\n\n# ifdef HAVE_MD5_PASSWORDS\n\tif (is_md5_salt(salt))\n\t\tcrypted = md5_crypt(password, salt);\n\telse\n\t\tcrypted = crypt(password, salt);\n# elif defined(__hpux) && !defined(HAVE_SECUREWARE)\n\tif (iscomsec())\n\t\tcrypted = bigcrypt(password, salt);\n\telse\n\t\tcrypted = crypt(password, salt);\n# elif defined(HAVE_SECUREWARE)\n\tcrypted = bigcrypt(password, salt);\n# else\n\tcrypted = crypt(password, salt);\n# endif\n\n\treturn crypted;\n}"
  },
  {
    "function_name": "pick_salt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/xcrypt.c",
    "lines": "72-97",
    "snippet": "static const char *\npick_salt(void)\n{\n\tstruct passwd *pw;\n\tchar *passwd, *p;\n\tsize_t typelen;\n\tstatic char salt[32];\n\n\tif (salt[0] != '\\0')\n\t\treturn salt;\n\tstrlcpy(salt, \"xx\", sizeof(salt));\n\tsetpwent();\n\twhile ((pw = getpwent()) != NULL) {\n\t\tif ((passwd = shadow_pw(pw)) == NULL)\n\t\t\tcontinue;\n\t\tif (passwd[0] == '$' && (p = strrchr(passwd+1, '$')) != NULL) {\n\t\t\ttypelen = p - passwd + 1;\n\t\t\tstrlcpy(salt, passwd, MIN(typelen, sizeof(salt)));\n\t\t\texplicit_bzero(passwd, strlen(passwd));\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\tendpwent();\n\treturn salt;\n}",
    "includes": [
      "#  include <openssl/des.h>",
      "#  include \"md5crypt.h\"",
      "#  include <pwdadj.h>",
      "#  include <sys/audit.h>",
      "#  include <sys/label.h>",
      "#  include <shadow.h>",
      "#  include <prot.h>",
      "#  include <sys/audit.h>",
      "#  include <sys/security.h>",
      "#  include <prot.h>",
      "#  include <hpsecurity.h>",
      "#  include <crypt.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "endpwent",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "passwd",
            "strlen(passwd)"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passwd"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "salt",
            "passwd",
            "MIN(typelen, sizeof(salt))"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "typelen",
            "sizeof(salt)"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "_SPLAY_MINMAX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sys-tree.h",
          "lines": "247-278",
          "snippet": "void name##_SPLAY_MINMAX(struct name *head, int __comp) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type __node, *__left, *__right, *__tmp;\t\t\t\\\n\\\n\tSPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\\n\t__left = __right = &__node;\t\t\t\t\t\\\n\\\n\twhile (1) {\t\t\t\t\t\t\t\\\n\t\tif (__comp < 0) {\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_LEFT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp < 0){\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_RIGHT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKLEFT(head, __right, field);\t\t\\\n\t\t} else if (__comp > 0) {\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp > 0) {\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_LEFT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKRIGHT(head, __left, field);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSPLAY_ASSEMBLE(head, &__node, __left, __right, field);\t\t\\\n}",
          "includes": [
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n\nvoid name##_SPLAY_MINMAX(struct name *head, int __comp) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type __node, *__left, *__right, *__tmp;\t\t\t\\\n\\\n\tSPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\\n\t__left = __right = &__node;\t\t\t\t\t\\\n\\\n\twhile (1) {\t\t\t\t\t\t\t\\\n\t\tif (__comp < 0) {\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_LEFT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp < 0){\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_RIGHT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKLEFT(head, __right, field);\t\t\\\n\t\t} else if (__comp > 0) {\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp > 0) {\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_LEFT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKRIGHT(head, __left, field);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSPLAY_ASSEMBLE(head, &__node, __left, __right, field);\t\t\\\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "passwd+1",
            "'$'"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shadow_pw",
          "args": [
            "pw"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "shadow_pw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/xcrypt.c",
          "lines": "135-163",
          "snippet": "char *\nshadow_pw(struct passwd *pw)\n{\n\tchar *pw_password = pw->pw_passwd;\n\n# if defined(HAVE_SHADOW_H) && !defined(DISABLE_SHADOW)\n\tstruct spwd *spw = getspnam(pw->pw_name);\n\n\tif (spw != NULL)\n\t\tpw_password = spw->sp_pwdp;\n# endif\n\n#ifdef USE_LIBIAF\n\treturn(get_iaf_password(pw));\n#endif\n\n# if defined(HAVE_GETPWANAM) && !defined(DISABLE_SHADOW)\n\tstruct passwd_adjunct *spw;\n\tif (issecure() && (spw = getpwanam(pw->pw_name)) != NULL)\n\t\tpw_password = spw->pwa_passwd;\n# elif defined(HAVE_SECUREWARE)\n\tstruct pr_passwd *spw = getprpwnam(pw->pw_name);\n\n\tif (spw != NULL)\n\t\tpw_password = spw->ufld.fd_encrypt;\n# endif\n\n\treturn pw_password;\n}",
          "includes": [
            "#  include <openssl/des.h>",
            "#  include \"md5crypt.h\"",
            "#  include <pwdadj.h>",
            "#  include <sys/audit.h>",
            "#  include <sys/label.h>",
            "#  include <shadow.h>",
            "#  include <prot.h>",
            "#  include <sys/audit.h>",
            "#  include <sys/security.h>",
            "#  include <prot.h>",
            "#  include <hpsecurity.h>",
            "#  include <crypt.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <openssl/des.h>\n#  include \"md5crypt.h\"\n#  include <pwdadj.h>\n#  include <sys/audit.h>\n#  include <sys/label.h>\n#  include <shadow.h>\n#  include <prot.h>\n#  include <sys/audit.h>\n#  include <sys/security.h>\n#  include <prot.h>\n#  include <hpsecurity.h>\n#  include <crypt.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nshadow_pw(struct passwd *pw)\n{\n\tchar *pw_password = pw->pw_passwd;\n\n# if defined(HAVE_SHADOW_H) && !defined(DISABLE_SHADOW)\n\tstruct spwd *spw = getspnam(pw->pw_name);\n\n\tif (spw != NULL)\n\t\tpw_password = spw->sp_pwdp;\n# endif\n\n#ifdef USE_LIBIAF\n\treturn(get_iaf_password(pw));\n#endif\n\n# if defined(HAVE_GETPWANAM) && !defined(DISABLE_SHADOW)\n\tstruct passwd_adjunct *spw;\n\tif (issecure() && (spw = getpwanam(pw->pw_name)) != NULL)\n\t\tpw_password = spw->pwa_passwd;\n# elif defined(HAVE_SECUREWARE)\n\tstruct pr_passwd *spw = getprpwnam(pw->pw_name);\n\n\tif (spw != NULL)\n\t\tpw_password = spw->ufld.fd_encrypt;\n# endif\n\n\treturn pw_password;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpwent",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setpwent",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <openssl/des.h>\n#  include \"md5crypt.h\"\n#  include <pwdadj.h>\n#  include <sys/audit.h>\n#  include <sys/label.h>\n#  include <shadow.h>\n#  include <prot.h>\n#  include <sys/audit.h>\n#  include <sys/security.h>\n#  include <prot.h>\n#  include <hpsecurity.h>\n#  include <crypt.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\npick_salt(void)\n{\n\tstruct passwd *pw;\n\tchar *passwd, *p;\n\tsize_t typelen;\n\tstatic char salt[32];\n\n\tif (salt[0] != '\\0')\n\t\treturn salt;\n\tstrlcpy(salt, \"xx\", sizeof(salt));\n\tsetpwent();\n\twhile ((pw = getpwent()) != NULL) {\n\t\tif ((passwd = shadow_pw(pw)) == NULL)\n\t\t\tcontinue;\n\t\tif (passwd[0] == '$' && (p = strrchr(passwd+1, '$')) != NULL) {\n\t\t\ttypelen = p - passwd + 1;\n\t\t\tstrlcpy(salt, passwd, MIN(typelen, sizeof(salt)));\n\t\t\texplicit_bzero(passwd, strlen(passwd));\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\tendpwent();\n\treturn salt;\n}"
  }
]