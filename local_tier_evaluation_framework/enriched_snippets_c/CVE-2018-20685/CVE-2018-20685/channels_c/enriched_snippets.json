[
  {
    "function_name": "x11_request_forwarding_with_spoofing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4816-4876",
    "snippet": "void\nx11_request_forwarding_with_spoofing(struct ssh *ssh, int client_session_id,\n    const char *disp, const char *proto, const char *data, int want_reply)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int data_len = (u_int) strlen(data) / 2;\n\tu_int i, value;\n\tconst char *cp;\n\tchar *new_data;\n\tint r, screen_number;\n\n\tif (sc->x11_saved_display == NULL)\n\t\tsc->x11_saved_display = xstrdup(disp);\n\telse if (strcmp(disp, sc->x11_saved_display) != 0) {\n\t\terror(\"x11_request_forwarding_with_spoofing: different \"\n\t\t    \"$DISPLAY already forwarded\");\n\t\treturn;\n\t}\n\n\tcp = strchr(disp, ':');\n\tif (cp)\n\t\tcp = strchr(cp, '.');\n\tif (cp)\n\t\tscreen_number = (u_int)strtonum(cp + 1, 0, 400, NULL);\n\telse\n\t\tscreen_number = 0;\n\n\tif (sc->x11_saved_proto == NULL) {\n\t\t/* Save protocol name. */\n\t\tsc->x11_saved_proto = xstrdup(proto);\n\n\t\t/* Extract real authentication data. */\n\t\tsc->x11_saved_data = xmalloc(data_len);\n\t\tfor (i = 0; i < data_len; i++) {\n\t\t\tif (sscanf(data + 2 * i, \"%2x\", &value) != 1)\n\t\t\t\tfatal(\"x11_request_forwarding: bad \"\n\t\t\t\t    \"authentication data: %.100s\", data);\n\t\t\tsc->x11_saved_data[i] = value;\n\t\t}\n\t\tsc->x11_saved_data_len = data_len;\n\n\t\t/* Generate fake data of the same length. */\n\t\tsc->x11_fake_data = xmalloc(data_len);\n\t\tarc4random_buf(sc->x11_fake_data, data_len);\n\t\tsc->x11_fake_data_len = data_len;\n\t}\n\n\t/* Convert the fake data into hex. */\n\tnew_data = tohex(sc->x11_fake_data, data_len);\n\n\t/* Send the request packet. */\n\tchannel_request_start(ssh, client_session_id, \"x11-req\", want_reply);\n\tif ((r = sshpkt_put_u8(ssh, 0)) != 0 || /* bool: single connection */\n\t    (r = sshpkt_put_cstring(ssh, proto)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, new_data)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, screen_number)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal(\"%s: send x11-req: %s\", __func__, ssh_err(r));\n\tfree(new_data);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "new_data"
          ],
          "line": 4875
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4195-4206",
          "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: send x11-req: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 4874
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 4874
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_write_wait",
          "args": [
            "ssh"
          ],
          "line": 4873
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_write_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "1930-1985",
          "snippet": "int\nssh_packet_write_wait(struct ssh *ssh)\n{\n\tfd_set *setp;\n\tint ret, r, ms_remain = 0;\n\tstruct timeval start, timeout, *timeoutp = NULL;\n\tstruct session_state *state = ssh->state;\n\n\tsetp = calloc(howmany(state->connection_out + 1,\n\t    NFDBITS), sizeof(fd_mask));\n\tif (setp == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\tfree(setp);\n\t\treturn r;\n\t}\n\twhile (ssh_packet_have_data_to_write(ssh)) {\n\t\tmemset(setp, 0, howmany(state->connection_out + 1,\n\t\t    NFDBITS) * sizeof(fd_mask));\n\t\tFD_SET(state->connection_out, setp);\n\n\t\tif (state->packet_timeout_ms > 0) {\n\t\t\tms_remain = state->packet_timeout_ms;\n\t\t\ttimeoutp = &timeout;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (state->packet_timeout_ms != -1) {\n\t\t\t\tms_to_timeval(&timeout, ms_remain);\n\t\t\t\tmonotime_tv(&start);\n\t\t\t}\n\t\t\tif ((ret = select(state->connection_out + 1,\n\t\t\t    NULL, setp, NULL, timeoutp)) >= 0)\n\t\t\t\tbreak;\n\t\t\tif (errno != EAGAIN && errno != EINTR &&\n\t\t\t    errno != EWOULDBLOCK)\n\t\t\t\tbreak;\n\t\t\tif (state->packet_timeout_ms == -1)\n\t\t\t\tcontinue;\n\t\t\tms_subtract_diff(&start, &ms_remain);\n\t\t\tif (ms_remain <= 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tfree(setp);\n\t\t\treturn SSH_ERR_CONN_TIMEOUT;\n\t\t}\n\t\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\t\tfree(setp);\n\t\t\treturn r;\n\t\t}\n\t}\n\tfree(setp);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_write_wait(struct ssh *ssh)\n{\n\tfd_set *setp;\n\tint ret, r, ms_remain = 0;\n\tstruct timeval start, timeout, *timeoutp = NULL;\n\tstruct session_state *state = ssh->state;\n\n\tsetp = calloc(howmany(state->connection_out + 1,\n\t    NFDBITS), sizeof(fd_mask));\n\tif (setp == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\tfree(setp);\n\t\treturn r;\n\t}\n\twhile (ssh_packet_have_data_to_write(ssh)) {\n\t\tmemset(setp, 0, howmany(state->connection_out + 1,\n\t\t    NFDBITS) * sizeof(fd_mask));\n\t\tFD_SET(state->connection_out, setp);\n\n\t\tif (state->packet_timeout_ms > 0) {\n\t\t\tms_remain = state->packet_timeout_ms;\n\t\t\ttimeoutp = &timeout;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (state->packet_timeout_ms != -1) {\n\t\t\t\tms_to_timeval(&timeout, ms_remain);\n\t\t\t\tmonotime_tv(&start);\n\t\t\t}\n\t\t\tif ((ret = select(state->connection_out + 1,\n\t\t\t    NULL, setp, NULL, timeoutp)) >= 0)\n\t\t\t\tbreak;\n\t\t\tif (errno != EAGAIN && errno != EINTR &&\n\t\t\t    errno != EWOULDBLOCK)\n\t\t\t\tbreak;\n\t\t\tif (state->packet_timeout_ms == -1)\n\t\t\t\tcontinue;\n\t\t\tms_subtract_diff(&start, &ms_remain);\n\t\t\tif (ms_remain <= 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tfree(setp);\n\t\t\treturn SSH_ERR_CONN_TIMEOUT;\n\t\t}\n\t\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\t\tfree(setp);\n\t\t\treturn r;\n\t\t}\n\t}\n\tfree(setp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 4872
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "screen_number"
          ],
          "line": 4871
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "new_data"
          ],
          "line": 4870
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u8",
          "args": [
            "ssh",
            "0"
          ],
          "line": 4868
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2435-2439",
          "snippet": "int\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_request_start",
          "args": [
            "ssh",
            "client_session_id",
            "\"x11-req\"",
            "want_reply"
          ],
          "line": 4867
        },
        "resolved": true,
        "details": {
          "function_name": "channel_request_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "932-952",
          "snippet": "void\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: unknown channel id\", __func__, id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: unknown channel id\", __func__, id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tohex",
          "args": [
            "sc->x11_fake_data",
            "data_len"
          ],
          "line": 4864
        },
        "resolved": true,
        "details": {
          "function_name": "tohex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1132-1149",
          "snippet": "char *\ntohex(const void *vp, size_t l)\n{\n\tconst u_char *p = (const u_char *)vp;\n\tchar b[3], *r;\n\tsize_t i, hl;\n\n\tif (l > 65536)\n\t\treturn xstrdup(\"tohex: length > 65536\");\n\n\thl = l * 2 + 1;\n\tr = xcalloc(1, hl);\n\tfor (i = 0; i < l; i++) {\n\t\tsnprintf(b, sizeof(b), \"%02x\", p[i]);\n\t\tstrlcat(r, b, hl);\n\t}\n\treturn (r);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ntohex(const void *vp, size_t l)\n{\n\tconst u_char *p = (const u_char *)vp;\n\tchar b[3], *r;\n\tsize_t i, hl;\n\n\tif (l > 65536)\n\t\treturn xstrdup(\"tohex: length > 65536\");\n\n\thl = l * 2 + 1;\n\tr = xcalloc(1, hl);\n\tfor (i = 0; i < l; i++) {\n\t\tsnprintf(b, sizeof(b), \"%02x\", p[i]);\n\t\tstrlcat(r, b, hl);\n\t}\n\treturn (r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arc4random_buf",
          "args": [
            "sc->x11_fake_data",
            "data_len"
          ],
          "line": 4859
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "263-277",
          "snippet": "void\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "data_len"
          ],
          "line": 4858
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"x11_request_forwarding: bad \"\n\t\t\t\t    \"authentication data: %.100s\"",
            "data"
          ],
          "line": 4851
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "data + 2 * i",
            "\"%2x\"",
            "&value"
          ],
          "line": 4850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "proto"
          ],
          "line": 4845
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtonum",
          "args": [
            "cp + 1",
            "0",
            "400",
            "NULL"
          ],
          "line": 4839
        },
        "resolved": true,
        "details": {
          "function_name": "strtonum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtonum.c",
          "lines": "33-70",
          "snippet": "long long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define TOOLARGE \t3",
            "#define TOOSMALL \t2",
            "#define INVALID \t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\n#define TOOLARGE \t3\n#define TOOSMALL \t2\n#define INVALID \t1\n\nlong long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cp",
            "'.'"
          ],
          "line": 4837
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"x11_request_forwarding_with_spoofing: different \"\n\t\t    \"$DISPLAY already forwarded\""
          ],
          "line": 4830
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "disp",
            "sc->x11_saved_display"
          ],
          "line": 4829
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "data"
          ],
          "line": 4821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nx11_request_forwarding_with_spoofing(struct ssh *ssh, int client_session_id,\n    const char *disp, const char *proto, const char *data, int want_reply)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int data_len = (u_int) strlen(data) / 2;\n\tu_int i, value;\n\tconst char *cp;\n\tchar *new_data;\n\tint r, screen_number;\n\n\tif (sc->x11_saved_display == NULL)\n\t\tsc->x11_saved_display = xstrdup(disp);\n\telse if (strcmp(disp, sc->x11_saved_display) != 0) {\n\t\terror(\"x11_request_forwarding_with_spoofing: different \"\n\t\t    \"$DISPLAY already forwarded\");\n\t\treturn;\n\t}\n\n\tcp = strchr(disp, ':');\n\tif (cp)\n\t\tcp = strchr(cp, '.');\n\tif (cp)\n\t\tscreen_number = (u_int)strtonum(cp + 1, 0, 400, NULL);\n\telse\n\t\tscreen_number = 0;\n\n\tif (sc->x11_saved_proto == NULL) {\n\t\t/* Save protocol name. */\n\t\tsc->x11_saved_proto = xstrdup(proto);\n\n\t\t/* Extract real authentication data. */\n\t\tsc->x11_saved_data = xmalloc(data_len);\n\t\tfor (i = 0; i < data_len; i++) {\n\t\t\tif (sscanf(data + 2 * i, \"%2x\", &value) != 1)\n\t\t\t\tfatal(\"x11_request_forwarding: bad \"\n\t\t\t\t    \"authentication data: %.100s\", data);\n\t\t\tsc->x11_saved_data[i] = value;\n\t\t}\n\t\tsc->x11_saved_data_len = data_len;\n\n\t\t/* Generate fake data of the same length. */\n\t\tsc->x11_fake_data = xmalloc(data_len);\n\t\tarc4random_buf(sc->x11_fake_data, data_len);\n\t\tsc->x11_fake_data_len = data_len;\n\t}\n\n\t/* Convert the fake data into hex. */\n\tnew_data = tohex(sc->x11_fake_data, data_len);\n\n\t/* Send the request packet. */\n\tchannel_request_start(ssh, client_session_id, \"x11-req\", want_reply);\n\tif ((r = sshpkt_put_u8(ssh, 0)) != 0 || /* bool: single connection */\n\t    (r = sshpkt_put_cstring(ssh, proto)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, new_data)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, screen_number)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal(\"%s: send x11-req: %s\", __func__, ssh_err(r));\n\tfree(new_data);\n}"
  },
  {
    "function_name": "x11_connect_display",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4693-4809",
    "snippet": "int\nx11_connect_display(struct ssh *ssh)\n{\n\tu_int display_number;\n\tconst char *display;\n\tchar buf[1024], *cp;\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar strport[NI_MAXSERV];\n\tint gaierr, sock = 0;\n\n\t/* Try to open a socket for the local X server. */\n\tdisplay = getenv(\"DISPLAY\");\n\tif (!display) {\n\t\terror(\"DISPLAY not set.\");\n\t\treturn -1;\n\t}\n\t/*\n\t * Now we decode the value of the DISPLAY variable and make a\n\t * connection to the real X server.\n\t */\n\n#ifdef __APPLE__\n\t/* Check if display is a path to a socket (as set by launchd). */\n\t{\n\t\tchar path[PATH_MAX];\n\n\t\tif (is_path_to_xsocket(display, path, sizeof(path))) {\n\t\t\tdebug(\"x11_connect_display: $DISPLAY is launchd\");\n\n\t\t\t/* Create a socket. */\n\t\t\tsock = connect_local_xsocket_path(path);\n\t\t\tif (sock < 0)\n\t\t\t\treturn -1;\n\n\t\t\t/* OK, we now have a connection to the display. */\n\t\t\treturn sock;\n\t\t}\n\t}\n#endif\n\t/*\n\t * Check if it is a unix domain socket.  Unix domain displays are in\n\t * one of the following formats: unix:d[.s], :d[.s], ::d[.s]\n\t */\n\tif (strncmp(display, \"unix:\", 5) == 0 ||\n\t    display[0] == ':') {\n\t\t/* Connect to the unix domain socket. */\n\t\tif (sscanf(strrchr(display, ':') + 1, \"%u\",\n\t\t    &display_number) != 1) {\n\t\t\terror(\"Could not parse display number from DISPLAY: \"\n\t\t\t    \"%.100s\", display);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Create a socket. */\n\t\tsock = connect_local_xsocket(display_number);\n\t\tif (sock < 0)\n\t\t\treturn -1;\n\n\t\t/* OK, we now have a connection to the display. */\n\t\treturn sock;\n\t}\n\t/*\n\t * Connect to an inet socket.  The DISPLAY value is supposedly\n\t * hostname:d[.s], where hostname may also be numeric IP address.\n\t */\n\tstrlcpy(buf, display, sizeof(buf));\n\tcp = strchr(buf, ':');\n\tif (!cp) {\n\t\terror(\"Could not find ':' in DISPLAY: %.100s\", display);\n\t\treturn -1;\n\t}\n\t*cp = 0;\n\t/*\n\t * buf now contains the host name.  But first we parse the\n\t * display number.\n\t */\n\tif (sscanf(cp + 1, \"%u\", &display_number) != 1) {\n\t\terror(\"Could not parse display number from DISPLAY: %.100s\",\n\t\t    display);\n\t\treturn -1;\n\t}\n\n\t/* Look up the host address */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = ssh->chanctxt->IPv4or6;\n\thints.ai_socktype = SOCK_STREAM;\n\tsnprintf(strport, sizeof strport, \"%u\", 6000 + display_number);\n\tif ((gaierr = getaddrinfo(buf, strport, &hints, &aitop)) != 0) {\n\t\terror(\"%.100s: unknown host. (%s)\", buf,\n\t\tssh_gai_strerror(gaierr));\n\t\treturn -1;\n\t}\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\t/* Create a socket. */\n\t\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (sock < 0) {\n\t\t\tdebug2(\"socket: %.100s\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Connect it to the display. */\n\t\tif (connect(sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\tdebug2(\"connect %.100s port %u: %.100s\", buf,\n\t\t\t    6000 + display_number, strerror(errno));\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Success */\n\t\tbreak;\n\t}\n\tfreeaddrinfo(aitop);\n\tif (!ai) {\n\t\terror(\"connect %.100s port %u: %.100s\", buf,\n\t\t    6000 + display_number, strerror(errno));\n\t\treturn -1;\n\t}\n\tset_nodelay(sock);\n\treturn sock;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_nodelay",
          "args": [
            "sock"
          ],
          "line": 4807
        },
        "resolved": true,
        "details": {
          "function_name": "set_nodelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "149-168",
          "snippet": "void\nset_nodelay(int fd)\n{\n\tint opt;\n\tsocklen_t optlen;\n\n\toptlen = sizeof opt;\n\tif (getsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, &optlen) == -1) {\n\t\tdebug(\"getsockopt TCP_NODELAY: %.100s\", strerror(errno));\n\t\treturn;\n\t}\n\tif (opt == 1) {\n\t\tdebug2(\"fd %d is TCP_NODELAY\", fd);\n\t\treturn;\n\t}\n\topt = 1;\n\tdebug2(\"fd %d setting TCP_NODELAY\", fd);\n\tif (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof opt) == -1)\n\t\terror(\"setsockopt TCP_NODELAY: %.100s\", strerror(errno));\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nset_nodelay(int fd)\n{\n\tint opt;\n\tsocklen_t optlen;\n\n\toptlen = sizeof opt;\n\tif (getsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, &optlen) == -1) {\n\t\tdebug(\"getsockopt TCP_NODELAY: %.100s\", strerror(errno));\n\t\treturn;\n\t}\n\tif (opt == 1) {\n\t\tdebug2(\"fd %d is TCP_NODELAY\", fd);\n\t\treturn;\n\t}\n\topt = 1;\n\tdebug2(\"fd %d setting TCP_NODELAY\", fd);\n\tif (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof opt) == -1)\n\t\terror(\"setsockopt TCP_NODELAY: %.100s\", strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"connect %.100s port %u: %.100s\"",
            "buf",
            "6000 + display_number",
            "strerror(errno)"
          ],
          "line": 4803
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 4804
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "aitop"
          ],
          "line": 4801
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 4795
        },
        "resolved": true,
        "details": {
          "function_name": "channel_close_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "656-664",
          "snippet": "void\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"connect %.100s port %u: %.100s\"",
            "buf",
            "6000 + display_number",
            "strerror(errno)"
          ],
          "line": 4793
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "sock",
            "ai->ai_addr",
            "ai->ai_addrlen"
          ],
          "line": 4792
        },
        "resolved": true,
        "details": {
          "function_name": "rdynamic_connect_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4482-4506",
          "snippet": "static Channel *\nrdynamic_connect_prepare(struct ssh *ssh, char *ctype, char *rname)\n{\n\tChannel *c;\n\tint r;\n\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_RDYNAMIC_OPEN, -1, -1, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = 0;\n\tc->path = NULL;\n\n\t/*\n\t * We need to open the channel before we have a FD,\n\t * so that we can get SOCKS header from peer.\n\t */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: confirm: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic Channel *\nrdynamic_connect_prepare(struct ssh *ssh, char *ctype, char *rname)\n{\n\tChannel *c;\n\tint r;\n\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_RDYNAMIC_OPEN, -1, -1, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = 0;\n\tc->path = NULL;\n\n\t/*\n\t * We need to open the channel before we have a FD,\n\t * so that we can get SOCKS header from peer.\n\t */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: confirm: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "ai->ai_family",
            "ai->ai_socktype",
            "ai->ai_protocol"
          ],
          "line": 4786
        },
        "resolved": true,
        "details": {
          "function_name": "is_path_to_xsocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4667-4690",
          "snippet": "static int\nis_path_to_xsocket(const char *display, char *path, size_t pathlen)\n{\n\tstruct stat sbuf;\n\n\tif (strlcpy(path, display, pathlen) >= pathlen) {\n\t\terror(\"%s: display path too long\", __func__);\n\t\treturn 0;\n\t}\n\tif (display[0] != '/')\n\t\treturn 0;\n\tif (stat(path, &sbuf) == 0) {\n\t\treturn 1;\n\t} else {\n\t\tchar *dot = strrchr(path, '.');\n\t\tif (dot != NULL) {\n\t\t\t*dot = '\\0';\n\t\t\tif (stat(path, &sbuf) == 0) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nis_path_to_xsocket(const char *display, char *path, size_t pathlen)\n{\n\tstruct stat sbuf;\n\n\tif (strlcpy(path, display, pathlen) >= pathlen) {\n\t\terror(\"%s: display path too long\", __func__);\n\t\treturn 0;\n\t}\n\tif (display[0] != '/')\n\t\treturn 0;\n\tif (stat(path, &sbuf) == 0) {\n\t\treturn 1;\n\t} else {\n\t\tchar *dot = strrchr(path, '.');\n\t\tif (dot != NULL) {\n\t\t\t*dot = '\\0';\n\t\t\tif (stat(path, &sbuf) == 0) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "buf",
            "strport",
            "&hints",
            "&aitop"
          ],
          "line": 4779
        },
        "resolved": true,
        "details": {
          "function_name": "getaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "154-234",
          "snippet": "int\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "strport",
            "sizeof strport",
            "\"%u\"",
            "6000 + display_number"
          ],
          "line": 4778
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 4775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "cp + 1",
            "\"%u\"",
            "&display_number"
          ],
          "line": 4768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "':'"
          ],
          "line": 4758
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "buf",
            "display",
            "sizeof(buf)"
          ],
          "line": 4757
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect_local_xsocket",
          "args": [
            "display_number"
          ],
          "line": 4746
        },
        "resolved": true,
        "details": {
          "function_name": "connect_local_xsocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4658-4664",
          "snippet": "static int\nconnect_local_xsocket(u_int dnr)\n{\n\tchar buf[1024];\n\tsnprintf(buf, sizeof buf, _PATH_UNIX_X, dnr);\n\treturn connect_local_xsocket_path(buf);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nconnect_local_xsocket(u_int dnr)\n{\n\tchar buf[1024];\n\tsnprintf(buf, sizeof buf, _PATH_UNIX_X, dnr);\n\treturn connect_local_xsocket_path(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "strrchr(display, ':') + 1",
            "\"%u\"",
            "&display_number"
          ],
          "line": 4739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "display",
            "':'"
          ],
          "line": 4739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "display",
            "\"unix:\"",
            "5"
          ],
          "line": 4736
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect_local_xsocket_path",
          "args": [
            "path"
          ],
          "line": 4723
        },
        "resolved": true,
        "details": {
          "function_name": "connect_local_xsocket_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4639-4656",
          "snippet": "static int\nconnect_local_xsocket_path(const char *pathname)\n{\n\tint sock;\n\tstruct sockaddr_un addr;\n\n\tsock = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sock < 0)\n\t\terror(\"socket: %.100s\", strerror(errno));\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\tstrlcpy(addr.sun_path, pathname, sizeof addr.sun_path);\n\tif (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == 0)\n\t\treturn sock;\n\tclose(sock);\n\terror(\"connect %.100s: %.100s\", addr.sun_path, strerror(errno));\n\treturn -1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nconnect_local_xsocket_path(const char *pathname)\n{\n\tint sock;\n\tstruct sockaddr_un addr;\n\n\tsock = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sock < 0)\n\t\terror(\"socket: %.100s\", strerror(errno));\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\tstrlcpy(addr.sun_path, pathname, sizeof addr.sun_path);\n\tif (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == 0)\n\t\treturn sock;\n\tclose(sock);\n\terror(\"connect %.100s: %.100s\", addr.sun_path, strerror(errno));\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"x11_connect_display: $DISPLAY is launchd\""
          ],
          "line": 4720
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DISPLAY\""
          ],
          "line": 4704
        },
        "resolved": true,
        "details": {
          "function_name": "pam_getenvlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "254-263",
          "snippet": "static char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nx11_connect_display(struct ssh *ssh)\n{\n\tu_int display_number;\n\tconst char *display;\n\tchar buf[1024], *cp;\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar strport[NI_MAXSERV];\n\tint gaierr, sock = 0;\n\n\t/* Try to open a socket for the local X server. */\n\tdisplay = getenv(\"DISPLAY\");\n\tif (!display) {\n\t\terror(\"DISPLAY not set.\");\n\t\treturn -1;\n\t}\n\t/*\n\t * Now we decode the value of the DISPLAY variable and make a\n\t * connection to the real X server.\n\t */\n\n#ifdef __APPLE__\n\t/* Check if display is a path to a socket (as set by launchd). */\n\t{\n\t\tchar path[PATH_MAX];\n\n\t\tif (is_path_to_xsocket(display, path, sizeof(path))) {\n\t\t\tdebug(\"x11_connect_display: $DISPLAY is launchd\");\n\n\t\t\t/* Create a socket. */\n\t\t\tsock = connect_local_xsocket_path(path);\n\t\t\tif (sock < 0)\n\t\t\t\treturn -1;\n\n\t\t\t/* OK, we now have a connection to the display. */\n\t\t\treturn sock;\n\t\t}\n\t}\n#endif\n\t/*\n\t * Check if it is a unix domain socket.  Unix domain displays are in\n\t * one of the following formats: unix:d[.s], :d[.s], ::d[.s]\n\t */\n\tif (strncmp(display, \"unix:\", 5) == 0 ||\n\t    display[0] == ':') {\n\t\t/* Connect to the unix domain socket. */\n\t\tif (sscanf(strrchr(display, ':') + 1, \"%u\",\n\t\t    &display_number) != 1) {\n\t\t\terror(\"Could not parse display number from DISPLAY: \"\n\t\t\t    \"%.100s\", display);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Create a socket. */\n\t\tsock = connect_local_xsocket(display_number);\n\t\tif (sock < 0)\n\t\t\treturn -1;\n\n\t\t/* OK, we now have a connection to the display. */\n\t\treturn sock;\n\t}\n\t/*\n\t * Connect to an inet socket.  The DISPLAY value is supposedly\n\t * hostname:d[.s], where hostname may also be numeric IP address.\n\t */\n\tstrlcpy(buf, display, sizeof(buf));\n\tcp = strchr(buf, ':');\n\tif (!cp) {\n\t\terror(\"Could not find ':' in DISPLAY: %.100s\", display);\n\t\treturn -1;\n\t}\n\t*cp = 0;\n\t/*\n\t * buf now contains the host name.  But first we parse the\n\t * display number.\n\t */\n\tif (sscanf(cp + 1, \"%u\", &display_number) != 1) {\n\t\terror(\"Could not parse display number from DISPLAY: %.100s\",\n\t\t    display);\n\t\treturn -1;\n\t}\n\n\t/* Look up the host address */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = ssh->chanctxt->IPv4or6;\n\thints.ai_socktype = SOCK_STREAM;\n\tsnprintf(strport, sizeof strport, \"%u\", 6000 + display_number);\n\tif ((gaierr = getaddrinfo(buf, strport, &hints, &aitop)) != 0) {\n\t\terror(\"%.100s: unknown host. (%s)\", buf,\n\t\tssh_gai_strerror(gaierr));\n\t\treturn -1;\n\t}\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\t/* Create a socket. */\n\t\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (sock < 0) {\n\t\t\tdebug2(\"socket: %.100s\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Connect it to the display. */\n\t\tif (connect(sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\tdebug2(\"connect %.100s port %u: %.100s\", buf,\n\t\t\t    6000 + display_number, strerror(errno));\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Success */\n\t\tbreak;\n\t}\n\tfreeaddrinfo(aitop);\n\tif (!ai) {\n\t\terror(\"connect %.100s port %u: %.100s\", buf,\n\t\t    6000 + display_number, strerror(errno));\n\t\treturn -1;\n\t}\n\tset_nodelay(sock);\n\treturn sock;\n}"
  },
  {
    "function_name": "is_path_to_xsocket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4667-4690",
    "snippet": "static int\nis_path_to_xsocket(const char *display, char *path, size_t pathlen)\n{\n\tstruct stat sbuf;\n\n\tif (strlcpy(path, display, pathlen) >= pathlen) {\n\t\terror(\"%s: display path too long\", __func__);\n\t\treturn 0;\n\t}\n\tif (display[0] != '/')\n\t\treturn 0;\n\tif (stat(path, &sbuf) == 0) {\n\t\treturn 1;\n\t} else {\n\t\tchar *dot = strrchr(path, '.');\n\t\tif (dot != NULL) {\n\t\t\t*dot = '\\0';\n\t\t\tif (stat(path, &sbuf) == 0) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&sbuf"
          ],
          "line": 4684
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "path",
            "'.'"
          ],
          "line": 4681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: display path too long\"",
            "__func__"
          ],
          "line": 4673
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "path",
            "display",
            "pathlen"
          ],
          "line": 4672
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nis_path_to_xsocket(const char *display, char *path, size_t pathlen)\n{\n\tstruct stat sbuf;\n\n\tif (strlcpy(path, display, pathlen) >= pathlen) {\n\t\terror(\"%s: display path too long\", __func__);\n\t\treturn 0;\n\t}\n\tif (display[0] != '/')\n\t\treturn 0;\n\tif (stat(path, &sbuf) == 0) {\n\t\treturn 1;\n\t} else {\n\t\tchar *dot = strrchr(path, '.');\n\t\tif (dot != NULL) {\n\t\t\t*dot = '\\0';\n\t\t\tif (stat(path, &sbuf) == 0) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "connect_local_xsocket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4658-4664",
    "snippet": "static int\nconnect_local_xsocket(u_int dnr)\n{\n\tchar buf[1024];\n\tsnprintf(buf, sizeof buf, _PATH_UNIX_X, dnr);\n\treturn connect_local_xsocket_path(buf);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "connect_local_xsocket_path",
          "args": [
            "buf"
          ],
          "line": 4663
        },
        "resolved": true,
        "details": {
          "function_name": "connect_local_xsocket_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4639-4656",
          "snippet": "static int\nconnect_local_xsocket_path(const char *pathname)\n{\n\tint sock;\n\tstruct sockaddr_un addr;\n\n\tsock = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sock < 0)\n\t\terror(\"socket: %.100s\", strerror(errno));\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\tstrlcpy(addr.sun_path, pathname, sizeof addr.sun_path);\n\tif (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == 0)\n\t\treturn sock;\n\tclose(sock);\n\terror(\"connect %.100s: %.100s\", addr.sun_path, strerror(errno));\n\treturn -1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nconnect_local_xsocket_path(const char *pathname)\n{\n\tint sock;\n\tstruct sockaddr_un addr;\n\n\tsock = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sock < 0)\n\t\terror(\"socket: %.100s\", strerror(errno));\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\tstrlcpy(addr.sun_path, pathname, sizeof addr.sun_path);\n\tif (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == 0)\n\t\treturn sock;\n\tclose(sock);\n\terror(\"connect %.100s: %.100s\", addr.sun_path, strerror(errno));\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof buf",
            "_PATH_UNIX_X",
            "dnr"
          ],
          "line": 4662
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nconnect_local_xsocket(u_int dnr)\n{\n\tchar buf[1024];\n\tsnprintf(buf, sizeof buf, _PATH_UNIX_X, dnr);\n\treturn connect_local_xsocket_path(buf);\n}"
  },
  {
    "function_name": "connect_local_xsocket_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4639-4656",
    "snippet": "static int\nconnect_local_xsocket_path(const char *pathname)\n{\n\tint sock;\n\tstruct sockaddr_un addr;\n\n\tsock = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sock < 0)\n\t\terror(\"socket: %.100s\", strerror(errno));\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\tstrlcpy(addr.sun_path, pathname, sizeof addr.sun_path);\n\tif (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == 0)\n\t\treturn sock;\n\tclose(sock);\n\terror(\"connect %.100s: %.100s\", addr.sun_path, strerror(errno));\n\treturn -1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"connect %.100s: %.100s\"",
            "addr.sun_path",
            "strerror(errno)"
          ],
          "line": 4654
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 4654
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 4653
        },
        "resolved": true,
        "details": {
          "function_name": "channel_close_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "656-664",
          "snippet": "void\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "sock",
            "(struct sockaddr *)&addr",
            "sizeof(addr)"
          ],
          "line": 4651
        },
        "resolved": true,
        "details": {
          "function_name": "rdynamic_connect_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4482-4506",
          "snippet": "static Channel *\nrdynamic_connect_prepare(struct ssh *ssh, char *ctype, char *rname)\n{\n\tChannel *c;\n\tint r;\n\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_RDYNAMIC_OPEN, -1, -1, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = 0;\n\tc->path = NULL;\n\n\t/*\n\t * We need to open the channel before we have a FD,\n\t * so that we can get SOCKS header from peer.\n\t */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: confirm: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic Channel *\nrdynamic_connect_prepare(struct ssh *ssh, char *ctype, char *rname)\n{\n\tChannel *c;\n\tint r;\n\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_RDYNAMIC_OPEN, -1, -1, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = 0;\n\tc->path = NULL;\n\n\t/*\n\t * We need to open the channel before we have a FD,\n\t * so that we can get SOCKS header from peer.\n\t */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: confirm: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "addr.sun_path",
            "pathname",
            "sizeof addr.sun_path"
          ],
          "line": 4650
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&addr",
            "0",
            "sizeof(addr)"
          ],
          "line": 4648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0"
          ],
          "line": 4645
        },
        "resolved": true,
        "details": {
          "function_name": "is_path_to_xsocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4667-4690",
          "snippet": "static int\nis_path_to_xsocket(const char *display, char *path, size_t pathlen)\n{\n\tstruct stat sbuf;\n\n\tif (strlcpy(path, display, pathlen) >= pathlen) {\n\t\terror(\"%s: display path too long\", __func__);\n\t\treturn 0;\n\t}\n\tif (display[0] != '/')\n\t\treturn 0;\n\tif (stat(path, &sbuf) == 0) {\n\t\treturn 1;\n\t} else {\n\t\tchar *dot = strrchr(path, '.');\n\t\tif (dot != NULL) {\n\t\t\t*dot = '\\0';\n\t\t\tif (stat(path, &sbuf) == 0) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nis_path_to_xsocket(const char *display, char *path, size_t pathlen)\n{\n\tstruct stat sbuf;\n\n\tif (strlcpy(path, display, pathlen) >= pathlen) {\n\t\terror(\"%s: display path too long\", __func__);\n\t\treturn 0;\n\t}\n\tif (display[0] != '/')\n\t\treturn 0;\n\tif (stat(path, &sbuf) == 0) {\n\t\treturn 1;\n\t} else {\n\t\tchar *dot = strrchr(path, '.');\n\t\tif (dot != NULL) {\n\t\t\t*dot = '\\0';\n\t\t\tif (stat(path, &sbuf) == 0) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nconnect_local_xsocket_path(const char *pathname)\n{\n\tint sock;\n\tstruct sockaddr_un addr;\n\n\tsock = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sock < 0)\n\t\terror(\"socket: %.100s\", strerror(errno));\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\tstrlcpy(addr.sun_path, pathname, sizeof addr.sun_path);\n\tif (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == 0)\n\t\treturn sock;\n\tclose(sock);\n\terror(\"connect %.100s: %.100s\", addr.sun_path, strerror(errno));\n\treturn -1;\n}"
  },
  {
    "function_name": "x11_create_display_inet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4536-4637",
    "snippet": "int\nx11_create_display_inet(struct ssh *ssh, int x11_display_offset,\n    int x11_use_localhost, int single_connection,\n    u_int *display_numberp, int **chanids)\n{\n\tChannel *nc = NULL;\n\tint display_number, sock;\n\tu_short port;\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar strport[NI_MAXSERV];\n\tint gaierr, n, num_socks = 0, socks[NUM_SOCKS];\n\n\tif (chanids == NULL)\n\t\treturn -1;\n\n\tfor (display_number = x11_display_offset;\n\t    display_number < MAX_DISPLAYS;\n\t    display_number++) {\n\t\tport = 6000 + display_number;\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ssh->chanctxt->IPv4or6;\n\t\thints.ai_flags = x11_use_localhost ? 0: AI_PASSIVE;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t\tsnprintf(strport, sizeof strport, \"%d\", port);\n\t\tif ((gaierr = getaddrinfo(NULL, strport,\n\t\t    &hints, &aitop)) != 0) {\n\t\t\terror(\"getaddrinfo: %.100s\", ssh_gai_strerror(gaierr));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\t\tif (ai->ai_family != AF_INET &&\n\t\t\t    ai->ai_family != AF_INET6)\n\t\t\t\tcontinue;\n\t\t\tsock = socket(ai->ai_family, ai->ai_socktype,\n\t\t\t    ai->ai_protocol);\n\t\t\tif (sock < 0) {\n\t\t\t\tif ((errno != EINVAL) && (errno != EAFNOSUPPORT)\n#ifdef EPFNOSUPPORT\n\t\t\t\t    && (errno != EPFNOSUPPORT)\n#endif \n\t\t\t\t    ) {\n\t\t\t\t\terror(\"socket: %.100s\", strerror(errno));\n\t\t\t\t\tfreeaddrinfo(aitop);\n\t\t\t\t\treturn -1;\n\t\t\t\t} else {\n\t\t\t\t\tdebug(\"x11_create_display_inet: Socket family %d not supported\",\n\t\t\t\t\t\t ai->ai_family);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ai->ai_family == AF_INET6)\n\t\t\t\tsock_set_v6only(sock);\n\t\t\tif (x11_use_localhost)\n\t\t\t\tset_reuseaddr(sock);\n\t\t\tif (bind(sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\t\tdebug2(\"%s: bind port %d: %.100s\", __func__,\n\t\t\t\t    port, strerror(errno));\n\t\t\t\tclose(sock);\n\t\t\t\tfor (n = 0; n < num_socks; n++)\n\t\t\t\t\tclose(socks[n]);\n\t\t\t\tnum_socks = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsocks[num_socks++] = sock;\n\t\t\tif (num_socks == NUM_SOCKS)\n\t\t\t\tbreak;\n\t\t}\n\t\tfreeaddrinfo(aitop);\n\t\tif (num_socks > 0)\n\t\t\tbreak;\n\t}\n\tif (display_number >= MAX_DISPLAYS) {\n\t\terror(\"Failed to allocate internet-domain X11 display socket.\");\n\t\treturn -1;\n\t}\n\t/* Start listening for connections on the socket. */\n\tfor (n = 0; n < num_socks; n++) {\n\t\tsock = socks[n];\n\t\tif (listen(sock, SSH_LISTEN_BACKLOG) < 0) {\n\t\t\terror(\"listen: %.100s\", strerror(errno));\n\t\t\tclose(sock);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Allocate a channel for each socket. */\n\t*chanids = xcalloc(num_socks + 1, sizeof(**chanids));\n\tfor (n = 0; n < num_socks; n++) {\n\t\tsock = socks[n];\n\t\tnc = channel_new(ssh, \"x11 listener\",\n\t\t    SSH_CHANNEL_X11_LISTENER, sock, sock, -1,\n\t\t    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,\n\t\t    0, \"X11 inet listener\", 1);\n\t\tnc->single_connection = single_connection;\n\t\t(*chanids)[n] = nc->self;\n\t}\n\t(*chanids)[n] = -1;\n\n\t/* Return the display number for the DISPLAY environment variable. */\n\t*display_numberp = display_number;\n\treturn 0;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MAX_DISPLAYS  1000",
      "#define\tNUM_SOCKS\t10"
    ],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "\"x11 listener\"",
            "SSH_CHANNEL_X11_LISTENER",
            "sock",
            "sock",
            "-1",
            "CHAN_X11_WINDOW_DEFAULT",
            "CHAN_X11_PACKET_DEFAULT",
            "0",
            "\"X11 inet listener\"",
            "1"
          ],
          "line": 4625
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "num_socks + 1",
            "sizeof(**chanids)"
          ],
          "line": 4622
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 4616
        },
        "resolved": true,
        "details": {
          "function_name": "channel_close_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "656-664",
          "snippet": "void\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"listen: %.100s\"",
            "strerror(errno)"
          ],
          "line": 4615
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 4615
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "sock",
            "SSH_LISTEN_BACKLOG"
          ],
          "line": 4614
        },
        "resolved": true,
        "details": {
          "function_name": "open_listen_match_streamlocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3931-3943",
          "snippet": "static int\nopen_listen_match_streamlocal(struct permission *allowed_open,\n    const char *requestedpath)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != PORT_STREAMLOCAL)\n\t\treturn 0;\n\tif (allowed_open->listen_path == NULL ||\n\t    strcmp(allowed_open->listen_path, requestedpath) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nopen_listen_match_streamlocal(struct permission *allowed_open,\n    const char *requestedpath)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != PORT_STREAMLOCAL)\n\t\treturn 0;\n\tif (allowed_open->listen_path == NULL ||\n\t    strcmp(allowed_open->listen_path, requestedpath) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "aitop"
          ],
          "line": 4603
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: bind port %d: %.100s\"",
            "__func__",
            "port",
            "strerror(errno)"
          ],
          "line": 4591
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "sock",
            "ai->ai_addr",
            "ai->ai_addrlen"
          ],
          "line": 4590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_reuseaddr",
          "args": [
            "sock"
          ],
          "line": 4589
        },
        "resolved": true,
        "details": {
          "function_name": "set_reuseaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "171-181",
          "snippet": "int\nset_reuseaddr(int fd)\n{\n\tint on = 1;\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {\n\t\terror(\"setsockopt SO_REUSEADDR fd %d: %s\", fd, strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nset_reuseaddr(int fd)\n{\n\tint on = 1;\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {\n\t\terror(\"setsockopt SO_REUSEADDR fd %d: %s\", fd, strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_set_v6only",
          "args": [
            "sock"
          ],
          "line": 4587
        },
        "resolved": true,
        "details": {
          "function_name": "sock_set_v6only",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1534-1544",
          "snippet": "void\nsock_set_v6only(int s)\n{\n#if defined(IPV6_V6ONLY) && !defined(__OpenBSD__)\n\tint on = 1;\n\n\tdebug3(\"%s: set socket %d IPV6_V6ONLY\", __func__, s);\n\tif (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &on, sizeof(on)) == -1)\n\t\terror(\"setsockopt IPV6_V6ONLY: %s\", strerror(errno));\n#endif\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsock_set_v6only(int s)\n{\n#if defined(IPV6_V6ONLY) && !defined(__OpenBSD__)\n\tint on = 1;\n\n\tdebug3(\"%s: set socket %d IPV6_V6ONLY\", __func__, s);\n\tif (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &on, sizeof(on)) == -1)\n\t\terror(\"setsockopt IPV6_V6ONLY: %s\", strerror(errno));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"x11_create_display_inet: Socket family %d not supported\"",
            "ai->ai_family"
          ],
          "line": 4581
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "ai->ai_family",
            "ai->ai_socktype",
            "ai->ai_protocol"
          ],
          "line": 4569
        },
        "resolved": true,
        "details": {
          "function_name": "is_path_to_xsocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4667-4690",
          "snippet": "static int\nis_path_to_xsocket(const char *display, char *path, size_t pathlen)\n{\n\tstruct stat sbuf;\n\n\tif (strlcpy(path, display, pathlen) >= pathlen) {\n\t\terror(\"%s: display path too long\", __func__);\n\t\treturn 0;\n\t}\n\tif (display[0] != '/')\n\t\treturn 0;\n\tif (stat(path, &sbuf) == 0) {\n\t\treturn 1;\n\t} else {\n\t\tchar *dot = strrchr(path, '.');\n\t\tif (dot != NULL) {\n\t\t\t*dot = '\\0';\n\t\t\tif (stat(path, &sbuf) == 0) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nis_path_to_xsocket(const char *display, char *path, size_t pathlen)\n{\n\tstruct stat sbuf;\n\n\tif (strlcpy(path, display, pathlen) >= pathlen) {\n\t\terror(\"%s: display path too long\", __func__);\n\t\treturn 0;\n\t}\n\tif (display[0] != '/')\n\t\treturn 0;\n\tif (stat(path, &sbuf) == 0) {\n\t\treturn 1;\n\t} else {\n\t\tchar *dot = strrchr(path, '.');\n\t\tif (dot != NULL) {\n\t\t\t*dot = '\\0';\n\t\t\tif (stat(path, &sbuf) == 0) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "NULL",
            "strport",
            "&hints",
            "&aitop"
          ],
          "line": 4560
        },
        "resolved": true,
        "details": {
          "function_name": "getaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "154-234",
          "snippet": "int\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "strport",
            "sizeof strport",
            "\"%d\"",
            "port"
          ],
          "line": 4559
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 4555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_DISPLAYS  1000\n#define\tNUM_SOCKS\t10\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nx11_create_display_inet(struct ssh *ssh, int x11_display_offset,\n    int x11_use_localhost, int single_connection,\n    u_int *display_numberp, int **chanids)\n{\n\tChannel *nc = NULL;\n\tint display_number, sock;\n\tu_short port;\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar strport[NI_MAXSERV];\n\tint gaierr, n, num_socks = 0, socks[NUM_SOCKS];\n\n\tif (chanids == NULL)\n\t\treturn -1;\n\n\tfor (display_number = x11_display_offset;\n\t    display_number < MAX_DISPLAYS;\n\t    display_number++) {\n\t\tport = 6000 + display_number;\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ssh->chanctxt->IPv4or6;\n\t\thints.ai_flags = x11_use_localhost ? 0: AI_PASSIVE;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t\tsnprintf(strport, sizeof strport, \"%d\", port);\n\t\tif ((gaierr = getaddrinfo(NULL, strport,\n\t\t    &hints, &aitop)) != 0) {\n\t\t\terror(\"getaddrinfo: %.100s\", ssh_gai_strerror(gaierr));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\t\tif (ai->ai_family != AF_INET &&\n\t\t\t    ai->ai_family != AF_INET6)\n\t\t\t\tcontinue;\n\t\t\tsock = socket(ai->ai_family, ai->ai_socktype,\n\t\t\t    ai->ai_protocol);\n\t\t\tif (sock < 0) {\n\t\t\t\tif ((errno != EINVAL) && (errno != EAFNOSUPPORT)\n#ifdef EPFNOSUPPORT\n\t\t\t\t    && (errno != EPFNOSUPPORT)\n#endif \n\t\t\t\t    ) {\n\t\t\t\t\terror(\"socket: %.100s\", strerror(errno));\n\t\t\t\t\tfreeaddrinfo(aitop);\n\t\t\t\t\treturn -1;\n\t\t\t\t} else {\n\t\t\t\t\tdebug(\"x11_create_display_inet: Socket family %d not supported\",\n\t\t\t\t\t\t ai->ai_family);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ai->ai_family == AF_INET6)\n\t\t\t\tsock_set_v6only(sock);\n\t\t\tif (x11_use_localhost)\n\t\t\t\tset_reuseaddr(sock);\n\t\t\tif (bind(sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\t\tdebug2(\"%s: bind port %d: %.100s\", __func__,\n\t\t\t\t    port, strerror(errno));\n\t\t\t\tclose(sock);\n\t\t\t\tfor (n = 0; n < num_socks; n++)\n\t\t\t\t\tclose(socks[n]);\n\t\t\t\tnum_socks = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsocks[num_socks++] = sock;\n\t\t\tif (num_socks == NUM_SOCKS)\n\t\t\t\tbreak;\n\t\t}\n\t\tfreeaddrinfo(aitop);\n\t\tif (num_socks > 0)\n\t\t\tbreak;\n\t}\n\tif (display_number >= MAX_DISPLAYS) {\n\t\terror(\"Failed to allocate internet-domain X11 display socket.\");\n\t\treturn -1;\n\t}\n\t/* Start listening for connections on the socket. */\n\tfor (n = 0; n < num_socks; n++) {\n\t\tsock = socks[n];\n\t\tif (listen(sock, SSH_LISTEN_BACKLOG) < 0) {\n\t\t\terror(\"listen: %.100s\", strerror(errno));\n\t\t\tclose(sock);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Allocate a channel for each socket. */\n\t*chanids = xcalloc(num_socks + 1, sizeof(**chanids));\n\tfor (n = 0; n < num_socks; n++) {\n\t\tsock = socks[n];\n\t\tnc = channel_new(ssh, \"x11 listener\",\n\t\t    SSH_CHANNEL_X11_LISTENER, sock, sock, -1,\n\t\t    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,\n\t\t    0, \"X11 inet listener\", 1);\n\t\tnc->single_connection = single_connection;\n\t\t(*chanids)[n] = nc->self;\n\t}\n\t(*chanids)[n] = -1;\n\n\t/* Return the display number for the DISPLAY environment variable. */\n\t*display_numberp = display_number;\n\treturn 0;\n}"
  },
  {
    "function_name": "rdynamic_connect_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4509-4527",
    "snippet": "static int\nrdynamic_connect_finish(struct ssh *ssh, Channel *c)\n{\n\tstruct channel_connect cctx;\n\tint sock;\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, c->path, c->host_port, SOCK_STREAM, NULL,\n\t    NULL, &cctx, NULL, NULL);\n\tif (sock == -1)\n\t\tchannel_connect_ctx_free(&cctx);\n\telse {\n\t\t/* similar to SSH_CHANNEL_CONNECTING but we've already sent the open */\n\t\tc->type = SSH_CHANNEL_RDYNAMIC_FINISH;\n\t\tc->connect_ctx = cctx;\n\t\tchannel_register_fds(ssh, c, sock, sock, -1, 0, 1, 0);\n\t}\n\treturn sock;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int connect_next(struct channel_connect *);",
      "static void channel_connect_ctx_free(struct channel_connect *);",
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_register_fds",
          "args": [
            "ssh",
            "c",
            "sock",
            "sock",
            "-1",
            "0",
            "1",
            "0"
          ],
          "line": 4524
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "308-348",
          "snippet": "static void\nchannel_register_fds(struct ssh *ssh, Channel *c, int rfd, int wfd, int efd,\n    int extusage, int nonblock, int is_tty)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\t/* Update the maximum file descriptor value. */\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, rfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, wfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, efd);\n\n\tif (rfd != -1)\n\t\tfcntl(rfd, F_SETFD, FD_CLOEXEC);\n\tif (wfd != -1 && wfd != rfd)\n\t\tfcntl(wfd, F_SETFD, FD_CLOEXEC);\n\tif (efd != -1 && efd != rfd && efd != wfd)\n\t\tfcntl(efd, F_SETFD, FD_CLOEXEC);\n\n\tc->rfd = rfd;\n\tc->wfd = wfd;\n\tc->sock = (rfd == wfd) ? rfd : -1;\n\tc->efd = efd;\n\tc->extended_usage = extusage;\n\n\tif ((c->isatty = is_tty) != 0)\n\t\tdebug2(\"channel %d: rfd %d isatty\", c->self, c->rfd);\n#ifdef _AIX\n\t/* XXX: Later AIX versions can't push as much data to tty */\n\tc->wfd_isatty = is_tty || isatty(c->wfd);\n#endif\n\n\t/* enable nonblocking mode */\n\tif (nonblock) {\n\t\tif (rfd != -1)\n\t\t\tset_nonblock(rfd);\n\t\tif (wfd != -1)\n\t\t\tset_nonblock(wfd);\n\t\tif (efd != -1)\n\t\t\tset_nonblock(efd);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic void\nchannel_register_fds(struct ssh *ssh, Channel *c, int rfd, int wfd, int efd,\n    int extusage, int nonblock, int is_tty)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\t/* Update the maximum file descriptor value. */\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, rfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, wfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, efd);\n\n\tif (rfd != -1)\n\t\tfcntl(rfd, F_SETFD, FD_CLOEXEC);\n\tif (wfd != -1 && wfd != rfd)\n\t\tfcntl(wfd, F_SETFD, FD_CLOEXEC);\n\tif (efd != -1 && efd != rfd && efd != wfd)\n\t\tfcntl(efd, F_SETFD, FD_CLOEXEC);\n\n\tc->rfd = rfd;\n\tc->wfd = wfd;\n\tc->sock = (rfd == wfd) ? rfd : -1;\n\tc->efd = efd;\n\tc->extended_usage = extusage;\n\n\tif ((c->isatty = is_tty) != 0)\n\t\tdebug2(\"channel %d: rfd %d isatty\", c->self, c->rfd);\n#ifdef _AIX\n\t/* XXX: Later AIX versions can't push as much data to tty */\n\tc->wfd_isatty = is_tty || isatty(c->wfd);\n#endif\n\n\t/* enable nonblocking mode */\n\tif (nonblock) {\n\t\tif (rfd != -1)\n\t\t\tset_nonblock(rfd);\n\t\tif (wfd != -1)\n\t\t\tset_nonblock(wfd);\n\t\tif (efd != -1)\n\t\t\tset_nonblock(efd);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_connect_ctx_free",
          "args": [
            "&cctx"
          ],
          "line": 4519
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4195-4206",
          "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect_to_helper",
          "args": [
            "ssh",
            "c->path",
            "c->host_port",
            "SOCK_STREAM",
            "NULL",
            "NULL",
            "&cctx",
            "NULL",
            "NULL"
          ],
          "line": 4516
        },
        "resolved": true,
        "details": {
          "function_name": "connect_to_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4212-4275",
          "snippet": "static int\nconnect_to_helper(struct ssh *ssh, const char *name, int port, int socktype,\n    char *ctype, char *rname, struct channel_connect *cctx,\n    int *reason, const char **errmsg)\n{\n\tstruct addrinfo hints;\n\tint gaierr;\n\tint sock = -1;\n\tchar strport[NI_MAXSERV];\n\n\tif (port == PORT_STREAMLOCAL) {\n\t\tstruct sockaddr_un *sunaddr;\n\t\tstruct addrinfo *ai;\n\n\t\tif (strlen(name) > sizeof(sunaddr->sun_path)) {\n\t\t\terror(\"%.100s: %.100s\", name, strerror(ENAMETOOLONG));\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Fake up a struct addrinfo for AF_UNIX connections.\n\t\t * channel_connect_ctx_free() must check ai_family\n\t\t * and use free() not freeaddirinfo() for AF_UNIX.\n\t\t */\n\t\tai = xmalloc(sizeof(*ai) + sizeof(*sunaddr));\n\t\tmemset(ai, 0, sizeof(*ai) + sizeof(*sunaddr));\n\t\tai->ai_addr = (struct sockaddr *)(ai + 1);\n\t\tai->ai_addrlen = sizeof(*sunaddr);\n\t\tai->ai_family = AF_UNIX;\n\t\tai->ai_socktype = socktype;\n\t\tai->ai_protocol = PF_UNSPEC;\n\t\tsunaddr = (struct sockaddr_un *)ai->ai_addr;\n\t\tsunaddr->sun_family = AF_UNIX;\n\t\tstrlcpy(sunaddr->sun_path, name, sizeof(sunaddr->sun_path));\n\t\tcctx->aitop = ai;\n\t} else {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ssh->chanctxt->IPv4or6;\n\t\thints.ai_socktype = socktype;\n\t\tsnprintf(strport, sizeof strport, \"%d\", port);\n\t\tif ((gaierr = getaddrinfo(name, strport, &hints, &cctx->aitop))\n\t\t    != 0) {\n\t\t\tif (errmsg != NULL)\n\t\t\t\t*errmsg = ssh_gai_strerror(gaierr);\n\t\t\tif (reason != NULL)\n\t\t\t\t*reason = SSH2_OPEN_CONNECT_FAILED;\n\t\t\terror(\"connect_to %.100s: unknown host (%s)\", name,\n\t\t\t    ssh_gai_strerror(gaierr));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcctx->host = xstrdup(name);\n\tcctx->port = port;\n\tcctx->ai = cctx->aitop;\n\n\tif ((sock = connect_next(cctx)) == -1) {\n\t\terror(\"connect to %.100s port %d failed: %s\",\n\t\t    name, port, strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn sock;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nstatic int\nconnect_to_helper(struct ssh *ssh, const char *name, int port, int socktype,\n    char *ctype, char *rname, struct channel_connect *cctx,\n    int *reason, const char **errmsg)\n{\n\tstruct addrinfo hints;\n\tint gaierr;\n\tint sock = -1;\n\tchar strport[NI_MAXSERV];\n\n\tif (port == PORT_STREAMLOCAL) {\n\t\tstruct sockaddr_un *sunaddr;\n\t\tstruct addrinfo *ai;\n\n\t\tif (strlen(name) > sizeof(sunaddr->sun_path)) {\n\t\t\terror(\"%.100s: %.100s\", name, strerror(ENAMETOOLONG));\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Fake up a struct addrinfo for AF_UNIX connections.\n\t\t * channel_connect_ctx_free() must check ai_family\n\t\t * and use free() not freeaddirinfo() for AF_UNIX.\n\t\t */\n\t\tai = xmalloc(sizeof(*ai) + sizeof(*sunaddr));\n\t\tmemset(ai, 0, sizeof(*ai) + sizeof(*sunaddr));\n\t\tai->ai_addr = (struct sockaddr *)(ai + 1);\n\t\tai->ai_addrlen = sizeof(*sunaddr);\n\t\tai->ai_family = AF_UNIX;\n\t\tai->ai_socktype = socktype;\n\t\tai->ai_protocol = PF_UNSPEC;\n\t\tsunaddr = (struct sockaddr_un *)ai->ai_addr;\n\t\tsunaddr->sun_family = AF_UNIX;\n\t\tstrlcpy(sunaddr->sun_path, name, sizeof(sunaddr->sun_path));\n\t\tcctx->aitop = ai;\n\t} else {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ssh->chanctxt->IPv4or6;\n\t\thints.ai_socktype = socktype;\n\t\tsnprintf(strport, sizeof strport, \"%d\", port);\n\t\tif ((gaierr = getaddrinfo(name, strport, &hints, &cctx->aitop))\n\t\t    != 0) {\n\t\t\tif (errmsg != NULL)\n\t\t\t\t*errmsg = ssh_gai_strerror(gaierr);\n\t\t\tif (reason != NULL)\n\t\t\t\t*reason = SSH2_OPEN_CONNECT_FAILED;\n\t\t\terror(\"connect_to %.100s: unknown host (%s)\", name,\n\t\t\t    ssh_gai_strerror(gaierr));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcctx->host = xstrdup(name);\n\tcctx->port = port;\n\tcctx->ai = cctx->aitop;\n\n\tif ((sock = connect_next(cctx)) == -1) {\n\t\terror(\"connect to %.100s port %d failed: %s\",\n\t\t    name, port, strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn sock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&cctx",
            "0",
            "sizeof(cctx)"
          ],
          "line": 4515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nrdynamic_connect_finish(struct ssh *ssh, Channel *c)\n{\n\tstruct channel_connect cctx;\n\tint sock;\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, c->path, c->host_port, SOCK_STREAM, NULL,\n\t    NULL, &cctx, NULL, NULL);\n\tif (sock == -1)\n\t\tchannel_connect_ctx_free(&cctx);\n\telse {\n\t\t/* similar to SSH_CHANNEL_CONNECTING but we've already sent the open */\n\t\tc->type = SSH_CHANNEL_RDYNAMIC_FINISH;\n\t\tc->connect_ctx = cctx;\n\t\tchannel_register_fds(ssh, c, sock, sock, -1, 0, 1, 0);\n\t}\n\treturn sock;\n}"
  },
  {
    "function_name": "rdynamic_connect_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4482-4506",
    "snippet": "static Channel *\nrdynamic_connect_prepare(struct ssh *ssh, char *ctype, char *rname)\n{\n\tChannel *c;\n\tint r;\n\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_RDYNAMIC_OPEN, -1, -1, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = 0;\n\tc->path = NULL;\n\n\t/*\n\t * We need to open the channel before we have a FD,\n\t * so that we can get SOCKS header from peer.\n\t */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: confirm: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\treturn c;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %i: confirm: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 4502
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 4503
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "c->local_maxpacket"
          ],
          "line": 4501
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_CHANNEL_OPEN_CONFIRMATION"
          ],
          "line": 4497
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "ctype",
            "SSH_CHANNEL_RDYNAMIC_OPEN",
            "-1",
            "-1",
            "-1",
            "CHAN_TCP_WINDOW_DEFAULT",
            "CHAN_TCP_PACKET_DEFAULT",
            "0",
            "rname",
            "1"
          ],
          "line": 4488
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic Channel *\nrdynamic_connect_prepare(struct ssh *ssh, char *ctype, char *rname)\n{\n\tChannel *c;\n\tint r;\n\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_RDYNAMIC_OPEN, -1, -1, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = 0;\n\tc->path = NULL;\n\n\t/*\n\t * We need to open the channel before we have a FD,\n\t * so that we can get SOCKS header from peer.\n\t */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: confirm: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\treturn c;\n}"
  },
  {
    "function_name": "channel_send_window_changes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4456-4479",
    "snippet": "void\nchannel_send_window_changes(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct winsize ws;\n\tint r;\n\tu_int i;\n\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL || !sc->channels[i]->client_tty ||\n\t\t    sc->channels[i]->type != SSH_CHANNEL_OPEN)\n\t\t\tcontinue;\n\t\tif (ioctl(sc->channels[i]->rfd, TIOCGWINSZ, &ws) < 0)\n\t\t\tcontinue;\n\t\tchannel_request_start(ssh, i, \"window-change\", 0);\n\t\tif ((r = sshpkt_put_u32(ssh, (u_int)ws.ws_col)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_row)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_xpixel)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_ypixel)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal(\"%s: channel %u: send window-change: %s\",\n\t\t\t    __func__, i, ssh_err(r));\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %u: send window-change: %s\"",
            "__func__",
            "i",
            "ssh_err(r)"
          ],
          "line": 4476
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 4477
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 4475
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "(u_int)ws.ws_ypixel"
          ],
          "line": 4474
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_request_start",
          "args": [
            "ssh",
            "i",
            "\"window-change\"",
            "0"
          ],
          "line": 4470
        },
        "resolved": true,
        "details": {
          "function_name": "channel_request_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "932-952",
          "snippet": "void\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: unknown channel id\", __func__, id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: unknown channel id\", __func__, id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sc->channels[i]->rfd",
            "TIOCGWINSZ",
            "&ws"
          ],
          "line": 4468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_send_window_changes(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct winsize ws;\n\tint r;\n\tu_int i;\n\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL || !sc->channels[i]->client_tty ||\n\t\t    sc->channels[i]->type != SSH_CHANNEL_OPEN)\n\t\t\tcontinue;\n\t\tif (ioctl(sc->channels[i]->rfd, TIOCGWINSZ, &ws) < 0)\n\t\t\tcontinue;\n\t\tchannel_request_start(ssh, i, \"window-change\", 0);\n\t\tif ((r = sshpkt_put_u32(ssh, (u_int)ws.ws_col)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_row)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_xpixel)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_ypixel)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal(\"%s: channel %u: send window-change: %s\",\n\t\t\t    __func__, i, ssh_err(r));\n\t}\n}"
  },
  {
    "function_name": "channel_connect_to_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4417-4454",
    "snippet": "Channel *\nchannel_connect_to_path(struct ssh *ssh, const char *path,\n    char *ctype, char *rname)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tu_int i, permit, permit_adm = 1;\n\tstruct permission *perm;\n\n\tpermit = pset->all_permitted;\n\tif (!permit) {\n\t\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\t\tperm = &pset->permitted_user[i];\n\t\t\tif (open_match(perm, path, PORT_STREAMLOCAL)) {\n\t\t\t\tpermit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pset->num_permitted_admin > 0) {\n\t\tpermit_adm = 0;\n\t\tfor (i = 0; i < pset->num_permitted_admin; i++) {\n\t\t\tperm = &pset->permitted_admin[i];\n\t\t\tif (open_match(perm, path, PORT_STREAMLOCAL)) {\n\t\t\t\tpermit_adm = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!permit || !permit_adm) {\n\t\tlogit(\"Received request to connect to path %.100s, \"\n\t\t    \"but the request was denied.\", path);\n\t\treturn NULL;\n\t}\n\treturn connect_to(ssh, path, PORT_STREAMLOCAL, ctype, rname);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "connect_to",
          "args": [
            "ssh",
            "path",
            "PORT_STREAMLOCAL",
            "ctype",
            "rname"
          ],
          "line": 4453
        },
        "resolved": true,
        "details": {
          "function_name": "connect_to",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4278-4300",
          "snippet": "static Channel *\nconnect_to(struct ssh *ssh, const char *host, int port,\n    char *ctype, char *rname)\n{\n\tstruct channel_connect cctx;\n\tChannel *c;\n\tint sock;\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, host, port, SOCK_STREAM, ctype, rname,\n\t    &cctx, NULL, NULL);\n\tif (sock == -1) {\n\t\tchannel_connect_ctx_free(&cctx);\n\t\treturn NULL;\n\t}\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_CONNECTING, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = port;\n\tc->path = xstrdup(host);\n\tc->connect_ctx = cctx;\n\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic Channel *\nconnect_to(struct ssh *ssh, const char *host, int port,\n    char *ctype, char *rname)\n{\n\tstruct channel_connect cctx;\n\tChannel *c;\n\tint sock;\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, host, port, SOCK_STREAM, ctype, rname,\n\t    &cctx, NULL, NULL);\n\tif (sock == -1) {\n\t\tchannel_connect_ctx_free(&cctx);\n\t\treturn NULL;\n\t}\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_CONNECTING, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = port;\n\tc->path = xstrdup(host);\n\tc->connect_ctx = cctx;\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Received request to connect to path %.100s, \"\n\t\t    \"but the request was denied.\"",
            "path"
          ],
          "line": 4449
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_match",
          "args": [
            "perm",
            "path",
            "PORT_STREAMLOCAL"
          ],
          "line": 4441
        },
        "resolved": true,
        "details": {
          "function_name": "open_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3888-3901",
          "snippet": "static int\nopen_match(struct permission *allowed_open, const char *requestedhost,\n    int requestedport)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->port_to_connect != FWD_PERMIT_ANY_PORT &&\n\t    allowed_open->port_to_connect != requestedport)\n\t\treturn 0;\n\tif (strcmp(allowed_open->host_to_connect, FWD_PERMIT_ANY_HOST) != 0 &&\n\t    strcmp(allowed_open->host_to_connect, requestedhost) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FWD_PERMIT_ANY_HOST\t\"*\"",
            "#define FWD_PERMIT_ANY_PORT\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define FWD_PERMIT_ANY_HOST\t\"*\"\n#define FWD_PERMIT_ANY_PORT\t0\n\nstatic int\nopen_match(struct permission *allowed_open, const char *requestedhost,\n    int requestedport)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->port_to_connect != FWD_PERMIT_ANY_PORT &&\n\t    allowed_open->port_to_connect != requestedport)\n\t\treturn 0;\n\tif (strcmp(allowed_open->host_to_connect, FWD_PERMIT_ANY_HOST) != 0 &&\n\t    strcmp(allowed_open->host_to_connect, requestedhost) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_connect_to_path(struct ssh *ssh, const char *path,\n    char *ctype, char *rname)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tu_int i, permit, permit_adm = 1;\n\tstruct permission *perm;\n\n\tpermit = pset->all_permitted;\n\tif (!permit) {\n\t\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\t\tperm = &pset->permitted_user[i];\n\t\t\tif (open_match(perm, path, PORT_STREAMLOCAL)) {\n\t\t\t\tpermit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pset->num_permitted_admin > 0) {\n\t\tpermit_adm = 0;\n\t\tfor (i = 0; i < pset->num_permitted_admin; i++) {\n\t\t\tperm = &pset->permitted_admin[i];\n\t\t\tif (open_match(perm, path, PORT_STREAMLOCAL)) {\n\t\t\t\tpermit_adm = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!permit || !permit_adm) {\n\t\tlogit(\"Received request to connect to path %.100s, \"\n\t\t    \"but the request was denied.\", path);\n\t\treturn NULL;\n\t}\n\treturn connect_to(ssh, path, PORT_STREAMLOCAL, ctype, rname);\n}"
  },
  {
    "function_name": "channel_connect_to_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4357-4414",
    "snippet": "Channel *\nchannel_connect_to_port(struct ssh *ssh, const char *host, u_short port,\n    char *ctype, char *rname, int *reason, const char **errmsg)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tstruct channel_connect cctx;\n\tChannel *c;\n\tu_int i, permit, permit_adm = 1;\n\tint sock;\n\tstruct permission *perm;\n\n\tpermit = pset->all_permitted;\n\tif (!permit) {\n\t\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\t\tperm = &pset->permitted_user[i];\n\t\t\tif (open_match(perm, host, port)) {\n\t\t\t\tpermit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pset->num_permitted_admin > 0) {\n\t\tpermit_adm = 0;\n\t\tfor (i = 0; i < pset->num_permitted_admin; i++) {\n\t\t\tperm = &pset->permitted_admin[i];\n\t\t\tif (open_match(perm, host, port)) {\n\t\t\t\tpermit_adm = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!permit || !permit_adm) {\n\t\tlogit(\"Received request to connect to host %.100s port %d, \"\n\t\t    \"but the request was denied.\", host, port);\n\t\tif (reason != NULL)\n\t\t\t*reason = SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED;\n\t\treturn NULL;\n\t}\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, host, port, SOCK_STREAM, ctype, rname,\n\t    &cctx, reason, errmsg);\n\tif (sock == -1) {\n\t\tchannel_connect_ctx_free(&cctx);\n\t\treturn NULL;\n\t}\n\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_CONNECTING, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = port;\n\tc->path = xstrdup(host);\n\tc->connect_ctx = cctx;\n\n\treturn c;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int connect_next(struct channel_connect *);",
      "static void channel_connect_ctx_free(struct channel_connect *);",
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "host"
          ],
          "line": 4410
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "ctype",
            "SSH_CHANNEL_CONNECTING",
            "sock",
            "sock",
            "-1",
            "CHAN_TCP_WINDOW_DEFAULT",
            "CHAN_TCP_PACKET_DEFAULT",
            "0",
            "rname",
            "1"
          ],
          "line": 4407
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_connect_ctx_free",
          "args": [
            "&cctx"
          ],
          "line": 4403
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4195-4206",
          "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect_to_helper",
          "args": [
            "ssh",
            "host",
            "port",
            "SOCK_STREAM",
            "ctype",
            "rname",
            "&cctx",
            "reason",
            "errmsg"
          ],
          "line": 4400
        },
        "resolved": true,
        "details": {
          "function_name": "connect_to_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4212-4275",
          "snippet": "static int\nconnect_to_helper(struct ssh *ssh, const char *name, int port, int socktype,\n    char *ctype, char *rname, struct channel_connect *cctx,\n    int *reason, const char **errmsg)\n{\n\tstruct addrinfo hints;\n\tint gaierr;\n\tint sock = -1;\n\tchar strport[NI_MAXSERV];\n\n\tif (port == PORT_STREAMLOCAL) {\n\t\tstruct sockaddr_un *sunaddr;\n\t\tstruct addrinfo *ai;\n\n\t\tif (strlen(name) > sizeof(sunaddr->sun_path)) {\n\t\t\terror(\"%.100s: %.100s\", name, strerror(ENAMETOOLONG));\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Fake up a struct addrinfo for AF_UNIX connections.\n\t\t * channel_connect_ctx_free() must check ai_family\n\t\t * and use free() not freeaddirinfo() for AF_UNIX.\n\t\t */\n\t\tai = xmalloc(sizeof(*ai) + sizeof(*sunaddr));\n\t\tmemset(ai, 0, sizeof(*ai) + sizeof(*sunaddr));\n\t\tai->ai_addr = (struct sockaddr *)(ai + 1);\n\t\tai->ai_addrlen = sizeof(*sunaddr);\n\t\tai->ai_family = AF_UNIX;\n\t\tai->ai_socktype = socktype;\n\t\tai->ai_protocol = PF_UNSPEC;\n\t\tsunaddr = (struct sockaddr_un *)ai->ai_addr;\n\t\tsunaddr->sun_family = AF_UNIX;\n\t\tstrlcpy(sunaddr->sun_path, name, sizeof(sunaddr->sun_path));\n\t\tcctx->aitop = ai;\n\t} else {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ssh->chanctxt->IPv4or6;\n\t\thints.ai_socktype = socktype;\n\t\tsnprintf(strport, sizeof strport, \"%d\", port);\n\t\tif ((gaierr = getaddrinfo(name, strport, &hints, &cctx->aitop))\n\t\t    != 0) {\n\t\t\tif (errmsg != NULL)\n\t\t\t\t*errmsg = ssh_gai_strerror(gaierr);\n\t\t\tif (reason != NULL)\n\t\t\t\t*reason = SSH2_OPEN_CONNECT_FAILED;\n\t\t\terror(\"connect_to %.100s: unknown host (%s)\", name,\n\t\t\t    ssh_gai_strerror(gaierr));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcctx->host = xstrdup(name);\n\tcctx->port = port;\n\tcctx->ai = cctx->aitop;\n\n\tif ((sock = connect_next(cctx)) == -1) {\n\t\terror(\"connect to %.100s port %d failed: %s\",\n\t\t    name, port, strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn sock;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nstatic int\nconnect_to_helper(struct ssh *ssh, const char *name, int port, int socktype,\n    char *ctype, char *rname, struct channel_connect *cctx,\n    int *reason, const char **errmsg)\n{\n\tstruct addrinfo hints;\n\tint gaierr;\n\tint sock = -1;\n\tchar strport[NI_MAXSERV];\n\n\tif (port == PORT_STREAMLOCAL) {\n\t\tstruct sockaddr_un *sunaddr;\n\t\tstruct addrinfo *ai;\n\n\t\tif (strlen(name) > sizeof(sunaddr->sun_path)) {\n\t\t\terror(\"%.100s: %.100s\", name, strerror(ENAMETOOLONG));\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Fake up a struct addrinfo for AF_UNIX connections.\n\t\t * channel_connect_ctx_free() must check ai_family\n\t\t * and use free() not freeaddirinfo() for AF_UNIX.\n\t\t */\n\t\tai = xmalloc(sizeof(*ai) + sizeof(*sunaddr));\n\t\tmemset(ai, 0, sizeof(*ai) + sizeof(*sunaddr));\n\t\tai->ai_addr = (struct sockaddr *)(ai + 1);\n\t\tai->ai_addrlen = sizeof(*sunaddr);\n\t\tai->ai_family = AF_UNIX;\n\t\tai->ai_socktype = socktype;\n\t\tai->ai_protocol = PF_UNSPEC;\n\t\tsunaddr = (struct sockaddr_un *)ai->ai_addr;\n\t\tsunaddr->sun_family = AF_UNIX;\n\t\tstrlcpy(sunaddr->sun_path, name, sizeof(sunaddr->sun_path));\n\t\tcctx->aitop = ai;\n\t} else {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ssh->chanctxt->IPv4or6;\n\t\thints.ai_socktype = socktype;\n\t\tsnprintf(strport, sizeof strport, \"%d\", port);\n\t\tif ((gaierr = getaddrinfo(name, strport, &hints, &cctx->aitop))\n\t\t    != 0) {\n\t\t\tif (errmsg != NULL)\n\t\t\t\t*errmsg = ssh_gai_strerror(gaierr);\n\t\t\tif (reason != NULL)\n\t\t\t\t*reason = SSH2_OPEN_CONNECT_FAILED;\n\t\t\terror(\"connect_to %.100s: unknown host (%s)\", name,\n\t\t\t    ssh_gai_strerror(gaierr));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcctx->host = xstrdup(name);\n\tcctx->port = port;\n\tcctx->ai = cctx->aitop;\n\n\tif ((sock = connect_next(cctx)) == -1) {\n\t\terror(\"connect to %.100s port %d failed: %s\",\n\t\t    name, port, strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn sock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&cctx",
            "0",
            "sizeof(cctx)"
          ],
          "line": 4399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Received request to connect to host %.100s port %d, \"\n\t\t    \"but the request was denied.\"",
            "host",
            "port"
          ],
          "line": 4392
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_match",
          "args": [
            "perm",
            "host",
            "port"
          ],
          "line": 4384
        },
        "resolved": true,
        "details": {
          "function_name": "open_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3888-3901",
          "snippet": "static int\nopen_match(struct permission *allowed_open, const char *requestedhost,\n    int requestedport)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->port_to_connect != FWD_PERMIT_ANY_PORT &&\n\t    allowed_open->port_to_connect != requestedport)\n\t\treturn 0;\n\tif (strcmp(allowed_open->host_to_connect, FWD_PERMIT_ANY_HOST) != 0 &&\n\t    strcmp(allowed_open->host_to_connect, requestedhost) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FWD_PERMIT_ANY_HOST\t\"*\"",
            "#define FWD_PERMIT_ANY_PORT\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define FWD_PERMIT_ANY_HOST\t\"*\"\n#define FWD_PERMIT_ANY_PORT\t0\n\nstatic int\nopen_match(struct permission *allowed_open, const char *requestedhost,\n    int requestedport)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->port_to_connect != FWD_PERMIT_ANY_PORT &&\n\t    allowed_open->port_to_connect != requestedport)\n\t\treturn 0;\n\tif (strcmp(allowed_open->host_to_connect, FWD_PERMIT_ANY_HOST) != 0 &&\n\t    strcmp(allowed_open->host_to_connect, requestedhost) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_connect_to_port(struct ssh *ssh, const char *host, u_short port,\n    char *ctype, char *rname, int *reason, const char **errmsg)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tstruct channel_connect cctx;\n\tChannel *c;\n\tu_int i, permit, permit_adm = 1;\n\tint sock;\n\tstruct permission *perm;\n\n\tpermit = pset->all_permitted;\n\tif (!permit) {\n\t\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\t\tperm = &pset->permitted_user[i];\n\t\t\tif (open_match(perm, host, port)) {\n\t\t\t\tpermit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pset->num_permitted_admin > 0) {\n\t\tpermit_adm = 0;\n\t\tfor (i = 0; i < pset->num_permitted_admin; i++) {\n\t\t\tperm = &pset->permitted_admin[i];\n\t\t\tif (open_match(perm, host, port)) {\n\t\t\t\tpermit_adm = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!permit || !permit_adm) {\n\t\tlogit(\"Received request to connect to host %.100s port %d, \"\n\t\t    \"but the request was denied.\", host, port);\n\t\tif (reason != NULL)\n\t\t\t*reason = SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED;\n\t\treturn NULL;\n\t}\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, host, port, SOCK_STREAM, ctype, rname,\n\t    &cctx, reason, errmsg);\n\tif (sock == -1) {\n\t\tchannel_connect_ctx_free(&cctx);\n\t\treturn NULL;\n\t}\n\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_CONNECTING, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = port;\n\tc->path = xstrdup(host);\n\tc->connect_ctx = cctx;\n\n\treturn c;\n}"
  },
  {
    "function_name": "channel_connect_by_listen_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4334-4354",
    "snippet": "Channel *\nchannel_connect_by_listen_path(struct ssh *ssh, const char *path,\n    char *ctype, char *rname)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tu_int i;\n\tstruct permission *perm;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_streamlocal(perm, path)) {\n\t\t\treturn connect_to(ssh,\n\t\t\t    perm->host_to_connect, perm->port_to_connect,\n\t\t\t    ctype, rname);\n\t\t}\n\t}\n\terror(\"WARNING: Server requests forwarding for unknown path %.100s\",\n\t    path);\n\treturn NULL;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"WARNING: Server requests forwarding for unknown path %.100s\"",
            "path"
          ],
          "line": 4351
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect_to",
          "args": [
            "ssh",
            "perm->host_to_connect",
            "perm->port_to_connect",
            "ctype",
            "rname"
          ],
          "line": 4346
        },
        "resolved": true,
        "details": {
          "function_name": "connect_to",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4278-4300",
          "snippet": "static Channel *\nconnect_to(struct ssh *ssh, const char *host, int port,\n    char *ctype, char *rname)\n{\n\tstruct channel_connect cctx;\n\tChannel *c;\n\tint sock;\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, host, port, SOCK_STREAM, ctype, rname,\n\t    &cctx, NULL, NULL);\n\tif (sock == -1) {\n\t\tchannel_connect_ctx_free(&cctx);\n\t\treturn NULL;\n\t}\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_CONNECTING, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = port;\n\tc->path = xstrdup(host);\n\tc->connect_ctx = cctx;\n\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic Channel *\nconnect_to(struct ssh *ssh, const char *host, int port,\n    char *ctype, char *rname)\n{\n\tstruct channel_connect cctx;\n\tChannel *c;\n\tint sock;\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, host, port, SOCK_STREAM, ctype, rname,\n\t    &cctx, NULL, NULL);\n\tif (sock == -1) {\n\t\tchannel_connect_ctx_free(&cctx);\n\t\treturn NULL;\n\t}\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_CONNECTING, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = port;\n\tc->path = xstrdup(host);\n\tc->connect_ctx = cctx;\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_listen_match_streamlocal",
          "args": [
            "perm",
            "path"
          ],
          "line": 4345
        },
        "resolved": true,
        "details": {
          "function_name": "open_listen_match_streamlocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3931-3943",
          "snippet": "static int\nopen_listen_match_streamlocal(struct permission *allowed_open,\n    const char *requestedpath)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != PORT_STREAMLOCAL)\n\t\treturn 0;\n\tif (allowed_open->listen_path == NULL ||\n\t    strcmp(allowed_open->listen_path, requestedpath) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nopen_listen_match_streamlocal(struct permission *allowed_open,\n    const char *requestedpath)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != PORT_STREAMLOCAL)\n\t\treturn 0;\n\tif (allowed_open->listen_path == NULL ||\n\t    strcmp(allowed_open->listen_path, requestedpath) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_connect_by_listen_path(struct ssh *ssh, const char *path,\n    char *ctype, char *rname)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tu_int i;\n\tstruct permission *perm;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_streamlocal(perm, path)) {\n\t\t\treturn connect_to(ssh,\n\t\t\t    perm->host_to_connect, perm->port_to_connect,\n\t\t\t    ctype, rname);\n\t\t}\n\t}\n\terror(\"WARNING: Server requests forwarding for unknown path %.100s\",\n\t    path);\n\treturn NULL;\n}"
  },
  {
    "function_name": "channel_connect_by_listen_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4306-4332",
    "snippet": "Channel *\nchannel_connect_by_listen_address(struct ssh *ssh, const char *listen_host,\n    u_short listen_port, char *ctype, char *rname)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tu_int i;\n\tstruct permission *perm;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_tcpip(perm,\n\t\t    listen_host, listen_port, 1)) {\n\t\t\tif (perm->downstream)\n\t\t\t\treturn perm->downstream;\n\t\t\tif (perm->port_to_connect == 0)\n\t\t\t\treturn rdynamic_connect_prepare(ssh,\n\t\t\t\t    ctype, rname);\n\t\t\treturn connect_to(ssh,\n\t\t\t    perm->host_to_connect, perm->port_to_connect,\n\t\t\t    ctype, rname);\n\t\t}\n\t}\n\terror(\"WARNING: Server requests forwarding for unknown listen_port %d\",\n\t    listen_port);\n\treturn NULL;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *channel_rfwd_bind_host(const char *listen_host);",
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"WARNING: Server requests forwarding for unknown listen_port %d\"",
            "listen_port"
          ],
          "line": 4329
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect_to",
          "args": [
            "ssh",
            "perm->host_to_connect",
            "perm->port_to_connect",
            "ctype",
            "rname"
          ],
          "line": 4324
        },
        "resolved": true,
        "details": {
          "function_name": "connect_to",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4278-4300",
          "snippet": "static Channel *\nconnect_to(struct ssh *ssh, const char *host, int port,\n    char *ctype, char *rname)\n{\n\tstruct channel_connect cctx;\n\tChannel *c;\n\tint sock;\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, host, port, SOCK_STREAM, ctype, rname,\n\t    &cctx, NULL, NULL);\n\tif (sock == -1) {\n\t\tchannel_connect_ctx_free(&cctx);\n\t\treturn NULL;\n\t}\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_CONNECTING, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = port;\n\tc->path = xstrdup(host);\n\tc->connect_ctx = cctx;\n\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic Channel *\nconnect_to(struct ssh *ssh, const char *host, int port,\n    char *ctype, char *rname)\n{\n\tstruct channel_connect cctx;\n\tChannel *c;\n\tint sock;\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, host, port, SOCK_STREAM, ctype, rname,\n\t    &cctx, NULL, NULL);\n\tif (sock == -1) {\n\t\tchannel_connect_ctx_free(&cctx);\n\t\treturn NULL;\n\t}\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_CONNECTING, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = port;\n\tc->path = xstrdup(host);\n\tc->connect_ctx = cctx;\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdynamic_connect_prepare",
          "args": [
            "ssh",
            "ctype",
            "rname"
          ],
          "line": 4322
        },
        "resolved": true,
        "details": {
          "function_name": "rdynamic_connect_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4482-4506",
          "snippet": "static Channel *\nrdynamic_connect_prepare(struct ssh *ssh, char *ctype, char *rname)\n{\n\tChannel *c;\n\tint r;\n\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_RDYNAMIC_OPEN, -1, -1, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = 0;\n\tc->path = NULL;\n\n\t/*\n\t * We need to open the channel before we have a FD,\n\t * so that we can get SOCKS header from peer.\n\t */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: confirm: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic Channel *\nrdynamic_connect_prepare(struct ssh *ssh, char *ctype, char *rname)\n{\n\tChannel *c;\n\tint r;\n\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_RDYNAMIC_OPEN, -1, -1, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = 0;\n\tc->path = NULL;\n\n\t/*\n\t * We need to open the channel before we have a FD,\n\t * so that we can get SOCKS header from peer.\n\t */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: confirm: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_listen_match_tcpip",
          "args": [
            "perm",
            "listen_host",
            "listen_port",
            "1"
          ],
          "line": 4317
        },
        "resolved": true,
        "details": {
          "function_name": "open_listen_match_tcpip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3909-3929",
          "snippet": "static int\nopen_listen_match_tcpip(struct permission *allowed_open,\n    const char *requestedhost, u_short requestedport, int translate)\n{\n\tconst char *allowed_host;\n\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != requestedport)\n\t\treturn 0;\n\tif (!translate && allowed_open->listen_host == NULL &&\n\t    requestedhost == NULL)\n\t\treturn 1;\n\tallowed_host = translate ?\n\t    channel_rfwd_bind_host(allowed_open->listen_host) :\n\t    allowed_open->listen_host;\n\tif (allowed_host == NULL || requestedhost == NULL ||\n\t    strcmp(allowed_host, requestedhost) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\n\nstatic int\nopen_listen_match_tcpip(struct permission *allowed_open,\n    const char *requestedhost, u_short requestedport, int translate)\n{\n\tconst char *allowed_host;\n\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != requestedport)\n\t\treturn 0;\n\tif (!translate && allowed_open->listen_host == NULL &&\n\t    requestedhost == NULL)\n\t\treturn 1;\n\tallowed_host = translate ?\n\t    channel_rfwd_bind_host(allowed_open->listen_host) :\n\t    allowed_open->listen_host;\n\tif (allowed_host == NULL || requestedhost == NULL ||\n\t    strcmp(allowed_host, requestedhost) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_connect_by_listen_address(struct ssh *ssh, const char *listen_host,\n    u_short listen_port, char *ctype, char *rname)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tu_int i;\n\tstruct permission *perm;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_tcpip(perm,\n\t\t    listen_host, listen_port, 1)) {\n\t\t\tif (perm->downstream)\n\t\t\t\treturn perm->downstream;\n\t\t\tif (perm->port_to_connect == 0)\n\t\t\t\treturn rdynamic_connect_prepare(ssh,\n\t\t\t\t    ctype, rname);\n\t\t\treturn connect_to(ssh,\n\t\t\t    perm->host_to_connect, perm->port_to_connect,\n\t\t\t    ctype, rname);\n\t\t}\n\t}\n\terror(\"WARNING: Server requests forwarding for unknown listen_port %d\",\n\t    listen_port);\n\treturn NULL;\n}"
  },
  {
    "function_name": "connect_to",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4278-4300",
    "snippet": "static Channel *\nconnect_to(struct ssh *ssh, const char *host, int port,\n    char *ctype, char *rname)\n{\n\tstruct channel_connect cctx;\n\tChannel *c;\n\tint sock;\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, host, port, SOCK_STREAM, ctype, rname,\n\t    &cctx, NULL, NULL);\n\tif (sock == -1) {\n\t\tchannel_connect_ctx_free(&cctx);\n\t\treturn NULL;\n\t}\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_CONNECTING, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = port;\n\tc->path = xstrdup(host);\n\tc->connect_ctx = cctx;\n\n\treturn c;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int connect_next(struct channel_connect *);",
      "static void channel_connect_ctx_free(struct channel_connect *);",
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "host"
          ],
          "line": 4296
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "ctype",
            "SSH_CHANNEL_CONNECTING",
            "sock",
            "sock",
            "-1",
            "CHAN_TCP_WINDOW_DEFAULT",
            "CHAN_TCP_PACKET_DEFAULT",
            "0",
            "rname",
            "1"
          ],
          "line": 4293
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_connect_ctx_free",
          "args": [
            "&cctx"
          ],
          "line": 4290
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4195-4206",
          "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect_to_helper",
          "args": [
            "ssh",
            "host",
            "port",
            "SOCK_STREAM",
            "ctype",
            "rname",
            "&cctx",
            "NULL",
            "NULL"
          ],
          "line": 4287
        },
        "resolved": true,
        "details": {
          "function_name": "connect_to_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4212-4275",
          "snippet": "static int\nconnect_to_helper(struct ssh *ssh, const char *name, int port, int socktype,\n    char *ctype, char *rname, struct channel_connect *cctx,\n    int *reason, const char **errmsg)\n{\n\tstruct addrinfo hints;\n\tint gaierr;\n\tint sock = -1;\n\tchar strport[NI_MAXSERV];\n\n\tif (port == PORT_STREAMLOCAL) {\n\t\tstruct sockaddr_un *sunaddr;\n\t\tstruct addrinfo *ai;\n\n\t\tif (strlen(name) > sizeof(sunaddr->sun_path)) {\n\t\t\terror(\"%.100s: %.100s\", name, strerror(ENAMETOOLONG));\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Fake up a struct addrinfo for AF_UNIX connections.\n\t\t * channel_connect_ctx_free() must check ai_family\n\t\t * and use free() not freeaddirinfo() for AF_UNIX.\n\t\t */\n\t\tai = xmalloc(sizeof(*ai) + sizeof(*sunaddr));\n\t\tmemset(ai, 0, sizeof(*ai) + sizeof(*sunaddr));\n\t\tai->ai_addr = (struct sockaddr *)(ai + 1);\n\t\tai->ai_addrlen = sizeof(*sunaddr);\n\t\tai->ai_family = AF_UNIX;\n\t\tai->ai_socktype = socktype;\n\t\tai->ai_protocol = PF_UNSPEC;\n\t\tsunaddr = (struct sockaddr_un *)ai->ai_addr;\n\t\tsunaddr->sun_family = AF_UNIX;\n\t\tstrlcpy(sunaddr->sun_path, name, sizeof(sunaddr->sun_path));\n\t\tcctx->aitop = ai;\n\t} else {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ssh->chanctxt->IPv4or6;\n\t\thints.ai_socktype = socktype;\n\t\tsnprintf(strport, sizeof strport, \"%d\", port);\n\t\tif ((gaierr = getaddrinfo(name, strport, &hints, &cctx->aitop))\n\t\t    != 0) {\n\t\t\tif (errmsg != NULL)\n\t\t\t\t*errmsg = ssh_gai_strerror(gaierr);\n\t\t\tif (reason != NULL)\n\t\t\t\t*reason = SSH2_OPEN_CONNECT_FAILED;\n\t\t\terror(\"connect_to %.100s: unknown host (%s)\", name,\n\t\t\t    ssh_gai_strerror(gaierr));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcctx->host = xstrdup(name);\n\tcctx->port = port;\n\tcctx->ai = cctx->aitop;\n\n\tif ((sock = connect_next(cctx)) == -1) {\n\t\terror(\"connect to %.100s port %d failed: %s\",\n\t\t    name, port, strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn sock;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nstatic int\nconnect_to_helper(struct ssh *ssh, const char *name, int port, int socktype,\n    char *ctype, char *rname, struct channel_connect *cctx,\n    int *reason, const char **errmsg)\n{\n\tstruct addrinfo hints;\n\tint gaierr;\n\tint sock = -1;\n\tchar strport[NI_MAXSERV];\n\n\tif (port == PORT_STREAMLOCAL) {\n\t\tstruct sockaddr_un *sunaddr;\n\t\tstruct addrinfo *ai;\n\n\t\tif (strlen(name) > sizeof(sunaddr->sun_path)) {\n\t\t\terror(\"%.100s: %.100s\", name, strerror(ENAMETOOLONG));\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Fake up a struct addrinfo for AF_UNIX connections.\n\t\t * channel_connect_ctx_free() must check ai_family\n\t\t * and use free() not freeaddirinfo() for AF_UNIX.\n\t\t */\n\t\tai = xmalloc(sizeof(*ai) + sizeof(*sunaddr));\n\t\tmemset(ai, 0, sizeof(*ai) + sizeof(*sunaddr));\n\t\tai->ai_addr = (struct sockaddr *)(ai + 1);\n\t\tai->ai_addrlen = sizeof(*sunaddr);\n\t\tai->ai_family = AF_UNIX;\n\t\tai->ai_socktype = socktype;\n\t\tai->ai_protocol = PF_UNSPEC;\n\t\tsunaddr = (struct sockaddr_un *)ai->ai_addr;\n\t\tsunaddr->sun_family = AF_UNIX;\n\t\tstrlcpy(sunaddr->sun_path, name, sizeof(sunaddr->sun_path));\n\t\tcctx->aitop = ai;\n\t} else {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ssh->chanctxt->IPv4or6;\n\t\thints.ai_socktype = socktype;\n\t\tsnprintf(strport, sizeof strport, \"%d\", port);\n\t\tif ((gaierr = getaddrinfo(name, strport, &hints, &cctx->aitop))\n\t\t    != 0) {\n\t\t\tif (errmsg != NULL)\n\t\t\t\t*errmsg = ssh_gai_strerror(gaierr);\n\t\t\tif (reason != NULL)\n\t\t\t\t*reason = SSH2_OPEN_CONNECT_FAILED;\n\t\t\terror(\"connect_to %.100s: unknown host (%s)\", name,\n\t\t\t    ssh_gai_strerror(gaierr));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcctx->host = xstrdup(name);\n\tcctx->port = port;\n\tcctx->ai = cctx->aitop;\n\n\tif ((sock = connect_next(cctx)) == -1) {\n\t\terror(\"connect to %.100s port %d failed: %s\",\n\t\t    name, port, strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn sock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&cctx",
            "0",
            "sizeof(cctx)"
          ],
          "line": 4286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic Channel *\nconnect_to(struct ssh *ssh, const char *host, int port,\n    char *ctype, char *rname)\n{\n\tstruct channel_connect cctx;\n\tChannel *c;\n\tint sock;\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, host, port, SOCK_STREAM, ctype, rname,\n\t    &cctx, NULL, NULL);\n\tif (sock == -1) {\n\t\tchannel_connect_ctx_free(&cctx);\n\t\treturn NULL;\n\t}\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_CONNECTING, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = port;\n\tc->path = xstrdup(host);\n\tc->connect_ctx = cctx;\n\n\treturn c;\n}"
  },
  {
    "function_name": "connect_to_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4212-4275",
    "snippet": "static int\nconnect_to_helper(struct ssh *ssh, const char *name, int port, int socktype,\n    char *ctype, char *rname, struct channel_connect *cctx,\n    int *reason, const char **errmsg)\n{\n\tstruct addrinfo hints;\n\tint gaierr;\n\tint sock = -1;\n\tchar strport[NI_MAXSERV];\n\n\tif (port == PORT_STREAMLOCAL) {\n\t\tstruct sockaddr_un *sunaddr;\n\t\tstruct addrinfo *ai;\n\n\t\tif (strlen(name) > sizeof(sunaddr->sun_path)) {\n\t\t\terror(\"%.100s: %.100s\", name, strerror(ENAMETOOLONG));\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Fake up a struct addrinfo for AF_UNIX connections.\n\t\t * channel_connect_ctx_free() must check ai_family\n\t\t * and use free() not freeaddirinfo() for AF_UNIX.\n\t\t */\n\t\tai = xmalloc(sizeof(*ai) + sizeof(*sunaddr));\n\t\tmemset(ai, 0, sizeof(*ai) + sizeof(*sunaddr));\n\t\tai->ai_addr = (struct sockaddr *)(ai + 1);\n\t\tai->ai_addrlen = sizeof(*sunaddr);\n\t\tai->ai_family = AF_UNIX;\n\t\tai->ai_socktype = socktype;\n\t\tai->ai_protocol = PF_UNSPEC;\n\t\tsunaddr = (struct sockaddr_un *)ai->ai_addr;\n\t\tsunaddr->sun_family = AF_UNIX;\n\t\tstrlcpy(sunaddr->sun_path, name, sizeof(sunaddr->sun_path));\n\t\tcctx->aitop = ai;\n\t} else {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ssh->chanctxt->IPv4or6;\n\t\thints.ai_socktype = socktype;\n\t\tsnprintf(strport, sizeof strport, \"%d\", port);\n\t\tif ((gaierr = getaddrinfo(name, strport, &hints, &cctx->aitop))\n\t\t    != 0) {\n\t\t\tif (errmsg != NULL)\n\t\t\t\t*errmsg = ssh_gai_strerror(gaierr);\n\t\t\tif (reason != NULL)\n\t\t\t\t*reason = SSH2_OPEN_CONNECT_FAILED;\n\t\t\terror(\"connect_to %.100s: unknown host (%s)\", name,\n\t\t\t    ssh_gai_strerror(gaierr));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcctx->host = xstrdup(name);\n\tcctx->port = port;\n\tcctx->ai = cctx->aitop;\n\n\tif ((sock = connect_next(cctx)) == -1) {\n\t\terror(\"connect to %.100s port %d failed: %s\",\n\t\t    name, port, strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn sock;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int connect_next(struct channel_connect *);",
      "static void channel_connect_ctx_free(struct channel_connect *);",
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"connect to %.100s port %d failed: %s\"",
            "name",
            "port",
            "strerror(errno)"
          ],
          "line": 4269
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 4270
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect_next",
          "args": [
            "cctx"
          ],
          "line": 4268
        },
        "resolved": true,
        "details": {
          "function_name": "connect_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4137-4193",
          "snippet": "static int\nconnect_next(struct channel_connect *cctx)\n{\n\tint sock, saved_errno;\n\tstruct sockaddr_un *sunaddr;\n\tchar ntop[NI_MAXHOST];\n\tchar strport[MAXIMUM(NI_MAXSERV, sizeof(sunaddr->sun_path))];\n\n\tfor (; cctx->ai; cctx->ai = cctx->ai->ai_next) {\n\t\tswitch (cctx->ai->ai_family) {\n\t\tcase AF_UNIX:\n\t\t\t/* unix:pathname instead of host:port */\n\t\t\tsunaddr = (struct sockaddr_un *)cctx->ai->ai_addr;\n\t\t\tstrlcpy(ntop, \"unix\", sizeof(ntop));\n\t\t\tstrlcpy(strport, sunaddr->sun_path, sizeof(strport));\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\tcase AF_INET6:\n\t\t\tif (getnameinfo(cctx->ai->ai_addr, cctx->ai->ai_addrlen,\n\t\t\t    ntop, sizeof(ntop), strport, sizeof(strport),\n\t\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\t\terror(\"connect_next: getnameinfo failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif ((sock = socket(cctx->ai->ai_family, cctx->ai->ai_socktype,\n\t\t    cctx->ai->ai_protocol)) == -1) {\n\t\t\tif (cctx->ai->ai_next == NULL)\n\t\t\t\terror(\"socket: %.100s\", strerror(errno));\n\t\t\telse\n\t\t\t\tverbose(\"socket: %.100s\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\tif (set_nonblock(sock) == -1)\n\t\t\tfatal(\"%s: set_nonblock(%d)\", __func__, sock);\n\t\tif (connect(sock, cctx->ai->ai_addr,\n\t\t    cctx->ai->ai_addrlen) == -1 && errno != EINPROGRESS) {\n\t\t\tdebug(\"connect_next: host %.100s ([%.100s]:%s): \"\n\t\t\t    \"%.100s\", cctx->host, ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tsaved_errno = errno;\n\t\t\tclose(sock);\n\t\t\terrno = saved_errno;\n\t\t\tcontinue;\t/* fail -- try next */\n\t\t}\n\t\tif (cctx->ai->ai_family != AF_UNIX)\n\t\t\tset_nodelay(sock);\n\t\tdebug(\"connect_next: host %.100s ([%.100s]:%s) \"\n\t\t    \"in progress, fd=%d\", cctx->host, ntop, strport, sock);\n\t\tcctx->ai = cctx->ai->ai_next;\n\t\treturn sock;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic int\nconnect_next(struct channel_connect *cctx)\n{\n\tint sock, saved_errno;\n\tstruct sockaddr_un *sunaddr;\n\tchar ntop[NI_MAXHOST];\n\tchar strport[MAXIMUM(NI_MAXSERV, sizeof(sunaddr->sun_path))];\n\n\tfor (; cctx->ai; cctx->ai = cctx->ai->ai_next) {\n\t\tswitch (cctx->ai->ai_family) {\n\t\tcase AF_UNIX:\n\t\t\t/* unix:pathname instead of host:port */\n\t\t\tsunaddr = (struct sockaddr_un *)cctx->ai->ai_addr;\n\t\t\tstrlcpy(ntop, \"unix\", sizeof(ntop));\n\t\t\tstrlcpy(strport, sunaddr->sun_path, sizeof(strport));\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\tcase AF_INET6:\n\t\t\tif (getnameinfo(cctx->ai->ai_addr, cctx->ai->ai_addrlen,\n\t\t\t    ntop, sizeof(ntop), strport, sizeof(strport),\n\t\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\t\terror(\"connect_next: getnameinfo failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif ((sock = socket(cctx->ai->ai_family, cctx->ai->ai_socktype,\n\t\t    cctx->ai->ai_protocol)) == -1) {\n\t\t\tif (cctx->ai->ai_next == NULL)\n\t\t\t\terror(\"socket: %.100s\", strerror(errno));\n\t\t\telse\n\t\t\t\tverbose(\"socket: %.100s\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\tif (set_nonblock(sock) == -1)\n\t\t\tfatal(\"%s: set_nonblock(%d)\", __func__, sock);\n\t\tif (connect(sock, cctx->ai->ai_addr,\n\t\t    cctx->ai->ai_addrlen) == -1 && errno != EINPROGRESS) {\n\t\t\tdebug(\"connect_next: host %.100s ([%.100s]:%s): \"\n\t\t\t    \"%.100s\", cctx->host, ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tsaved_errno = errno;\n\t\t\tclose(sock);\n\t\t\terrno = saved_errno;\n\t\t\tcontinue;\t/* fail -- try next */\n\t\t}\n\t\tif (cctx->ai->ai_family != AF_UNIX)\n\t\t\tset_nodelay(sock);\n\t\tdebug(\"connect_next: host %.100s ([%.100s]:%s) \"\n\t\t    \"in progress, fd=%d\", cctx->host, ntop, strport, sock);\n\t\tcctx->ai = cctx->ai->ai_next;\n\t\treturn sock;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "name"
          ],
          "line": 4264
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "name",
            "strport",
            "&hints",
            "&cctx->aitop"
          ],
          "line": 4252
        },
        "resolved": true,
        "details": {
          "function_name": "getaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "154-234",
          "snippet": "int\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "strport",
            "sizeof strport",
            "\"%d\"",
            "port"
          ],
          "line": 4251
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 4248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "sunaddr->sun_path",
            "name",
            "sizeof(sunaddr->sun_path)"
          ],
          "line": 4245
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ai",
            "0",
            "sizeof(*ai) + sizeof(*sunaddr)"
          ],
          "line": 4237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(*ai) + sizeof(*sunaddr)"
          ],
          "line": 4236
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 4226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nstatic int\nconnect_to_helper(struct ssh *ssh, const char *name, int port, int socktype,\n    char *ctype, char *rname, struct channel_connect *cctx,\n    int *reason, const char **errmsg)\n{\n\tstruct addrinfo hints;\n\tint gaierr;\n\tint sock = -1;\n\tchar strport[NI_MAXSERV];\n\n\tif (port == PORT_STREAMLOCAL) {\n\t\tstruct sockaddr_un *sunaddr;\n\t\tstruct addrinfo *ai;\n\n\t\tif (strlen(name) > sizeof(sunaddr->sun_path)) {\n\t\t\terror(\"%.100s: %.100s\", name, strerror(ENAMETOOLONG));\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Fake up a struct addrinfo for AF_UNIX connections.\n\t\t * channel_connect_ctx_free() must check ai_family\n\t\t * and use free() not freeaddirinfo() for AF_UNIX.\n\t\t */\n\t\tai = xmalloc(sizeof(*ai) + sizeof(*sunaddr));\n\t\tmemset(ai, 0, sizeof(*ai) + sizeof(*sunaddr));\n\t\tai->ai_addr = (struct sockaddr *)(ai + 1);\n\t\tai->ai_addrlen = sizeof(*sunaddr);\n\t\tai->ai_family = AF_UNIX;\n\t\tai->ai_socktype = socktype;\n\t\tai->ai_protocol = PF_UNSPEC;\n\t\tsunaddr = (struct sockaddr_un *)ai->ai_addr;\n\t\tsunaddr->sun_family = AF_UNIX;\n\t\tstrlcpy(sunaddr->sun_path, name, sizeof(sunaddr->sun_path));\n\t\tcctx->aitop = ai;\n\t} else {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ssh->chanctxt->IPv4or6;\n\t\thints.ai_socktype = socktype;\n\t\tsnprintf(strport, sizeof strport, \"%d\", port);\n\t\tif ((gaierr = getaddrinfo(name, strport, &hints, &cctx->aitop))\n\t\t    != 0) {\n\t\t\tif (errmsg != NULL)\n\t\t\t\t*errmsg = ssh_gai_strerror(gaierr);\n\t\t\tif (reason != NULL)\n\t\t\t\t*reason = SSH2_OPEN_CONNECT_FAILED;\n\t\t\terror(\"connect_to %.100s: unknown host (%s)\", name,\n\t\t\t    ssh_gai_strerror(gaierr));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcctx->host = xstrdup(name);\n\tcctx->port = port;\n\tcctx->ai = cctx->aitop;\n\n\tif ((sock = connect_next(cctx)) == -1) {\n\t\terror(\"connect to %.100s port %d failed: %s\",\n\t\t    name, port, strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn sock;\n}"
  },
  {
    "function_name": "channel_connect_ctx_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4195-4206",
    "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int connect_next(struct channel_connect *);",
      "static void channel_connect_ctx_free(struct channel_connect *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cctx",
            "0",
            "sizeof(*cctx)"
          ],
          "line": 4205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "cctx->aitop"
          ],
          "line": 4203
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cctx->aitop"
          ],
          "line": 4201
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4195-4206",
          "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}"
  },
  {
    "function_name": "connect_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4137-4193",
    "snippet": "static int\nconnect_next(struct channel_connect *cctx)\n{\n\tint sock, saved_errno;\n\tstruct sockaddr_un *sunaddr;\n\tchar ntop[NI_MAXHOST];\n\tchar strport[MAXIMUM(NI_MAXSERV, sizeof(sunaddr->sun_path))];\n\n\tfor (; cctx->ai; cctx->ai = cctx->ai->ai_next) {\n\t\tswitch (cctx->ai->ai_family) {\n\t\tcase AF_UNIX:\n\t\t\t/* unix:pathname instead of host:port */\n\t\t\tsunaddr = (struct sockaddr_un *)cctx->ai->ai_addr;\n\t\t\tstrlcpy(ntop, \"unix\", sizeof(ntop));\n\t\t\tstrlcpy(strport, sunaddr->sun_path, sizeof(strport));\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\tcase AF_INET6:\n\t\t\tif (getnameinfo(cctx->ai->ai_addr, cctx->ai->ai_addrlen,\n\t\t\t    ntop, sizeof(ntop), strport, sizeof(strport),\n\t\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\t\terror(\"connect_next: getnameinfo failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif ((sock = socket(cctx->ai->ai_family, cctx->ai->ai_socktype,\n\t\t    cctx->ai->ai_protocol)) == -1) {\n\t\t\tif (cctx->ai->ai_next == NULL)\n\t\t\t\terror(\"socket: %.100s\", strerror(errno));\n\t\t\telse\n\t\t\t\tverbose(\"socket: %.100s\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\tif (set_nonblock(sock) == -1)\n\t\t\tfatal(\"%s: set_nonblock(%d)\", __func__, sock);\n\t\tif (connect(sock, cctx->ai->ai_addr,\n\t\t    cctx->ai->ai_addrlen) == -1 && errno != EINPROGRESS) {\n\t\t\tdebug(\"connect_next: host %.100s ([%.100s]:%s): \"\n\t\t\t    \"%.100s\", cctx->host, ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tsaved_errno = errno;\n\t\t\tclose(sock);\n\t\t\terrno = saved_errno;\n\t\t\tcontinue;\t/* fail -- try next */\n\t\t}\n\t\tif (cctx->ai->ai_family != AF_UNIX)\n\t\t\tset_nodelay(sock);\n\t\tdebug(\"connect_next: host %.100s ([%.100s]:%s) \"\n\t\t    \"in progress, fd=%d\", cctx->host, ntop, strport, sock);\n\t\tcctx->ai = cctx->ai->ai_next;\n\t\treturn sock;\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int connect_next(struct channel_connect *);",
      "static void channel_connect_ctx_free(struct channel_connect *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"connect_next: host %.100s ([%.100s]:%s) \"\n\t\t    \"in progress, fd=%d\"",
            "cctx->host",
            "ntop",
            "strport",
            "sock"
          ],
          "line": 4187
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nodelay",
          "args": [
            "sock"
          ],
          "line": 4186
        },
        "resolved": true,
        "details": {
          "function_name": "set_nodelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "149-168",
          "snippet": "void\nset_nodelay(int fd)\n{\n\tint opt;\n\tsocklen_t optlen;\n\n\toptlen = sizeof opt;\n\tif (getsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, &optlen) == -1) {\n\t\tdebug(\"getsockopt TCP_NODELAY: %.100s\", strerror(errno));\n\t\treturn;\n\t}\n\tif (opt == 1) {\n\t\tdebug2(\"fd %d is TCP_NODELAY\", fd);\n\t\treturn;\n\t}\n\topt = 1;\n\tdebug2(\"fd %d setting TCP_NODELAY\", fd);\n\tif (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof opt) == -1)\n\t\terror(\"setsockopt TCP_NODELAY: %.100s\", strerror(errno));\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nset_nodelay(int fd)\n{\n\tint opt;\n\tsocklen_t optlen;\n\n\toptlen = sizeof opt;\n\tif (getsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, &optlen) == -1) {\n\t\tdebug(\"getsockopt TCP_NODELAY: %.100s\", strerror(errno));\n\t\treturn;\n\t}\n\tif (opt == 1) {\n\t\tdebug2(\"fd %d is TCP_NODELAY\", fd);\n\t\treturn;\n\t}\n\topt = 1;\n\tdebug2(\"fd %d setting TCP_NODELAY\", fd);\n\tif (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof opt) == -1)\n\t\terror(\"setsockopt TCP_NODELAY: %.100s\", strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 4181
        },
        "resolved": true,
        "details": {
          "function_name": "channel_close_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "656-664",
          "snippet": "void\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 4179
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "sock",
            "cctx->ai->ai_addr",
            "cctx->ai->ai_addrlen"
          ],
          "line": 4175
        },
        "resolved": true,
        "details": {
          "function_name": "rdynamic_connect_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4482-4506",
          "snippet": "static Channel *\nrdynamic_connect_prepare(struct ssh *ssh, char *ctype, char *rname)\n{\n\tChannel *c;\n\tint r;\n\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_RDYNAMIC_OPEN, -1, -1, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = 0;\n\tc->path = NULL;\n\n\t/*\n\t * We need to open the channel before we have a FD,\n\t * so that we can get SOCKS header from peer.\n\t */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: confirm: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic Channel *\nrdynamic_connect_prepare(struct ssh *ssh, char *ctype, char *rname)\n{\n\tChannel *c;\n\tint r;\n\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_RDYNAMIC_OPEN, -1, -1, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = 0;\n\tc->path = NULL;\n\n\t/*\n\t * We need to open the channel before we have a FD,\n\t * so that we can get SOCKS header from peer.\n\t */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: confirm: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: set_nonblock(%d)\"",
            "__func__",
            "sock"
          ],
          "line": 4174
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nonblock",
          "args": [
            "sock"
          ],
          "line": 4173
        },
        "resolved": true,
        "details": {
          "function_name": "unset_nonblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "116-138",
          "snippet": "int\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"socket: %.100s\"",
            "strerror(errno)"
          ],
          "line": 4170
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"socket: %.100s\"",
            "strerror(errno)"
          ],
          "line": 4168
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "cctx->ai->ai_family",
            "cctx->ai->ai_socktype",
            "cctx->ai->ai_protocol"
          ],
          "line": 4165
        },
        "resolved": true,
        "details": {
          "function_name": "is_path_to_xsocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4667-4690",
          "snippet": "static int\nis_path_to_xsocket(const char *display, char *path, size_t pathlen)\n{\n\tstruct stat sbuf;\n\n\tif (strlcpy(path, display, pathlen) >= pathlen) {\n\t\terror(\"%s: display path too long\", __func__);\n\t\treturn 0;\n\t}\n\tif (display[0] != '/')\n\t\treturn 0;\n\tif (stat(path, &sbuf) == 0) {\n\t\treturn 1;\n\t} else {\n\t\tchar *dot = strrchr(path, '.');\n\t\tif (dot != NULL) {\n\t\t\t*dot = '\\0';\n\t\t\tif (stat(path, &sbuf) == 0) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nis_path_to_xsocket(const char *display, char *path, size_t pathlen)\n{\n\tstruct stat sbuf;\n\n\tif (strlcpy(path, display, pathlen) >= pathlen) {\n\t\terror(\"%s: display path too long\", __func__);\n\t\treturn 0;\n\t}\n\tif (display[0] != '/')\n\t\treturn 0;\n\tif (stat(path, &sbuf) == 0) {\n\t\treturn 1;\n\t} else {\n\t\tchar *dot = strrchr(path, '.');\n\t\tif (dot != NULL) {\n\t\t\t*dot = '\\0';\n\t\t\tif (stat(path, &sbuf) == 0) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "cctx->ai->ai_addr",
            "cctx->ai->ai_addrlen",
            "ntop",
            "sizeof(ntop)",
            "strport",
            "sizeof(strport)",
            "NI_NUMERICHOST|NI_NUMERICSERV"
          ],
          "line": 4155
        },
        "resolved": true,
        "details": {
          "function_name": "sshaix_getnameinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "415-434",
          "snippet": "int\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "strport",
            "sunaddr->sun_path",
            "sizeof(strport)"
          ],
          "line": 4151
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "NI_MAXSERV",
            "sizeof(sunaddr->sun_path)"
          ],
          "line": 4143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic int\nconnect_next(struct channel_connect *cctx)\n{\n\tint sock, saved_errno;\n\tstruct sockaddr_un *sunaddr;\n\tchar ntop[NI_MAXHOST];\n\tchar strport[MAXIMUM(NI_MAXSERV, sizeof(sunaddr->sun_path))];\n\n\tfor (; cctx->ai; cctx->ai = cctx->ai->ai_next) {\n\t\tswitch (cctx->ai->ai_family) {\n\t\tcase AF_UNIX:\n\t\t\t/* unix:pathname instead of host:port */\n\t\t\tsunaddr = (struct sockaddr_un *)cctx->ai->ai_addr;\n\t\t\tstrlcpy(ntop, \"unix\", sizeof(ntop));\n\t\t\tstrlcpy(strport, sunaddr->sun_path, sizeof(strport));\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\tcase AF_INET6:\n\t\t\tif (getnameinfo(cctx->ai->ai_addr, cctx->ai->ai_addrlen,\n\t\t\t    ntop, sizeof(ntop), strport, sizeof(strport),\n\t\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\t\terror(\"connect_next: getnameinfo failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif ((sock = socket(cctx->ai->ai_family, cctx->ai->ai_socktype,\n\t\t    cctx->ai->ai_protocol)) == -1) {\n\t\t\tif (cctx->ai->ai_next == NULL)\n\t\t\t\terror(\"socket: %.100s\", strerror(errno));\n\t\t\telse\n\t\t\t\tverbose(\"socket: %.100s\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\tif (set_nonblock(sock) == -1)\n\t\t\tfatal(\"%s: set_nonblock(%d)\", __func__, sock);\n\t\tif (connect(sock, cctx->ai->ai_addr,\n\t\t    cctx->ai->ai_addrlen) == -1 && errno != EINPROGRESS) {\n\t\t\tdebug(\"connect_next: host %.100s ([%.100s]:%s): \"\n\t\t\t    \"%.100s\", cctx->host, ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tsaved_errno = errno;\n\t\t\tclose(sock);\n\t\t\terrno = saved_errno;\n\t\t\tcontinue;\t/* fail -- try next */\n\t\t}\n\t\tif (cctx->ai->ai_family != AF_UNIX)\n\t\t\tset_nodelay(sock);\n\t\tdebug(\"connect_next: host %.100s ([%.100s]:%s) \"\n\t\t    \"in progress, fd=%d\", cctx->host, ntop, strport, sock);\n\t\tcctx->ai = cctx->ai->ai_next;\n\t\treturn sock;\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "permitopen_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4124-4134",
    "snippet": "int\npermitopen_port(const char *p)\n{\n\tint port;\n\n\tif (strcmp(p, \"*\") == 0)\n\t\treturn FWD_PERMIT_ANY_PORT;\n\tif ((port = a2port(p)) > 0)\n\t\treturn port;\n\treturn -1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define FWD_PERMIT_ANY_PORT\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "a2port",
          "args": [
            "p"
          ],
          "line": 4131
        },
        "resolved": true,
        "details": {
          "function_name": "a2port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "333-346",
          "snippet": "int\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"*\""
          ],
          "line": 4129
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define FWD_PERMIT_ANY_PORT\t0\n\nint\npermitopen_port(const char *p)\n{\n\tint port;\n\n\tif (strcmp(p, \"*\") == 0)\n\t\treturn FWD_PERMIT_ANY_PORT;\n\tif ((port = a2port(p)) > 0)\n\t\treturn port;\n\treturn -1;\n}"
  },
  {
    "function_name": "channel_update_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4100-4121",
    "snippet": "void\nchannel_update_permission(struct ssh *ssh, int idx, int newport)\n{\n\tstruct permission_set *pset = &ssh->chanctxt->local_perms;\n\n\tif (idx < 0 || (u_int)idx >= pset->num_permitted_user) {\n\t\tdebug(\"%s: index out of range: %d num_permitted_user %d\",\n\t\t    __func__, idx, pset->num_permitted_user);\n\t\treturn;\n\t}\n\tdebug(\"%s allowed port %d for forwarding to host %s port %d\",\n\t    newport > 0 ? \"Updating\" : \"Removing\",\n\t    newport,\n\t    pset->permitted_user[idx].host_to_connect,\n\t    pset->permitted_user[idx].port_to_connect);\n\tif (newport <= 0)\n\t\tfwd_perm_clear(&pset->permitted_user[idx]);\n\telse {\n\t\tpset->permitted_user[idx].listen_port =\n\t\t    (datafellows & SSH_BUG_DYNAMIC_RPORT) ? 0 : newport;\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fwd_perm_clear",
          "args": [
            "&pset->permitted_user[idx]"
          ],
          "line": 4116
        },
        "resolved": true,
        "details": {
          "function_name": "fwd_perm_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "455-462",
          "snippet": "static void\nfwd_perm_clear(struct permission *perm)\n{\n\tfree(perm->host_to_connect);\n\tfree(perm->listen_host);\n\tfree(perm->listen_path);\n\tbzero(perm, sizeof(*perm));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\n\nstatic void\nfwd_perm_clear(struct permission *perm)\n{\n\tfree(perm->host_to_connect);\n\tfree(perm->listen_host);\n\tfree(perm->listen_path);\n\tbzero(perm, sizeof(*perm));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s allowed port %d for forwarding to host %s port %d\"",
            "newport > 0 ? \"Updating\" : \"Removing\"",
            "newport",
            "pset->permitted_user[idx].host_to_connect",
            "pset->permitted_user[idx].port_to_connect"
          ],
          "line": 4110
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_update_permission(struct ssh *ssh, int idx, int newport)\n{\n\tstruct permission_set *pset = &ssh->chanctxt->local_perms;\n\n\tif (idx < 0 || (u_int)idx >= pset->num_permitted_user) {\n\t\tdebug(\"%s: index out of range: %d num_permitted_user %d\",\n\t\t    __func__, idx, pset->num_permitted_user);\n\t\treturn;\n\t}\n\tdebug(\"%s allowed port %d for forwarding to host %s port %d\",\n\t    newport > 0 ? \"Updating\" : \"Removing\",\n\t    newport,\n\t    pset->permitted_user[idx].host_to_connect,\n\t    pset->permitted_user[idx].port_to_connect);\n\tif (newport <= 0)\n\t\tfwd_perm_clear(&pset->permitted_user[idx]);\n\telse {\n\t\tpset->permitted_user[idx].listen_port =\n\t\t    (datafellows & SSH_BUG_DYNAMIC_RPORT) ? 0 : newport;\n\t}\n}"
  },
  {
    "function_name": "channel_clear_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4084-4093",
    "snippet": "void\nchannel_clear_permission(struct ssh *ssh, int who, int where)\n{\n\tstruct permission **permp;\n\tu_int *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\t*permp = xrecallocarray(*permp, *npermp, 0, sizeof(**permp));\n\t*npermp = 0;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xrecallocarray",
          "args": [
            "*permp",
            "*npermp",
            "0",
            "sizeof(**permp)"
          ],
          "line": 4091
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "permission_set_get_array",
          "args": [
            "ssh",
            "who",
            "where",
            "&permp",
            "&npermp"
          ],
          "line": 4090
        },
        "resolved": true,
        "details": {
          "function_name": "permission_set_get_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "501-519",
          "snippet": "static void\npermission_set_get_array(struct ssh *ssh, int who, int where,\n    struct permission ***permpp, u_int **npermpp)\n{\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tswitch (who) {\n\tcase FORWARD_USER:\n\t\t*permpp = &pset->permitted_user;\n\t\t*npermpp = &pset->num_permitted_user;\n\t\tbreak;\n\tcase FORWARD_ADM:\n\t\t*permpp = &pset->permitted_admin;\n\t\t*npermpp = &pset->num_permitted_admin;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: invalid forwarding client %d\", __func__, who);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nstatic void\npermission_set_get_array(struct ssh *ssh, int who, int where,\n    struct permission ***permpp, u_int **npermpp)\n{\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tswitch (who) {\n\tcase FORWARD_USER:\n\t\t*permpp = &pset->permitted_user;\n\t\t*npermpp = &pset->num_permitted_user;\n\t\tbreak;\n\tcase FORWARD_ADM:\n\t\t*permpp = &pset->permitted_admin;\n\t\t*npermpp = &pset->num_permitted_admin;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: invalid forwarding client %d\", __func__, who);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_clear_permission(struct ssh *ssh, int who, int where)\n{\n\tstruct permission **permp;\n\tu_int *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\t*permp = xrecallocarray(*permp, *npermp, 0, sizeof(**permp));\n\t*npermp = 0;\n}"
  },
  {
    "function_name": "channel_disable_admin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4073-4079",
    "snippet": "void\nchannel_disable_admin(struct ssh *ssh, int where)\n{\n\tchannel_clear_permission(ssh, FORWARD_ADM, where);\n\tpermission_set_add(ssh, FORWARD_ADM, where,\n\t    NULL, 0, NULL, NULL, 0, NULL);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "permission_set_add",
          "args": [
            "ssh",
            "FORWARD_ADM",
            "where",
            "NULL",
            "0",
            "NULL",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 4077
        },
        "resolved": true,
        "details": {
          "function_name": "permission_set_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "522-547",
          "snippet": "static int\npermission_set_add(struct ssh *ssh, int who, int where,\n    const char *host_to_connect, int port_to_connect,\n    const char *listen_host, const char *listen_path, int listen_port,\n    Channel *downstream)\n{\n\tstruct permission **permp;\n\tu_int n, *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\n\tif (*npermp >= INT_MAX)\n\t\tfatal(\"%s: %s overflow\", __func__, fwd_ident(who, where));\n\n\t*permp = xrecallocarray(*permp, *npermp, *npermp + 1, sizeof(**permp));\n\tn = (*npermp)++;\n#define MAYBE_DUP(s) ((s == NULL) ? NULL : xstrdup(s))\n\t(*permp)[n].host_to_connect = MAYBE_DUP(host_to_connect);\n\t(*permp)[n].port_to_connect = port_to_connect;\n\t(*permp)[n].listen_host = MAYBE_DUP(listen_host);\n\t(*permp)[n].listen_path = MAYBE_DUP(listen_path);\n\t(*permp)[n].listen_port = listen_port;\n\t(*permp)[n].downstream = downstream;\n#undef MAYBE_DUP\n\treturn (int)n;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\npermission_set_add(struct ssh *ssh, int who, int where,\n    const char *host_to_connect, int port_to_connect,\n    const char *listen_host, const char *listen_path, int listen_port,\n    Channel *downstream)\n{\n\tstruct permission **permp;\n\tu_int n, *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\n\tif (*npermp >= INT_MAX)\n\t\tfatal(\"%s: %s overflow\", __func__, fwd_ident(who, where));\n\n\t*permp = xrecallocarray(*permp, *npermp, *npermp + 1, sizeof(**permp));\n\tn = (*npermp)++;\n#define MAYBE_DUP(s) ((s == NULL) ? NULL : xstrdup(s))\n\t(*permp)[n].host_to_connect = MAYBE_DUP(host_to_connect);\n\t(*permp)[n].port_to_connect = port_to_connect;\n\t(*permp)[n].listen_host = MAYBE_DUP(listen_host);\n\t(*permp)[n].listen_path = MAYBE_DUP(listen_path);\n\t(*permp)[n].listen_port = listen_port;\n\t(*permp)[n].downstream = downstream;\n#undef MAYBE_DUP\n\treturn (int)n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_clear_permission",
          "args": [
            "ssh",
            "FORWARD_ADM",
            "where"
          ],
          "line": 4076
        },
        "resolved": true,
        "details": {
          "function_name": "channel_clear_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4084-4093",
          "snippet": "void\nchannel_clear_permission(struct ssh *ssh, int who, int where)\n{\n\tstruct permission **permp;\n\tu_int *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\t*permp = xrecallocarray(*permp, *npermp, 0, sizeof(**permp));\n\t*npermp = 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_clear_permission(struct ssh *ssh, int who, int where)\n{\n\tstruct permission **permp;\n\tu_int *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\t*permp = xrecallocarray(*permp, *npermp, 0, sizeof(**permp));\n\t*npermp = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_disable_admin(struct ssh *ssh, int where)\n{\n\tchannel_clear_permission(ssh, FORWARD_ADM, where);\n\tpermission_set_add(ssh, FORWARD_ADM, where,\n\t    NULL, 0, NULL, NULL, 0, NULL);\n}"
  },
  {
    "function_name": "channel_add_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4051-4068",
    "snippet": "void\nchannel_add_permission(struct ssh *ssh, int who, int where,\n    char *host, int port)\n{\n\tint local = where == FORWARD_LOCAL;\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tdebug(\"allow %s forwarding to host %s port %d\",\n\t    fwd_ident(who, where), host, port);\n\t/*\n\t * Remote forwards set listen_host/port, local forwards set\n\t * host/port_to_connect.\n\t */\n\tpermission_set_add(ssh, who, where,\n\t    local ? host : 0, local ? port : 0,\n\t    local ? NULL : host, NULL, local ? 0 : port, NULL);\n\tpset->all_permitted = 0;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *channel_rfwd_bind_host(const char *listen_host);",
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "permission_set_add",
          "args": [
            "ssh",
            "who",
            "where",
            "local ? host : 0",
            "local ? port : 0",
            "local ? NULL : host",
            "NULL",
            "local ? 0 : port",
            "NULL"
          ],
          "line": 4064
        },
        "resolved": true,
        "details": {
          "function_name": "permission_set_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "522-547",
          "snippet": "static int\npermission_set_add(struct ssh *ssh, int who, int where,\n    const char *host_to_connect, int port_to_connect,\n    const char *listen_host, const char *listen_path, int listen_port,\n    Channel *downstream)\n{\n\tstruct permission **permp;\n\tu_int n, *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\n\tif (*npermp >= INT_MAX)\n\t\tfatal(\"%s: %s overflow\", __func__, fwd_ident(who, where));\n\n\t*permp = xrecallocarray(*permp, *npermp, *npermp + 1, sizeof(**permp));\n\tn = (*npermp)++;\n#define MAYBE_DUP(s) ((s == NULL) ? NULL : xstrdup(s))\n\t(*permp)[n].host_to_connect = MAYBE_DUP(host_to_connect);\n\t(*permp)[n].port_to_connect = port_to_connect;\n\t(*permp)[n].listen_host = MAYBE_DUP(listen_host);\n\t(*permp)[n].listen_path = MAYBE_DUP(listen_path);\n\t(*permp)[n].listen_port = listen_port;\n\t(*permp)[n].downstream = downstream;\n#undef MAYBE_DUP\n\treturn (int)n;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\npermission_set_add(struct ssh *ssh, int who, int where,\n    const char *host_to_connect, int port_to_connect,\n    const char *listen_host, const char *listen_path, int listen_port,\n    Channel *downstream)\n{\n\tstruct permission **permp;\n\tu_int n, *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\n\tif (*npermp >= INT_MAX)\n\t\tfatal(\"%s: %s overflow\", __func__, fwd_ident(who, where));\n\n\t*permp = xrecallocarray(*permp, *npermp, *npermp + 1, sizeof(**permp));\n\tn = (*npermp)++;\n#define MAYBE_DUP(s) ((s == NULL) ? NULL : xstrdup(s))\n\t(*permp)[n].host_to_connect = MAYBE_DUP(host_to_connect);\n\t(*permp)[n].port_to_connect = port_to_connect;\n\t(*permp)[n].listen_host = MAYBE_DUP(listen_host);\n\t(*permp)[n].listen_path = MAYBE_DUP(listen_path);\n\t(*permp)[n].listen_port = listen_port;\n\t(*permp)[n].downstream = downstream;\n#undef MAYBE_DUP\n\treturn (int)n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"allow %s forwarding to host %s port %d\"",
            "fwd_ident(who, where)",
            "host",
            "port"
          ],
          "line": 4058
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fwd_ident",
          "args": [
            "who",
            "where"
          ],
          "line": 4059
        },
        "resolved": true,
        "details": {
          "function_name": "fwd_ident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "465-480",
          "snippet": "static const char *\nfwd_ident(int who, int where)\n{\n\tif (who == FORWARD_ADM) {\n\t\tif (where == FORWARD_LOCAL)\n\t\t\treturn \"admin local\";\n\t\telse if (where == FORWARD_REMOTE)\n\t\t\treturn \"admin remote\";\n\t} else if (who == FORWARD_USER) {\n\t\tif (where == FORWARD_LOCAL)\n\t\t\treturn \"user local\";\n\t\telse if (where == FORWARD_REMOTE)\n\t\t\treturn \"user remote\";\n\t}\n\tfatal(\"Unknown forward permission list %d/%d\", who, where);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfwd_ident(int who, int where)\n{\n\tif (who == FORWARD_ADM) {\n\t\tif (where == FORWARD_LOCAL)\n\t\t\treturn \"admin local\";\n\t\telse if (where == FORWARD_REMOTE)\n\t\t\treturn \"admin remote\";\n\t} else if (who == FORWARD_USER) {\n\t\tif (where == FORWARD_LOCAL)\n\t\t\treturn \"user local\";\n\t\telse if (where == FORWARD_REMOTE)\n\t\t\treturn \"user remote\";\n\t}\n\tfatal(\"Unknown forward permission list %d/%d\", who, where);\n}"
        }
      },
      {
        "call_info": {
          "callee": "permission_set_get",
          "args": [
            "ssh",
            "where"
          ],
          "line": 4056
        },
        "resolved": true,
        "details": {
          "function_name": "permission_set_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "483-498",
          "snippet": "static struct permission_set *\npermission_set_get(struct ssh *ssh, int where)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\tswitch (where) {\n\tcase FORWARD_LOCAL:\n\t\treturn &sc->local_perms;\n\t\tbreak;\n\tcase FORWARD_REMOTE:\n\t\treturn &sc->remote_perms;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: invalid forwarding direction %d\", __func__, where);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic struct permission_set *\npermission_set_get(struct ssh *ssh, int where)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\tswitch (where) {\n\tcase FORWARD_LOCAL:\n\t\treturn &sc->local_perms;\n\t\tbreak;\n\tcase FORWARD_REMOTE:\n\t\treturn &sc->remote_perms;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: invalid forwarding direction %d\", __func__, where);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_add_permission(struct ssh *ssh, int who, int where,\n    char *host, int port)\n{\n\tint local = where == FORWARD_LOCAL;\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tdebug(\"allow %s forwarding to host %s port %d\",\n\t    fwd_ident(who, where), host, port);\n\t/*\n\t * Remote forwards set listen_host/port, local forwards set\n\t * host/port_to_connect.\n\t */\n\tpermission_set_add(ssh, who, where,\n\t    local ? host : 0, local ? port : 0,\n\t    local ? NULL : host, NULL, local ? 0 : port, NULL);\n\tpset->all_permitted = 0;\n}"
  },
  {
    "function_name": "channel_permit_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4039-4046",
    "snippet": "void\nchannel_permit_all(struct ssh *ssh, int where)\n{\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tif (pset->num_permitted_user == 0)\n\t\tpset->all_permitted = 1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "permission_set_get",
          "args": [
            "ssh",
            "where"
          ],
          "line": 4042
        },
        "resolved": true,
        "details": {
          "function_name": "permission_set_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "483-498",
          "snippet": "static struct permission_set *\npermission_set_get(struct ssh *ssh, int where)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\tswitch (where) {\n\tcase FORWARD_LOCAL:\n\t\treturn &sc->local_perms;\n\t\tbreak;\n\tcase FORWARD_REMOTE:\n\t\treturn &sc->remote_perms;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: invalid forwarding direction %d\", __func__, where);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic struct permission_set *\npermission_set_get(struct ssh *ssh, int where)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\tswitch (where) {\n\tcase FORWARD_LOCAL:\n\t\treturn &sc->local_perms;\n\t\tbreak;\n\tcase FORWARD_REMOTE:\n\t\treturn &sc->remote_perms;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: invalid forwarding direction %d\", __func__, where);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_permit_all(struct ssh *ssh, int where)\n{\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tif (pset->num_permitted_user == 0)\n\t\tpset->all_permitted = 1;\n}"
  },
  {
    "function_name": "channel_request_rforward_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "4021-4032",
    "snippet": "int\nchannel_request_rforward_cancel(struct ssh *ssh, struct Forward *fwd)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_request_rforward_cancel_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_request_rforward_cancel_tcpip(ssh,\n\t\t    fwd->listen_host,\n\t\t    fwd->listen_port ? fwd->listen_port : fwd->allocated_port);\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *channel_rfwd_bind_host(const char *listen_host);",
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_request_rforward_cancel_tcpip",
          "args": [
            "ssh",
            "fwd->listen_host",
            "fwd->listen_port ? fwd->listen_port : fwd->allocated_port"
          ],
          "line": 4028
        },
        "resolved": true,
        "details": {
          "function_name": "channel_request_rforward_cancel_tcpip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3949-3980",
          "snippet": "static int\nchannel_request_rforward_cancel_tcpip(struct ssh *ssh,\n    const char *host, u_short port)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tint r;\n\tu_int i;\n\tstruct permission *perm;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_tcpip(perm, host, port, 0))\n\t\t\tbreak;\n\t\tperm = NULL;\n\t}\n\tif (perm == NULL) {\n\t\tdebug(\"%s: requested forward not found\", __func__);\n\t\treturn -1;\n\t}\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"cancel-tcpip-forward\")) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 || /* want reply */\n\t    (r = sshpkt_put_cstring(ssh, channel_rfwd_bind_host(host))) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, port)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: send cancel: %s\", __func__, ssh_err(r));\n\n\tfwd_perm_clear(perm); /* unregister */\n\n\treturn 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic int\nchannel_request_rforward_cancel_tcpip(struct ssh *ssh,\n    const char *host, u_short port)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tint r;\n\tu_int i;\n\tstruct permission *perm;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_tcpip(perm, host, port, 0))\n\t\t\tbreak;\n\t\tperm = NULL;\n\t}\n\tif (perm == NULL) {\n\t\tdebug(\"%s: requested forward not found\", __func__);\n\t\treturn -1;\n\t}\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"cancel-tcpip-forward\")) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 || /* want reply */\n\t    (r = sshpkt_put_cstring(ssh, channel_rfwd_bind_host(host))) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, port)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: send cancel: %s\", __func__, ssh_err(r));\n\n\tfwd_perm_clear(perm); /* unregister */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_request_rforward_cancel_streamlocal",
          "args": [
            "ssh",
            "fwd->listen_path"
          ],
          "line": 4025
        },
        "resolved": true,
        "details": {
          "function_name": "channel_request_rforward_cancel_streamlocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3986-4016",
          "snippet": "static int\nchannel_request_rforward_cancel_streamlocal(struct ssh *ssh, const char *path)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tint r;\n\tu_int i;\n\tstruct permission *perm;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_streamlocal(perm, path))\n\t\t\tbreak;\n\t\tperm = NULL;\n\t}\n\tif (perm == NULL) {\n\t\tdebug(\"%s: requested forward not found\", __func__);\n\t\treturn -1;\n\t}\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh,\n\t    \"cancel-streamlocal-forward@openssh.com\")) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 || /* want reply */\n\t    (r = sshpkt_put_cstring(ssh, path)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: send cancel: %s\", __func__, ssh_err(r));\n\n\tfwd_perm_clear(perm); /* unregister */\n\n\treturn 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic int\nchannel_request_rforward_cancel_streamlocal(struct ssh *ssh, const char *path)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tint r;\n\tu_int i;\n\tstruct permission *perm;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_streamlocal(perm, path))\n\t\t\tbreak;\n\t\tperm = NULL;\n\t}\n\tif (perm == NULL) {\n\t\tdebug(\"%s: requested forward not found\", __func__);\n\t\treturn -1;\n\t}\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh,\n\t    \"cancel-streamlocal-forward@openssh.com\")) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 || /* want reply */\n\t    (r = sshpkt_put_cstring(ssh, path)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: send cancel: %s\", __func__, ssh_err(r));\n\n\tfwd_perm_clear(perm); /* unregister */\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_request_rforward_cancel(struct ssh *ssh, struct Forward *fwd)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_request_rforward_cancel_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_request_rforward_cancel_tcpip(ssh,\n\t\t    fwd->listen_host,\n\t\t    fwd->listen_port ? fwd->listen_port : fwd->allocated_port);\n\t}\n}"
  },
  {
    "function_name": "channel_request_rforward_cancel_streamlocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3986-4016",
    "snippet": "static int\nchannel_request_rforward_cancel_streamlocal(struct ssh *ssh, const char *path)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tint r;\n\tu_int i;\n\tstruct permission *perm;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_streamlocal(perm, path))\n\t\t\tbreak;\n\t\tperm = NULL;\n\t}\n\tif (perm == NULL) {\n\t\tdebug(\"%s: requested forward not found\", __func__);\n\t\treturn -1;\n\t}\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh,\n\t    \"cancel-streamlocal-forward@openssh.com\")) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 || /* want reply */\n\t    (r = sshpkt_put_cstring(ssh, path)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: send cancel: %s\", __func__, ssh_err(r));\n\n\tfwd_perm_clear(perm); /* unregister */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fwd_perm_clear",
          "args": [
            "perm"
          ],
          "line": 4013
        },
        "resolved": true,
        "details": {
          "function_name": "fwd_perm_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "455-462",
          "snippet": "static void\nfwd_perm_clear(struct permission *perm)\n{\n\tfree(perm->host_to_connect);\n\tfree(perm->listen_host);\n\tfree(perm->listen_path);\n\tbzero(perm, sizeof(*perm));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\n\nstatic void\nfwd_perm_clear(struct permission *perm)\n{\n\tfree(perm->host_to_connect);\n\tfree(perm->listen_host);\n\tfree(perm->listen_path);\n\tbzero(perm, sizeof(*perm));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: send cancel: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 4011
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 4011
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 4010
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "path"
          ],
          "line": 4009
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u8",
          "args": [
            "ssh",
            "0"
          ],
          "line": 4008
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2435-2439",
          "snippet": "int\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_GLOBAL_REQUEST"
          ],
          "line": 4005
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: requested forward not found\"",
            "__func__"
          ],
          "line": 4002
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_listen_match_streamlocal",
          "args": [
            "perm",
            "path"
          ],
          "line": 3997
        },
        "resolved": true,
        "details": {
          "function_name": "open_listen_match_streamlocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3931-3943",
          "snippet": "static int\nopen_listen_match_streamlocal(struct permission *allowed_open,\n    const char *requestedpath)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != PORT_STREAMLOCAL)\n\t\treturn 0;\n\tif (allowed_open->listen_path == NULL ||\n\t    strcmp(allowed_open->listen_path, requestedpath) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nopen_listen_match_streamlocal(struct permission *allowed_open,\n    const char *requestedpath)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != PORT_STREAMLOCAL)\n\t\treturn 0;\n\tif (allowed_open->listen_path == NULL ||\n\t    strcmp(allowed_open->listen_path, requestedpath) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic int\nchannel_request_rforward_cancel_streamlocal(struct ssh *ssh, const char *path)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tint r;\n\tu_int i;\n\tstruct permission *perm;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_streamlocal(perm, path))\n\t\t\tbreak;\n\t\tperm = NULL;\n\t}\n\tif (perm == NULL) {\n\t\tdebug(\"%s: requested forward not found\", __func__);\n\t\treturn -1;\n\t}\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh,\n\t    \"cancel-streamlocal-forward@openssh.com\")) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 || /* want reply */\n\t    (r = sshpkt_put_cstring(ssh, path)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: send cancel: %s\", __func__, ssh_err(r));\n\n\tfwd_perm_clear(perm); /* unregister */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "channel_request_rforward_cancel_tcpip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3949-3980",
    "snippet": "static int\nchannel_request_rforward_cancel_tcpip(struct ssh *ssh,\n    const char *host, u_short port)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tint r;\n\tu_int i;\n\tstruct permission *perm;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_tcpip(perm, host, port, 0))\n\t\t\tbreak;\n\t\tperm = NULL;\n\t}\n\tif (perm == NULL) {\n\t\tdebug(\"%s: requested forward not found\", __func__);\n\t\treturn -1;\n\t}\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"cancel-tcpip-forward\")) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 || /* want reply */\n\t    (r = sshpkt_put_cstring(ssh, channel_rfwd_bind_host(host))) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, port)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: send cancel: %s\", __func__, ssh_err(r));\n\n\tfwd_perm_clear(perm); /* unregister */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fwd_perm_clear",
          "args": [
            "perm"
          ],
          "line": 3977
        },
        "resolved": true,
        "details": {
          "function_name": "fwd_perm_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "455-462",
          "snippet": "static void\nfwd_perm_clear(struct permission *perm)\n{\n\tfree(perm->host_to_connect);\n\tfree(perm->listen_host);\n\tfree(perm->listen_path);\n\tbzero(perm, sizeof(*perm));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\n\nstatic void\nfwd_perm_clear(struct permission *perm)\n{\n\tfree(perm->host_to_connect);\n\tfree(perm->listen_host);\n\tfree(perm->listen_path);\n\tbzero(perm, sizeof(*perm));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: send cancel: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 3975
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 3975
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 3974
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "port"
          ],
          "line": 3973
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "channel_rfwd_bind_host(host)"
          ],
          "line": 3972
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_rfwd_bind_host",
          "args": [
            "host"
          ],
          "line": 3972
        },
        "resolved": true,
        "details": {
          "function_name": "channel_rfwd_bind_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3813-3822",
          "snippet": "static const char *\nchannel_rfwd_bind_host(const char *listen_host)\n{\n\tif (listen_host == NULL) {\n\t\treturn \"localhost\";\n\t} else if (*listen_host == '\\0' || strcmp(listen_host, \"*\") == 0) {\n\t\treturn \"\";\n\t} else\n\t\treturn listen_host;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\n\nstatic const char *\nchannel_rfwd_bind_host(const char *listen_host)\n{\n\tif (listen_host == NULL) {\n\t\treturn \"localhost\";\n\t} else if (*listen_host == '\\0' || strcmp(listen_host, \"*\") == 0) {\n\t\treturn \"\";\n\t} else\n\t\treturn listen_host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u8",
          "args": [
            "ssh",
            "0"
          ],
          "line": 3971
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2435-2439",
          "snippet": "int\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_GLOBAL_REQUEST"
          ],
          "line": 3969
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: requested forward not found\"",
            "__func__"
          ],
          "line": 3966
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_listen_match_tcpip",
          "args": [
            "perm",
            "host",
            "port",
            "0"
          ],
          "line": 3961
        },
        "resolved": true,
        "details": {
          "function_name": "open_listen_match_tcpip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3909-3929",
          "snippet": "static int\nopen_listen_match_tcpip(struct permission *allowed_open,\n    const char *requestedhost, u_short requestedport, int translate)\n{\n\tconst char *allowed_host;\n\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != requestedport)\n\t\treturn 0;\n\tif (!translate && allowed_open->listen_host == NULL &&\n\t    requestedhost == NULL)\n\t\treturn 1;\n\tallowed_host = translate ?\n\t    channel_rfwd_bind_host(allowed_open->listen_host) :\n\t    allowed_open->listen_host;\n\tif (allowed_host == NULL || requestedhost == NULL ||\n\t    strcmp(allowed_host, requestedhost) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\n\nstatic int\nopen_listen_match_tcpip(struct permission *allowed_open,\n    const char *requestedhost, u_short requestedport, int translate)\n{\n\tconst char *allowed_host;\n\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != requestedport)\n\t\treturn 0;\n\tif (!translate && allowed_open->listen_host == NULL &&\n\t    requestedhost == NULL)\n\t\treturn 1;\n\tallowed_host = translate ?\n\t    channel_rfwd_bind_host(allowed_open->listen_host) :\n\t    allowed_open->listen_host;\n\tif (allowed_host == NULL || requestedhost == NULL ||\n\t    strcmp(allowed_host, requestedhost) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic int\nchannel_request_rforward_cancel_tcpip(struct ssh *ssh,\n    const char *host, u_short port)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tint r;\n\tu_int i;\n\tstruct permission *perm;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_tcpip(perm, host, port, 0))\n\t\t\tbreak;\n\t\tperm = NULL;\n\t}\n\tif (perm == NULL) {\n\t\tdebug(\"%s: requested forward not found\", __func__);\n\t\treturn -1;\n\t}\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"cancel-tcpip-forward\")) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 || /* want reply */\n\t    (r = sshpkt_put_cstring(ssh, channel_rfwd_bind_host(host))) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, port)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: send cancel: %s\", __func__, ssh_err(r));\n\n\tfwd_perm_clear(perm); /* unregister */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "open_listen_match_streamlocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3931-3943",
    "snippet": "static int\nopen_listen_match_streamlocal(struct permission *allowed_open,\n    const char *requestedpath)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != PORT_STREAMLOCAL)\n\t\treturn 0;\n\tif (allowed_open->listen_path == NULL ||\n\t    strcmp(allowed_open->listen_path, requestedpath) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "allowed_open->listen_path",
            "requestedpath"
          ],
          "line": 3940
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nopen_listen_match_streamlocal(struct permission *allowed_open,\n    const char *requestedpath)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != PORT_STREAMLOCAL)\n\t\treturn 0;\n\tif (allowed_open->listen_path == NULL ||\n\t    strcmp(allowed_open->listen_path, requestedpath) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "open_listen_match_tcpip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3909-3929",
    "snippet": "static int\nopen_listen_match_tcpip(struct permission *allowed_open,\n    const char *requestedhost, u_short requestedport, int translate)\n{\n\tconst char *allowed_host;\n\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != requestedport)\n\t\treturn 0;\n\tif (!translate && allowed_open->listen_host == NULL &&\n\t    requestedhost == NULL)\n\t\treturn 1;\n\tallowed_host = translate ?\n\t    channel_rfwd_bind_host(allowed_open->listen_host) :\n\t    allowed_open->listen_host;\n\tif (allowed_host == NULL || requestedhost == NULL ||\n\t    strcmp(allowed_host, requestedhost) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *channel_rfwd_bind_host(const char *listen_host);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "allowed_host",
            "requestedhost"
          ],
          "line": 3926
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_rfwd_bind_host",
          "args": [
            "allowed_open->listen_host"
          ],
          "line": 3923
        },
        "resolved": true,
        "details": {
          "function_name": "channel_rfwd_bind_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3813-3822",
          "snippet": "static const char *\nchannel_rfwd_bind_host(const char *listen_host)\n{\n\tif (listen_host == NULL) {\n\t\treturn \"localhost\";\n\t} else if (*listen_host == '\\0' || strcmp(listen_host, \"*\") == 0) {\n\t\treturn \"\";\n\t} else\n\t\treturn listen_host;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\n\nstatic const char *\nchannel_rfwd_bind_host(const char *listen_host)\n{\n\tif (listen_host == NULL) {\n\t\treturn \"localhost\";\n\t} else if (*listen_host == '\\0' || strcmp(listen_host, \"*\") == 0) {\n\t\treturn \"\";\n\t} else\n\t\treturn listen_host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\n\nstatic int\nopen_listen_match_tcpip(struct permission *allowed_open,\n    const char *requestedhost, u_short requestedport, int translate)\n{\n\tconst char *allowed_host;\n\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != requestedport)\n\t\treturn 0;\n\tif (!translate && allowed_open->listen_host == NULL &&\n\t    requestedhost == NULL)\n\t\treturn 1;\n\tallowed_host = translate ?\n\t    channel_rfwd_bind_host(allowed_open->listen_host) :\n\t    allowed_open->listen_host;\n\tif (allowed_host == NULL || requestedhost == NULL ||\n\t    strcmp(allowed_host, requestedhost) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "open_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3888-3901",
    "snippet": "static int\nopen_match(struct permission *allowed_open, const char *requestedhost,\n    int requestedport)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->port_to_connect != FWD_PERMIT_ANY_PORT &&\n\t    allowed_open->port_to_connect != requestedport)\n\t\treturn 0;\n\tif (strcmp(allowed_open->host_to_connect, FWD_PERMIT_ANY_HOST) != 0 &&\n\t    strcmp(allowed_open->host_to_connect, requestedhost) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define FWD_PERMIT_ANY_HOST\t\"*\"",
      "#define FWD_PERMIT_ANY_PORT\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "allowed_open->host_to_connect",
            "requestedhost"
          ],
          "line": 3898
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define FWD_PERMIT_ANY_HOST\t\"*\"\n#define FWD_PERMIT_ANY_PORT\t0\n\nstatic int\nopen_match(struct permission *allowed_open, const char *requestedhost,\n    int requestedport)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->port_to_connect != FWD_PERMIT_ANY_PORT &&\n\t    allowed_open->port_to_connect != requestedport)\n\t\treturn 0;\n\tif (strcmp(allowed_open->host_to_connect, FWD_PERMIT_ANY_HOST) != 0 &&\n\t    strcmp(allowed_open->host_to_connect, requestedhost) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "channel_request_remote_forwarding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3830-3886",
    "snippet": "int\nchannel_request_remote_forwarding(struct ssh *ssh, struct Forward *fwd)\n{\n\tint r, success = 0, idx = -1;\n\tchar *host_to_connect, *listen_host, *listen_path;\n\tint port_to_connect, listen_port;\n\n\t/* Send the forward request to the remote side. */\n\tif (fwd->listen_path != NULL) {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"streamlocal-forward@openssh.com\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0 || /* want reply */\n\t\t    (r = sshpkt_put_cstring(ssh, fwd->listen_path)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal(\"%s: request streamlocal: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t} else {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, \"tcpip-forward\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0 || /* want reply */\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    channel_rfwd_bind_host(fwd->listen_host))) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, fwd->listen_port)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal(\"%s: request tcpip-forward: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n\t/* Assume that server accepts the request */\n\tsuccess = 1;\n\tif (success) {\n\t\t/* Record that connection to this host/port is permitted. */\n\t\thost_to_connect = listen_host = listen_path = NULL;\n\t\tport_to_connect = listen_port = 0;\n\t\tif (fwd->connect_path != NULL) {\n\t\t\thost_to_connect = xstrdup(fwd->connect_path);\n\t\t\tport_to_connect = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\thost_to_connect = xstrdup(fwd->connect_host);\n\t\t\tport_to_connect = fwd->connect_port;\n\t\t}\n\t\tif (fwd->listen_path != NULL) {\n\t\t\tlisten_path = xstrdup(fwd->listen_path);\n\t\t\tlisten_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tif (fwd->listen_host != NULL)\n\t\t\t\tlisten_host = xstrdup(fwd->listen_host);\n\t\t\tlisten_port = fwd->listen_port;\n\t\t}\n\t\tidx = permission_set_add(ssh, FORWARD_USER, FORWARD_LOCAL,\n\t\t    host_to_connect, port_to_connect,\n\t\t    listen_host, listen_path, listen_port, NULL);\n\t}\n\treturn idx;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *channel_rfwd_bind_host(const char *listen_host);",
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "permission_set_add",
          "args": [
            "ssh",
            "FORWARD_USER",
            "FORWARD_LOCAL",
            "host_to_connect",
            "port_to_connect",
            "listen_host",
            "listen_path",
            "listen_port",
            "NULL"
          ],
          "line": 3881
        },
        "resolved": true,
        "details": {
          "function_name": "permission_set_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "522-547",
          "snippet": "static int\npermission_set_add(struct ssh *ssh, int who, int where,\n    const char *host_to_connect, int port_to_connect,\n    const char *listen_host, const char *listen_path, int listen_port,\n    Channel *downstream)\n{\n\tstruct permission **permp;\n\tu_int n, *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\n\tif (*npermp >= INT_MAX)\n\t\tfatal(\"%s: %s overflow\", __func__, fwd_ident(who, where));\n\n\t*permp = xrecallocarray(*permp, *npermp, *npermp + 1, sizeof(**permp));\n\tn = (*npermp)++;\n#define MAYBE_DUP(s) ((s == NULL) ? NULL : xstrdup(s))\n\t(*permp)[n].host_to_connect = MAYBE_DUP(host_to_connect);\n\t(*permp)[n].port_to_connect = port_to_connect;\n\t(*permp)[n].listen_host = MAYBE_DUP(listen_host);\n\t(*permp)[n].listen_path = MAYBE_DUP(listen_path);\n\t(*permp)[n].listen_port = listen_port;\n\t(*permp)[n].downstream = downstream;\n#undef MAYBE_DUP\n\treturn (int)n;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\npermission_set_add(struct ssh *ssh, int who, int where,\n    const char *host_to_connect, int port_to_connect,\n    const char *listen_host, const char *listen_path, int listen_port,\n    Channel *downstream)\n{\n\tstruct permission **permp;\n\tu_int n, *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\n\tif (*npermp >= INT_MAX)\n\t\tfatal(\"%s: %s overflow\", __func__, fwd_ident(who, where));\n\n\t*permp = xrecallocarray(*permp, *npermp, *npermp + 1, sizeof(**permp));\n\tn = (*npermp)++;\n#define MAYBE_DUP(s) ((s == NULL) ? NULL : xstrdup(s))\n\t(*permp)[n].host_to_connect = MAYBE_DUP(host_to_connect);\n\t(*permp)[n].port_to_connect = port_to_connect;\n\t(*permp)[n].listen_host = MAYBE_DUP(listen_host);\n\t(*permp)[n].listen_path = MAYBE_DUP(listen_path);\n\t(*permp)[n].listen_port = listen_port;\n\t(*permp)[n].downstream = downstream;\n#undef MAYBE_DUP\n\treturn (int)n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "fwd->listen_host"
          ],
          "line": 3878
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: request tcpip-forward: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 3857
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 3858
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_write_wait",
          "args": [
            "ssh"
          ],
          "line": 3856
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_write_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "1930-1985",
          "snippet": "int\nssh_packet_write_wait(struct ssh *ssh)\n{\n\tfd_set *setp;\n\tint ret, r, ms_remain = 0;\n\tstruct timeval start, timeout, *timeoutp = NULL;\n\tstruct session_state *state = ssh->state;\n\n\tsetp = calloc(howmany(state->connection_out + 1,\n\t    NFDBITS), sizeof(fd_mask));\n\tif (setp == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\tfree(setp);\n\t\treturn r;\n\t}\n\twhile (ssh_packet_have_data_to_write(ssh)) {\n\t\tmemset(setp, 0, howmany(state->connection_out + 1,\n\t\t    NFDBITS) * sizeof(fd_mask));\n\t\tFD_SET(state->connection_out, setp);\n\n\t\tif (state->packet_timeout_ms > 0) {\n\t\t\tms_remain = state->packet_timeout_ms;\n\t\t\ttimeoutp = &timeout;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (state->packet_timeout_ms != -1) {\n\t\t\t\tms_to_timeval(&timeout, ms_remain);\n\t\t\t\tmonotime_tv(&start);\n\t\t\t}\n\t\t\tif ((ret = select(state->connection_out + 1,\n\t\t\t    NULL, setp, NULL, timeoutp)) >= 0)\n\t\t\t\tbreak;\n\t\t\tif (errno != EAGAIN && errno != EINTR &&\n\t\t\t    errno != EWOULDBLOCK)\n\t\t\t\tbreak;\n\t\t\tif (state->packet_timeout_ms == -1)\n\t\t\t\tcontinue;\n\t\t\tms_subtract_diff(&start, &ms_remain);\n\t\t\tif (ms_remain <= 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tfree(setp);\n\t\t\treturn SSH_ERR_CONN_TIMEOUT;\n\t\t}\n\t\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\t\tfree(setp);\n\t\t\treturn r;\n\t\t}\n\t}\n\tfree(setp);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_write_wait(struct ssh *ssh)\n{\n\tfd_set *setp;\n\tint ret, r, ms_remain = 0;\n\tstruct timeval start, timeout, *timeoutp = NULL;\n\tstruct session_state *state = ssh->state;\n\n\tsetp = calloc(howmany(state->connection_out + 1,\n\t    NFDBITS), sizeof(fd_mask));\n\tif (setp == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\tfree(setp);\n\t\treturn r;\n\t}\n\twhile (ssh_packet_have_data_to_write(ssh)) {\n\t\tmemset(setp, 0, howmany(state->connection_out + 1,\n\t\t    NFDBITS) * sizeof(fd_mask));\n\t\tFD_SET(state->connection_out, setp);\n\n\t\tif (state->packet_timeout_ms > 0) {\n\t\t\tms_remain = state->packet_timeout_ms;\n\t\t\ttimeoutp = &timeout;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (state->packet_timeout_ms != -1) {\n\t\t\t\tms_to_timeval(&timeout, ms_remain);\n\t\t\t\tmonotime_tv(&start);\n\t\t\t}\n\t\t\tif ((ret = select(state->connection_out + 1,\n\t\t\t    NULL, setp, NULL, timeoutp)) >= 0)\n\t\t\t\tbreak;\n\t\t\tif (errno != EAGAIN && errno != EINTR &&\n\t\t\t    errno != EWOULDBLOCK)\n\t\t\t\tbreak;\n\t\t\tif (state->packet_timeout_ms == -1)\n\t\t\t\tcontinue;\n\t\t\tms_subtract_diff(&start, &ms_remain);\n\t\t\tif (ms_remain <= 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tfree(setp);\n\t\t\treturn SSH_ERR_CONN_TIMEOUT;\n\t\t}\n\t\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\t\tfree(setp);\n\t\t\treturn r;\n\t\t}\n\t}\n\tfree(setp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 3855
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "fwd->listen_port"
          ],
          "line": 3854
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "channel_rfwd_bind_host(fwd->listen_host)"
          ],
          "line": 3852
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_rfwd_bind_host",
          "args": [
            "fwd->listen_host"
          ],
          "line": 3853
        },
        "resolved": true,
        "details": {
          "function_name": "channel_rfwd_bind_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3813-3822",
          "snippet": "static const char *\nchannel_rfwd_bind_host(const char *listen_host)\n{\n\tif (listen_host == NULL) {\n\t\treturn \"localhost\";\n\t} else if (*listen_host == '\\0' || strcmp(listen_host, \"*\") == 0) {\n\t\treturn \"\";\n\t} else\n\t\treturn listen_host;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\n\nstatic const char *\nchannel_rfwd_bind_host(const char *listen_host)\n{\n\tif (listen_host == NULL) {\n\t\treturn \"localhost\";\n\t} else if (*listen_host == '\\0' || strcmp(listen_host, \"*\") == 0) {\n\t\treturn \"\";\n\t} else\n\t\treturn listen_host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u8",
          "args": [
            "ssh",
            "1"
          ],
          "line": 3851
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2435-2439",
          "snippet": "int\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_GLOBAL_REQUEST"
          ],
          "line": 3849
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_request_remote_forwarding(struct ssh *ssh, struct Forward *fwd)\n{\n\tint r, success = 0, idx = -1;\n\tchar *host_to_connect, *listen_host, *listen_path;\n\tint port_to_connect, listen_port;\n\n\t/* Send the forward request to the remote side. */\n\tif (fwd->listen_path != NULL) {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"streamlocal-forward@openssh.com\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0 || /* want reply */\n\t\t    (r = sshpkt_put_cstring(ssh, fwd->listen_path)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal(\"%s: request streamlocal: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t} else {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, \"tcpip-forward\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0 || /* want reply */\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    channel_rfwd_bind_host(fwd->listen_host))) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, fwd->listen_port)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal(\"%s: request tcpip-forward: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n\t/* Assume that server accepts the request */\n\tsuccess = 1;\n\tif (success) {\n\t\t/* Record that connection to this host/port is permitted. */\n\t\thost_to_connect = listen_host = listen_path = NULL;\n\t\tport_to_connect = listen_port = 0;\n\t\tif (fwd->connect_path != NULL) {\n\t\t\thost_to_connect = xstrdup(fwd->connect_path);\n\t\t\tport_to_connect = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\thost_to_connect = xstrdup(fwd->connect_host);\n\t\t\tport_to_connect = fwd->connect_port;\n\t\t}\n\t\tif (fwd->listen_path != NULL) {\n\t\t\tlisten_path = xstrdup(fwd->listen_path);\n\t\t\tlisten_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tif (fwd->listen_host != NULL)\n\t\t\t\tlisten_host = xstrdup(fwd->listen_host);\n\t\t\tlisten_port = fwd->listen_port;\n\t\t}\n\t\tidx = permission_set_add(ssh, FORWARD_USER, FORWARD_LOCAL,\n\t\t    host_to_connect, port_to_connect,\n\t\t    listen_host, listen_path, listen_port, NULL);\n\t}\n\treturn idx;\n}"
  },
  {
    "function_name": "channel_rfwd_bind_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3813-3822",
    "snippet": "static const char *\nchannel_rfwd_bind_host(const char *listen_host)\n{\n\tif (listen_host == NULL) {\n\t\treturn \"localhost\";\n\t} else if (*listen_host == '\\0' || strcmp(listen_host, \"*\") == 0) {\n\t\treturn \"\";\n\t} else\n\t\treturn listen_host;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *channel_rfwd_bind_host(const char *listen_host);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "listen_host",
            "\"*\""
          ],
          "line": 3818
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\n\nstatic const char *\nchannel_rfwd_bind_host(const char *listen_host)\n{\n\tif (listen_host == NULL) {\n\t\treturn \"localhost\";\n\t} else if (*listen_host == '\\0' || strcmp(listen_host, \"*\") == 0) {\n\t\treturn \"\";\n\t} else\n\t\treturn listen_host;\n}"
  },
  {
    "function_name": "channel_setup_remote_fwd_listener",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3791-3807",
    "snippet": "int\nchannel_setup_remote_fwd_listener(struct ssh *ssh, struct Forward *fwd,\n    int *allocated_listen_port, struct ForwardOptions *fwd_opts)\n{\n\tif (!check_rfwd_permission(ssh, fwd)) {\n\t\tpacket_send_debug(\"port forwarding refused\");\n\t\treturn 0;\n\t}\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_setup_fwd_listener_streamlocal(ssh,\n\t\t    SSH_CHANNEL_RUNIX_LISTENER, fwd, fwd_opts);\n\t} else {\n\t\treturn channel_setup_fwd_listener_tcpip(ssh,\n\t\t    SSH_CHANNEL_RPORT_LISTENER, fwd, allocated_listen_port,\n\t\t    fwd_opts);\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_setup_fwd_listener_tcpip",
          "args": [
            "ssh",
            "SSH_CHANNEL_RPORT_LISTENER",
            "fwd",
            "allocated_listen_port",
            "fwd_opts"
          ],
          "line": 3803
        },
        "resolved": true,
        "details": {
          "function_name": "channel_setup_fwd_listener_tcpip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3348-3506",
          "snippet": "static int\nchannel_setup_fwd_listener_tcpip(struct ssh *ssh, int type,\n    struct Forward *fwd, int *allocated_listen_port,\n    struct ForwardOptions *fwd_opts)\n{\n\tChannel *c;\n\tint sock, r, success = 0, wildcard = 0, is_client;\n\tstruct addrinfo hints, *ai, *aitop;\n\tconst char *host, *addr;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\tin_port_t *lport_p;\n\n\tis_client = (type == SSH_CHANNEL_PORT_LISTENER);\n\n\tif (is_client && fwd->connect_path != NULL) {\n\t\thost = fwd->connect_path;\n\t} else {\n\t\thost = (type == SSH_CHANNEL_RPORT_LISTENER) ?\n\t\t    fwd->listen_host : fwd->connect_host;\n\t\tif (host == NULL) {\n\t\t\terror(\"No forward host name.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (strlen(host) >= NI_MAXHOST) {\n\t\t\terror(\"Forward host name too long.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Determine the bind address, cf. channel_fwd_bind_addr() comment */\n\taddr = channel_fwd_bind_addr(fwd->listen_host, &wildcard,\n\t    is_client, fwd_opts);\n\tdebug3(\"%s: type %d wildcard %d addr %s\", __func__,\n\t    type, wildcard, (addr == NULL) ? \"NULL\" : addr);\n\n\t/*\n\t * getaddrinfo returns a loopback address if the hostname is\n\t * set to NULL and hints.ai_flags is not AI_PASSIVE\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = ssh->chanctxt->IPv4or6;\n\thints.ai_flags = wildcard ? AI_PASSIVE : 0;\n\thints.ai_socktype = SOCK_STREAM;\n\tsnprintf(strport, sizeof strport, \"%d\", fwd->listen_port);\n\tif ((r = getaddrinfo(addr, strport, &hints, &aitop)) != 0) {\n\t\tif (addr == NULL) {\n\t\t\t/* This really shouldn't happen */\n\t\t\tpacket_disconnect(\"getaddrinfo: fatal error: %s\",\n\t\t\t    ssh_gai_strerror(r));\n\t\t} else {\n\t\t\terror(\"%s: getaddrinfo(%.64s): %s\", __func__, addr,\n\t\t\t    ssh_gai_strerror(r));\n\t\t}\n\t\treturn 0;\n\t}\n\tif (allocated_listen_port != NULL)\n\t\t*allocated_listen_port = 0;\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\tswitch (ai->ai_family) {\n\t\tcase AF_INET:\n\t\t\tlport_p = &((struct sockaddr_in *)ai->ai_addr)->\n\t\t\t    sin_port;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tlport_p = &((struct sockaddr_in6 *)ai->ai_addr)->\n\t\t\t    sin6_port;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * If allocating a port for -R forwards, then use the\n\t\t * same port for all address families.\n\t\t */\n\t\tif (type == SSH_CHANNEL_RPORT_LISTENER &&\n\t\t    fwd->listen_port == 0 && allocated_listen_port != NULL &&\n\t\t    *allocated_listen_port > 0)\n\t\t\t*lport_p = htons(*allocated_listen_port);\n\n\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop, sizeof(ntop),\n\t\t    strport, sizeof(strport),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\terror(\"%s: getnameinfo failed\", __func__);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Create a port to listen for the host. */\n\t\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (sock < 0) {\n\t\t\t/* this is no error since kernel may not support ipv6 */\n\t\t\tverbose(\"socket [%s]:%s: %.100s\", ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_reuseaddr(sock);\n\t\tif (ai->ai_family == AF_INET6)\n\t\t\tsock_set_v6only(sock);\n\n\t\tdebug(\"Local forwarding listening on %s port %s.\",\n\t\t    ntop, strport);\n\n\t\t/* Bind the socket to the address. */\n\t\tif (bind(sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\t/*\n\t\t\t * address can be in if use ipv6 address is\n\t\t\t * already bound\n\t\t\t */\n\t\t\tif (!ai->ai_next)\n\t\t\t\terror(\"bind [%s]:%s: %.100s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\t\t\telse\n\t\t\t\tverbose(\"bind [%s]:%s: %.100s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Start listening for connections on the socket. */\n\t\tif (listen(sock, SSH_LISTEN_BACKLOG) < 0) {\n\t\t\terror(\"listen: %.100s\", strerror(errno));\n\t\t\terror(\"listen [%s]:%s: %.100s\", ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * fwd->listen_port == 0 requests a dynamically allocated port -\n\t\t * record what we got.\n\t\t */\n\t\tif (type == SSH_CHANNEL_RPORT_LISTENER &&\n\t\t    fwd->listen_port == 0 &&\n\t\t    allocated_listen_port != NULL &&\n\t\t    *allocated_listen_port == 0) {\n\t\t\t*allocated_listen_port = get_local_port(sock);\n\t\t\tdebug(\"Allocated listen port %d\",\n\t\t\t    *allocated_listen_port);\n\t\t}\n\n\t\t/* Allocate a channel number for the socket. */\n\t\tc = channel_new(ssh, \"port listener\", type, sock, sock, -1,\n\t\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t\t    0, \"port listener\", 1);\n\t\tc->path = xstrdup(host);\n\t\tc->host_port = fwd->connect_port;\n\t\tc->listening_addr = addr == NULL ? NULL : xstrdup(addr);\n\t\tif (fwd->listen_port == 0 && allocated_listen_port != NULL &&\n\t\t    !(datafellows & SSH_BUG_DYNAMIC_RPORT))\n\t\t\tc->listening_port = *allocated_listen_port;\n\t\telse\n\t\t\tc->listening_port = fwd->listen_port;\n\t\tsuccess = 1;\n\t}\n\tif (success == 0)\n\t\terror(\"%s: cannot listen to port: %d\", __func__,\n\t\t    fwd->listen_port);\n\tfreeaddrinfo(aitop);\n\treturn success;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_setup_fwd_listener_tcpip(struct ssh *ssh, int type,\n    struct Forward *fwd, int *allocated_listen_port,\n    struct ForwardOptions *fwd_opts)\n{\n\tChannel *c;\n\tint sock, r, success = 0, wildcard = 0, is_client;\n\tstruct addrinfo hints, *ai, *aitop;\n\tconst char *host, *addr;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\tin_port_t *lport_p;\n\n\tis_client = (type == SSH_CHANNEL_PORT_LISTENER);\n\n\tif (is_client && fwd->connect_path != NULL) {\n\t\thost = fwd->connect_path;\n\t} else {\n\t\thost = (type == SSH_CHANNEL_RPORT_LISTENER) ?\n\t\t    fwd->listen_host : fwd->connect_host;\n\t\tif (host == NULL) {\n\t\t\terror(\"No forward host name.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (strlen(host) >= NI_MAXHOST) {\n\t\t\terror(\"Forward host name too long.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Determine the bind address, cf. channel_fwd_bind_addr() comment */\n\taddr = channel_fwd_bind_addr(fwd->listen_host, &wildcard,\n\t    is_client, fwd_opts);\n\tdebug3(\"%s: type %d wildcard %d addr %s\", __func__,\n\t    type, wildcard, (addr == NULL) ? \"NULL\" : addr);\n\n\t/*\n\t * getaddrinfo returns a loopback address if the hostname is\n\t * set to NULL and hints.ai_flags is not AI_PASSIVE\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = ssh->chanctxt->IPv4or6;\n\thints.ai_flags = wildcard ? AI_PASSIVE : 0;\n\thints.ai_socktype = SOCK_STREAM;\n\tsnprintf(strport, sizeof strport, \"%d\", fwd->listen_port);\n\tif ((r = getaddrinfo(addr, strport, &hints, &aitop)) != 0) {\n\t\tif (addr == NULL) {\n\t\t\t/* This really shouldn't happen */\n\t\t\tpacket_disconnect(\"getaddrinfo: fatal error: %s\",\n\t\t\t    ssh_gai_strerror(r));\n\t\t} else {\n\t\t\terror(\"%s: getaddrinfo(%.64s): %s\", __func__, addr,\n\t\t\t    ssh_gai_strerror(r));\n\t\t}\n\t\treturn 0;\n\t}\n\tif (allocated_listen_port != NULL)\n\t\t*allocated_listen_port = 0;\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\tswitch (ai->ai_family) {\n\t\tcase AF_INET:\n\t\t\tlport_p = &((struct sockaddr_in *)ai->ai_addr)->\n\t\t\t    sin_port;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tlport_p = &((struct sockaddr_in6 *)ai->ai_addr)->\n\t\t\t    sin6_port;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * If allocating a port for -R forwards, then use the\n\t\t * same port for all address families.\n\t\t */\n\t\tif (type == SSH_CHANNEL_RPORT_LISTENER &&\n\t\t    fwd->listen_port == 0 && allocated_listen_port != NULL &&\n\t\t    *allocated_listen_port > 0)\n\t\t\t*lport_p = htons(*allocated_listen_port);\n\n\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop, sizeof(ntop),\n\t\t    strport, sizeof(strport),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\terror(\"%s: getnameinfo failed\", __func__);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Create a port to listen for the host. */\n\t\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (sock < 0) {\n\t\t\t/* this is no error since kernel may not support ipv6 */\n\t\t\tverbose(\"socket [%s]:%s: %.100s\", ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_reuseaddr(sock);\n\t\tif (ai->ai_family == AF_INET6)\n\t\t\tsock_set_v6only(sock);\n\n\t\tdebug(\"Local forwarding listening on %s port %s.\",\n\t\t    ntop, strport);\n\n\t\t/* Bind the socket to the address. */\n\t\tif (bind(sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\t/*\n\t\t\t * address can be in if use ipv6 address is\n\t\t\t * already bound\n\t\t\t */\n\t\t\tif (!ai->ai_next)\n\t\t\t\terror(\"bind [%s]:%s: %.100s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\t\t\telse\n\t\t\t\tverbose(\"bind [%s]:%s: %.100s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Start listening for connections on the socket. */\n\t\tif (listen(sock, SSH_LISTEN_BACKLOG) < 0) {\n\t\t\terror(\"listen: %.100s\", strerror(errno));\n\t\t\terror(\"listen [%s]:%s: %.100s\", ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * fwd->listen_port == 0 requests a dynamically allocated port -\n\t\t * record what we got.\n\t\t */\n\t\tif (type == SSH_CHANNEL_RPORT_LISTENER &&\n\t\t    fwd->listen_port == 0 &&\n\t\t    allocated_listen_port != NULL &&\n\t\t    *allocated_listen_port == 0) {\n\t\t\t*allocated_listen_port = get_local_port(sock);\n\t\t\tdebug(\"Allocated listen port %d\",\n\t\t\t    *allocated_listen_port);\n\t\t}\n\n\t\t/* Allocate a channel number for the socket. */\n\t\tc = channel_new(ssh, \"port listener\", type, sock, sock, -1,\n\t\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t\t    0, \"port listener\", 1);\n\t\tc->path = xstrdup(host);\n\t\tc->host_port = fwd->connect_port;\n\t\tc->listening_addr = addr == NULL ? NULL : xstrdup(addr);\n\t\tif (fwd->listen_port == 0 && allocated_listen_port != NULL &&\n\t\t    !(datafellows & SSH_BUG_DYNAMIC_RPORT))\n\t\t\tc->listening_port = *allocated_listen_port;\n\t\telse\n\t\t\tc->listening_port = fwd->listen_port;\n\t\tsuccess = 1;\n\t}\n\tif (success == 0)\n\t\terror(\"%s: cannot listen to port: %d\", __func__,\n\t\t    fwd->listen_port);\n\tfreeaddrinfo(aitop);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_setup_fwd_listener_streamlocal",
          "args": [
            "ssh",
            "SSH_CHANNEL_RUNIX_LISTENER",
            "fwd",
            "fwd_opts"
          ],
          "line": 3800
        },
        "resolved": true,
        "details": {
          "function_name": "channel_setup_fwd_listener_streamlocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3508-3580",
          "snippet": "static int\nchannel_setup_fwd_listener_streamlocal(struct ssh *ssh, int type,\n    struct Forward *fwd, struct ForwardOptions *fwd_opts)\n{\n\tstruct sockaddr_un sunaddr;\n\tconst char *path;\n\tChannel *c;\n\tint port, sock;\n\tmode_t omask;\n\n\tswitch (type) {\n\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tif (fwd->connect_path != NULL) {\n\t\t\tif (strlen(fwd->connect_path) > sizeof(sunaddr.sun_path)) {\n\t\t\t\terror(\"Local connecting path too long: %s\",\n\t\t\t\t    fwd->connect_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpath = fwd->connect_path;\n\t\t\tport = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tif (fwd->connect_host == NULL) {\n\t\t\t\terror(\"No forward host name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (strlen(fwd->connect_host) >= NI_MAXHOST) {\n\t\t\t\terror(\"Forward host name too long.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpath = fwd->connect_host;\n\t\t\tport = fwd->connect_port;\n\t\t}\n\t\tbreak;\n\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\tpath = fwd->listen_path;\n\t\tport = PORT_STREAMLOCAL;\n\t\tbreak;\n\tdefault:\n\t\terror(\"%s: unexpected channel type %d\", __func__, type);\n\t\treturn 0;\n\t}\n\n\tif (fwd->listen_path == NULL) {\n\t\terror(\"No forward path name.\");\n\t\treturn 0;\n\t}\n\tif (strlen(fwd->listen_path) > sizeof(sunaddr.sun_path)) {\n\t\terror(\"Local listening path too long: %s\", fwd->listen_path);\n\t\treturn 0;\n\t}\n\n\tdebug3(\"%s: type %d path %s\", __func__, type, fwd->listen_path);\n\n\t/* Start a Unix domain listener. */\n\tomask = umask(fwd_opts->streamlocal_bind_mask);\n\tsock = unix_listener(fwd->listen_path, SSH_LISTEN_BACKLOG,\n\t    fwd_opts->streamlocal_bind_unlink);\n\tumask(omask);\n\tif (sock < 0)\n\t\treturn 0;\n\n\tdebug(\"Local forwarding listening on path %s.\", fwd->listen_path);\n\n\t/* Allocate a channel number for the socket. */\n\tc = channel_new(ssh, \"unix listener\", type, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, \"unix listener\", 1);\n\tc->path = xstrdup(path);\n\tc->host_port = port;\n\tc->listening_port = PORT_STREAMLOCAL;\n\tc->listening_addr = xstrdup(fwd->listen_path);\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_setup_fwd_listener_streamlocal(struct ssh *ssh, int type,\n    struct Forward *fwd, struct ForwardOptions *fwd_opts)\n{\n\tstruct sockaddr_un sunaddr;\n\tconst char *path;\n\tChannel *c;\n\tint port, sock;\n\tmode_t omask;\n\n\tswitch (type) {\n\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tif (fwd->connect_path != NULL) {\n\t\t\tif (strlen(fwd->connect_path) > sizeof(sunaddr.sun_path)) {\n\t\t\t\terror(\"Local connecting path too long: %s\",\n\t\t\t\t    fwd->connect_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpath = fwd->connect_path;\n\t\t\tport = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tif (fwd->connect_host == NULL) {\n\t\t\t\terror(\"No forward host name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (strlen(fwd->connect_host) >= NI_MAXHOST) {\n\t\t\t\terror(\"Forward host name too long.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpath = fwd->connect_host;\n\t\t\tport = fwd->connect_port;\n\t\t}\n\t\tbreak;\n\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\tpath = fwd->listen_path;\n\t\tport = PORT_STREAMLOCAL;\n\t\tbreak;\n\tdefault:\n\t\terror(\"%s: unexpected channel type %d\", __func__, type);\n\t\treturn 0;\n\t}\n\n\tif (fwd->listen_path == NULL) {\n\t\terror(\"No forward path name.\");\n\t\treturn 0;\n\t}\n\tif (strlen(fwd->listen_path) > sizeof(sunaddr.sun_path)) {\n\t\terror(\"Local listening path too long: %s\", fwd->listen_path);\n\t\treturn 0;\n\t}\n\n\tdebug3(\"%s: type %d path %s\", __func__, type, fwd->listen_path);\n\n\t/* Start a Unix domain listener. */\n\tomask = umask(fwd_opts->streamlocal_bind_mask);\n\tsock = unix_listener(fwd->listen_path, SSH_LISTEN_BACKLOG,\n\t    fwd_opts->streamlocal_bind_unlink);\n\tumask(omask);\n\tif (sock < 0)\n\t\treturn 0;\n\n\tdebug(\"Local forwarding listening on path %s.\", fwd->listen_path);\n\n\t/* Allocate a channel number for the socket. */\n\tc = channel_new(ssh, \"unix listener\", type, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, \"unix listener\", 1);\n\tc->path = xstrdup(path);\n\tc->host_port = port;\n\tc->listening_port = PORT_STREAMLOCAL;\n\tc->listening_addr = xstrdup(fwd->listen_path);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send_debug",
          "args": [
            "\"port forwarding refused\""
          ],
          "line": 3796
        },
        "resolved": true,
        "details": {
          "function_name": "packet_send_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "310-320",
          "snippet": "void\npacket_send_debug(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_send_debug(active_state, \"%s\", buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_send_debug(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_send_debug(active_state, \"%s\", buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_rfwd_permission",
          "args": [
            "ssh",
            "fwd"
          ],
          "line": 3795
        },
        "resolved": true,
        "details": {
          "function_name": "check_rfwd_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3755-3788",
          "snippet": "static int\ncheck_rfwd_permission(struct ssh *ssh, struct Forward *fwd)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->remote_perms;\n\tu_int i, permit, permit_adm = 1;\n\tstruct permission *perm;\n\n\t/* XXX apply GatewayPorts override before checking? */\n\n\tpermit = pset->all_permitted;\n\tif (!permit) {\n\t\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\t\tperm = &pset->permitted_user[i];\n\t\t\tif (remote_open_match(perm, fwd)) {\n\t\t\t\tpermit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pset->num_permitted_admin > 0) {\n\t\tpermit_adm = 0;\n\t\tfor (i = 0; i < pset->num_permitted_admin; i++) {\n\t\t\tperm = &pset->permitted_admin[i];\n\t\t\tif (remote_open_match(perm, fwd)) {\n\t\t\t\tpermit_adm = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn permit && permit_adm;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic int\ncheck_rfwd_permission(struct ssh *ssh, struct Forward *fwd)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->remote_perms;\n\tu_int i, permit, permit_adm = 1;\n\tstruct permission *perm;\n\n\t/* XXX apply GatewayPorts override before checking? */\n\n\tpermit = pset->all_permitted;\n\tif (!permit) {\n\t\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\t\tperm = &pset->permitted_user[i];\n\t\t\tif (remote_open_match(perm, fwd)) {\n\t\t\t\tpermit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pset->num_permitted_admin > 0) {\n\t\tpermit_adm = 0;\n\t\tfor (i = 0; i < pset->num_permitted_admin; i++) {\n\t\t\tperm = &pset->permitted_admin[i];\n\t\t\tif (remote_open_match(perm, fwd)) {\n\t\t\t\tpermit_adm = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn permit && permit_adm;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_setup_remote_fwd_listener(struct ssh *ssh, struct Forward *fwd,\n    int *allocated_listen_port, struct ForwardOptions *fwd_opts)\n{\n\tif (!check_rfwd_permission(ssh, fwd)) {\n\t\tpacket_send_debug(\"port forwarding refused\");\n\t\treturn 0;\n\t}\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_setup_fwd_listener_streamlocal(ssh,\n\t\t    SSH_CHANNEL_RUNIX_LISTENER, fwd, fwd_opts);\n\t} else {\n\t\treturn channel_setup_fwd_listener_tcpip(ssh,\n\t\t    SSH_CHANNEL_RPORT_LISTENER, fwd, allocated_listen_port,\n\t\t    fwd_opts);\n\t}\n}"
  },
  {
    "function_name": "check_rfwd_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3755-3788",
    "snippet": "static int\ncheck_rfwd_permission(struct ssh *ssh, struct Forward *fwd)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->remote_perms;\n\tu_int i, permit, permit_adm = 1;\n\tstruct permission *perm;\n\n\t/* XXX apply GatewayPorts override before checking? */\n\n\tpermit = pset->all_permitted;\n\tif (!permit) {\n\t\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\t\tperm = &pset->permitted_user[i];\n\t\t\tif (remote_open_match(perm, fwd)) {\n\t\t\t\tpermit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pset->num_permitted_admin > 0) {\n\t\tpermit_adm = 0;\n\t\tfor (i = 0; i < pset->num_permitted_admin; i++) {\n\t\t\tperm = &pset->permitted_admin[i];\n\t\t\tif (remote_open_match(perm, fwd)) {\n\t\t\t\tpermit_adm = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn permit && permit_adm;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remote_open_match",
          "args": [
            "perm",
            "fwd"
          ],
          "line": 3780
        },
        "resolved": true,
        "details": {
          "function_name": "remote_open_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3728-3752",
          "snippet": "static int\nremote_open_match(struct permission *allowed_open, struct Forward *fwd)\n{\n\tint ret;\n\tchar *lhost;\n\n\t/* XXX add ACLs for streamlocal */\n\tif (fwd->listen_path != NULL)\n\t\treturn 1;\n\n\tif (fwd->listen_host == NULL || allowed_open->listen_host == NULL)\n\t\treturn 0;\n\n\tif (allowed_open->listen_port != FWD_PERMIT_ANY_PORT &&\n\t    allowed_open->listen_port != fwd->listen_port)\n\t\treturn 0;\n\n\t/* Match hostnames case-insensitively */\n\tlhost = xstrdup(fwd->listen_host);\n\tlowercase(lhost);\n\tret = match_pattern(lhost, allowed_open->listen_host);\n\tfree(lhost);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FWD_PERMIT_ANY_PORT\t0"
          ],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define FWD_PERMIT_ANY_PORT\t0\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\n\nstatic int\nremote_open_match(struct permission *allowed_open, struct Forward *fwd)\n{\n\tint ret;\n\tchar *lhost;\n\n\t/* XXX add ACLs for streamlocal */\n\tif (fwd->listen_path != NULL)\n\t\treturn 1;\n\n\tif (fwd->listen_host == NULL || allowed_open->listen_host == NULL)\n\t\treturn 0;\n\n\tif (allowed_open->listen_port != FWD_PERMIT_ANY_PORT &&\n\t    allowed_open->listen_port != fwd->listen_port)\n\t\treturn 0;\n\n\t/* Match hostnames case-insensitively */\n\tlhost = xstrdup(fwd->listen_host);\n\tlowercase(lhost);\n\tret = match_pattern(lhost, allowed_open->listen_host);\n\tfree(lhost);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic int\ncheck_rfwd_permission(struct ssh *ssh, struct Forward *fwd)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->remote_perms;\n\tu_int i, permit, permit_adm = 1;\n\tstruct permission *perm;\n\n\t/* XXX apply GatewayPorts override before checking? */\n\n\tpermit = pset->all_permitted;\n\tif (!permit) {\n\t\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\t\tperm = &pset->permitted_user[i];\n\t\t\tif (remote_open_match(perm, fwd)) {\n\t\t\t\tpermit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pset->num_permitted_admin > 0) {\n\t\tpermit_adm = 0;\n\t\tfor (i = 0; i < pset->num_permitted_admin; i++) {\n\t\t\tperm = &pset->permitted_admin[i];\n\t\t\tif (remote_open_match(perm, fwd)) {\n\t\t\t\tpermit_adm = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn permit && permit_adm;\n}"
  },
  {
    "function_name": "remote_open_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3728-3752",
    "snippet": "static int\nremote_open_match(struct permission *allowed_open, struct Forward *fwd)\n{\n\tint ret;\n\tchar *lhost;\n\n\t/* XXX add ACLs for streamlocal */\n\tif (fwd->listen_path != NULL)\n\t\treturn 1;\n\n\tif (fwd->listen_host == NULL || allowed_open->listen_host == NULL)\n\t\treturn 0;\n\n\tif (allowed_open->listen_port != FWD_PERMIT_ANY_PORT &&\n\t    allowed_open->listen_port != fwd->listen_port)\n\t\treturn 0;\n\n\t/* Match hostnames case-insensitively */\n\tlhost = xstrdup(fwd->listen_host);\n\tlowercase(lhost);\n\tret = match_pattern(lhost, allowed_open->listen_host);\n\tfree(lhost);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define FWD_PERMIT_ANY_PORT\t0"
    ],
    "globals_used": [
      "static const char *channel_rfwd_bind_host(const char *listen_host);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "lhost"
          ],
          "line": 3749
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4195-4206",
          "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_pattern",
          "args": [
            "lhost",
            "allowed_open->listen_host"
          ],
          "line": 3748
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "56-112",
          "snippet": "int\nmatch_pattern(const char *s, const char *pattern)\n{\n\tfor (;;) {\n\t\t/* If at end of pattern, accept if also at end of string. */\n\t\tif (!*pattern)\n\t\t\treturn !*s;\n\n\t\tif (*pattern == '*') {\n\t\t\t/* Skip the asterisk. */\n\t\t\tpattern++;\n\n\t\t\t/* If at end of pattern, accept immediately. */\n\t\t\tif (!*pattern)\n\t\t\t\treturn 1;\n\n\t\t\t/* If next character in pattern is known, optimize. */\n\t\t\tif (*pattern != '?' && *pattern != '*') {\n\t\t\t\t/*\n\t\t\t\t * Look instances of the next character in\n\t\t\t\t * pattern, and try to match starting from\n\t\t\t\t * those.\n\t\t\t\t */\n\t\t\t\tfor (; *s; s++)\n\t\t\t\t\tif (*s == *pattern &&\n\t\t\t\t\t    match_pattern(s + 1, pattern + 1))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t/* Failed. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Move ahead one character at a time and try to\n\t\t\t * match at each position.\n\t\t\t */\n\t\t\tfor (; *s; s++)\n\t\t\t\tif (match_pattern(s, pattern))\n\t\t\t\t\treturn 1;\n\t\t\t/* Failed. */\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * There must be at least one more character in the string.\n\t\t * If we are at the end, fail.\n\t\t */\n\t\tif (!*s)\n\t\t\treturn 0;\n\n\t\t/* Check if the next character of the string is acceptable. */\n\t\tif (*pattern != '?' && *pattern != *s)\n\t\t\treturn 0;\n\n\t\t/* Move to the next character, both in string and in pattern. */\n\t\ts++;\n\t\tpattern++;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern(const char *s, const char *pattern)\n{\n\tfor (;;) {\n\t\t/* If at end of pattern, accept if also at end of string. */\n\t\tif (!*pattern)\n\t\t\treturn !*s;\n\n\t\tif (*pattern == '*') {\n\t\t\t/* Skip the asterisk. */\n\t\t\tpattern++;\n\n\t\t\t/* If at end of pattern, accept immediately. */\n\t\t\tif (!*pattern)\n\t\t\t\treturn 1;\n\n\t\t\t/* If next character in pattern is known, optimize. */\n\t\t\tif (*pattern != '?' && *pattern != '*') {\n\t\t\t\t/*\n\t\t\t\t * Look instances of the next character in\n\t\t\t\t * pattern, and try to match starting from\n\t\t\t\t * those.\n\t\t\t\t */\n\t\t\t\tfor (; *s; s++)\n\t\t\t\t\tif (*s == *pattern &&\n\t\t\t\t\t    match_pattern(s + 1, pattern + 1))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t/* Failed. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Move ahead one character at a time and try to\n\t\t\t * match at each position.\n\t\t\t */\n\t\t\tfor (; *s; s++)\n\t\t\t\tif (match_pattern(s, pattern))\n\t\t\t\t\treturn 1;\n\t\t\t/* Failed. */\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * There must be at least one more character in the string.\n\t\t * If we are at the end, fail.\n\t\t */\n\t\tif (!*s)\n\t\t\treturn 0;\n\n\t\t/* Check if the next character of the string is acceptable. */\n\t\tif (*pattern != '?' && *pattern != *s)\n\t\t\treturn 0;\n\n\t\t/* Move to the next character, both in string and in pattern. */\n\t\ts++;\n\t\tpattern++;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "lowercase",
          "args": [
            "lhost"
          ],
          "line": 3747
        },
        "resolved": true,
        "details": {
          "function_name": "lowercase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1480-1485",
          "snippet": "void\nlowercase(char *s)\n{\n\tfor (; *s; s++)\n\t\t*s = tolower((u_char)*s);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlowercase(char *s)\n{\n\tfor (; *s; s++)\n\t\t*s = tolower((u_char)*s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "fwd->listen_host"
          ],
          "line": 3746
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define FWD_PERMIT_ANY_PORT\t0\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\n\nstatic int\nremote_open_match(struct permission *allowed_open, struct Forward *fwd)\n{\n\tint ret;\n\tchar *lhost;\n\n\t/* XXX add ACLs for streamlocal */\n\tif (fwd->listen_path != NULL)\n\t\treturn 1;\n\n\tif (fwd->listen_host == NULL || allowed_open->listen_host == NULL)\n\t\treturn 0;\n\n\tif (allowed_open->listen_port != FWD_PERMIT_ANY_PORT &&\n\t    allowed_open->listen_port != fwd->listen_port)\n\t\treturn 0;\n\n\t/* Match hostnames case-insensitively */\n\tlhost = xstrdup(fwd->listen_host);\n\tlowercase(lhost);\n\tret = match_pattern(lhost, allowed_open->listen_host);\n\tfree(lhost);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "channel_setup_local_fwd_listener",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3714-3725",
    "snippet": "int\nchannel_setup_local_fwd_listener(struct ssh *ssh,\n    struct Forward *fwd, struct ForwardOptions *fwd_opts)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_setup_fwd_listener_streamlocal(ssh,\n\t\t    SSH_CHANNEL_UNIX_LISTENER, fwd, fwd_opts);\n\t} else {\n\t\treturn channel_setup_fwd_listener_tcpip(ssh,\n\t\t    SSH_CHANNEL_PORT_LISTENER, fwd, NULL, fwd_opts);\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_setup_fwd_listener_tcpip",
          "args": [
            "ssh",
            "SSH_CHANNEL_PORT_LISTENER",
            "fwd",
            "NULL",
            "fwd_opts"
          ],
          "line": 3722
        },
        "resolved": true,
        "details": {
          "function_name": "channel_setup_fwd_listener_tcpip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3348-3506",
          "snippet": "static int\nchannel_setup_fwd_listener_tcpip(struct ssh *ssh, int type,\n    struct Forward *fwd, int *allocated_listen_port,\n    struct ForwardOptions *fwd_opts)\n{\n\tChannel *c;\n\tint sock, r, success = 0, wildcard = 0, is_client;\n\tstruct addrinfo hints, *ai, *aitop;\n\tconst char *host, *addr;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\tin_port_t *lport_p;\n\n\tis_client = (type == SSH_CHANNEL_PORT_LISTENER);\n\n\tif (is_client && fwd->connect_path != NULL) {\n\t\thost = fwd->connect_path;\n\t} else {\n\t\thost = (type == SSH_CHANNEL_RPORT_LISTENER) ?\n\t\t    fwd->listen_host : fwd->connect_host;\n\t\tif (host == NULL) {\n\t\t\terror(\"No forward host name.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (strlen(host) >= NI_MAXHOST) {\n\t\t\terror(\"Forward host name too long.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Determine the bind address, cf. channel_fwd_bind_addr() comment */\n\taddr = channel_fwd_bind_addr(fwd->listen_host, &wildcard,\n\t    is_client, fwd_opts);\n\tdebug3(\"%s: type %d wildcard %d addr %s\", __func__,\n\t    type, wildcard, (addr == NULL) ? \"NULL\" : addr);\n\n\t/*\n\t * getaddrinfo returns a loopback address if the hostname is\n\t * set to NULL and hints.ai_flags is not AI_PASSIVE\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = ssh->chanctxt->IPv4or6;\n\thints.ai_flags = wildcard ? AI_PASSIVE : 0;\n\thints.ai_socktype = SOCK_STREAM;\n\tsnprintf(strport, sizeof strport, \"%d\", fwd->listen_port);\n\tif ((r = getaddrinfo(addr, strport, &hints, &aitop)) != 0) {\n\t\tif (addr == NULL) {\n\t\t\t/* This really shouldn't happen */\n\t\t\tpacket_disconnect(\"getaddrinfo: fatal error: %s\",\n\t\t\t    ssh_gai_strerror(r));\n\t\t} else {\n\t\t\terror(\"%s: getaddrinfo(%.64s): %s\", __func__, addr,\n\t\t\t    ssh_gai_strerror(r));\n\t\t}\n\t\treturn 0;\n\t}\n\tif (allocated_listen_port != NULL)\n\t\t*allocated_listen_port = 0;\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\tswitch (ai->ai_family) {\n\t\tcase AF_INET:\n\t\t\tlport_p = &((struct sockaddr_in *)ai->ai_addr)->\n\t\t\t    sin_port;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tlport_p = &((struct sockaddr_in6 *)ai->ai_addr)->\n\t\t\t    sin6_port;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * If allocating a port for -R forwards, then use the\n\t\t * same port for all address families.\n\t\t */\n\t\tif (type == SSH_CHANNEL_RPORT_LISTENER &&\n\t\t    fwd->listen_port == 0 && allocated_listen_port != NULL &&\n\t\t    *allocated_listen_port > 0)\n\t\t\t*lport_p = htons(*allocated_listen_port);\n\n\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop, sizeof(ntop),\n\t\t    strport, sizeof(strport),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\terror(\"%s: getnameinfo failed\", __func__);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Create a port to listen for the host. */\n\t\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (sock < 0) {\n\t\t\t/* this is no error since kernel may not support ipv6 */\n\t\t\tverbose(\"socket [%s]:%s: %.100s\", ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_reuseaddr(sock);\n\t\tif (ai->ai_family == AF_INET6)\n\t\t\tsock_set_v6only(sock);\n\n\t\tdebug(\"Local forwarding listening on %s port %s.\",\n\t\t    ntop, strport);\n\n\t\t/* Bind the socket to the address. */\n\t\tif (bind(sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\t/*\n\t\t\t * address can be in if use ipv6 address is\n\t\t\t * already bound\n\t\t\t */\n\t\t\tif (!ai->ai_next)\n\t\t\t\terror(\"bind [%s]:%s: %.100s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\t\t\telse\n\t\t\t\tverbose(\"bind [%s]:%s: %.100s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Start listening for connections on the socket. */\n\t\tif (listen(sock, SSH_LISTEN_BACKLOG) < 0) {\n\t\t\terror(\"listen: %.100s\", strerror(errno));\n\t\t\terror(\"listen [%s]:%s: %.100s\", ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * fwd->listen_port == 0 requests a dynamically allocated port -\n\t\t * record what we got.\n\t\t */\n\t\tif (type == SSH_CHANNEL_RPORT_LISTENER &&\n\t\t    fwd->listen_port == 0 &&\n\t\t    allocated_listen_port != NULL &&\n\t\t    *allocated_listen_port == 0) {\n\t\t\t*allocated_listen_port = get_local_port(sock);\n\t\t\tdebug(\"Allocated listen port %d\",\n\t\t\t    *allocated_listen_port);\n\t\t}\n\n\t\t/* Allocate a channel number for the socket. */\n\t\tc = channel_new(ssh, \"port listener\", type, sock, sock, -1,\n\t\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t\t    0, \"port listener\", 1);\n\t\tc->path = xstrdup(host);\n\t\tc->host_port = fwd->connect_port;\n\t\tc->listening_addr = addr == NULL ? NULL : xstrdup(addr);\n\t\tif (fwd->listen_port == 0 && allocated_listen_port != NULL &&\n\t\t    !(datafellows & SSH_BUG_DYNAMIC_RPORT))\n\t\t\tc->listening_port = *allocated_listen_port;\n\t\telse\n\t\t\tc->listening_port = fwd->listen_port;\n\t\tsuccess = 1;\n\t}\n\tif (success == 0)\n\t\terror(\"%s: cannot listen to port: %d\", __func__,\n\t\t    fwd->listen_port);\n\tfreeaddrinfo(aitop);\n\treturn success;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_setup_fwd_listener_tcpip(struct ssh *ssh, int type,\n    struct Forward *fwd, int *allocated_listen_port,\n    struct ForwardOptions *fwd_opts)\n{\n\tChannel *c;\n\tint sock, r, success = 0, wildcard = 0, is_client;\n\tstruct addrinfo hints, *ai, *aitop;\n\tconst char *host, *addr;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\tin_port_t *lport_p;\n\n\tis_client = (type == SSH_CHANNEL_PORT_LISTENER);\n\n\tif (is_client && fwd->connect_path != NULL) {\n\t\thost = fwd->connect_path;\n\t} else {\n\t\thost = (type == SSH_CHANNEL_RPORT_LISTENER) ?\n\t\t    fwd->listen_host : fwd->connect_host;\n\t\tif (host == NULL) {\n\t\t\terror(\"No forward host name.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (strlen(host) >= NI_MAXHOST) {\n\t\t\terror(\"Forward host name too long.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Determine the bind address, cf. channel_fwd_bind_addr() comment */\n\taddr = channel_fwd_bind_addr(fwd->listen_host, &wildcard,\n\t    is_client, fwd_opts);\n\tdebug3(\"%s: type %d wildcard %d addr %s\", __func__,\n\t    type, wildcard, (addr == NULL) ? \"NULL\" : addr);\n\n\t/*\n\t * getaddrinfo returns a loopback address if the hostname is\n\t * set to NULL and hints.ai_flags is not AI_PASSIVE\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = ssh->chanctxt->IPv4or6;\n\thints.ai_flags = wildcard ? AI_PASSIVE : 0;\n\thints.ai_socktype = SOCK_STREAM;\n\tsnprintf(strport, sizeof strport, \"%d\", fwd->listen_port);\n\tif ((r = getaddrinfo(addr, strport, &hints, &aitop)) != 0) {\n\t\tif (addr == NULL) {\n\t\t\t/* This really shouldn't happen */\n\t\t\tpacket_disconnect(\"getaddrinfo: fatal error: %s\",\n\t\t\t    ssh_gai_strerror(r));\n\t\t} else {\n\t\t\terror(\"%s: getaddrinfo(%.64s): %s\", __func__, addr,\n\t\t\t    ssh_gai_strerror(r));\n\t\t}\n\t\treturn 0;\n\t}\n\tif (allocated_listen_port != NULL)\n\t\t*allocated_listen_port = 0;\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\tswitch (ai->ai_family) {\n\t\tcase AF_INET:\n\t\t\tlport_p = &((struct sockaddr_in *)ai->ai_addr)->\n\t\t\t    sin_port;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tlport_p = &((struct sockaddr_in6 *)ai->ai_addr)->\n\t\t\t    sin6_port;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * If allocating a port for -R forwards, then use the\n\t\t * same port for all address families.\n\t\t */\n\t\tif (type == SSH_CHANNEL_RPORT_LISTENER &&\n\t\t    fwd->listen_port == 0 && allocated_listen_port != NULL &&\n\t\t    *allocated_listen_port > 0)\n\t\t\t*lport_p = htons(*allocated_listen_port);\n\n\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop, sizeof(ntop),\n\t\t    strport, sizeof(strport),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\terror(\"%s: getnameinfo failed\", __func__);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Create a port to listen for the host. */\n\t\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (sock < 0) {\n\t\t\t/* this is no error since kernel may not support ipv6 */\n\t\t\tverbose(\"socket [%s]:%s: %.100s\", ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_reuseaddr(sock);\n\t\tif (ai->ai_family == AF_INET6)\n\t\t\tsock_set_v6only(sock);\n\n\t\tdebug(\"Local forwarding listening on %s port %s.\",\n\t\t    ntop, strport);\n\n\t\t/* Bind the socket to the address. */\n\t\tif (bind(sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\t/*\n\t\t\t * address can be in if use ipv6 address is\n\t\t\t * already bound\n\t\t\t */\n\t\t\tif (!ai->ai_next)\n\t\t\t\terror(\"bind [%s]:%s: %.100s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\t\t\telse\n\t\t\t\tverbose(\"bind [%s]:%s: %.100s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Start listening for connections on the socket. */\n\t\tif (listen(sock, SSH_LISTEN_BACKLOG) < 0) {\n\t\t\terror(\"listen: %.100s\", strerror(errno));\n\t\t\terror(\"listen [%s]:%s: %.100s\", ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * fwd->listen_port == 0 requests a dynamically allocated port -\n\t\t * record what we got.\n\t\t */\n\t\tif (type == SSH_CHANNEL_RPORT_LISTENER &&\n\t\t    fwd->listen_port == 0 &&\n\t\t    allocated_listen_port != NULL &&\n\t\t    *allocated_listen_port == 0) {\n\t\t\t*allocated_listen_port = get_local_port(sock);\n\t\t\tdebug(\"Allocated listen port %d\",\n\t\t\t    *allocated_listen_port);\n\t\t}\n\n\t\t/* Allocate a channel number for the socket. */\n\t\tc = channel_new(ssh, \"port listener\", type, sock, sock, -1,\n\t\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t\t    0, \"port listener\", 1);\n\t\tc->path = xstrdup(host);\n\t\tc->host_port = fwd->connect_port;\n\t\tc->listening_addr = addr == NULL ? NULL : xstrdup(addr);\n\t\tif (fwd->listen_port == 0 && allocated_listen_port != NULL &&\n\t\t    !(datafellows & SSH_BUG_DYNAMIC_RPORT))\n\t\t\tc->listening_port = *allocated_listen_port;\n\t\telse\n\t\t\tc->listening_port = fwd->listen_port;\n\t\tsuccess = 1;\n\t}\n\tif (success == 0)\n\t\terror(\"%s: cannot listen to port: %d\", __func__,\n\t\t    fwd->listen_port);\n\tfreeaddrinfo(aitop);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_setup_fwd_listener_streamlocal",
          "args": [
            "ssh",
            "SSH_CHANNEL_UNIX_LISTENER",
            "fwd",
            "fwd_opts"
          ],
          "line": 3719
        },
        "resolved": true,
        "details": {
          "function_name": "channel_setup_fwd_listener_streamlocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3508-3580",
          "snippet": "static int\nchannel_setup_fwd_listener_streamlocal(struct ssh *ssh, int type,\n    struct Forward *fwd, struct ForwardOptions *fwd_opts)\n{\n\tstruct sockaddr_un sunaddr;\n\tconst char *path;\n\tChannel *c;\n\tint port, sock;\n\tmode_t omask;\n\n\tswitch (type) {\n\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tif (fwd->connect_path != NULL) {\n\t\t\tif (strlen(fwd->connect_path) > sizeof(sunaddr.sun_path)) {\n\t\t\t\terror(\"Local connecting path too long: %s\",\n\t\t\t\t    fwd->connect_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpath = fwd->connect_path;\n\t\t\tport = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tif (fwd->connect_host == NULL) {\n\t\t\t\terror(\"No forward host name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (strlen(fwd->connect_host) >= NI_MAXHOST) {\n\t\t\t\terror(\"Forward host name too long.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpath = fwd->connect_host;\n\t\t\tport = fwd->connect_port;\n\t\t}\n\t\tbreak;\n\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\tpath = fwd->listen_path;\n\t\tport = PORT_STREAMLOCAL;\n\t\tbreak;\n\tdefault:\n\t\terror(\"%s: unexpected channel type %d\", __func__, type);\n\t\treturn 0;\n\t}\n\n\tif (fwd->listen_path == NULL) {\n\t\terror(\"No forward path name.\");\n\t\treturn 0;\n\t}\n\tif (strlen(fwd->listen_path) > sizeof(sunaddr.sun_path)) {\n\t\terror(\"Local listening path too long: %s\", fwd->listen_path);\n\t\treturn 0;\n\t}\n\n\tdebug3(\"%s: type %d path %s\", __func__, type, fwd->listen_path);\n\n\t/* Start a Unix domain listener. */\n\tomask = umask(fwd_opts->streamlocal_bind_mask);\n\tsock = unix_listener(fwd->listen_path, SSH_LISTEN_BACKLOG,\n\t    fwd_opts->streamlocal_bind_unlink);\n\tumask(omask);\n\tif (sock < 0)\n\t\treturn 0;\n\n\tdebug(\"Local forwarding listening on path %s.\", fwd->listen_path);\n\n\t/* Allocate a channel number for the socket. */\n\tc = channel_new(ssh, \"unix listener\", type, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, \"unix listener\", 1);\n\tc->path = xstrdup(path);\n\tc->host_port = port;\n\tc->listening_port = PORT_STREAMLOCAL;\n\tc->listening_addr = xstrdup(fwd->listen_path);\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_setup_fwd_listener_streamlocal(struct ssh *ssh, int type,\n    struct Forward *fwd, struct ForwardOptions *fwd_opts)\n{\n\tstruct sockaddr_un sunaddr;\n\tconst char *path;\n\tChannel *c;\n\tint port, sock;\n\tmode_t omask;\n\n\tswitch (type) {\n\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tif (fwd->connect_path != NULL) {\n\t\t\tif (strlen(fwd->connect_path) > sizeof(sunaddr.sun_path)) {\n\t\t\t\terror(\"Local connecting path too long: %s\",\n\t\t\t\t    fwd->connect_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpath = fwd->connect_path;\n\t\t\tport = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tif (fwd->connect_host == NULL) {\n\t\t\t\terror(\"No forward host name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (strlen(fwd->connect_host) >= NI_MAXHOST) {\n\t\t\t\terror(\"Forward host name too long.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpath = fwd->connect_host;\n\t\t\tport = fwd->connect_port;\n\t\t}\n\t\tbreak;\n\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\tpath = fwd->listen_path;\n\t\tport = PORT_STREAMLOCAL;\n\t\tbreak;\n\tdefault:\n\t\terror(\"%s: unexpected channel type %d\", __func__, type);\n\t\treturn 0;\n\t}\n\n\tif (fwd->listen_path == NULL) {\n\t\terror(\"No forward path name.\");\n\t\treturn 0;\n\t}\n\tif (strlen(fwd->listen_path) > sizeof(sunaddr.sun_path)) {\n\t\terror(\"Local listening path too long: %s\", fwd->listen_path);\n\t\treturn 0;\n\t}\n\n\tdebug3(\"%s: type %d path %s\", __func__, type, fwd->listen_path);\n\n\t/* Start a Unix domain listener. */\n\tomask = umask(fwd_opts->streamlocal_bind_mask);\n\tsock = unix_listener(fwd->listen_path, SSH_LISTEN_BACKLOG,\n\t    fwd_opts->streamlocal_bind_unlink);\n\tumask(omask);\n\tif (sock < 0)\n\t\treturn 0;\n\n\tdebug(\"Local forwarding listening on path %s.\", fwd->listen_path);\n\n\t/* Allocate a channel number for the socket. */\n\tc = channel_new(ssh, \"unix listener\", type, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, \"unix listener\", 1);\n\tc->path = xstrdup(path);\n\tc->host_port = port;\n\tc->listening_port = PORT_STREAMLOCAL;\n\tc->listening_addr = xstrdup(fwd->listen_path);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_setup_local_fwd_listener(struct ssh *ssh,\n    struct Forward *fwd, struct ForwardOptions *fwd_opts)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_setup_fwd_listener_streamlocal(ssh,\n\t\t    SSH_CHANNEL_UNIX_LISTENER, fwd, fwd_opts);\n\t} else {\n\t\treturn channel_setup_fwd_listener_tcpip(ssh,\n\t\t    SSH_CHANNEL_PORT_LISTENER, fwd, NULL, fwd_opts);\n\t}\n}"
  },
  {
    "function_name": "channel_cancel_lport_listener",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3700-3711",
    "snippet": "int\nchannel_cancel_lport_listener(struct ssh *ssh,\n    struct Forward *fwd, int cport, struct ForwardOptions *fwd_opts)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_cancel_lport_listener_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_cancel_lport_listener_tcpip(ssh,\n\t\t    fwd->listen_host, fwd->listen_port, cport, fwd_opts);\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *channel_rfwd_bind_host(const char *listen_host);",
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_cancel_lport_listener_tcpip",
          "args": [
            "ssh",
            "fwd->listen_host",
            "fwd->listen_port",
            "cport",
            "fwd_opts"
          ],
          "line": 3708
        },
        "resolved": true,
        "details": {
          "function_name": "channel_cancel_lport_listener_tcpip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3637-3671",
          "snippet": "static int\nchannel_cancel_lport_listener_tcpip(struct ssh *ssh,\n    const char *lhost, u_short lport, int cport,\n    struct ForwardOptions *fwd_opts)\n{\n\tu_int i;\n\tint found = 0;\n\tconst char *addr = channel_fwd_bind_addr(lhost, NULL, 1, fwd_opts);\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_PORT_LISTENER)\n\t\t\tcontinue;\n\t\tif (c->listening_port != lport)\n\t\t\tcontinue;\n\t\tif (cport == CHANNEL_CANCEL_PORT_STATIC) {\n\t\t\t/* skip dynamic forwardings */\n\t\t\tif (c->host_port == 0)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (c->host_port != cport)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif ((c->listening_addr == NULL && addr != NULL) ||\n\t\t    (c->listening_addr != NULL && addr == NULL))\n\t\t\tcontinue;\n\t\tif (addr == NULL || strcmp(c->listening_addr, addr) == 0) {\n\t\t\tdebug2(\"%s: close channel %d\", __func__, i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_cancel_lport_listener_tcpip(struct ssh *ssh,\n    const char *lhost, u_short lport, int cport,\n    struct ForwardOptions *fwd_opts)\n{\n\tu_int i;\n\tint found = 0;\n\tconst char *addr = channel_fwd_bind_addr(lhost, NULL, 1, fwd_opts);\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_PORT_LISTENER)\n\t\t\tcontinue;\n\t\tif (c->listening_port != lport)\n\t\t\tcontinue;\n\t\tif (cport == CHANNEL_CANCEL_PORT_STATIC) {\n\t\t\t/* skip dynamic forwardings */\n\t\t\tif (c->host_port == 0)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (c->host_port != cport)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif ((c->listening_addr == NULL && addr != NULL) ||\n\t\t    (c->listening_addr != NULL && addr == NULL))\n\t\t\tcontinue;\n\t\tif (addr == NULL || strcmp(c->listening_addr, addr) == 0) {\n\t\t\tdebug2(\"%s: close channel %d\", __func__, i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_cancel_lport_listener_streamlocal",
          "args": [
            "ssh",
            "fwd->listen_path"
          ],
          "line": 3705
        },
        "resolved": true,
        "details": {
          "function_name": "channel_cancel_lport_listener_streamlocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3673-3698",
          "snippet": "static int\nchannel_cancel_lport_listener_streamlocal(struct ssh *ssh, const char *path)\n{\n\tu_int i;\n\tint found = 0;\n\n\tif (path == NULL) {\n\t\terror(\"%s: no path specified.\", __func__);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_UNIX_LISTENER)\n\t\t\tcontinue;\n\t\tif (c->listening_addr == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(c->listening_addr, path) == 0) {\n\t\t\tdebug2(\"%s: close channel %d\", __func__, i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_cancel_lport_listener_streamlocal(struct ssh *ssh, const char *path)\n{\n\tu_int i;\n\tint found = 0;\n\n\tif (path == NULL) {\n\t\terror(\"%s: no path specified.\", __func__);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_UNIX_LISTENER)\n\t\t\tcontinue;\n\t\tif (c->listening_addr == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(c->listening_addr, path) == 0) {\n\t\t\tdebug2(\"%s: close channel %d\", __func__, i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_cancel_lport_listener(struct ssh *ssh,\n    struct Forward *fwd, int cport, struct ForwardOptions *fwd_opts)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_cancel_lport_listener_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_cancel_lport_listener_tcpip(ssh,\n\t\t    fwd->listen_host, fwd->listen_port, cport, fwd_opts);\n\t}\n}"
  },
  {
    "function_name": "channel_cancel_lport_listener_streamlocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3673-3698",
    "snippet": "static int\nchannel_cancel_lport_listener_streamlocal(struct ssh *ssh, const char *path)\n{\n\tu_int i;\n\tint found = 0;\n\n\tif (path == NULL) {\n\t\terror(\"%s: no path specified.\", __func__);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_UNIX_LISTENER)\n\t\t\tcontinue;\n\t\tif (c->listening_addr == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(c->listening_addr, path) == 0) {\n\t\t\tdebug2(\"%s: close channel %d\", __func__, i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_free",
          "args": [
            "ssh",
            "c"
          ],
          "line": 3692
        },
        "resolved": true,
        "details": {
          "function_name": "channel_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "582-640",
          "snippet": "void\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: close channel %d\"",
            "__func__",
            "i"
          ],
          "line": 3691
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "c->listening_addr",
            "path"
          ],
          "line": 3690
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: no path specified.\"",
            "__func__"
          ],
          "line": 3680
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_cancel_lport_listener_streamlocal(struct ssh *ssh, const char *path)\n{\n\tu_int i;\n\tint found = 0;\n\n\tif (path == NULL) {\n\t\terror(\"%s: no path specified.\", __func__);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_UNIX_LISTENER)\n\t\t\tcontinue;\n\t\tif (c->listening_addr == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(c->listening_addr, path) == 0) {\n\t\t\tdebug2(\"%s: close channel %d\", __func__, i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "channel_cancel_lport_listener_tcpip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3637-3671",
    "snippet": "static int\nchannel_cancel_lport_listener_tcpip(struct ssh *ssh,\n    const char *lhost, u_short lport, int cport,\n    struct ForwardOptions *fwd_opts)\n{\n\tu_int i;\n\tint found = 0;\n\tconst char *addr = channel_fwd_bind_addr(lhost, NULL, 1, fwd_opts);\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_PORT_LISTENER)\n\t\t\tcontinue;\n\t\tif (c->listening_port != lport)\n\t\t\tcontinue;\n\t\tif (cport == CHANNEL_CANCEL_PORT_STATIC) {\n\t\t\t/* skip dynamic forwardings */\n\t\t\tif (c->host_port == 0)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (c->host_port != cport)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif ((c->listening_addr == NULL && addr != NULL) ||\n\t\t    (c->listening_addr != NULL && addr == NULL))\n\t\t\tcontinue;\n\t\tif (addr == NULL || strcmp(c->listening_addr, addr) == 0) {\n\t\t\tdebug2(\"%s: close channel %d\", __func__, i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_free",
          "args": [
            "ssh",
            "c"
          ],
          "line": 3665
        },
        "resolved": true,
        "details": {
          "function_name": "channel_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "582-640",
          "snippet": "void\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: close channel %d\"",
            "__func__",
            "i"
          ],
          "line": 3664
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "c->listening_addr",
            "addr"
          ],
          "line": 3663
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_fwd_bind_addr",
          "args": [
            "lhost",
            "NULL",
            "1",
            "fwd_opts"
          ],
          "line": 3644
        },
        "resolved": true,
        "details": {
          "function_name": "channel_fwd_bind_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3300-3346",
          "snippet": "static const char *\nchannel_fwd_bind_addr(const char *listen_addr, int *wildcardp,\n    int is_client, struct ForwardOptions *fwd_opts)\n{\n\tconst char *addr = NULL;\n\tint wildcard = 0;\n\n\tif (listen_addr == NULL) {\n\t\t/* No address specified: default to gateway_ports setting */\n\t\tif (fwd_opts->gateway_ports)\n\t\t\twildcard = 1;\n\t} else if (fwd_opts->gateway_ports || is_client) {\n\t\tif (((datafellows & SSH_OLD_FORWARD_ADDR) &&\n\t\t    strcmp(listen_addr, \"0.0.0.0\") == 0 && is_client == 0) ||\n\t\t    *listen_addr == '\\0' || strcmp(listen_addr, \"*\") == 0 ||\n\t\t    (!is_client && fwd_opts->gateway_ports == 1)) {\n\t\t\twildcard = 1;\n\t\t\t/*\n\t\t\t * Notify client if they requested a specific listen\n\t\t\t * address and it was overridden.\n\t\t\t */\n\t\t\tif (*listen_addr != '\\0' &&\n\t\t\t    strcmp(listen_addr, \"0.0.0.0\") != 0 &&\n\t\t\t    strcmp(listen_addr, \"*\") != 0) {\n\t\t\t\tpacket_send_debug(\"Forwarding listen address \"\n\t\t\t\t    \"\\\"%s\\\" overridden by server \"\n\t\t\t\t    \"GatewayPorts\", listen_addr);\n\t\t\t}\n\t\t} else if (strcmp(listen_addr, \"localhost\") != 0 ||\n\t\t    strcmp(listen_addr, \"127.0.0.1\") == 0 ||\n\t\t    strcmp(listen_addr, \"::1\") == 0) {\n\t\t\t/* Accept localhost address when GatewayPorts=yes */\n\t\t\taddr = listen_addr;\n\t\t}\n\t} else if (strcmp(listen_addr, \"127.0.0.1\") == 0 ||\n\t    strcmp(listen_addr, \"::1\") == 0) {\n\t\t/*\n\t\t * If a specific IPv4/IPv6 localhost address has been\n\t\t * requested then accept it even if gateway_ports is in\n\t\t * effect. This allows the client to prefer IPv4 or IPv6.\n\t\t */\n\t\taddr = listen_addr;\n\t}\n\tif (wildcardp != NULL)\n\t\t*wildcardp = wildcard;\n\treturn addr;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nchannel_fwd_bind_addr(const char *listen_addr, int *wildcardp,\n    int is_client, struct ForwardOptions *fwd_opts)\n{\n\tconst char *addr = NULL;\n\tint wildcard = 0;\n\n\tif (listen_addr == NULL) {\n\t\t/* No address specified: default to gateway_ports setting */\n\t\tif (fwd_opts->gateway_ports)\n\t\t\twildcard = 1;\n\t} else if (fwd_opts->gateway_ports || is_client) {\n\t\tif (((datafellows & SSH_OLD_FORWARD_ADDR) &&\n\t\t    strcmp(listen_addr, \"0.0.0.0\") == 0 && is_client == 0) ||\n\t\t    *listen_addr == '\\0' || strcmp(listen_addr, \"*\") == 0 ||\n\t\t    (!is_client && fwd_opts->gateway_ports == 1)) {\n\t\t\twildcard = 1;\n\t\t\t/*\n\t\t\t * Notify client if they requested a specific listen\n\t\t\t * address and it was overridden.\n\t\t\t */\n\t\t\tif (*listen_addr != '\\0' &&\n\t\t\t    strcmp(listen_addr, \"0.0.0.0\") != 0 &&\n\t\t\t    strcmp(listen_addr, \"*\") != 0) {\n\t\t\t\tpacket_send_debug(\"Forwarding listen address \"\n\t\t\t\t    \"\\\"%s\\\" overridden by server \"\n\t\t\t\t    \"GatewayPorts\", listen_addr);\n\t\t\t}\n\t\t} else if (strcmp(listen_addr, \"localhost\") != 0 ||\n\t\t    strcmp(listen_addr, \"127.0.0.1\") == 0 ||\n\t\t    strcmp(listen_addr, \"::1\") == 0) {\n\t\t\t/* Accept localhost address when GatewayPorts=yes */\n\t\t\taddr = listen_addr;\n\t\t}\n\t} else if (strcmp(listen_addr, \"127.0.0.1\") == 0 ||\n\t    strcmp(listen_addr, \"::1\") == 0) {\n\t\t/*\n\t\t * If a specific IPv4/IPv6 localhost address has been\n\t\t * requested then accept it even if gateway_ports is in\n\t\t * effect. This allows the client to prefer IPv4 or IPv6.\n\t\t */\n\t\taddr = listen_addr;\n\t}\n\tif (wildcardp != NULL)\n\t\t*wildcardp = wildcard;\n\treturn addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_cancel_lport_listener_tcpip(struct ssh *ssh,\n    const char *lhost, u_short lport, int cport,\n    struct ForwardOptions *fwd_opts)\n{\n\tu_int i;\n\tint found = 0;\n\tconst char *addr = channel_fwd_bind_addr(lhost, NULL, 1, fwd_opts);\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_PORT_LISTENER)\n\t\t\tcontinue;\n\t\tif (c->listening_port != lport)\n\t\t\tcontinue;\n\t\tif (cport == CHANNEL_CANCEL_PORT_STATIC) {\n\t\t\t/* skip dynamic forwardings */\n\t\t\tif (c->host_port == 0)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (c->host_port != cport)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif ((c->listening_addr == NULL && addr != NULL) ||\n\t\t    (c->listening_addr != NULL && addr == NULL))\n\t\t\tcontinue;\n\t\tif (addr == NULL || strcmp(c->listening_addr, addr) == 0) {\n\t\t\tdebug2(\"%s: close channel %d\", __func__, i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "channel_cancel_rport_listener",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3625-3635",
    "snippet": "int\nchannel_cancel_rport_listener(struct ssh *ssh, struct Forward *fwd)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_cancel_rport_listener_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_cancel_rport_listener_tcpip(ssh,\n\t\t    fwd->listen_host, fwd->listen_port);\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *channel_rfwd_bind_host(const char *listen_host);",
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_cancel_rport_listener_tcpip",
          "args": [
            "ssh",
            "fwd->listen_host",
            "fwd->listen_port"
          ],
          "line": 3632
        },
        "resolved": true,
        "details": {
          "function_name": "channel_cancel_rport_listener_tcpip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3582-3601",
          "snippet": "static int\nchannel_cancel_rport_listener_tcpip(struct ssh *ssh,\n    const char *host, u_short port)\n{\n\tu_int i;\n\tint found = 0;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_RPORT_LISTENER)\n\t\t\tcontinue;\n\t\tif (strcmp(c->path, host) == 0 && c->listening_port == port) {\n\t\t\tdebug2(\"%s: close channel %d\", __func__, i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_cancel_rport_listener_tcpip(struct ssh *ssh,\n    const char *host, u_short port)\n{\n\tu_int i;\n\tint found = 0;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_RPORT_LISTENER)\n\t\t\tcontinue;\n\t\tif (strcmp(c->path, host) == 0 && c->listening_port == port) {\n\t\t\tdebug2(\"%s: close channel %d\", __func__, i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_cancel_rport_listener_streamlocal",
          "args": [
            "ssh",
            "fwd->listen_path"
          ],
          "line": 3629
        },
        "resolved": true,
        "details": {
          "function_name": "channel_cancel_rport_listener_streamlocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3603-3623",
          "snippet": "static int\nchannel_cancel_rport_listener_streamlocal(struct ssh *ssh, const char *path)\n{\n\tu_int i;\n\tint found = 0;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_RUNIX_LISTENER)\n\t\t\tcontinue;\n\t\tif (c->path == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(c->path, path) == 0) {\n\t\t\tdebug2(\"%s: close channel %d\", __func__, i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_cancel_rport_listener_streamlocal(struct ssh *ssh, const char *path)\n{\n\tu_int i;\n\tint found = 0;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_RUNIX_LISTENER)\n\t\t\tcontinue;\n\t\tif (c->path == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(c->path, path) == 0) {\n\t\t\tdebug2(\"%s: close channel %d\", __func__, i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nint\nchannel_cancel_rport_listener(struct ssh *ssh, struct Forward *fwd)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_cancel_rport_listener_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_cancel_rport_listener_tcpip(ssh,\n\t\t    fwd->listen_host, fwd->listen_port);\n\t}\n}"
  },
  {
    "function_name": "channel_cancel_rport_listener_streamlocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3603-3623",
    "snippet": "static int\nchannel_cancel_rport_listener_streamlocal(struct ssh *ssh, const char *path)\n{\n\tu_int i;\n\tint found = 0;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_RUNIX_LISTENER)\n\t\t\tcontinue;\n\t\tif (c->path == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(c->path, path) == 0) {\n\t\t\tdebug2(\"%s: close channel %d\", __func__, i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_free",
          "args": [
            "ssh",
            "c"
          ],
          "line": 3617
        },
        "resolved": true,
        "details": {
          "function_name": "channel_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "582-640",
          "snippet": "void\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: close channel %d\"",
            "__func__",
            "i"
          ],
          "line": 3616
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "c->path",
            "path"
          ],
          "line": 3615
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_cancel_rport_listener_streamlocal(struct ssh *ssh, const char *path)\n{\n\tu_int i;\n\tint found = 0;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_RUNIX_LISTENER)\n\t\t\tcontinue;\n\t\tif (c->path == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(c->path, path) == 0) {\n\t\t\tdebug2(\"%s: close channel %d\", __func__, i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "channel_cancel_rport_listener_tcpip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3582-3601",
    "snippet": "static int\nchannel_cancel_rport_listener_tcpip(struct ssh *ssh,\n    const char *host, u_short port)\n{\n\tu_int i;\n\tint found = 0;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_RPORT_LISTENER)\n\t\t\tcontinue;\n\t\tif (strcmp(c->path, host) == 0 && c->listening_port == port) {\n\t\t\tdebug2(\"%s: close channel %d\", __func__, i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_free",
          "args": [
            "ssh",
            "c"
          ],
          "line": 3595
        },
        "resolved": true,
        "details": {
          "function_name": "channel_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "582-640",
          "snippet": "void\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: close channel %d\"",
            "__func__",
            "i"
          ],
          "line": 3594
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "c->path",
            "host"
          ],
          "line": 3593
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_cancel_rport_listener_tcpip(struct ssh *ssh,\n    const char *host, u_short port)\n{\n\tu_int i;\n\tint found = 0;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_RPORT_LISTENER)\n\t\t\tcontinue;\n\t\tif (strcmp(c->path, host) == 0 && c->listening_port == port) {\n\t\t\tdebug2(\"%s: close channel %d\", __func__, i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "channel_setup_fwd_listener_streamlocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3508-3580",
    "snippet": "static int\nchannel_setup_fwd_listener_streamlocal(struct ssh *ssh, int type,\n    struct Forward *fwd, struct ForwardOptions *fwd_opts)\n{\n\tstruct sockaddr_un sunaddr;\n\tconst char *path;\n\tChannel *c;\n\tint port, sock;\n\tmode_t omask;\n\n\tswitch (type) {\n\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tif (fwd->connect_path != NULL) {\n\t\t\tif (strlen(fwd->connect_path) > sizeof(sunaddr.sun_path)) {\n\t\t\t\terror(\"Local connecting path too long: %s\",\n\t\t\t\t    fwd->connect_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpath = fwd->connect_path;\n\t\t\tport = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tif (fwd->connect_host == NULL) {\n\t\t\t\terror(\"No forward host name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (strlen(fwd->connect_host) >= NI_MAXHOST) {\n\t\t\t\terror(\"Forward host name too long.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpath = fwd->connect_host;\n\t\t\tport = fwd->connect_port;\n\t\t}\n\t\tbreak;\n\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\tpath = fwd->listen_path;\n\t\tport = PORT_STREAMLOCAL;\n\t\tbreak;\n\tdefault:\n\t\terror(\"%s: unexpected channel type %d\", __func__, type);\n\t\treturn 0;\n\t}\n\n\tif (fwd->listen_path == NULL) {\n\t\terror(\"No forward path name.\");\n\t\treturn 0;\n\t}\n\tif (strlen(fwd->listen_path) > sizeof(sunaddr.sun_path)) {\n\t\terror(\"Local listening path too long: %s\", fwd->listen_path);\n\t\treturn 0;\n\t}\n\n\tdebug3(\"%s: type %d path %s\", __func__, type, fwd->listen_path);\n\n\t/* Start a Unix domain listener. */\n\tomask = umask(fwd_opts->streamlocal_bind_mask);\n\tsock = unix_listener(fwd->listen_path, SSH_LISTEN_BACKLOG,\n\t    fwd_opts->streamlocal_bind_unlink);\n\tumask(omask);\n\tif (sock < 0)\n\t\treturn 0;\n\n\tdebug(\"Local forwarding listening on path %s.\", fwd->listen_path);\n\n\t/* Allocate a channel number for the socket. */\n\tc = channel_new(ssh, \"unix listener\", type, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, \"unix listener\", 1);\n\tc->path = xstrdup(path);\n\tc->host_port = port;\n\tc->listening_port = PORT_STREAMLOCAL;\n\tc->listening_addr = xstrdup(fwd->listen_path);\n\treturn 1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "fwd->listen_path"
          ],
          "line": 3578
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "\"unix listener\"",
            "type",
            "sock",
            "sock",
            "-1",
            "CHAN_TCP_WINDOW_DEFAULT",
            "CHAN_TCP_PACKET_DEFAULT",
            "0",
            "\"unix listener\"",
            "1"
          ],
          "line": 3572
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Local forwarding listening on path %s.\"",
            "fwd->listen_path"
          ],
          "line": 3569
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "omask"
          ],
          "line": 3565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unix_listener",
          "args": [
            "fwd->listen_path",
            "SSH_LISTEN_BACKLOG",
            "fwd_opts->streamlocal_bind_unlink"
          ],
          "line": 3563
        },
        "resolved": true,
        "details": {
          "function_name": "unix_listener",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1487-1532",
          "snippet": "int\nunix_listener(const char *path, int backlog, int unlink_first)\n{\n\tstruct sockaddr_un sunaddr;\n\tint saved_errno, sock;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tif (strlcpy(sunaddr.sun_path, path,\n\t    sizeof(sunaddr.sun_path)) >= sizeof(sunaddr.sun_path)) {\n\t\terror(\"%s: path \\\"%s\\\" too long for Unix domain socket\",\n\t\t    __func__, path);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\tsock = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (sock < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: socket: %.100s\", __func__, strerror(errno));\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (unlink_first == 1) {\n\t\tif (unlink(path) != 0 && errno != ENOENT)\n\t\t\terror(\"unlink(%s): %.100s\", path, strerror(errno));\n\t}\n\tif (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: cannot bind to path %s: %s\",\n\t\t    __func__, path, strerror(errno));\n\t\tclose(sock);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (listen(sock, backlog) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: cannot listen on path %s: %s\",\n\t\t    __func__, path, strerror(errno));\n\t\tclose(sock);\n\t\tunlink(path);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\treturn sock;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunix_listener(const char *path, int backlog, int unlink_first)\n{\n\tstruct sockaddr_un sunaddr;\n\tint saved_errno, sock;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tif (strlcpy(sunaddr.sun_path, path,\n\t    sizeof(sunaddr.sun_path)) >= sizeof(sunaddr.sun_path)) {\n\t\terror(\"%s: path \\\"%s\\\" too long for Unix domain socket\",\n\t\t    __func__, path);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\tsock = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (sock < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: socket: %.100s\", __func__, strerror(errno));\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (unlink_first == 1) {\n\t\tif (unlink(path) != 0 && errno != ENOENT)\n\t\t\terror(\"unlink(%s): %.100s\", path, strerror(errno));\n\t}\n\tif (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: cannot bind to path %s: %s\",\n\t\t    __func__, path, strerror(errno));\n\t\tclose(sock);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (listen(sock, backlog) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: cannot listen on path %s: %s\",\n\t\t    __func__, path, strerror(errno));\n\t\tclose(sock);\n\t\tunlink(path);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\treturn sock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "fwd_opts->streamlocal_bind_mask"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Local listening path too long: %s\"",
            "fwd->listen_path"
          ],
          "line": 3555
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fwd->listen_path"
          ],
          "line": 3554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fwd->connect_host"
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fwd->connect_path"
          ],
          "line": 3521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_setup_fwd_listener_streamlocal(struct ssh *ssh, int type,\n    struct Forward *fwd, struct ForwardOptions *fwd_opts)\n{\n\tstruct sockaddr_un sunaddr;\n\tconst char *path;\n\tChannel *c;\n\tint port, sock;\n\tmode_t omask;\n\n\tswitch (type) {\n\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tif (fwd->connect_path != NULL) {\n\t\t\tif (strlen(fwd->connect_path) > sizeof(sunaddr.sun_path)) {\n\t\t\t\terror(\"Local connecting path too long: %s\",\n\t\t\t\t    fwd->connect_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpath = fwd->connect_path;\n\t\t\tport = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tif (fwd->connect_host == NULL) {\n\t\t\t\terror(\"No forward host name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (strlen(fwd->connect_host) >= NI_MAXHOST) {\n\t\t\t\terror(\"Forward host name too long.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpath = fwd->connect_host;\n\t\t\tport = fwd->connect_port;\n\t\t}\n\t\tbreak;\n\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\tpath = fwd->listen_path;\n\t\tport = PORT_STREAMLOCAL;\n\t\tbreak;\n\tdefault:\n\t\terror(\"%s: unexpected channel type %d\", __func__, type);\n\t\treturn 0;\n\t}\n\n\tif (fwd->listen_path == NULL) {\n\t\terror(\"No forward path name.\");\n\t\treturn 0;\n\t}\n\tif (strlen(fwd->listen_path) > sizeof(sunaddr.sun_path)) {\n\t\terror(\"Local listening path too long: %s\", fwd->listen_path);\n\t\treturn 0;\n\t}\n\n\tdebug3(\"%s: type %d path %s\", __func__, type, fwd->listen_path);\n\n\t/* Start a Unix domain listener. */\n\tomask = umask(fwd_opts->streamlocal_bind_mask);\n\tsock = unix_listener(fwd->listen_path, SSH_LISTEN_BACKLOG,\n\t    fwd_opts->streamlocal_bind_unlink);\n\tumask(omask);\n\tif (sock < 0)\n\t\treturn 0;\n\n\tdebug(\"Local forwarding listening on path %s.\", fwd->listen_path);\n\n\t/* Allocate a channel number for the socket. */\n\tc = channel_new(ssh, \"unix listener\", type, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, \"unix listener\", 1);\n\tc->path = xstrdup(path);\n\tc->host_port = port;\n\tc->listening_port = PORT_STREAMLOCAL;\n\tc->listening_addr = xstrdup(fwd->listen_path);\n\treturn 1;\n}"
  },
  {
    "function_name": "channel_setup_fwd_listener_tcpip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3348-3506",
    "snippet": "static int\nchannel_setup_fwd_listener_tcpip(struct ssh *ssh, int type,\n    struct Forward *fwd, int *allocated_listen_port,\n    struct ForwardOptions *fwd_opts)\n{\n\tChannel *c;\n\tint sock, r, success = 0, wildcard = 0, is_client;\n\tstruct addrinfo hints, *ai, *aitop;\n\tconst char *host, *addr;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\tin_port_t *lport_p;\n\n\tis_client = (type == SSH_CHANNEL_PORT_LISTENER);\n\n\tif (is_client && fwd->connect_path != NULL) {\n\t\thost = fwd->connect_path;\n\t} else {\n\t\thost = (type == SSH_CHANNEL_RPORT_LISTENER) ?\n\t\t    fwd->listen_host : fwd->connect_host;\n\t\tif (host == NULL) {\n\t\t\terror(\"No forward host name.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (strlen(host) >= NI_MAXHOST) {\n\t\t\terror(\"Forward host name too long.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Determine the bind address, cf. channel_fwd_bind_addr() comment */\n\taddr = channel_fwd_bind_addr(fwd->listen_host, &wildcard,\n\t    is_client, fwd_opts);\n\tdebug3(\"%s: type %d wildcard %d addr %s\", __func__,\n\t    type, wildcard, (addr == NULL) ? \"NULL\" : addr);\n\n\t/*\n\t * getaddrinfo returns a loopback address if the hostname is\n\t * set to NULL and hints.ai_flags is not AI_PASSIVE\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = ssh->chanctxt->IPv4or6;\n\thints.ai_flags = wildcard ? AI_PASSIVE : 0;\n\thints.ai_socktype = SOCK_STREAM;\n\tsnprintf(strport, sizeof strport, \"%d\", fwd->listen_port);\n\tif ((r = getaddrinfo(addr, strport, &hints, &aitop)) != 0) {\n\t\tif (addr == NULL) {\n\t\t\t/* This really shouldn't happen */\n\t\t\tpacket_disconnect(\"getaddrinfo: fatal error: %s\",\n\t\t\t    ssh_gai_strerror(r));\n\t\t} else {\n\t\t\terror(\"%s: getaddrinfo(%.64s): %s\", __func__, addr,\n\t\t\t    ssh_gai_strerror(r));\n\t\t}\n\t\treturn 0;\n\t}\n\tif (allocated_listen_port != NULL)\n\t\t*allocated_listen_port = 0;\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\tswitch (ai->ai_family) {\n\t\tcase AF_INET:\n\t\t\tlport_p = &((struct sockaddr_in *)ai->ai_addr)->\n\t\t\t    sin_port;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tlport_p = &((struct sockaddr_in6 *)ai->ai_addr)->\n\t\t\t    sin6_port;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * If allocating a port for -R forwards, then use the\n\t\t * same port for all address families.\n\t\t */\n\t\tif (type == SSH_CHANNEL_RPORT_LISTENER &&\n\t\t    fwd->listen_port == 0 && allocated_listen_port != NULL &&\n\t\t    *allocated_listen_port > 0)\n\t\t\t*lport_p = htons(*allocated_listen_port);\n\n\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop, sizeof(ntop),\n\t\t    strport, sizeof(strport),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\terror(\"%s: getnameinfo failed\", __func__);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Create a port to listen for the host. */\n\t\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (sock < 0) {\n\t\t\t/* this is no error since kernel may not support ipv6 */\n\t\t\tverbose(\"socket [%s]:%s: %.100s\", ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_reuseaddr(sock);\n\t\tif (ai->ai_family == AF_INET6)\n\t\t\tsock_set_v6only(sock);\n\n\t\tdebug(\"Local forwarding listening on %s port %s.\",\n\t\t    ntop, strport);\n\n\t\t/* Bind the socket to the address. */\n\t\tif (bind(sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\t/*\n\t\t\t * address can be in if use ipv6 address is\n\t\t\t * already bound\n\t\t\t */\n\t\t\tif (!ai->ai_next)\n\t\t\t\terror(\"bind [%s]:%s: %.100s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\t\t\telse\n\t\t\t\tverbose(\"bind [%s]:%s: %.100s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Start listening for connections on the socket. */\n\t\tif (listen(sock, SSH_LISTEN_BACKLOG) < 0) {\n\t\t\terror(\"listen: %.100s\", strerror(errno));\n\t\t\terror(\"listen [%s]:%s: %.100s\", ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * fwd->listen_port == 0 requests a dynamically allocated port -\n\t\t * record what we got.\n\t\t */\n\t\tif (type == SSH_CHANNEL_RPORT_LISTENER &&\n\t\t    fwd->listen_port == 0 &&\n\t\t    allocated_listen_port != NULL &&\n\t\t    *allocated_listen_port == 0) {\n\t\t\t*allocated_listen_port = get_local_port(sock);\n\t\t\tdebug(\"Allocated listen port %d\",\n\t\t\t    *allocated_listen_port);\n\t\t}\n\n\t\t/* Allocate a channel number for the socket. */\n\t\tc = channel_new(ssh, \"port listener\", type, sock, sock, -1,\n\t\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t\t    0, \"port listener\", 1);\n\t\tc->path = xstrdup(host);\n\t\tc->host_port = fwd->connect_port;\n\t\tc->listening_addr = addr == NULL ? NULL : xstrdup(addr);\n\t\tif (fwd->listen_port == 0 && allocated_listen_port != NULL &&\n\t\t    !(datafellows & SSH_BUG_DYNAMIC_RPORT))\n\t\t\tc->listening_port = *allocated_listen_port;\n\t\telse\n\t\t\tc->listening_port = fwd->listen_port;\n\t\tsuccess = 1;\n\t}\n\tif (success == 0)\n\t\terror(\"%s: cannot listen to port: %d\", __func__,\n\t\t    fwd->listen_port);\n\tfreeaddrinfo(aitop);\n\treturn success;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *channel_rfwd_bind_host(const char *listen_host);",
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "aitop"
          ],
          "line": 3504
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: cannot listen to port: %d\"",
            "__func__",
            "fwd->listen_port"
          ],
          "line": 3502
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "addr"
          ],
          "line": 3493
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "\"port listener\"",
            "type",
            "sock",
            "sock",
            "-1",
            "CHAN_TCP_WINDOW_DEFAULT",
            "CHAN_TCP_PACKET_DEFAULT",
            "0",
            "\"port listener\"",
            "1"
          ],
          "line": 3488
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Allocated listen port %d\"",
            "*allocated_listen_port"
          ],
          "line": 3483
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_local_port",
          "args": [
            "sock"
          ],
          "line": 3482
        },
        "resolved": true,
        "details": {
          "function_name": "get_local_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "200-204",
          "snippet": "int\nget_local_port(int sock)\n{\n\treturn get_sock_port(sock, 1);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nget_local_port(int sock)\n{\n\treturn get_sock_port(sock, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 3470
        },
        "resolved": true,
        "details": {
          "function_name": "channel_close_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "656-664",
          "snippet": "void\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 3469
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "sock",
            "SSH_LISTEN_BACKLOG"
          ],
          "line": 3466
        },
        "resolved": true,
        "details": {
          "function_name": "open_listen_match_streamlocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3931-3943",
          "snippet": "static int\nopen_listen_match_streamlocal(struct permission *allowed_open,\n    const char *requestedpath)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != PORT_STREAMLOCAL)\n\t\treturn 0;\n\tif (allowed_open->listen_path == NULL ||\n\t    strcmp(allowed_open->listen_path, requestedpath) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nopen_listen_match_streamlocal(struct permission *allowed_open,\n    const char *requestedpath)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != PORT_STREAMLOCAL)\n\t\treturn 0;\n\tif (allowed_open->listen_path == NULL ||\n\t    strcmp(allowed_open->listen_path, requestedpath) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"bind [%s]:%s: %.100s\"",
            "ntop",
            "strport",
            "strerror(errno)"
          ],
          "line": 3459
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "sock",
            "ai->ai_addr",
            "ai->ai_addrlen"
          ],
          "line": 3450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_set_v6only",
          "args": [
            "sock"
          ],
          "line": 3444
        },
        "resolved": true,
        "details": {
          "function_name": "sock_set_v6only",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1534-1544",
          "snippet": "void\nsock_set_v6only(int s)\n{\n#if defined(IPV6_V6ONLY) && !defined(__OpenBSD__)\n\tint on = 1;\n\n\tdebug3(\"%s: set socket %d IPV6_V6ONLY\", __func__, s);\n\tif (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &on, sizeof(on)) == -1)\n\t\terror(\"setsockopt IPV6_V6ONLY: %s\", strerror(errno));\n#endif\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsock_set_v6only(int s)\n{\n#if defined(IPV6_V6ONLY) && !defined(__OpenBSD__)\n\tint on = 1;\n\n\tdebug3(\"%s: set socket %d IPV6_V6ONLY\", __func__, s);\n\tif (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &on, sizeof(on)) == -1)\n\t\terror(\"setsockopt IPV6_V6ONLY: %s\", strerror(errno));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_reuseaddr",
          "args": [
            "sock"
          ],
          "line": 3442
        },
        "resolved": true,
        "details": {
          "function_name": "set_reuseaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "171-181",
          "snippet": "int\nset_reuseaddr(int fd)\n{\n\tint on = 1;\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {\n\t\terror(\"setsockopt SO_REUSEADDR fd %d: %s\", fd, strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nset_reuseaddr(int fd)\n{\n\tint on = 1;\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {\n\t\terror(\"setsockopt SO_REUSEADDR fd %d: %s\", fd, strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "ai->ai_family",
            "ai->ai_socktype",
            "ai->ai_protocol"
          ],
          "line": 3434
        },
        "resolved": true,
        "details": {
          "function_name": "is_path_to_xsocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4667-4690",
          "snippet": "static int\nis_path_to_xsocket(const char *display, char *path, size_t pathlen)\n{\n\tstruct stat sbuf;\n\n\tif (strlcpy(path, display, pathlen) >= pathlen) {\n\t\terror(\"%s: display path too long\", __func__);\n\t\treturn 0;\n\t}\n\tif (display[0] != '/')\n\t\treturn 0;\n\tif (stat(path, &sbuf) == 0) {\n\t\treturn 1;\n\t} else {\n\t\tchar *dot = strrchr(path, '.');\n\t\tif (dot != NULL) {\n\t\t\t*dot = '\\0';\n\t\t\tif (stat(path, &sbuf) == 0) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nis_path_to_xsocket(const char *display, char *path, size_t pathlen)\n{\n\tstruct stat sbuf;\n\n\tif (strlcpy(path, display, pathlen) >= pathlen) {\n\t\terror(\"%s: display path too long\", __func__);\n\t\treturn 0;\n\t}\n\tif (display[0] != '/')\n\t\treturn 0;\n\tif (stat(path, &sbuf) == 0) {\n\t\treturn 1;\n\t} else {\n\t\tchar *dot = strrchr(path, '.');\n\t\tif (dot != NULL) {\n\t\t\t*dot = '\\0';\n\t\t\tif (stat(path, &sbuf) == 0) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "ai->ai_addr",
            "ai->ai_addrlen",
            "ntop",
            "sizeof(ntop)",
            "strport",
            "sizeof(strport)",
            "NI_NUMERICHOST|NI_NUMERICSERV"
          ],
          "line": 3427
        },
        "resolved": true,
        "details": {
          "function_name": "sshaix_getnameinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "415-434",
          "snippet": "int\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "*allocated_listen_port"
          ],
          "line": 3425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_disconnect",
          "args": [
            "\"getaddrinfo: fatal error: %s\"",
            "ssh_gai_strerror(r)"
          ],
          "line": 3395
        },
        "resolved": true,
        "details": {
          "function_name": "packet_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "298-308",
          "snippet": "void\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "addr",
            "strport",
            "&hints",
            "&aitop"
          ],
          "line": 3392
        },
        "resolved": true,
        "details": {
          "function_name": "getaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "154-234",
          "snippet": "int\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "strport",
            "sizeof strport",
            "\"%d\"",
            "fwd->listen_port"
          ],
          "line": 3391
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 3387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_fwd_bind_addr",
          "args": [
            "fwd->listen_host",
            "&wildcard",
            "is_client",
            "fwd_opts"
          ],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "channel_fwd_bind_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3300-3346",
          "snippet": "static const char *\nchannel_fwd_bind_addr(const char *listen_addr, int *wildcardp,\n    int is_client, struct ForwardOptions *fwd_opts)\n{\n\tconst char *addr = NULL;\n\tint wildcard = 0;\n\n\tif (listen_addr == NULL) {\n\t\t/* No address specified: default to gateway_ports setting */\n\t\tif (fwd_opts->gateway_ports)\n\t\t\twildcard = 1;\n\t} else if (fwd_opts->gateway_ports || is_client) {\n\t\tif (((datafellows & SSH_OLD_FORWARD_ADDR) &&\n\t\t    strcmp(listen_addr, \"0.0.0.0\") == 0 && is_client == 0) ||\n\t\t    *listen_addr == '\\0' || strcmp(listen_addr, \"*\") == 0 ||\n\t\t    (!is_client && fwd_opts->gateway_ports == 1)) {\n\t\t\twildcard = 1;\n\t\t\t/*\n\t\t\t * Notify client if they requested a specific listen\n\t\t\t * address and it was overridden.\n\t\t\t */\n\t\t\tif (*listen_addr != '\\0' &&\n\t\t\t    strcmp(listen_addr, \"0.0.0.0\") != 0 &&\n\t\t\t    strcmp(listen_addr, \"*\") != 0) {\n\t\t\t\tpacket_send_debug(\"Forwarding listen address \"\n\t\t\t\t    \"\\\"%s\\\" overridden by server \"\n\t\t\t\t    \"GatewayPorts\", listen_addr);\n\t\t\t}\n\t\t} else if (strcmp(listen_addr, \"localhost\") != 0 ||\n\t\t    strcmp(listen_addr, \"127.0.0.1\") == 0 ||\n\t\t    strcmp(listen_addr, \"::1\") == 0) {\n\t\t\t/* Accept localhost address when GatewayPorts=yes */\n\t\t\taddr = listen_addr;\n\t\t}\n\t} else if (strcmp(listen_addr, \"127.0.0.1\") == 0 ||\n\t    strcmp(listen_addr, \"::1\") == 0) {\n\t\t/*\n\t\t * If a specific IPv4/IPv6 localhost address has been\n\t\t * requested then accept it even if gateway_ports is in\n\t\t * effect. This allows the client to prefer IPv4 or IPv6.\n\t\t */\n\t\taddr = listen_addr;\n\t}\n\tif (wildcardp != NULL)\n\t\t*wildcardp = wildcard;\n\treturn addr;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nchannel_fwd_bind_addr(const char *listen_addr, int *wildcardp,\n    int is_client, struct ForwardOptions *fwd_opts)\n{\n\tconst char *addr = NULL;\n\tint wildcard = 0;\n\n\tif (listen_addr == NULL) {\n\t\t/* No address specified: default to gateway_ports setting */\n\t\tif (fwd_opts->gateway_ports)\n\t\t\twildcard = 1;\n\t} else if (fwd_opts->gateway_ports || is_client) {\n\t\tif (((datafellows & SSH_OLD_FORWARD_ADDR) &&\n\t\t    strcmp(listen_addr, \"0.0.0.0\") == 0 && is_client == 0) ||\n\t\t    *listen_addr == '\\0' || strcmp(listen_addr, \"*\") == 0 ||\n\t\t    (!is_client && fwd_opts->gateway_ports == 1)) {\n\t\t\twildcard = 1;\n\t\t\t/*\n\t\t\t * Notify client if they requested a specific listen\n\t\t\t * address and it was overridden.\n\t\t\t */\n\t\t\tif (*listen_addr != '\\0' &&\n\t\t\t    strcmp(listen_addr, \"0.0.0.0\") != 0 &&\n\t\t\t    strcmp(listen_addr, \"*\") != 0) {\n\t\t\t\tpacket_send_debug(\"Forwarding listen address \"\n\t\t\t\t    \"\\\"%s\\\" overridden by server \"\n\t\t\t\t    \"GatewayPorts\", listen_addr);\n\t\t\t}\n\t\t} else if (strcmp(listen_addr, \"localhost\") != 0 ||\n\t\t    strcmp(listen_addr, \"127.0.0.1\") == 0 ||\n\t\t    strcmp(listen_addr, \"::1\") == 0) {\n\t\t\t/* Accept localhost address when GatewayPorts=yes */\n\t\t\taddr = listen_addr;\n\t\t}\n\t} else if (strcmp(listen_addr, \"127.0.0.1\") == 0 ||\n\t    strcmp(listen_addr, \"::1\") == 0) {\n\t\t/*\n\t\t * If a specific IPv4/IPv6 localhost address has been\n\t\t * requested then accept it even if gateway_ports is in\n\t\t * effect. This allows the client to prefer IPv4 or IPv6.\n\t\t */\n\t\taddr = listen_addr;\n\t}\n\tif (wildcardp != NULL)\n\t\t*wildcardp = wildcard;\n\treturn addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "host"
          ],
          "line": 3371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_setup_fwd_listener_tcpip(struct ssh *ssh, int type,\n    struct Forward *fwd, int *allocated_listen_port,\n    struct ForwardOptions *fwd_opts)\n{\n\tChannel *c;\n\tint sock, r, success = 0, wildcard = 0, is_client;\n\tstruct addrinfo hints, *ai, *aitop;\n\tconst char *host, *addr;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\tin_port_t *lport_p;\n\n\tis_client = (type == SSH_CHANNEL_PORT_LISTENER);\n\n\tif (is_client && fwd->connect_path != NULL) {\n\t\thost = fwd->connect_path;\n\t} else {\n\t\thost = (type == SSH_CHANNEL_RPORT_LISTENER) ?\n\t\t    fwd->listen_host : fwd->connect_host;\n\t\tif (host == NULL) {\n\t\t\terror(\"No forward host name.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (strlen(host) >= NI_MAXHOST) {\n\t\t\terror(\"Forward host name too long.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Determine the bind address, cf. channel_fwd_bind_addr() comment */\n\taddr = channel_fwd_bind_addr(fwd->listen_host, &wildcard,\n\t    is_client, fwd_opts);\n\tdebug3(\"%s: type %d wildcard %d addr %s\", __func__,\n\t    type, wildcard, (addr == NULL) ? \"NULL\" : addr);\n\n\t/*\n\t * getaddrinfo returns a loopback address if the hostname is\n\t * set to NULL and hints.ai_flags is not AI_PASSIVE\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = ssh->chanctxt->IPv4or6;\n\thints.ai_flags = wildcard ? AI_PASSIVE : 0;\n\thints.ai_socktype = SOCK_STREAM;\n\tsnprintf(strport, sizeof strport, \"%d\", fwd->listen_port);\n\tif ((r = getaddrinfo(addr, strport, &hints, &aitop)) != 0) {\n\t\tif (addr == NULL) {\n\t\t\t/* This really shouldn't happen */\n\t\t\tpacket_disconnect(\"getaddrinfo: fatal error: %s\",\n\t\t\t    ssh_gai_strerror(r));\n\t\t} else {\n\t\t\terror(\"%s: getaddrinfo(%.64s): %s\", __func__, addr,\n\t\t\t    ssh_gai_strerror(r));\n\t\t}\n\t\treturn 0;\n\t}\n\tif (allocated_listen_port != NULL)\n\t\t*allocated_listen_port = 0;\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\tswitch (ai->ai_family) {\n\t\tcase AF_INET:\n\t\t\tlport_p = &((struct sockaddr_in *)ai->ai_addr)->\n\t\t\t    sin_port;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tlport_p = &((struct sockaddr_in6 *)ai->ai_addr)->\n\t\t\t    sin6_port;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * If allocating a port for -R forwards, then use the\n\t\t * same port for all address families.\n\t\t */\n\t\tif (type == SSH_CHANNEL_RPORT_LISTENER &&\n\t\t    fwd->listen_port == 0 && allocated_listen_port != NULL &&\n\t\t    *allocated_listen_port > 0)\n\t\t\t*lport_p = htons(*allocated_listen_port);\n\n\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop, sizeof(ntop),\n\t\t    strport, sizeof(strport),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\terror(\"%s: getnameinfo failed\", __func__);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Create a port to listen for the host. */\n\t\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (sock < 0) {\n\t\t\t/* this is no error since kernel may not support ipv6 */\n\t\t\tverbose(\"socket [%s]:%s: %.100s\", ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_reuseaddr(sock);\n\t\tif (ai->ai_family == AF_INET6)\n\t\t\tsock_set_v6only(sock);\n\n\t\tdebug(\"Local forwarding listening on %s port %s.\",\n\t\t    ntop, strport);\n\n\t\t/* Bind the socket to the address. */\n\t\tif (bind(sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\t/*\n\t\t\t * address can be in if use ipv6 address is\n\t\t\t * already bound\n\t\t\t */\n\t\t\tif (!ai->ai_next)\n\t\t\t\terror(\"bind [%s]:%s: %.100s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\t\t\telse\n\t\t\t\tverbose(\"bind [%s]:%s: %.100s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Start listening for connections on the socket. */\n\t\tif (listen(sock, SSH_LISTEN_BACKLOG) < 0) {\n\t\t\terror(\"listen: %.100s\", strerror(errno));\n\t\t\terror(\"listen [%s]:%s: %.100s\", ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * fwd->listen_port == 0 requests a dynamically allocated port -\n\t\t * record what we got.\n\t\t */\n\t\tif (type == SSH_CHANNEL_RPORT_LISTENER &&\n\t\t    fwd->listen_port == 0 &&\n\t\t    allocated_listen_port != NULL &&\n\t\t    *allocated_listen_port == 0) {\n\t\t\t*allocated_listen_port = get_local_port(sock);\n\t\t\tdebug(\"Allocated listen port %d\",\n\t\t\t    *allocated_listen_port);\n\t\t}\n\n\t\t/* Allocate a channel number for the socket. */\n\t\tc = channel_new(ssh, \"port listener\", type, sock, sock, -1,\n\t\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t\t    0, \"port listener\", 1);\n\t\tc->path = xstrdup(host);\n\t\tc->host_port = fwd->connect_port;\n\t\tc->listening_addr = addr == NULL ? NULL : xstrdup(addr);\n\t\tif (fwd->listen_port == 0 && allocated_listen_port != NULL &&\n\t\t    !(datafellows & SSH_BUG_DYNAMIC_RPORT))\n\t\t\tc->listening_port = *allocated_listen_port;\n\t\telse\n\t\t\tc->listening_port = fwd->listen_port;\n\t\tsuccess = 1;\n\t}\n\tif (success == 0)\n\t\terror(\"%s: cannot listen to port: %d\", __func__,\n\t\t    fwd->listen_port);\n\tfreeaddrinfo(aitop);\n\treturn success;\n}"
  },
  {
    "function_name": "channel_fwd_bind_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3300-3346",
    "snippet": "static const char *\nchannel_fwd_bind_addr(const char *listen_addr, int *wildcardp,\n    int is_client, struct ForwardOptions *fwd_opts)\n{\n\tconst char *addr = NULL;\n\tint wildcard = 0;\n\n\tif (listen_addr == NULL) {\n\t\t/* No address specified: default to gateway_ports setting */\n\t\tif (fwd_opts->gateway_ports)\n\t\t\twildcard = 1;\n\t} else if (fwd_opts->gateway_ports || is_client) {\n\t\tif (((datafellows & SSH_OLD_FORWARD_ADDR) &&\n\t\t    strcmp(listen_addr, \"0.0.0.0\") == 0 && is_client == 0) ||\n\t\t    *listen_addr == '\\0' || strcmp(listen_addr, \"*\") == 0 ||\n\t\t    (!is_client && fwd_opts->gateway_ports == 1)) {\n\t\t\twildcard = 1;\n\t\t\t/*\n\t\t\t * Notify client if they requested a specific listen\n\t\t\t * address and it was overridden.\n\t\t\t */\n\t\t\tif (*listen_addr != '\\0' &&\n\t\t\t    strcmp(listen_addr, \"0.0.0.0\") != 0 &&\n\t\t\t    strcmp(listen_addr, \"*\") != 0) {\n\t\t\t\tpacket_send_debug(\"Forwarding listen address \"\n\t\t\t\t    \"\\\"%s\\\" overridden by server \"\n\t\t\t\t    \"GatewayPorts\", listen_addr);\n\t\t\t}\n\t\t} else if (strcmp(listen_addr, \"localhost\") != 0 ||\n\t\t    strcmp(listen_addr, \"127.0.0.1\") == 0 ||\n\t\t    strcmp(listen_addr, \"::1\") == 0) {\n\t\t\t/* Accept localhost address when GatewayPorts=yes */\n\t\t\taddr = listen_addr;\n\t\t}\n\t} else if (strcmp(listen_addr, \"127.0.0.1\") == 0 ||\n\t    strcmp(listen_addr, \"::1\") == 0) {\n\t\t/*\n\t\t * If a specific IPv4/IPv6 localhost address has been\n\t\t * requested then accept it even if gateway_ports is in\n\t\t * effect. This allows the client to prefer IPv4 or IPv6.\n\t\t */\n\t\taddr = listen_addr;\n\t}\n\tif (wildcardp != NULL)\n\t\t*wildcardp = wildcard;\n\treturn addr;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "listen_addr",
            "\"::1\""
          ],
          "line": 3335
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send_debug",
          "args": [
            "\"Forwarding listen address \"\n\t\t\t\t    \"\\\"%s\\\" overridden by server \"\n\t\t\t\t    \"GatewayPorts\"",
            "listen_addr"
          ],
          "line": 3324
        },
        "resolved": true,
        "details": {
          "function_name": "packet_send_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "310-320",
          "snippet": "void\npacket_send_debug(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_send_debug(active_state, \"%s\", buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_send_debug(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_send_debug(active_state, \"%s\", buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nchannel_fwd_bind_addr(const char *listen_addr, int *wildcardp,\n    int is_client, struct ForwardOptions *fwd_opts)\n{\n\tconst char *addr = NULL;\n\tint wildcard = 0;\n\n\tif (listen_addr == NULL) {\n\t\t/* No address specified: default to gateway_ports setting */\n\t\tif (fwd_opts->gateway_ports)\n\t\t\twildcard = 1;\n\t} else if (fwd_opts->gateway_ports || is_client) {\n\t\tif (((datafellows & SSH_OLD_FORWARD_ADDR) &&\n\t\t    strcmp(listen_addr, \"0.0.0.0\") == 0 && is_client == 0) ||\n\t\t    *listen_addr == '\\0' || strcmp(listen_addr, \"*\") == 0 ||\n\t\t    (!is_client && fwd_opts->gateway_ports == 1)) {\n\t\t\twildcard = 1;\n\t\t\t/*\n\t\t\t * Notify client if they requested a specific listen\n\t\t\t * address and it was overridden.\n\t\t\t */\n\t\t\tif (*listen_addr != '\\0' &&\n\t\t\t    strcmp(listen_addr, \"0.0.0.0\") != 0 &&\n\t\t\t    strcmp(listen_addr, \"*\") != 0) {\n\t\t\t\tpacket_send_debug(\"Forwarding listen address \"\n\t\t\t\t    \"\\\"%s\\\" overridden by server \"\n\t\t\t\t    \"GatewayPorts\", listen_addr);\n\t\t\t}\n\t\t} else if (strcmp(listen_addr, \"localhost\") != 0 ||\n\t\t    strcmp(listen_addr, \"127.0.0.1\") == 0 ||\n\t\t    strcmp(listen_addr, \"::1\") == 0) {\n\t\t\t/* Accept localhost address when GatewayPorts=yes */\n\t\t\taddr = listen_addr;\n\t\t}\n\t} else if (strcmp(listen_addr, \"127.0.0.1\") == 0 ||\n\t    strcmp(listen_addr, \"::1\") == 0) {\n\t\t/*\n\t\t * If a specific IPv4/IPv6 localhost address has been\n\t\t * requested then accept it even if gateway_ports is in\n\t\t * effect. This allows the client to prefer IPv4 or IPv6.\n\t\t */\n\t\taddr = listen_addr;\n\t}\n\tif (wildcardp != NULL)\n\t\t*wildcardp = wildcard;\n\treturn addr;\n}"
  },
  {
    "function_name": "channel_set_af",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3278-3282",
    "snippet": "void\nchannel_set_af(struct ssh *ssh, int af)\n{\n\tssh->chanctxt->IPv4or6 = af;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_set_af(struct ssh *ssh, int af)\n{\n\tssh->chanctxt->IPv4or6 = af;\n}"
  },
  {
    "function_name": "channel_input_status_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3248-3274",
    "snippet": "int\nchannel_input_status_confirm(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tint id = channel_parse_id(ssh, __func__, \"status confirm\");\n\tChannel *c;\n\tstruct channel_confirm *cc;\n\n\t/* Reset keepalive timeout */\n\tpacket_set_alive_timeouts(0);\n\n\tdebug2(\"%s: type %d id %d\", __func__, type, id);\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tlogit(\"%s: %d: unknown\", __func__, id);\n\t\treturn 0;\n\t}\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tssh_packet_check_eom(ssh);\n\tif ((cc = TAILQ_FIRST(&c->status_confirms)) == NULL)\n\t\treturn 0;\n\tcc->cb(ssh, type, c, cc->ctx);\n\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n\treturn 0;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cc"
          ],
          "line": 3272
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4195-4206",
          "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "cc",
            "sizeof(*cc)"
          ],
          "line": 3271
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&c->status_confirms",
            "cc",
            "entry"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cc->cb",
          "args": [
            "ssh",
            "type",
            "c",
            "cc->ctx"
          ],
          "line": 3269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&c->status_confirms"
          ],
          "line": 3267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_packet_check_eom",
          "args": [
            "ssh"
          ],
          "line": 3266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_proxy_upstream",
          "args": [
            "c",
            "type",
            "seq",
            "ssh"
          ],
          "line": 3264
        },
        "resolved": true,
        "details": {
          "function_name": "channel_proxy_upstream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2865-2943",
          "snippet": "int\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s: %d: unknown\"",
            "__func__",
            "id"
          ],
          "line": 3261
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_lookup",
          "args": [
            "ssh",
            "id"
          ],
          "line": 3260
        },
        "resolved": true,
        "details": {
          "function_name": "channel_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "279-302",
          "snippet": "Channel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: type %d id %d\"",
            "__func__",
            "type",
            "id"
          ],
          "line": 3258
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_set_alive_timeouts",
          "args": [
            "0"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_parse_id",
          "args": [
            "ssh",
            "__func__",
            "\"status confirm\""
          ],
          "line": 3251
        },
        "resolved": true,
        "details": {
          "function_name": "channel_parse_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2948-2963",
          "snippet": "static int\nchannel_parse_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tu_int32_t id;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, &id)) != 0) {\n\t\terror(\"%s: parse id: %s\", where, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid %s message\", what);\n\t}\n\tif (id > INT_MAX) {\n\t\terror(\"%s: bad channel id %u: %s\", where, id, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid %s channel id\", what);\n\t}\n\treturn (int)id;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nstatic int\nchannel_parse_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tu_int32_t id;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, &id)) != 0) {\n\t\terror(\"%s: parse id: %s\", where, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid %s message\", what);\n\t}\n\tif (id > INT_MAX) {\n\t\terror(\"%s: bad channel id %u: %s\", where, id, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid %s channel id\", what);\n\t}\n\treturn (int)id;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_input_status_confirm(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tint id = channel_parse_id(ssh, __func__, \"status confirm\");\n\tChannel *c;\n\tstruct channel_confirm *cc;\n\n\t/* Reset keepalive timeout */\n\tpacket_set_alive_timeouts(0);\n\n\tdebug2(\"%s: type %d id %d\", __func__, type, id);\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tlogit(\"%s: %d: unknown\", __func__, id);\n\t\treturn 0;\n\t}\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tssh_packet_check_eom(ssh);\n\tif ((cc = TAILQ_FIRST(&c->status_confirms)) == NULL)\n\t\treturn 0;\n\tcc->cb(ssh, type, c, cc->ctx);\n\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n\treturn 0;\n}"
  },
  {
    "function_name": "channel_input_window_adjust",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3218-3246",
    "snippet": "int\nchannel_input_window_adjust(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tint id = channel_parse_id(ssh, __func__, \"window adjust\");\n\tChannel *c;\n\tu_int32_t adjust;\n\tu_int new_rwin;\n\tint r;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tlogit(\"Received window adjust for non-open channel %d.\", id);\n\t\treturn 0;\n\t}\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tif ((r = sshpkt_get_u32(ssh, &adjust)) != 0) {\n\t\terror(\"%s: adjust: %s\", __func__, ssh_err(r));\n\t\tpacket_disconnect(\"Invalid window adjust message\");\n\t}\n\tssh_packet_check_eom(ssh);\n\tdebug2(\"channel %d: rcvd adjust %u\", c->self, adjust);\n\tif ((new_rwin = c->remote_window + adjust) < c->remote_window) {\n\t\tfatal(\"channel %d: adjust %u overflows remote window %u\",\n\t\t    c->self, adjust, c->remote_window);\n\t}\n\tc->remote_window = new_rwin;\n\treturn 0;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"channel %d: adjust %u overflows remote window %u\"",
            "c->self",
            "adjust",
            "c->remote_window"
          ],
          "line": 3241
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: rcvd adjust %u\"",
            "c->self",
            "adjust"
          ],
          "line": 3239
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_check_eom",
          "args": [
            "ssh"
          ],
          "line": 3238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_disconnect",
          "args": [
            "\"Invalid window adjust message\""
          ],
          "line": 3236
        },
        "resolved": true,
        "details": {
          "function_name": "packet_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "298-308",
          "snippet": "void\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: adjust: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 3235
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 3235
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_u32",
          "args": [
            "ssh",
            "&adjust"
          ],
          "line": 3234
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2502-2506",
          "snippet": "int\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_proxy_upstream",
          "args": [
            "c",
            "type",
            "seq",
            "ssh"
          ],
          "line": 3232
        },
        "resolved": true,
        "details": {
          "function_name": "channel_proxy_upstream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2865-2943",
          "snippet": "int\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Received window adjust for non-open channel %d.\"",
            "id"
          ],
          "line": 3228
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_lookup",
          "args": [
            "ssh",
            "id"
          ],
          "line": 3227
        },
        "resolved": true,
        "details": {
          "function_name": "channel_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "279-302",
          "snippet": "Channel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_parse_id",
          "args": [
            "ssh",
            "__func__",
            "\"window adjust\""
          ],
          "line": 3221
        },
        "resolved": true,
        "details": {
          "function_name": "channel_parse_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2948-2963",
          "snippet": "static int\nchannel_parse_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tu_int32_t id;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, &id)) != 0) {\n\t\terror(\"%s: parse id: %s\", where, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid %s message\", what);\n\t}\n\tif (id > INT_MAX) {\n\t\terror(\"%s: bad channel id %u: %s\", where, id, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid %s channel id\", what);\n\t}\n\treturn (int)id;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nstatic int\nchannel_parse_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tu_int32_t id;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, &id)) != 0) {\n\t\terror(\"%s: parse id: %s\", where, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid %s message\", what);\n\t}\n\tif (id > INT_MAX) {\n\t\terror(\"%s: bad channel id %u: %s\", where, id, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid %s channel id\", what);\n\t}\n\treturn (int)id;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_input_window_adjust(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tint id = channel_parse_id(ssh, __func__, \"window adjust\");\n\tChannel *c;\n\tu_int32_t adjust;\n\tu_int new_rwin;\n\tint r;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tlogit(\"Received window adjust for non-open channel %d.\", id);\n\t\treturn 0;\n\t}\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tif ((r = sshpkt_get_u32(ssh, &adjust)) != 0) {\n\t\terror(\"%s: adjust: %s\", __func__, ssh_err(r));\n\t\tpacket_disconnect(\"Invalid window adjust message\");\n\t}\n\tssh_packet_check_eom(ssh);\n\tdebug2(\"channel %d: rcvd adjust %u\", c->self, adjust);\n\tif ((new_rwin = c->remote_window + adjust) < c->remote_window) {\n\t\tfatal(\"channel %d: adjust %u overflows remote window %u\",\n\t\t    c->self, adjust, c->remote_window);\n\t}\n\tc->remote_window = new_rwin;\n\treturn 0;\n}"
  },
  {
    "function_name": "channel_input_open_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3181-3216",
    "snippet": "int\nchannel_input_open_failure(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = channel_from_packet_id(ssh, __func__, \"open failure\");\n\tu_int32_t reason;\n\tchar *msg = NULL;\n\tint r;\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tif (c->type != SSH_CHANNEL_OPENING)\n\t\tpacket_disconnect(\"Received open failure for \"\n\t\t    \"non-opening channel %d.\", c->self);\n\tif ((r = sshpkt_get_u32(ssh, &reason)) != 0) {\n\t\terror(\"%s: reason: %s\", __func__, ssh_err(r));\n\t\tpacket_disconnect(\"Invalid open failure message\");\n\t}\n\t/* skip language */\n\tif ((r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||\n\t    (r = sshpkt_get_string_direct(ssh, NULL, NULL)) != 0) {\n\t\terror(\"%s: message/lang: %s\", __func__, ssh_err(r));\n\t\tpacket_disconnect(\"Invalid open failure message\");\n\t}\n\tssh_packet_check_eom(ssh);\n\tlogit(\"channel %d: open failed: %s%s%s\", c->self,\n\t    reason2txt(reason), msg ? \": \": \"\", msg ? msg : \"\");\n\tfree(msg);\n\tif (c->open_confirm) {\n\t\tdebug2(\"%s: channel %d: callback start\", __func__, c->self);\n\t\tc->open_confirm(ssh, c->self, 0, c->open_confirm_ctx);\n\t\tdebug2(\"%s: channel %d: callback done\", __func__, c->self);\n\t}\n\t/* Schedule the channel for cleanup/deletion. */\n\tchan_mark_dead(ssh, c);\n\treturn 0;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "chan_mark_dead",
          "args": [
            "ssh",
            "c"
          ],
          "line": 3214
        },
        "resolved": true,
        "details": {
          "function_name": "chan_mark_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "324-328",
          "snippet": "void\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: channel %d: callback done\"",
            "__func__",
            "c->self"
          ],
          "line": 3211
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->open_confirm",
          "args": [
            "ssh",
            "c->self",
            "0",
            "c->open_confirm_ctx"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "msg"
          ],
          "line": 3207
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4195-4206",
          "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"channel %d: open failed: %s%s%s\"",
            "c->self",
            "reason2txt(reason)",
            "msg ? \": \": \"\"",
            "msg ? msg : \"\""
          ],
          "line": 3205
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reason2txt",
          "args": [
            "reason"
          ],
          "line": 3206
        },
        "resolved": true,
        "details": {
          "function_name": "reason2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3165-3179",
          "snippet": "static char *\nreason2txt(int reason)\n{\n\tswitch (reason) {\n\tcase SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED:\n\t\treturn \"administratively prohibited\";\n\tcase SSH2_OPEN_CONNECT_FAILED:\n\t\treturn \"connect failed\";\n\tcase SSH2_OPEN_UNKNOWN_CHANNEL_TYPE:\n\t\treturn \"unknown channel type\";\n\tcase SSH2_OPEN_RESOURCE_SHORTAGE:\n\t\treturn \"resource shortage\";\n\t}\n\treturn \"unknown reason\";\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nreason2txt(int reason)\n{\n\tswitch (reason) {\n\tcase SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED:\n\t\treturn \"administratively prohibited\";\n\tcase SSH2_OPEN_CONNECT_FAILED:\n\t\treturn \"connect failed\";\n\tcase SSH2_OPEN_UNKNOWN_CHANNEL_TYPE:\n\t\treturn \"unknown channel type\";\n\tcase SSH2_OPEN_RESOURCE_SHORTAGE:\n\t\treturn \"resource shortage\";\n\t}\n\treturn \"unknown reason\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_check_eom",
          "args": [
            "ssh"
          ],
          "line": 3204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_disconnect",
          "args": [
            "\"Invalid open failure message\""
          ],
          "line": 3202
        },
        "resolved": true,
        "details": {
          "function_name": "packet_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "298-308",
          "snippet": "void\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: message/lang: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 3201
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 3201
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_string_direct",
          "args": [
            "ssh",
            "NULL",
            "NULL"
          ],
          "line": 3200
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2520-2524",
          "snippet": "int\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_cstring",
          "args": [
            "ssh",
            "&msg",
            "NULL"
          ],
          "line": 3199
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2532-2536",
          "snippet": "int\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_u32",
          "args": [
            "ssh",
            "&reason"
          ],
          "line": 3194
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2502-2506",
          "snippet": "int\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_proxy_upstream",
          "args": [
            "c",
            "type",
            "seq",
            "ssh"
          ],
          "line": 3189
        },
        "resolved": true,
        "details": {
          "function_name": "channel_proxy_upstream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2865-2943",
          "snippet": "int\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_from_packet_id",
          "args": [
            "ssh",
            "__func__",
            "\"open failure\""
          ],
          "line": 3184
        },
        "resolved": true,
        "details": {
          "function_name": "channel_from_packet_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2966-2977",
          "snippet": "static Channel *\nchannel_from_packet_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tint id = channel_parse_id(ssh, where, what);\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tssh_packet_disconnect(ssh,\n\t\t    \"%s packet referred to nonexistent channel %d\", what, id);\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic Channel *\nchannel_from_packet_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tint id = channel_parse_id(ssh, where, what);\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tssh_packet_disconnect(ssh,\n\t\t    \"%s packet referred to nonexistent channel %d\", what, id);\n\t}\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_input_open_failure(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = channel_from_packet_id(ssh, __func__, \"open failure\");\n\tu_int32_t reason;\n\tchar *msg = NULL;\n\tint r;\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tif (c->type != SSH_CHANNEL_OPENING)\n\t\tpacket_disconnect(\"Received open failure for \"\n\t\t    \"non-opening channel %d.\", c->self);\n\tif ((r = sshpkt_get_u32(ssh, &reason)) != 0) {\n\t\terror(\"%s: reason: %s\", __func__, ssh_err(r));\n\t\tpacket_disconnect(\"Invalid open failure message\");\n\t}\n\t/* skip language */\n\tif ((r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||\n\t    (r = sshpkt_get_string_direct(ssh, NULL, NULL)) != 0) {\n\t\terror(\"%s: message/lang: %s\", __func__, ssh_err(r));\n\t\tpacket_disconnect(\"Invalid open failure message\");\n\t}\n\tssh_packet_check_eom(ssh);\n\tlogit(\"channel %d: open failed: %s%s%s\", c->self,\n\t    reason2txt(reason), msg ? \": \": \"\", msg ? msg : \"\");\n\tfree(msg);\n\tif (c->open_confirm) {\n\t\tdebug2(\"%s: channel %d: callback start\", __func__, c->self);\n\t\tc->open_confirm(ssh, c->self, 0, c->open_confirm_ctx);\n\t\tdebug2(\"%s: channel %d: callback done\", __func__, c->self);\n\t}\n\t/* Schedule the channel for cleanup/deletion. */\n\tchan_mark_dead(ssh, c);\n\treturn 0;\n}"
  },
  {
    "function_name": "reason2txt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3165-3179",
    "snippet": "static char *\nreason2txt(int reason)\n{\n\tswitch (reason) {\n\tcase SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED:\n\t\treturn \"administratively prohibited\";\n\tcase SSH2_OPEN_CONNECT_FAILED:\n\t\treturn \"connect failed\";\n\tcase SSH2_OPEN_UNKNOWN_CHANNEL_TYPE:\n\t\treturn \"unknown channel type\";\n\tcase SSH2_OPEN_RESOURCE_SHORTAGE:\n\t\treturn \"resource shortage\";\n\t}\n\treturn \"unknown reason\";\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nreason2txt(int reason)\n{\n\tswitch (reason) {\n\tcase SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED:\n\t\treturn \"administratively prohibited\";\n\tcase SSH2_OPEN_CONNECT_FAILED:\n\t\treturn \"connect failed\";\n\tcase SSH2_OPEN_UNKNOWN_CHANNEL_TYPE:\n\t\treturn \"unknown channel type\";\n\tcase SSH2_OPEN_RESOURCE_SHORTAGE:\n\t\treturn \"resource shortage\";\n\t}\n\treturn \"unknown reason\";\n}"
  },
  {
    "function_name": "channel_input_open_confirmation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3127-3163",
    "snippet": "int\nchannel_input_open_confirmation(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = channel_from_packet_id(ssh, __func__, \"open confirmation\");\n\tu_int32_t remote_window, remote_maxpacket;\n\tint r;\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tif (c->type != SSH_CHANNEL_OPENING)\n\t\tpacket_disconnect(\"Received open confirmation for \"\n\t\t    \"non-opening channel %d.\", c->self);\n\t/*\n\t * Record the remote channel number and mark that the channel\n\t * is now open.\n\t */\n\tif ((r = sshpkt_get_u32(ssh, &c->remote_id)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &remote_window)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &remote_maxpacket)) != 0) {\n\t\terror(\"%s: window/maxpacket: %s\", __func__, ssh_err(r));\n\t\tpacket_disconnect(\"Invalid open confirmation message\");\n\t}\n\tssh_packet_check_eom(ssh);\n\n\tc->have_remote_id = 1;\n\tc->remote_window = remote_window;\n\tc->remote_maxpacket = remote_maxpacket;\n\tc->type = SSH_CHANNEL_OPEN;\n\tif (c->open_confirm) {\n\t\tdebug2(\"%s: channel %d: callback start\", __func__, c->self);\n\t\tc->open_confirm(ssh, c->self, 1, c->open_confirm_ctx);\n\t\tdebug2(\"%s: channel %d: callback done\", __func__, c->self);\n\t}\n\tdebug2(\"channel %d: open confirm rwindow %u rmax %u\", c->self,\n\t    c->remote_window, c->remote_maxpacket);\n\treturn 0;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: open confirm rwindow %u rmax %u\"",
            "c->self",
            "c->remote_window",
            "c->remote_maxpacket"
          ],
          "line": 3160
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->open_confirm",
          "args": [
            "ssh",
            "c->self",
            "1",
            "c->open_confirm_ctx"
          ],
          "line": 3157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_packet_check_eom",
          "args": [
            "ssh"
          ],
          "line": 3149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_disconnect",
          "args": [
            "\"Invalid open confirmation message\""
          ],
          "line": 3147
        },
        "resolved": true,
        "details": {
          "function_name": "packet_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "298-308",
          "snippet": "void\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: window/maxpacket: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 3146
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 3146
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_u32",
          "args": [
            "ssh",
            "&remote_maxpacket"
          ],
          "line": 3145
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2502-2506",
          "snippet": "int\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_proxy_upstream",
          "args": [
            "c",
            "type",
            "seq",
            "ssh"
          ],
          "line": 3134
        },
        "resolved": true,
        "details": {
          "function_name": "channel_proxy_upstream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2865-2943",
          "snippet": "int\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_from_packet_id",
          "args": [
            "ssh",
            "__func__",
            "\"open confirmation\""
          ],
          "line": 3130
        },
        "resolved": true,
        "details": {
          "function_name": "channel_from_packet_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2966-2977",
          "snippet": "static Channel *\nchannel_from_packet_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tint id = channel_parse_id(ssh, where, what);\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tssh_packet_disconnect(ssh,\n\t\t    \"%s packet referred to nonexistent channel %d\", what, id);\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic Channel *\nchannel_from_packet_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tint id = channel_parse_id(ssh, where, what);\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tssh_packet_disconnect(ssh,\n\t\t    \"%s packet referred to nonexistent channel %d\", what, id);\n\t}\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_input_open_confirmation(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = channel_from_packet_id(ssh, __func__, \"open confirmation\");\n\tu_int32_t remote_window, remote_maxpacket;\n\tint r;\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tif (c->type != SSH_CHANNEL_OPENING)\n\t\tpacket_disconnect(\"Received open confirmation for \"\n\t\t    \"non-opening channel %d.\", c->self);\n\t/*\n\t * Record the remote channel number and mark that the channel\n\t * is now open.\n\t */\n\tif ((r = sshpkt_get_u32(ssh, &c->remote_id)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &remote_window)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &remote_maxpacket)) != 0) {\n\t\terror(\"%s: window/maxpacket: %s\", __func__, ssh_err(r));\n\t\tpacket_disconnect(\"Invalid open confirmation message\");\n\t}\n\tssh_packet_check_eom(ssh);\n\n\tc->have_remote_id = 1;\n\tc->remote_window = remote_window;\n\tc->remote_maxpacket = remote_maxpacket;\n\tc->type = SSH_CHANNEL_OPEN;\n\tif (c->open_confirm) {\n\t\tdebug2(\"%s: channel %d: callback start\", __func__, c->self);\n\t\tc->open_confirm(ssh, c->self, 1, c->open_confirm_ctx);\n\t\tdebug2(\"%s: channel %d: callback done\", __func__, c->self);\n\t}\n\tdebug2(\"channel %d: open confirm rwindow %u rmax %u\", c->self,\n\t    c->remote_window, c->remote_maxpacket);\n\treturn 0;\n}"
  },
  {
    "function_name": "channel_input_oclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3115-3125",
    "snippet": "int\nchannel_input_oclose(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = channel_from_packet_id(ssh, __func__, \"oclose\");\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tssh_packet_check_eom(ssh);\n\tchan_rcvd_oclose(ssh, c);\n\treturn 0;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "chan_rcvd_oclose",
          "args": [
            "ssh",
            "c"
          ],
          "line": 3123
        },
        "resolved": true,
        "details": {
          "function_name": "chan_rcvd_oclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "265-303",
          "snippet": "void\nchan_rcvd_oclose(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: rcvd close\", c->self);\n\tif (!(c->flags & CHAN_LOCAL)) {\n\t\tif (c->flags & CHAN_CLOSE_RCVD)\n\t\t\terror(\"channel %d: protocol error: close rcvd twice\",\n\t\t\t    c->self);\n\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t}\n\tif (c->type == SSH_CHANNEL_LARVAL) {\n\t\t/* tear down larval channels immediately */\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\treturn;\n\t}\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\t\t/*\n\t\t * wait until a data from the channel is consumed if a CLOSE\n\t\t * is received\n\t\t */\n\t\tchan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);\n\t\tbreak;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_shutdown_extended_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & CHAN_LOCAL))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_shutdown_extended_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_rcvd_oclose(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: rcvd close\", c->self);\n\tif (!(c->flags & CHAN_LOCAL)) {\n\t\tif (c->flags & CHAN_CLOSE_RCVD)\n\t\t\terror(\"channel %d: protocol error: close rcvd twice\",\n\t\t\t    c->self);\n\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t}\n\tif (c->type == SSH_CHANNEL_LARVAL) {\n\t\t/* tear down larval channels immediately */\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\treturn;\n\t}\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\t\t/*\n\t\t * wait until a data from the channel is consumed if a CLOSE\n\t\t * is received\n\t\t */\n\t\tchan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);\n\t\tbreak;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_shutdown_extended_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & CHAN_LOCAL))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_shutdown_extended_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_check_eom",
          "args": [
            "ssh"
          ],
          "line": 3122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_proxy_upstream",
          "args": [
            "c",
            "type",
            "seq",
            "ssh"
          ],
          "line": 3120
        },
        "resolved": true,
        "details": {
          "function_name": "channel_proxy_upstream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2865-2943",
          "snippet": "int\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_from_packet_id",
          "args": [
            "ssh",
            "__func__",
            "\"oclose\""
          ],
          "line": 3118
        },
        "resolved": true,
        "details": {
          "function_name": "channel_from_packet_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2966-2977",
          "snippet": "static Channel *\nchannel_from_packet_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tint id = channel_parse_id(ssh, where, what);\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tssh_packet_disconnect(ssh,\n\t\t    \"%s packet referred to nonexistent channel %d\", what, id);\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic Channel *\nchannel_from_packet_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tint id = channel_parse_id(ssh, where, what);\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tssh_packet_disconnect(ssh,\n\t\t    \"%s packet referred to nonexistent channel %d\", what, id);\n\t}\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_input_oclose(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = channel_from_packet_id(ssh, __func__, \"oclose\");\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tssh_packet_check_eom(ssh);\n\tchan_rcvd_oclose(ssh, c);\n\treturn 0;\n}"
  },
  {
    "function_name": "channel_input_ieof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3094-3113",
    "snippet": "int\nchannel_input_ieof(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = channel_from_packet_id(ssh, __func__, \"ieof\");\n\n\tssh_packet_check_eom(ssh);\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tchan_rcvd_ieof(ssh, c);\n\n\t/* XXX force input close */\n\tif (c->force_drain && c->istate == CHAN_INPUT_OPEN) {\n\t\tdebug(\"channel %d: FORCE input drain\", c->self);\n\t\tc->istate = CHAN_INPUT_WAIT_DRAIN;\n\t\tif (sshbuf_len(c->input) == 0)\n\t\t\tchan_ibuf_empty(ssh, c);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "chan_ibuf_empty",
          "args": [
            "ssh",
            "c"
          ],
          "line": 3110
        },
        "resolved": true,
        "details": {
          "function_name": "chan_ibuf_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "124-144",
          "snippet": "void\nchan_ibuf_empty(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: ibuf empty\", c->self);\n\tif (sshbuf_len(c->input)) {\n\t\terror(\"channel %d: chan_ibuf_empty for non empty buffer\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & (CHAN_CLOSE_SENT|CHAN_LOCAL)))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_ibuf_empty for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_ibuf_empty(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: ibuf empty\", c->self);\n\tif (sshbuf_len(c->input)) {\n\t\terror(\"channel %d: chan_ibuf_empty for non empty buffer\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & (CHAN_CLOSE_SENT|CHAN_LOCAL)))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_ibuf_empty for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "c->input"
          ],
          "line": 3109
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"channel %d: FORCE input drain\"",
            "c->self"
          ],
          "line": 3107
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_rcvd_ieof",
          "args": [
            "ssh",
            "c"
          ],
          "line": 3103
        },
        "resolved": true,
        "details": {
          "function_name": "chan_rcvd_ieof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "252-263",
          "snippet": "void\nchan_rcvd_ieof(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: rcvd eof\", c->self);\n\tc->flags |= CHAN_EOF_RCVD;\n\tif (c->ostate == CHAN_OUTPUT_OPEN)\n\t\tchan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);\n\tif (c->ostate == CHAN_OUTPUT_WAIT_DRAIN &&\n\t    sshbuf_len(c->output) == 0 &&\n\t    !CHANNEL_EFD_OUTPUT_ACTIVE(c))\n\t\tchan_obuf_empty(ssh, c);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_rcvd_ieof(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: rcvd eof\", c->self);\n\tc->flags |= CHAN_EOF_RCVD;\n\tif (c->ostate == CHAN_OUTPUT_OPEN)\n\t\tchan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);\n\tif (c->ostate == CHAN_OUTPUT_WAIT_DRAIN &&\n\t    sshbuf_len(c->output) == 0 &&\n\t    !CHANNEL_EFD_OUTPUT_ACTIVE(c))\n\t\tchan_obuf_empty(ssh, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_proxy_upstream",
          "args": [
            "c",
            "type",
            "seq",
            "ssh"
          ],
          "line": 3101
        },
        "resolved": true,
        "details": {
          "function_name": "channel_proxy_upstream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2865-2943",
          "snippet": "int\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_check_eom",
          "args": [
            "ssh"
          ],
          "line": 3099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_from_packet_id",
          "args": [
            "ssh",
            "__func__",
            "\"ieof\""
          ],
          "line": 3097
        },
        "resolved": true,
        "details": {
          "function_name": "channel_from_packet_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2966-2977",
          "snippet": "static Channel *\nchannel_from_packet_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tint id = channel_parse_id(ssh, where, what);\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tssh_packet_disconnect(ssh,\n\t\t    \"%s packet referred to nonexistent channel %d\", what, id);\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic Channel *\nchannel_from_packet_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tint id = channel_parse_id(ssh, where, what);\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tssh_packet_disconnect(ssh,\n\t\t    \"%s packet referred to nonexistent channel %d\", what, id);\n\t}\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_input_ieof(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = channel_from_packet_id(ssh, __func__, \"ieof\");\n\n\tssh_packet_check_eom(ssh);\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tchan_rcvd_ieof(ssh, c);\n\n\t/* XXX force input close */\n\tif (c->force_drain && c->istate == CHAN_INPUT_OPEN) {\n\t\tdebug(\"channel %d: FORCE input drain\", c->self);\n\t\tc->istate = CHAN_INPUT_WAIT_DRAIN;\n\t\tif (sshbuf_len(c->input) == 0)\n\t\t\tchan_ibuf_empty(ssh, c);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "channel_input_extended_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "3041-3092",
    "snippet": "int\nchannel_input_extended_data(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tconst u_char *data;\n\tsize_t data_len;\n\tu_int32_t tcode;\n\tChannel *c = channel_from_packet_id(ssh, __func__, \"extended data\");\n\tint r;\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tif (c->type != SSH_CHANNEL_OPEN) {\n\t\tlogit(\"channel %d: ext data for non open\", c->self);\n\t\treturn 0;\n\t}\n\tif (c->flags & CHAN_EOF_RCVD) {\n\t\tif (datafellows & SSH_BUG_EXTEOF)\n\t\t\tdebug(\"channel %d: accepting ext data after eof\",\n\t\t\t    c->self);\n\t\telse\n\t\t\tssh_packet_disconnect(ssh, \"Received extended_data \"\n\t\t\t    \"after EOF on channel %d.\", c->self);\n\t}\n\n\tif ((r = sshpkt_get_u32(ssh, &tcode)) != 0) {\n\t\terror(\"%s: parse tcode: %s\", __func__, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid extended_data message\");\n\t}\n\tif (c->efd == -1 ||\n\t    c->extended_usage != CHAN_EXTENDED_WRITE ||\n\t    tcode != SSH2_EXTENDED_DATA_STDERR) {\n\t\tlogit(\"channel %d: bad ext data\", c->self);\n\t\treturn 0;\n\t}\n\tif ((r = sshpkt_get_string_direct(ssh, &data, &data_len)) != 0) {\n\t\terror(\"%s: parse data: %s\", __func__, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid extended_data message\");\n\t}\n\tssh_packet_check_eom(ssh);\n\n\tif (data_len > c->local_window) {\n\t\tlogit(\"channel %d: rcvd too much extended_data %zu, win %u\",\n\t\t    c->self, data_len, c->local_window);\n\t\treturn 0;\n\t}\n\tdebug2(\"channel %d: rcvd ext data %zu\", c->self, data_len);\n\t/* XXX sshpkt_getb? */\n\tif ((r = sshbuf_put(c->extended, data, data_len)) != 0)\n\t\terror(\"%s: append: %s\", __func__, ssh_err(r));\n\tc->local_window -= data_len;\n\treturn 0;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: append: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 3089
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 3089
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "c->extended",
            "data",
            "data_len"
          ],
          "line": 3088
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: rcvd ext data %zu\"",
            "c->self",
            "data_len"
          ],
          "line": 3086
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"channel %d: rcvd too much extended_data %zu, win %u\"",
            "c->self",
            "data_len",
            "c->local_window"
          ],
          "line": 3082
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_check_eom",
          "args": [
            "ssh"
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_packet_disconnect",
          "args": [
            "ssh",
            "\"Invalid extended_data message\""
          ],
          "line": 3077
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "1859-1896",
          "snippet": "void\nssh_packet_disconnect(struct ssh *ssh, const char *fmt,...)\n{\n\tchar buf[1024], remote_id[512];\n\tva_list args;\n\tstatic int disconnecting = 0;\n\tint r;\n\n\tif (disconnecting)\t/* Guard against recursive invocations. */\n\t\tfatal(\"packet_disconnect called recursively.\");\n\tdisconnecting = 1;\n\n\t/*\n\t * Format the message.  Note that the caller must make sure the\n\t * message is of limited size.\n\t */\n\tsshpkt_fmt_connection_id(ssh, remote_id, sizeof(remote_id));\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\t/* Display the error locally */\n\tlogit(\"Disconnecting %s: %.100s\", remote_id, buf);\n\n\t/*\n\t * Send the disconnect message to the other side, and wait\n\t * for it to get sent.\n\t */\n\tif ((r = sshpkt_disconnect(ssh, \"%s\", buf)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n\n\tif ((r = ssh_packet_write_wait(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n\n\t/* Close the connection. */\n\tssh_packet_close(ssh);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_packet_disconnect(struct ssh *ssh, const char *fmt,...)\n{\n\tchar buf[1024], remote_id[512];\n\tva_list args;\n\tstatic int disconnecting = 0;\n\tint r;\n\n\tif (disconnecting)\t/* Guard against recursive invocations. */\n\t\tfatal(\"packet_disconnect called recursively.\");\n\tdisconnecting = 1;\n\n\t/*\n\t * Format the message.  Note that the caller must make sure the\n\t * message is of limited size.\n\t */\n\tsshpkt_fmt_connection_id(ssh, remote_id, sizeof(remote_id));\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\t/* Display the error locally */\n\tlogit(\"Disconnecting %s: %.100s\", remote_id, buf);\n\n\t/*\n\t * Send the disconnect message to the other side, and wait\n\t * for it to get sent.\n\t */\n\tif ((r = sshpkt_disconnect(ssh, \"%s\", buf)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n\n\tif ((r = ssh_packet_write_wait(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n\n\t/* Close the connection. */\n\tssh_packet_close(ssh);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_string_direct",
          "args": [
            "ssh",
            "&data",
            "&data_len"
          ],
          "line": 3075
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2520-2524",
          "snippet": "int\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_u32",
          "args": [
            "ssh",
            "&tcode"
          ],
          "line": 3065
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2502-2506",
          "snippet": "int\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"channel %d: accepting ext data after eof\"",
            "c->self"
          ],
          "line": 3058
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_proxy_upstream",
          "args": [
            "c",
            "type",
            "seq",
            "ssh"
          ],
          "line": 3050
        },
        "resolved": true,
        "details": {
          "function_name": "channel_proxy_upstream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2865-2943",
          "snippet": "int\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_from_packet_id",
          "args": [
            "ssh",
            "__func__",
            "\"extended data\""
          ],
          "line": 3047
        },
        "resolved": true,
        "details": {
          "function_name": "channel_from_packet_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2966-2977",
          "snippet": "static Channel *\nchannel_from_packet_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tint id = channel_parse_id(ssh, where, what);\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tssh_packet_disconnect(ssh,\n\t\t    \"%s packet referred to nonexistent channel %d\", what, id);\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic Channel *\nchannel_from_packet_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tint id = channel_parse_id(ssh, where, what);\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tssh_packet_disconnect(ssh,\n\t\t    \"%s packet referred to nonexistent channel %d\", what, id);\n\t}\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_input_extended_data(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tconst u_char *data;\n\tsize_t data_len;\n\tu_int32_t tcode;\n\tChannel *c = channel_from_packet_id(ssh, __func__, \"extended data\");\n\tint r;\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tif (c->type != SSH_CHANNEL_OPEN) {\n\t\tlogit(\"channel %d: ext data for non open\", c->self);\n\t\treturn 0;\n\t}\n\tif (c->flags & CHAN_EOF_RCVD) {\n\t\tif (datafellows & SSH_BUG_EXTEOF)\n\t\t\tdebug(\"channel %d: accepting ext data after eof\",\n\t\t\t    c->self);\n\t\telse\n\t\t\tssh_packet_disconnect(ssh, \"Received extended_data \"\n\t\t\t    \"after EOF on channel %d.\", c->self);\n\t}\n\n\tif ((r = sshpkt_get_u32(ssh, &tcode)) != 0) {\n\t\terror(\"%s: parse tcode: %s\", __func__, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid extended_data message\");\n\t}\n\tif (c->efd == -1 ||\n\t    c->extended_usage != CHAN_EXTENDED_WRITE ||\n\t    tcode != SSH2_EXTENDED_DATA_STDERR) {\n\t\tlogit(\"channel %d: bad ext data\", c->self);\n\t\treturn 0;\n\t}\n\tif ((r = sshpkt_get_string_direct(ssh, &data, &data_len)) != 0) {\n\t\terror(\"%s: parse data: %s\", __func__, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid extended_data message\");\n\t}\n\tssh_packet_check_eom(ssh);\n\n\tif (data_len > c->local_window) {\n\t\tlogit(\"channel %d: rcvd too much extended_data %zu, win %u\",\n\t\t    c->self, data_len, c->local_window);\n\t\treturn 0;\n\t}\n\tdebug2(\"channel %d: rcvd ext data %zu\", c->self, data_len);\n\t/* XXX sshpkt_getb? */\n\tif ((r = sshbuf_put(c->extended, data, data_len)) != 0)\n\t\terror(\"%s: append: %s\", __func__, ssh_err(r));\n\tc->local_window -= data_len;\n\treturn 0;\n}"
  },
  {
    "function_name": "channel_input_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2979-3039",
    "snippet": "int\nchannel_input_data(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tconst u_char *data;\n\tsize_t data_len, win_len;\n\tChannel *c = channel_from_packet_id(ssh, __func__, \"data\");\n\tint r;\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\n\t/* Ignore any data for non-open channels (might happen on close) */\n\tif (c->type != SSH_CHANNEL_OPEN &&\n\t    c->type != SSH_CHANNEL_RDYNAMIC_OPEN &&\n\t    c->type != SSH_CHANNEL_RDYNAMIC_FINISH &&\n\t    c->type != SSH_CHANNEL_X11_OPEN)\n\t\treturn 0;\n\n\t/* Get the data. */\n\tif ((r = sshpkt_get_string_direct(ssh, &data, &data_len)) != 0)\n\t\tfatal(\"%s: channel %d: get data: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\tssh_packet_check_eom(ssh);\n\n\twin_len = data_len;\n\tif (c->datagram)\n\t\twin_len += 4;  /* string length header */\n\n\t/*\n\t * The sending side reduces its window as it sends data, so we\n\t * must 'fake' consumption of the data in order to ensure that window\n\t * updates are sent back. Otherwise the connection might deadlock.\n\t */\n\tif (c->ostate != CHAN_OUTPUT_OPEN) {\n\t\tc->local_window -= win_len;\n\t\tc->local_consumed += win_len;\n\t\treturn 0;\n\t}\n\n\tif (win_len > c->local_maxpacket) {\n\t\tlogit(\"channel %d: rcvd big packet %zu, maxpack %u\",\n\t\t    c->self, win_len, c->local_maxpacket);\n\t\treturn 0;\n\t}\n\tif (win_len > c->local_window) {\n\t\tlogit(\"channel %d: rcvd too much data %zu, win %u\",\n\t\t    c->self, win_len, c->local_window);\n\t\treturn 0;\n\t}\n\tc->local_window -= win_len;\n\n\tif (c->datagram) {\n\t\tif ((r = sshbuf_put_string(c->output, data, data_len)) != 0)\n\t\t\tfatal(\"%s: channel %d: append datagram: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t} else if ((r = sshbuf_put(c->output, data, data_len)) != 0)\n\t\tfatal(\"%s: channel %d: append data: %s\",\n\t\t    __func__, c->self, ssh_err(r));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %d: append data: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 3035
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 3036
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "c->output",
            "data",
            "data_len"
          ],
          "line": 3034
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "c->output",
            "data",
            "data_len"
          ],
          "line": 3031
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"channel %d: rcvd too much data %zu, win %u\"",
            "c->self",
            "win_len",
            "c->local_window"
          ],
          "line": 3024
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_check_eom",
          "args": [
            "ssh"
          ],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshpkt_get_string_direct",
          "args": [
            "ssh",
            "&data",
            "&data_len"
          ],
          "line": 2998
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2520-2524",
          "snippet": "int\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_proxy_upstream",
          "args": [
            "c",
            "type",
            "seq",
            "ssh"
          ],
          "line": 2987
        },
        "resolved": true,
        "details": {
          "function_name": "channel_proxy_upstream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2865-2943",
          "snippet": "int\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_from_packet_id",
          "args": [
            "ssh",
            "__func__",
            "\"data\""
          ],
          "line": 2984
        },
        "resolved": true,
        "details": {
          "function_name": "channel_from_packet_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2966-2977",
          "snippet": "static Channel *\nchannel_from_packet_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tint id = channel_parse_id(ssh, where, what);\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tssh_packet_disconnect(ssh,\n\t\t    \"%s packet referred to nonexistent channel %d\", what, id);\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic Channel *\nchannel_from_packet_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tint id = channel_parse_id(ssh, where, what);\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tssh_packet_disconnect(ssh,\n\t\t    \"%s packet referred to nonexistent channel %d\", what, id);\n\t}\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_input_data(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tconst u_char *data;\n\tsize_t data_len, win_len;\n\tChannel *c = channel_from_packet_id(ssh, __func__, \"data\");\n\tint r;\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\n\t/* Ignore any data for non-open channels (might happen on close) */\n\tif (c->type != SSH_CHANNEL_OPEN &&\n\t    c->type != SSH_CHANNEL_RDYNAMIC_OPEN &&\n\t    c->type != SSH_CHANNEL_RDYNAMIC_FINISH &&\n\t    c->type != SSH_CHANNEL_X11_OPEN)\n\t\treturn 0;\n\n\t/* Get the data. */\n\tif ((r = sshpkt_get_string_direct(ssh, &data, &data_len)) != 0)\n\t\tfatal(\"%s: channel %d: get data: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\tssh_packet_check_eom(ssh);\n\n\twin_len = data_len;\n\tif (c->datagram)\n\t\twin_len += 4;  /* string length header */\n\n\t/*\n\t * The sending side reduces its window as it sends data, so we\n\t * must 'fake' consumption of the data in order to ensure that window\n\t * updates are sent back. Otherwise the connection might deadlock.\n\t */\n\tif (c->ostate != CHAN_OUTPUT_OPEN) {\n\t\tc->local_window -= win_len;\n\t\tc->local_consumed += win_len;\n\t\treturn 0;\n\t}\n\n\tif (win_len > c->local_maxpacket) {\n\t\tlogit(\"channel %d: rcvd big packet %zu, maxpack %u\",\n\t\t    c->self, win_len, c->local_maxpacket);\n\t\treturn 0;\n\t}\n\tif (win_len > c->local_window) {\n\t\tlogit(\"channel %d: rcvd too much data %zu, win %u\",\n\t\t    c->self, win_len, c->local_window);\n\t\treturn 0;\n\t}\n\tc->local_window -= win_len;\n\n\tif (c->datagram) {\n\t\tif ((r = sshbuf_put_string(c->output, data, data_len)) != 0)\n\t\t\tfatal(\"%s: channel %d: append datagram: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t} else if ((r = sshbuf_put(c->output, data, data_len)) != 0)\n\t\tfatal(\"%s: channel %d: append data: %s\",\n\t\t    __func__, c->self, ssh_err(r));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "channel_from_packet_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2966-2977",
    "snippet": "static Channel *\nchannel_from_packet_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tint id = channel_parse_id(ssh, where, what);\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tssh_packet_disconnect(ssh,\n\t\t    \"%s packet referred to nonexistent channel %d\", what, id);\n\t}\n\treturn c;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_packet_disconnect",
          "args": [
            "ssh",
            "\"%s packet referred to nonexistent channel %d\"",
            "what",
            "id"
          ],
          "line": 2973
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "1859-1896",
          "snippet": "void\nssh_packet_disconnect(struct ssh *ssh, const char *fmt,...)\n{\n\tchar buf[1024], remote_id[512];\n\tva_list args;\n\tstatic int disconnecting = 0;\n\tint r;\n\n\tif (disconnecting)\t/* Guard against recursive invocations. */\n\t\tfatal(\"packet_disconnect called recursively.\");\n\tdisconnecting = 1;\n\n\t/*\n\t * Format the message.  Note that the caller must make sure the\n\t * message is of limited size.\n\t */\n\tsshpkt_fmt_connection_id(ssh, remote_id, sizeof(remote_id));\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\t/* Display the error locally */\n\tlogit(\"Disconnecting %s: %.100s\", remote_id, buf);\n\n\t/*\n\t * Send the disconnect message to the other side, and wait\n\t * for it to get sent.\n\t */\n\tif ((r = sshpkt_disconnect(ssh, \"%s\", buf)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n\n\tif ((r = ssh_packet_write_wait(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n\n\t/* Close the connection. */\n\tssh_packet_close(ssh);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_packet_disconnect(struct ssh *ssh, const char *fmt,...)\n{\n\tchar buf[1024], remote_id[512];\n\tva_list args;\n\tstatic int disconnecting = 0;\n\tint r;\n\n\tif (disconnecting)\t/* Guard against recursive invocations. */\n\t\tfatal(\"packet_disconnect called recursively.\");\n\tdisconnecting = 1;\n\n\t/*\n\t * Format the message.  Note that the caller must make sure the\n\t * message is of limited size.\n\t */\n\tsshpkt_fmt_connection_id(ssh, remote_id, sizeof(remote_id));\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\t/* Display the error locally */\n\tlogit(\"Disconnecting %s: %.100s\", remote_id, buf);\n\n\t/*\n\t * Send the disconnect message to the other side, and wait\n\t * for it to get sent.\n\t */\n\tif ((r = sshpkt_disconnect(ssh, \"%s\", buf)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n\n\tif ((r = ssh_packet_write_wait(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n\n\t/* Close the connection. */\n\tssh_packet_close(ssh);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_lookup",
          "args": [
            "ssh",
            "id"
          ],
          "line": 2972
        },
        "resolved": true,
        "details": {
          "function_name": "channel_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "279-302",
          "snippet": "Channel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_parse_id",
          "args": [
            "ssh",
            "where",
            "what"
          ],
          "line": 2969
        },
        "resolved": true,
        "details": {
          "function_name": "channel_parse_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2948-2963",
          "snippet": "static int\nchannel_parse_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tu_int32_t id;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, &id)) != 0) {\n\t\terror(\"%s: parse id: %s\", where, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid %s message\", what);\n\t}\n\tif (id > INT_MAX) {\n\t\terror(\"%s: bad channel id %u: %s\", where, id, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid %s channel id\", what);\n\t}\n\treturn (int)id;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nstatic int\nchannel_parse_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tu_int32_t id;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, &id)) != 0) {\n\t\terror(\"%s: parse id: %s\", where, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid %s message\", what);\n\t}\n\tif (id > INT_MAX) {\n\t\terror(\"%s: bad channel id %u: %s\", where, id, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid %s channel id\", what);\n\t}\n\treturn (int)id;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic Channel *\nchannel_from_packet_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tint id = channel_parse_id(ssh, where, what);\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tssh_packet_disconnect(ssh,\n\t\t    \"%s packet referred to nonexistent channel %d\", what, id);\n\t}\n\treturn c;\n}"
  },
  {
    "function_name": "channel_parse_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2948-2963",
    "snippet": "static int\nchannel_parse_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tu_int32_t id;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, &id)) != 0) {\n\t\terror(\"%s: parse id: %s\", where, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid %s message\", what);\n\t}\n\tif (id > INT_MAX) {\n\t\terror(\"%s: bad channel id %u: %s\", where, id, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid %s channel id\", what);\n\t}\n\treturn (int)id;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_packet_disconnect",
          "args": [
            "ssh",
            "\"Invalid %s channel id\"",
            "what"
          ],
          "line": 2960
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "1859-1896",
          "snippet": "void\nssh_packet_disconnect(struct ssh *ssh, const char *fmt,...)\n{\n\tchar buf[1024], remote_id[512];\n\tva_list args;\n\tstatic int disconnecting = 0;\n\tint r;\n\n\tif (disconnecting)\t/* Guard against recursive invocations. */\n\t\tfatal(\"packet_disconnect called recursively.\");\n\tdisconnecting = 1;\n\n\t/*\n\t * Format the message.  Note that the caller must make sure the\n\t * message is of limited size.\n\t */\n\tsshpkt_fmt_connection_id(ssh, remote_id, sizeof(remote_id));\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\t/* Display the error locally */\n\tlogit(\"Disconnecting %s: %.100s\", remote_id, buf);\n\n\t/*\n\t * Send the disconnect message to the other side, and wait\n\t * for it to get sent.\n\t */\n\tif ((r = sshpkt_disconnect(ssh, \"%s\", buf)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n\n\tif ((r = ssh_packet_write_wait(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n\n\t/* Close the connection. */\n\tssh_packet_close(ssh);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_packet_disconnect(struct ssh *ssh, const char *fmt,...)\n{\n\tchar buf[1024], remote_id[512];\n\tva_list args;\n\tstatic int disconnecting = 0;\n\tint r;\n\n\tif (disconnecting)\t/* Guard against recursive invocations. */\n\t\tfatal(\"packet_disconnect called recursively.\");\n\tdisconnecting = 1;\n\n\t/*\n\t * Format the message.  Note that the caller must make sure the\n\t * message is of limited size.\n\t */\n\tsshpkt_fmt_connection_id(ssh, remote_id, sizeof(remote_id));\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\t/* Display the error locally */\n\tlogit(\"Disconnecting %s: %.100s\", remote_id, buf);\n\n\t/*\n\t * Send the disconnect message to the other side, and wait\n\t * for it to get sent.\n\t */\n\tif ((r = sshpkt_disconnect(ssh, \"%s\", buf)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n\n\tif ((r = ssh_packet_write_wait(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n\n\t/* Close the connection. */\n\tssh_packet_close(ssh);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: bad channel id %u: %s\"",
            "where",
            "id",
            "ssh_err(r)"
          ],
          "line": 2959
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2959
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_u32",
          "args": [
            "ssh",
            "&id"
          ],
          "line": 2954
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2502-2506",
          "snippet": "int\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nstatic int\nchannel_parse_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tu_int32_t id;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, &id)) != 0) {\n\t\terror(\"%s: parse id: %s\", where, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid %s message\", what);\n\t}\n\tif (id > INT_MAX) {\n\t\terror(\"%s: bad channel id %u: %s\", where, id, ssh_err(r));\n\t\tssh_packet_disconnect(ssh, \"Invalid %s channel id\", what);\n\t}\n\treturn (int)id;\n}"
  },
  {
    "function_name": "channel_proxy_upstream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2865-2943",
    "snippet": "int\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 2941
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_free",
          "args": [
            "ssh",
            "c"
          ],
          "line": 2936
        },
        "resolved": true,
        "details": {
          "function_name": "channel_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "582-640",
          "snippet": "void\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PEEK_U32",
          "args": [
            "cp"
          ],
          "line": 2930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: channel %u: up->down: type %u\"",
            "__func__",
            "c->self",
            "type"
          ],
          "line": 2922
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_log_type",
          "args": [
            "type"
          ],
          "line": 2921
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_log_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "1010-1021",
          "snippet": "int\nssh_packet_log_type(u_char type)\n{\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_log_type(u_char type)\n{\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: compose for muxclient %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 2917
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2917
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "downstream->output",
            "b"
          ],
          "line": 2916
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "b",
            "cp",
            "len"
          ],
          "line": 2915
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "b",
            "c->mux_downstream_id"
          ],
          "line": 2914
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "b",
            "type"
          ],
          "line": 2913
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_ptr",
          "args": [
            "ssh",
            "&len"
          ],
          "line": 2906
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2563-2569",
          "snippet": "const u_char *\nsshpkt_ptr(struct ssh *ssh, size_t *lenp)\n{\n\tif (lenp != NULL)\n\t\t*lenp = sshbuf_len(ssh->state->incoming_packet);\n\treturn sshbuf_ptr(ssh->state->incoming_packet);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshpkt_ptr(struct ssh *ssh, size_t *lenp)\n{\n\tif (lenp != NULL)\n\t\t*lenp = sshbuf_len(ssh->state->incoming_packet);\n\treturn sshbuf_ptr(ssh->state->incoming_packet);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 2901
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: channel %u: unsupported type %u\"",
            "__func__",
            "c->self",
            "type"
          ],
          "line": 2897
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * When receiving packets from the peer we need to check whether we\n\t * need to forward the packets to the mux client. In this case we\n\t * restore the original channel id and keep track of CLOSE messages,\n\t * so we can cleanup the channel.\n\t */\n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"%s: channel %u: unsupported type %u\", __func__,\n\t\t    c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: alloc reply\", __func__);\n\t\tgoto out;\n\t}\n\t/* get remaining payload (after id) */\n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror(\"%s: no packet\", __func__);\n\t\tgoto out;\n\t}\n\t/* translate id and send to muxclient */\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* padlen */\n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror(\"%s: compose for muxclient %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* sshbuf_dump(b, stderr); */\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: up->down: type %u\", __func__, c->self,\n\t\t    type);\n out:\n\t/* update state */\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */\n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}"
  },
  {
    "function_name": "channel_proxy_downstream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2711-2857",
    "snippet": "int\nchannel_proxy_downstream(struct ssh *ssh, Channel *downstream)\n{\n\tChannel *c = NULL;\n\tstruct sshbuf *original = NULL, *modified = NULL;\n\tconst u_char *cp;\n\tchar *ctype = NULL, *listen_host = NULL;\n\tu_char type;\n\tsize_t have;\n\tint ret = -1, r;\n\tu_int id, remote_id, listen_port;\n\n\t/* sshbuf_dump(downstream->input, stderr); */\n\tif ((r = sshbuf_get_string_direct(downstream->input, &cp, &have))\n\t    != 0) {\n\t\terror(\"%s: malformed message: %s\", __func__, ssh_err(r));\n\t\treturn -1;\n\t}\n\tif (have < 2) {\n\t\terror(\"%s: short message\", __func__);\n\t\treturn -1;\n\t}\n\ttype = cp[1];\n\t/* skip padlen + type */\n\tcp += 2;\n\thave -= 2;\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: down->up: type %u\", __func__,\n\t\t    downstream->self, type);\n\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN:\n\t\tif ((original = sshbuf_from(cp, have)) == NULL ||\n\t\t    (modified = sshbuf_new()) == NULL) {\n\t\t\terror(\"%s: alloc\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(original, &ctype, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_u32(original, &id)) != 0) {\n\t\t\terror(\"%s: parse error %s\", __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tc = channel_new(ssh, \"mux proxy\", SSH_CHANNEL_MUX_PROXY,\n\t\t   -1, -1, -1, 0, 0, 0, ctype, 1);\n\t\tc->mux_ctx = downstream;\t/* point to mux client */\n\t\tc->mux_downstream_id = id;\t/* original downstream id */\n\t\tif ((r = sshbuf_put_cstring(modified, ctype)) != 0 ||\n\t\t    (r = sshbuf_put_u32(modified, c->self)) != 0 ||\n\t\t    (r = sshbuf_putb(modified, original)) != 0) {\n\t\t\terror(\"%s: compose error %s\", __func__, ssh_err(r));\n\t\t\tchannel_free(ssh, c);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/*\n\t\t * Almost the same as SSH2_MSG_CHANNEL_OPEN, except then we\n\t\t * need to parse 'remote_id' instead of 'ctype'.\n\t\t */\n\t\tif ((original = sshbuf_from(cp, have)) == NULL ||\n\t\t    (modified = sshbuf_new()) == NULL) {\n\t\t\terror(\"%s: alloc\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_u32(original, &remote_id)) != 0 ||\n\t\t    (r = sshbuf_get_u32(original, &id)) != 0) {\n\t\t\terror(\"%s: parse error %s\", __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tc = channel_new(ssh, \"mux proxy\", SSH_CHANNEL_MUX_PROXY,\n\t\t   -1, -1, -1, 0, 0, 0, \"mux-down-connect\", 1);\n\t\tc->mux_ctx = downstream;\t/* point to mux client */\n\t\tc->mux_downstream_id = id;\n\t\tc->remote_id = remote_id;\n\t\tc->have_remote_id = 1;\n\t\tif ((r = sshbuf_put_u32(modified, remote_id)) != 0 ||\n\t\t    (r = sshbuf_put_u32(modified, c->self)) != 0 ||\n\t\t    (r = sshbuf_putb(modified, original)) != 0) {\n\t\t\terror(\"%s: compose error %s\", __func__, ssh_err(r));\n\t\t\tchannel_free(ssh, c);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_GLOBAL_REQUEST:\n\t\tif ((original = sshbuf_from(cp, have)) == NULL) {\n\t\t\terror(\"%s: alloc\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(original, &ctype, NULL)) != 0) {\n\t\t\terror(\"%s: parse error %s\", __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcmp(ctype, \"tcpip-forward\") != 0) {\n\t\t\terror(\"%s: unsupported request %s\", __func__, ctype);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_u8(original, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_cstring(original, &listen_host, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_u32(original, &listen_port)) != 0) {\n\t\t\terror(\"%s: parse error %s\", __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tif (listen_port > 65535) {\n\t\t\terror(\"%s: tcpip-forward for %s: bad port %u\",\n\t\t\t    __func__, listen_host, listen_port);\n\t\t\tgoto out;\n\t\t}\n\t\t/* Record that connection to this host/port is permitted. */\n\t\tpermission_set_add(ssh, FORWARD_USER, FORWARD_LOCAL, \"<mux>\", -1,\n\t\t    listen_host, NULL, (int)listen_port, downstream);\n\t\tlisten_host = NULL;\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (have < 4)\n\t\t\tbreak;\n\t\tremote_id = PEEK_U32(cp);\n\t\tif ((c = channel_by_remote_id(ssh, remote_id)) != NULL) {\n\t\t\tif (c->flags & CHAN_CLOSE_RCVD)\n\t\t\t\tchannel_free(ssh, c);\n\t\t\telse\n\t\t\t\tc->flags |= CHAN_CLOSE_SENT;\n\t\t}\n\t\tbreak;\n\t}\n\tif (modified) {\n\t\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t\t    (r = sshpkt_putb(ssh, modified)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\terror(\"%s: send %s\", __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t\t    (r = sshpkt_put(ssh, cp, have)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\terror(\"%s: send %s\", __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\n out:\n\tfree(ctype);\n\tfree(listen_host);\n\tsshbuf_free(original);\n\tsshbuf_free(modified);\n\treturn ret;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *channel_rfwd_bind_host(const char *listen_host);",
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "modified"
          ],
          "line": 2855
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "listen_host"
          ],
          "line": 2853
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4195-4206",
          "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: send %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 2846
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2846
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 2845
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put",
          "args": [
            "ssh",
            "cp",
            "have"
          ],
          "line": 2844
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_ec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2473-2477",
          "snippet": "int\nsshpkt_put_ec(struct ssh *ssh, const EC_POINT *v, const EC_GROUP *g)\n{\n\treturn sshbuf_put_ec(ssh->state->outgoing_packet, v, g);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_ec(struct ssh *ssh, const EC_POINT *v, const EC_GROUP *g)\n{\n\treturn sshbuf_put_ec(ssh->state->outgoing_packet, v, g);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "type"
          ],
          "line": 2843
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_putb",
          "args": [
            "ssh",
            "modified"
          ],
          "line": 2837
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_putb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2429-2433",
          "snippet": "int\nsshpkt_putb(struct ssh *ssh, const struct sshbuf *b)\n{\n\treturn sshbuf_putb(ssh->state->outgoing_packet, b);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_putb(struct ssh *ssh, const struct sshbuf *b)\n{\n\treturn sshbuf_putb(ssh->state->outgoing_packet, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_free",
          "args": [
            "ssh",
            "c"
          ],
          "line": 2829
        },
        "resolved": true,
        "details": {
          "function_name": "channel_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "582-640",
          "snippet": "void\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_by_remote_id",
          "args": [
            "ssh",
            "remote_id"
          ],
          "line": 2827
        },
        "resolved": true,
        "details": {
          "function_name": "channel_by_remote_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "261-273",
          "snippet": "Channel *\nchannel_by_remote_id(struct ssh *ssh, u_int remote_id)\n{\n\tChannel *c;\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c != NULL && c->have_remote_id && c->remote_id == remote_id)\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_by_remote_id(struct ssh *ssh, u_int remote_id)\n{\n\tChannel *c;\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c != NULL && c->have_remote_id && c->remote_id == remote_id)\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PEEK_U32",
          "args": [
            "cp"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "permission_set_add",
          "args": [
            "ssh",
            "FORWARD_USER",
            "FORWARD_LOCAL",
            "\"<mux>\"",
            "-1",
            "listen_host",
            "NULL",
            "(int)listen_port",
            "downstream"
          ],
          "line": 2819
        },
        "resolved": true,
        "details": {
          "function_name": "permission_set_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "522-547",
          "snippet": "static int\npermission_set_add(struct ssh *ssh, int who, int where,\n    const char *host_to_connect, int port_to_connect,\n    const char *listen_host, const char *listen_path, int listen_port,\n    Channel *downstream)\n{\n\tstruct permission **permp;\n\tu_int n, *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\n\tif (*npermp >= INT_MAX)\n\t\tfatal(\"%s: %s overflow\", __func__, fwd_ident(who, where));\n\n\t*permp = xrecallocarray(*permp, *npermp, *npermp + 1, sizeof(**permp));\n\tn = (*npermp)++;\n#define MAYBE_DUP(s) ((s == NULL) ? NULL : xstrdup(s))\n\t(*permp)[n].host_to_connect = MAYBE_DUP(host_to_connect);\n\t(*permp)[n].port_to_connect = port_to_connect;\n\t(*permp)[n].listen_host = MAYBE_DUP(listen_host);\n\t(*permp)[n].listen_path = MAYBE_DUP(listen_path);\n\t(*permp)[n].listen_port = listen_port;\n\t(*permp)[n].downstream = downstream;\n#undef MAYBE_DUP\n\treturn (int)n;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\npermission_set_add(struct ssh *ssh, int who, int where,\n    const char *host_to_connect, int port_to_connect,\n    const char *listen_host, const char *listen_path, int listen_port,\n    Channel *downstream)\n{\n\tstruct permission **permp;\n\tu_int n, *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\n\tif (*npermp >= INT_MAX)\n\t\tfatal(\"%s: %s overflow\", __func__, fwd_ident(who, where));\n\n\t*permp = xrecallocarray(*permp, *npermp, *npermp + 1, sizeof(**permp));\n\tn = (*npermp)++;\n#define MAYBE_DUP(s) ((s == NULL) ? NULL : xstrdup(s))\n\t(*permp)[n].host_to_connect = MAYBE_DUP(host_to_connect);\n\t(*permp)[n].port_to_connect = port_to_connect;\n\t(*permp)[n].listen_host = MAYBE_DUP(listen_host);\n\t(*permp)[n].listen_path = MAYBE_DUP(listen_path);\n\t(*permp)[n].listen_port = listen_port;\n\t(*permp)[n].downstream = downstream;\n#undef MAYBE_DUP\n\treturn (int)n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "original",
            "&listen_port"
          ],
          "line": 2809
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "original",
            "&listen_host",
            "NULL"
          ],
          "line": 2808
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "original",
            "NULL"
          ],
          "line": 2807
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ctype",
            "\"tcpip-forward\""
          ],
          "line": 2803
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_from",
          "args": [
            "cp",
            "have"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_from",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "87-102",
          "snippet": "struct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_putb",
          "args": [
            "modified",
            "original"
          ],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "248-252",
          "snippet": "int\nsshbuf_putb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "modified",
            "c->self"
          ],
          "line": 2787
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "\"mux proxy\"",
            "SSH_CHANNEL_MUX_PROXY",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "\"mux-down-connect\"",
            "1"
          ],
          "line": 2780
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 2771
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "modified",
            "ctype"
          ],
          "line": 2757
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: channel %u: down->up: type %u\"",
            "__func__",
            "downstream->self",
            "type"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_log_type",
          "args": [
            "type"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_log_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "1010-1021",
          "snippet": "int\nssh_packet_log_type(u_char type)\n{\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_log_type(u_char type)\n{\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string_direct",
          "args": [
            "downstream->input",
            "&cp",
            "&have"
          ],
          "line": 2724
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_proxy_downstream(struct ssh *ssh, Channel *downstream)\n{\n\tChannel *c = NULL;\n\tstruct sshbuf *original = NULL, *modified = NULL;\n\tconst u_char *cp;\n\tchar *ctype = NULL, *listen_host = NULL;\n\tu_char type;\n\tsize_t have;\n\tint ret = -1, r;\n\tu_int id, remote_id, listen_port;\n\n\t/* sshbuf_dump(downstream->input, stderr); */\n\tif ((r = sshbuf_get_string_direct(downstream->input, &cp, &have))\n\t    != 0) {\n\t\terror(\"%s: malformed message: %s\", __func__, ssh_err(r));\n\t\treturn -1;\n\t}\n\tif (have < 2) {\n\t\terror(\"%s: short message\", __func__);\n\t\treturn -1;\n\t}\n\ttype = cp[1];\n\t/* skip padlen + type */\n\tcp += 2;\n\thave -= 2;\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"%s: channel %u: down->up: type %u\", __func__,\n\t\t    downstream->self, type);\n\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN:\n\t\tif ((original = sshbuf_from(cp, have)) == NULL ||\n\t\t    (modified = sshbuf_new()) == NULL) {\n\t\t\terror(\"%s: alloc\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(original, &ctype, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_u32(original, &id)) != 0) {\n\t\t\terror(\"%s: parse error %s\", __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tc = channel_new(ssh, \"mux proxy\", SSH_CHANNEL_MUX_PROXY,\n\t\t   -1, -1, -1, 0, 0, 0, ctype, 1);\n\t\tc->mux_ctx = downstream;\t/* point to mux client */\n\t\tc->mux_downstream_id = id;\t/* original downstream id */\n\t\tif ((r = sshbuf_put_cstring(modified, ctype)) != 0 ||\n\t\t    (r = sshbuf_put_u32(modified, c->self)) != 0 ||\n\t\t    (r = sshbuf_putb(modified, original)) != 0) {\n\t\t\terror(\"%s: compose error %s\", __func__, ssh_err(r));\n\t\t\tchannel_free(ssh, c);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t/*\n\t\t * Almost the same as SSH2_MSG_CHANNEL_OPEN, except then we\n\t\t * need to parse 'remote_id' instead of 'ctype'.\n\t\t */\n\t\tif ((original = sshbuf_from(cp, have)) == NULL ||\n\t\t    (modified = sshbuf_new()) == NULL) {\n\t\t\terror(\"%s: alloc\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_u32(original, &remote_id)) != 0 ||\n\t\t    (r = sshbuf_get_u32(original, &id)) != 0) {\n\t\t\terror(\"%s: parse error %s\", __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tc = channel_new(ssh, \"mux proxy\", SSH_CHANNEL_MUX_PROXY,\n\t\t   -1, -1, -1, 0, 0, 0, \"mux-down-connect\", 1);\n\t\tc->mux_ctx = downstream;\t/* point to mux client */\n\t\tc->mux_downstream_id = id;\n\t\tc->remote_id = remote_id;\n\t\tc->have_remote_id = 1;\n\t\tif ((r = sshbuf_put_u32(modified, remote_id)) != 0 ||\n\t\t    (r = sshbuf_put_u32(modified, c->self)) != 0 ||\n\t\t    (r = sshbuf_putb(modified, original)) != 0) {\n\t\t\terror(\"%s: compose error %s\", __func__, ssh_err(r));\n\t\t\tchannel_free(ssh, c);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_GLOBAL_REQUEST:\n\t\tif ((original = sshbuf_from(cp, have)) == NULL) {\n\t\t\terror(\"%s: alloc\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(original, &ctype, NULL)) != 0) {\n\t\t\terror(\"%s: parse error %s\", __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcmp(ctype, \"tcpip-forward\") != 0) {\n\t\t\terror(\"%s: unsupported request %s\", __func__, ctype);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_u8(original, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_cstring(original, &listen_host, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_u32(original, &listen_port)) != 0) {\n\t\t\terror(\"%s: parse error %s\", __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tif (listen_port > 65535) {\n\t\t\terror(\"%s: tcpip-forward for %s: bad port %u\",\n\t\t\t    __func__, listen_host, listen_port);\n\t\t\tgoto out;\n\t\t}\n\t\t/* Record that connection to this host/port is permitted. */\n\t\tpermission_set_add(ssh, FORWARD_USER, FORWARD_LOCAL, \"<mux>\", -1,\n\t\t    listen_host, NULL, (int)listen_port, downstream);\n\t\tlisten_host = NULL;\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (have < 4)\n\t\t\tbreak;\n\t\tremote_id = PEEK_U32(cp);\n\t\tif ((c = channel_by_remote_id(ssh, remote_id)) != NULL) {\n\t\t\tif (c->flags & CHAN_CLOSE_RCVD)\n\t\t\t\tchannel_free(ssh, c);\n\t\t\telse\n\t\t\t\tc->flags |= CHAN_CLOSE_SENT;\n\t\t}\n\t\tbreak;\n\t}\n\tif (modified) {\n\t\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t\t    (r = sshpkt_putb(ssh, modified)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\terror(\"%s: send %s\", __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t\t    (r = sshpkt_put(ssh, cp, have)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\terror(\"%s: send %s\", __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\n out:\n\tfree(ctype);\n\tfree(listen_host);\n\tsshbuf_free(original);\n\tsshbuf_free(modified);\n\treturn ret;\n}"
  },
  {
    "function_name": "channel_output_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2635-2669",
    "snippet": "void\nchannel_output_poll(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tChannel *c;\n\tu_int i;\n\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We are only interested in channels that can have buffered\n\t\t * incoming data.\n\t\t */\n\t\tif (c->type != SSH_CHANNEL_OPEN)\n\t\t\tcontinue;\n\t\tif ((c->flags & (CHAN_CLOSE_SENT|CHAN_CLOSE_RCVD))) {\n\t\t\t/* XXX is this true? */\n\t\t\tdebug3(\"channel %d: will not send data after close\",\n\t\t\t    c->self);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the amount of buffered data for this channel. */\n\t\tif (c->istate == CHAN_INPUT_OPEN ||\n\t\t    c->istate == CHAN_INPUT_WAIT_DRAIN)\n\t\t\tchannel_output_poll_input_open(ssh, c);\n\t\t/* Send extended data, i.e. stderr */\n\t\tif (!(c->flags & CHAN_EOF_SENT) &&\n\t\t    c->extended_usage == CHAN_EXTENDED_READ)\n\t\t\tchannel_output_poll_extended_read(ssh, c);\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_output_poll_extended_read",
          "args": [
            "ssh",
            "c"
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "channel_output_poll_extended_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2600-2632",
          "snippet": "static void\nchannel_output_poll_extended_read(struct ssh *ssh, Channel *c)\n{\n\tsize_t len;\n\tint r;\n\n\tif ((len = sshbuf_len(c->extended)) == 0)\n\t\treturn;\n\n\tdebug2(\"channel %d: rwin %u elen %zu euse %d\", c->self,\n\t    c->remote_window, sshbuf_len(c->extended), c->extended_usage);\n\tif (len > c->remote_window)\n\t\tlen = c->remote_window;\n\tif (len > c->remote_maxpacket)\n\t\tlen = c->remote_maxpacket;\n\tif (len == 0)\n\t\treturn;\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_EXTENDED_DATA)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, SSH2_EXTENDED_DATA_STDERR)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, sshbuf_ptr(c->extended), len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0) {\n\t\tfatal(\"%s: channel %i: data: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tif ((r = sshbuf_consume(c->extended, len)) != 0)\n\t\tfatal(\"%s: channel %i: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\tc->remote_window -= len;\n\tdebug2(\"channel %d: sent ext data %zu\", c->self, len);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_output_poll_extended_read(struct ssh *ssh, Channel *c)\n{\n\tsize_t len;\n\tint r;\n\n\tif ((len = sshbuf_len(c->extended)) == 0)\n\t\treturn;\n\n\tdebug2(\"channel %d: rwin %u elen %zu euse %d\", c->self,\n\t    c->remote_window, sshbuf_len(c->extended), c->extended_usage);\n\tif (len > c->remote_window)\n\t\tlen = c->remote_window;\n\tif (len > c->remote_maxpacket)\n\t\tlen = c->remote_maxpacket;\n\tif (len == 0)\n\t\treturn;\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_EXTENDED_DATA)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, SSH2_EXTENDED_DATA_STDERR)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, sshbuf_ptr(c->extended), len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0) {\n\t\tfatal(\"%s: channel %i: data: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tif ((r = sshbuf_consume(c->extended, len)) != 0)\n\t\tfatal(\"%s: channel %i: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\tc->remote_window -= len;\n\tdebug2(\"channel %d: sent ext data %zu\", c->self, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_output_poll_input_open",
          "args": [
            "ssh",
            "c"
          ],
          "line": 2663
        },
        "resolved": true,
        "details": {
          "function_name": "channel_output_poll_input_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2522-2595",
          "snippet": "static void\nchannel_output_poll_input_open(struct ssh *ssh, Channel *c)\n{\n\tsize_t len, plen;\n\tconst u_char *pkt;\n\tint r;\n\n\tif ((len = sshbuf_len(c->input)) == 0) {\n\t\tif (c->istate == CHAN_INPUT_WAIT_DRAIN) {\n\t\t\t/*\n\t\t\t * input-buffer is empty and read-socket shutdown:\n\t\t\t * tell peer, that we will not send more data:\n\t\t\t * send IEOF.\n\t\t\t * hack for extended data: delay EOF if EFD still\n\t\t\t * in use.\n\t\t\t */\n\t\t\tif (CHANNEL_EFD_INPUT_ACTIVE(c))\n\t\t\t\tdebug2(\"channel %d: \"\n\t\t\t\t    \"ibuf_empty delayed efd %d/(%zu)\",\n\t\t\t\t    c->self, c->efd, sshbuf_len(c->extended));\n\t\t\telse\n\t\t\t\tchan_ibuf_empty(ssh, c);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tif (c->datagram) {\n\t\t/* Check datagram will fit; drop if not */\n\t\tif ((r = sshbuf_get_string_direct(c->input, &pkt, &plen)) != 0)\n\t\t\tfatal(\"%s: channel %d: get datagram: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t/*\n\t\t * XXX this does tail-drop on the datagram queue which is\n\t\t * usually suboptimal compared to head-drop. Better to have\n\t\t * backpressure at read time? (i.e. read + discard)\n\t\t */\n\t\tif (plen > c->remote_window || plen > c->remote_maxpacket) {\n\t\t\tdebug(\"channel %d: datagram too big\", c->self);\n\t\t\treturn;\n\t\t}\n\t\t/* Enqueue it */\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_DATA)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t    (r = sshpkt_put_string(ssh, pkt, plen)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\tfatal(\"%s: channel %i: datagram: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\tc->remote_window -= plen;\n\t\treturn;\n\t}\n\n\t/* Enqueue packet for buffered data. */\n\tif (len > c->remote_window)\n\t\tlen = c->remote_window;\n\tif (len > c->remote_maxpacket)\n\t\tlen = c->remote_maxpacket;\n\tif (len == 0)\n\t\treturn;\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_DATA)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, sshbuf_ptr(c->input), len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0) {\n\t\tfatal(\"%s: channel %i: data: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tif ((r = sshbuf_consume(c->input, len)) != 0)\n\t\tfatal(\"%s: channel %i: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\tc->remote_window -= len;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_output_poll_input_open(struct ssh *ssh, Channel *c)\n{\n\tsize_t len, plen;\n\tconst u_char *pkt;\n\tint r;\n\n\tif ((len = sshbuf_len(c->input)) == 0) {\n\t\tif (c->istate == CHAN_INPUT_WAIT_DRAIN) {\n\t\t\t/*\n\t\t\t * input-buffer is empty and read-socket shutdown:\n\t\t\t * tell peer, that we will not send more data:\n\t\t\t * send IEOF.\n\t\t\t * hack for extended data: delay EOF if EFD still\n\t\t\t * in use.\n\t\t\t */\n\t\t\tif (CHANNEL_EFD_INPUT_ACTIVE(c))\n\t\t\t\tdebug2(\"channel %d: \"\n\t\t\t\t    \"ibuf_empty delayed efd %d/(%zu)\",\n\t\t\t\t    c->self, c->efd, sshbuf_len(c->extended));\n\t\t\telse\n\t\t\t\tchan_ibuf_empty(ssh, c);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tif (c->datagram) {\n\t\t/* Check datagram will fit; drop if not */\n\t\tif ((r = sshbuf_get_string_direct(c->input, &pkt, &plen)) != 0)\n\t\t\tfatal(\"%s: channel %d: get datagram: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t/*\n\t\t * XXX this does tail-drop on the datagram queue which is\n\t\t * usually suboptimal compared to head-drop. Better to have\n\t\t * backpressure at read time? (i.e. read + discard)\n\t\t */\n\t\tif (plen > c->remote_window || plen > c->remote_maxpacket) {\n\t\t\tdebug(\"channel %d: datagram too big\", c->self);\n\t\t\treturn;\n\t\t}\n\t\t/* Enqueue it */\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_DATA)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t    (r = sshpkt_put_string(ssh, pkt, plen)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\tfatal(\"%s: channel %i: datagram: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\tc->remote_window -= plen;\n\t\treturn;\n\t}\n\n\t/* Enqueue packet for buffered data. */\n\tif (len > c->remote_window)\n\t\tlen = c->remote_window;\n\tif (len > c->remote_maxpacket)\n\t\tlen = c->remote_maxpacket;\n\tif (len == 0)\n\t\treturn;\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_DATA)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, sshbuf_ptr(c->input), len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0) {\n\t\tfatal(\"%s: channel %i: data: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tif ((r = sshbuf_consume(c->input, len)) != 0)\n\t\tfatal(\"%s: channel %i: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\tc->remote_window -= len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"channel %d: will not send data after close\"",
            "c->self"
          ],
          "line": 2655
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_output_poll(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tChannel *c;\n\tu_int i;\n\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We are only interested in channels that can have buffered\n\t\t * incoming data.\n\t\t */\n\t\tif (c->type != SSH_CHANNEL_OPEN)\n\t\t\tcontinue;\n\t\tif ((c->flags & (CHAN_CLOSE_SENT|CHAN_CLOSE_RCVD))) {\n\t\t\t/* XXX is this true? */\n\t\t\tdebug3(\"channel %d: will not send data after close\",\n\t\t\t    c->self);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the amount of buffered data for this channel. */\n\t\tif (c->istate == CHAN_INPUT_OPEN ||\n\t\t    c->istate == CHAN_INPUT_WAIT_DRAIN)\n\t\t\tchannel_output_poll_input_open(ssh, c);\n\t\t/* Send extended data, i.e. stderr */\n\t\tif (!(c->flags & CHAN_EOF_SENT) &&\n\t\t    c->extended_usage == CHAN_EXTENDED_READ)\n\t\t\tchannel_output_poll_extended_read(ssh, c);\n\t}\n}"
  },
  {
    "function_name": "channel_output_poll_extended_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2600-2632",
    "snippet": "static void\nchannel_output_poll_extended_read(struct ssh *ssh, Channel *c)\n{\n\tsize_t len;\n\tint r;\n\n\tif ((len = sshbuf_len(c->extended)) == 0)\n\t\treturn;\n\n\tdebug2(\"channel %d: rwin %u elen %zu euse %d\", c->self,\n\t    c->remote_window, sshbuf_len(c->extended), c->extended_usage);\n\tif (len > c->remote_window)\n\t\tlen = c->remote_window;\n\tif (len > c->remote_maxpacket)\n\t\tlen = c->remote_maxpacket;\n\tif (len == 0)\n\t\treturn;\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_EXTENDED_DATA)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, SSH2_EXTENDED_DATA_STDERR)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, sshbuf_ptr(c->extended), len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0) {\n\t\tfatal(\"%s: channel %i: data: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tif ((r = sshbuf_consume(c->extended, len)) != 0)\n\t\tfatal(\"%s: channel %i: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\tc->remote_window -= len;\n\tdebug2(\"channel %d: sent ext data %zu\", c->self, len);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: sent ext data %zu\"",
            "c->self",
            "len"
          ],
          "line": 2631
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %i: consume: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 2628
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "c->extended",
            "len"
          ],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 2623
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_string",
          "args": [
            "ssh",
            "sshbuf_ptr(c->extended)",
            "len"
          ],
          "line": 2622
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2453-2457",
          "snippet": "int\nsshpkt_put_string(struct ssh *ssh, const void *v, size_t len)\n{\n\treturn sshbuf_put_string(ssh->state->outgoing_packet, v, len);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_string(struct ssh *ssh, const void *v, size_t len)\n{\n\treturn sshbuf_put_string(ssh->state->outgoing_packet, v, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "c->extended"
          ],
          "line": 2622
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "SSH2_EXTENDED_DATA_STDERR"
          ],
          "line": 2621
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_CHANNEL_EXTENDED_DATA"
          ],
          "line": 2619
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "c->extended"
          ],
          "line": 2610
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_output_poll_extended_read(struct ssh *ssh, Channel *c)\n{\n\tsize_t len;\n\tint r;\n\n\tif ((len = sshbuf_len(c->extended)) == 0)\n\t\treturn;\n\n\tdebug2(\"channel %d: rwin %u elen %zu euse %d\", c->self,\n\t    c->remote_window, sshbuf_len(c->extended), c->extended_usage);\n\tif (len > c->remote_window)\n\t\tlen = c->remote_window;\n\tif (len > c->remote_maxpacket)\n\t\tlen = c->remote_maxpacket;\n\tif (len == 0)\n\t\treturn;\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_EXTENDED_DATA)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, SSH2_EXTENDED_DATA_STDERR)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, sshbuf_ptr(c->extended), len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0) {\n\t\tfatal(\"%s: channel %i: data: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tif ((r = sshbuf_consume(c->extended, len)) != 0)\n\t\tfatal(\"%s: channel %i: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\tc->remote_window -= len;\n\tdebug2(\"channel %d: sent ext data %zu\", c->self, len);\n}"
  },
  {
    "function_name": "channel_output_poll_input_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2522-2595",
    "snippet": "static void\nchannel_output_poll_input_open(struct ssh *ssh, Channel *c)\n{\n\tsize_t len, plen;\n\tconst u_char *pkt;\n\tint r;\n\n\tif ((len = sshbuf_len(c->input)) == 0) {\n\t\tif (c->istate == CHAN_INPUT_WAIT_DRAIN) {\n\t\t\t/*\n\t\t\t * input-buffer is empty and read-socket shutdown:\n\t\t\t * tell peer, that we will not send more data:\n\t\t\t * send IEOF.\n\t\t\t * hack for extended data: delay EOF if EFD still\n\t\t\t * in use.\n\t\t\t */\n\t\t\tif (CHANNEL_EFD_INPUT_ACTIVE(c))\n\t\t\t\tdebug2(\"channel %d: \"\n\t\t\t\t    \"ibuf_empty delayed efd %d/(%zu)\",\n\t\t\t\t    c->self, c->efd, sshbuf_len(c->extended));\n\t\t\telse\n\t\t\t\tchan_ibuf_empty(ssh, c);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tif (c->datagram) {\n\t\t/* Check datagram will fit; drop if not */\n\t\tif ((r = sshbuf_get_string_direct(c->input, &pkt, &plen)) != 0)\n\t\t\tfatal(\"%s: channel %d: get datagram: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t/*\n\t\t * XXX this does tail-drop on the datagram queue which is\n\t\t * usually suboptimal compared to head-drop. Better to have\n\t\t * backpressure at read time? (i.e. read + discard)\n\t\t */\n\t\tif (plen > c->remote_window || plen > c->remote_maxpacket) {\n\t\t\tdebug(\"channel %d: datagram too big\", c->self);\n\t\t\treturn;\n\t\t}\n\t\t/* Enqueue it */\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_DATA)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t    (r = sshpkt_put_string(ssh, pkt, plen)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\tfatal(\"%s: channel %i: datagram: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\tc->remote_window -= plen;\n\t\treturn;\n\t}\n\n\t/* Enqueue packet for buffered data. */\n\tif (len > c->remote_window)\n\t\tlen = c->remote_window;\n\tif (len > c->remote_maxpacket)\n\t\tlen = c->remote_maxpacket;\n\tif (len == 0)\n\t\treturn;\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_DATA)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, sshbuf_ptr(c->input), len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0) {\n\t\tfatal(\"%s: channel %i: data: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tif ((r = sshbuf_consume(c->input, len)) != 0)\n\t\tfatal(\"%s: channel %i: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\tc->remote_window -= len;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %i: consume: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 2592
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "c->input",
            "len"
          ],
          "line": 2591
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 2587
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_string",
          "args": [
            "ssh",
            "sshbuf_ptr(c->input)",
            "len"
          ],
          "line": 2586
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2453-2457",
          "snippet": "int\nsshpkt_put_string(struct ssh *ssh, const void *v, size_t len)\n{\n\treturn sshbuf_put_string(ssh->state->outgoing_packet, v, len);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_string(struct ssh *ssh, const void *v, size_t len)\n{\n\treturn sshbuf_put_string(ssh->state->outgoing_packet, v, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "c->input"
          ],
          "line": 2586
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "c->remote_id"
          ],
          "line": 2585
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_CHANNEL_DATA"
          ],
          "line": 2584
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"channel %d: datagram too big\"",
            "c->self"
          ],
          "line": 2562
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string_direct",
          "args": [
            "c->input",
            "&pkt",
            "&plen"
          ],
          "line": 2553
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_ibuf_empty",
          "args": [
            "ssh",
            "c"
          ],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "chan_ibuf_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "124-144",
          "snippet": "void\nchan_ibuf_empty(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: ibuf empty\", c->self);\n\tif (sshbuf_len(c->input)) {\n\t\terror(\"channel %d: chan_ibuf_empty for non empty buffer\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & (CHAN_CLOSE_SENT|CHAN_LOCAL)))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_ibuf_empty for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_ibuf_empty(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: ibuf empty\", c->self);\n\tif (sshbuf_len(c->input)) {\n\t\terror(\"channel %d: chan_ibuf_empty for non empty buffer\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & (CHAN_CLOSE_SENT|CHAN_LOCAL)))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_ibuf_empty for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: \"\n\t\t\t\t    \"ibuf_empty delayed efd %d/(%zu)\"",
            "c->self",
            "c->efd",
            "sshbuf_len(c->extended)"
          ],
          "line": 2539
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "c->extended"
          ],
          "line": 2541
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHANNEL_EFD_INPUT_ACTIVE",
          "args": [
            "c"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_output_poll_input_open(struct ssh *ssh, Channel *c)\n{\n\tsize_t len, plen;\n\tconst u_char *pkt;\n\tint r;\n\n\tif ((len = sshbuf_len(c->input)) == 0) {\n\t\tif (c->istate == CHAN_INPUT_WAIT_DRAIN) {\n\t\t\t/*\n\t\t\t * input-buffer is empty and read-socket shutdown:\n\t\t\t * tell peer, that we will not send more data:\n\t\t\t * send IEOF.\n\t\t\t * hack for extended data: delay EOF if EFD still\n\t\t\t * in use.\n\t\t\t */\n\t\t\tif (CHANNEL_EFD_INPUT_ACTIVE(c))\n\t\t\t\tdebug2(\"channel %d: \"\n\t\t\t\t    \"ibuf_empty delayed efd %d/(%zu)\",\n\t\t\t\t    c->self, c->efd, sshbuf_len(c->extended));\n\t\t\telse\n\t\t\t\tchan_ibuf_empty(ssh, c);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tif (c->datagram) {\n\t\t/* Check datagram will fit; drop if not */\n\t\tif ((r = sshbuf_get_string_direct(c->input, &pkt, &plen)) != 0)\n\t\t\tfatal(\"%s: channel %d: get datagram: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t/*\n\t\t * XXX this does tail-drop on the datagram queue which is\n\t\t * usually suboptimal compared to head-drop. Better to have\n\t\t * backpressure at read time? (i.e. read + discard)\n\t\t */\n\t\tif (plen > c->remote_window || plen > c->remote_maxpacket) {\n\t\t\tdebug(\"channel %d: datagram too big\", c->self);\n\t\t\treturn;\n\t\t}\n\t\t/* Enqueue it */\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_DATA)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t    (r = sshpkt_put_string(ssh, pkt, plen)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\tfatal(\"%s: channel %i: datagram: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\tc->remote_window -= plen;\n\t\treturn;\n\t}\n\n\t/* Enqueue packet for buffered data. */\n\tif (len > c->remote_window)\n\t\tlen = c->remote_window;\n\tif (len > c->remote_maxpacket)\n\t\tlen = c->remote_maxpacket;\n\tif (len == 0)\n\t\treturn;\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_DATA)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, sshbuf_ptr(c->input), len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0) {\n\t\tfatal(\"%s: channel %i: data: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tif ((r = sshbuf_consume(c->input, len)) != 0)\n\t\tfatal(\"%s: channel %i: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\tc->remote_window -= len;\n}"
  },
  {
    "function_name": "channel_after_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2513-2517",
    "snippet": "void\nchannel_after_select(struct ssh *ssh, fd_set *readset, fd_set *writeset)\n{\n\tchannel_handler(ssh, CHAN_POST, readset, writeset, NULL);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_handler",
          "args": [
            "ssh",
            "CHAN_POST",
            "readset",
            "writeset",
            "NULL"
          ],
          "line": 2516
        },
        "resolved": true,
        "details": {
          "function_name": "channel_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2404-2451",
          "snippet": "static void\nchannel_handler(struct ssh *ssh, int table,\n    fd_set *readset, fd_set *writeset, time_t *unpause_secs)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchan_fn **ftab = table == CHAN_PRE ? sc->channel_pre : sc->channel_post;\n\tu_int i, oalloc;\n\tChannel *c;\n\ttime_t now;\n\n\tnow = monotime();\n\tif (unpause_secs != NULL)\n\t\t*unpause_secs = 0;\n\tfor (i = 0, oalloc = sc->channels_alloc; i < oalloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tif (c->delayed) {\n\t\t\tif (table == CHAN_PRE)\n\t\t\t\tc->delayed = 0;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (ftab[c->type] != NULL) {\n\t\t\t/*\n\t\t\t * Run handlers that are not paused.\n\t\t\t */\n\t\t\tif (c->notbefore <= now)\n\t\t\t\t(*ftab[c->type])(ssh, c, readset, writeset);\n\t\t\telse if (unpause_secs != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Collect the time that the earliest\n\t\t\t\t * channel comes off pause.\n\t\t\t\t */\n\t\t\t\tdebug3(\"%s: chan %d: skip for %d more seconds\",\n\t\t\t\t    __func__, c->self,\n\t\t\t\t    (int)(c->notbefore - now));\n\t\t\t\tif (*unpause_secs == 0 ||\n\t\t\t\t    (c->notbefore - now) < *unpause_secs)\n\t\t\t\t\t*unpause_secs = c->notbefore - now;\n\t\t\t}\n\t\t}\n\t\tchannel_garbage_collect(ssh, c);\n\t}\n\tif (unpause_secs != NULL && *unpause_secs != 0)\n\t\tdebug3(\"%s: first channel unpauses in %d seconds\",\n\t\t    __func__, (int)*unpause_secs);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic void\nchannel_handler(struct ssh *ssh, int table,\n    fd_set *readset, fd_set *writeset, time_t *unpause_secs)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchan_fn **ftab = table == CHAN_PRE ? sc->channel_pre : sc->channel_post;\n\tu_int i, oalloc;\n\tChannel *c;\n\ttime_t now;\n\n\tnow = monotime();\n\tif (unpause_secs != NULL)\n\t\t*unpause_secs = 0;\n\tfor (i = 0, oalloc = sc->channels_alloc; i < oalloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tif (c->delayed) {\n\t\t\tif (table == CHAN_PRE)\n\t\t\t\tc->delayed = 0;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (ftab[c->type] != NULL) {\n\t\t\t/*\n\t\t\t * Run handlers that are not paused.\n\t\t\t */\n\t\t\tif (c->notbefore <= now)\n\t\t\t\t(*ftab[c->type])(ssh, c, readset, writeset);\n\t\t\telse if (unpause_secs != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Collect the time that the earliest\n\t\t\t\t * channel comes off pause.\n\t\t\t\t */\n\t\t\t\tdebug3(\"%s: chan %d: skip for %d more seconds\",\n\t\t\t\t    __func__, c->self,\n\t\t\t\t    (int)(c->notbefore - now));\n\t\t\t\tif (*unpause_secs == 0 ||\n\t\t\t\t    (c->notbefore - now) < *unpause_secs)\n\t\t\t\t\t*unpause_secs = c->notbefore - now;\n\t\t\t}\n\t\t}\n\t\tchannel_garbage_collect(ssh, c);\n\t}\n\tif (unpause_secs != NULL && *unpause_secs != 0)\n\t\tdebug3(\"%s: first channel unpauses in %d seconds\",\n\t\t    __func__, (int)*unpause_secs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_after_select(struct ssh *ssh, fd_set *readset, fd_set *writeset)\n{\n\tchannel_handler(ssh, CHAN_POST, readset, writeset, NULL);\n}"
  },
  {
    "function_name": "channel_prepare_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2478-2507",
    "snippet": "void\nchannel_prepare_select(struct ssh *ssh, fd_set **readsetp, fd_set **writesetp,\n    int *maxfdp, u_int *nallocp, time_t *minwait_secs)\n{\n\tu_int n, sz, nfdset;\n\n\tchannel_before_prepare_select(ssh); /* might update channel_max_fd */\n\n\tn = MAXIMUM(*maxfdp, ssh->chanctxt->channel_max_fd);\n\n\tnfdset = howmany(n+1, NFDBITS);\n\t/* Explicitly test here, because xrealloc isn't always called */\n\tif (nfdset && SIZE_MAX / nfdset < sizeof(fd_mask))\n\t\tfatal(\"channel_prepare_select: max_fd (%d) is too large\", n);\n\tsz = nfdset * sizeof(fd_mask);\n\n\t/* perhaps check sz < nalloc/2 and shrink? */\n\tif (*readsetp == NULL || sz > *nallocp) {\n\t\t*readsetp = xreallocarray(*readsetp, nfdset, sizeof(fd_mask));\n\t\t*writesetp = xreallocarray(*writesetp, nfdset, sizeof(fd_mask));\n\t\t*nallocp = sz;\n\t}\n\t*maxfdp = n;\n\tmemset(*readsetp, 0, sz);\n\tmemset(*writesetp, 0, sz);\n\n\tif (!ssh_packet_is_rekeying(ssh))\n\t\tchannel_handler(ssh, CHAN_PRE, *readsetp, *writesetp,\n\t\t    minwait_secs);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_handler",
          "args": [
            "ssh",
            "CHAN_PRE",
            "*readsetp",
            "*writesetp",
            "minwait_secs"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "channel_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2404-2451",
          "snippet": "static void\nchannel_handler(struct ssh *ssh, int table,\n    fd_set *readset, fd_set *writeset, time_t *unpause_secs)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchan_fn **ftab = table == CHAN_PRE ? sc->channel_pre : sc->channel_post;\n\tu_int i, oalloc;\n\tChannel *c;\n\ttime_t now;\n\n\tnow = monotime();\n\tif (unpause_secs != NULL)\n\t\t*unpause_secs = 0;\n\tfor (i = 0, oalloc = sc->channels_alloc; i < oalloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tif (c->delayed) {\n\t\t\tif (table == CHAN_PRE)\n\t\t\t\tc->delayed = 0;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (ftab[c->type] != NULL) {\n\t\t\t/*\n\t\t\t * Run handlers that are not paused.\n\t\t\t */\n\t\t\tif (c->notbefore <= now)\n\t\t\t\t(*ftab[c->type])(ssh, c, readset, writeset);\n\t\t\telse if (unpause_secs != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Collect the time that the earliest\n\t\t\t\t * channel comes off pause.\n\t\t\t\t */\n\t\t\t\tdebug3(\"%s: chan %d: skip for %d more seconds\",\n\t\t\t\t    __func__, c->self,\n\t\t\t\t    (int)(c->notbefore - now));\n\t\t\t\tif (*unpause_secs == 0 ||\n\t\t\t\t    (c->notbefore - now) < *unpause_secs)\n\t\t\t\t\t*unpause_secs = c->notbefore - now;\n\t\t\t}\n\t\t}\n\t\tchannel_garbage_collect(ssh, c);\n\t}\n\tif (unpause_secs != NULL && *unpause_secs != 0)\n\t\tdebug3(\"%s: first channel unpauses in %d seconds\",\n\t\t    __func__, (int)*unpause_secs);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic void\nchannel_handler(struct ssh *ssh, int table,\n    fd_set *readset, fd_set *writeset, time_t *unpause_secs)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchan_fn **ftab = table == CHAN_PRE ? sc->channel_pre : sc->channel_post;\n\tu_int i, oalloc;\n\tChannel *c;\n\ttime_t now;\n\n\tnow = monotime();\n\tif (unpause_secs != NULL)\n\t\t*unpause_secs = 0;\n\tfor (i = 0, oalloc = sc->channels_alloc; i < oalloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tif (c->delayed) {\n\t\t\tif (table == CHAN_PRE)\n\t\t\t\tc->delayed = 0;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (ftab[c->type] != NULL) {\n\t\t\t/*\n\t\t\t * Run handlers that are not paused.\n\t\t\t */\n\t\t\tif (c->notbefore <= now)\n\t\t\t\t(*ftab[c->type])(ssh, c, readset, writeset);\n\t\t\telse if (unpause_secs != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Collect the time that the earliest\n\t\t\t\t * channel comes off pause.\n\t\t\t\t */\n\t\t\t\tdebug3(\"%s: chan %d: skip for %d more seconds\",\n\t\t\t\t    __func__, c->self,\n\t\t\t\t    (int)(c->notbefore - now));\n\t\t\t\tif (*unpause_secs == 0 ||\n\t\t\t\t    (c->notbefore - now) < *unpause_secs)\n\t\t\t\t\t*unpause_secs = c->notbefore - now;\n\t\t\t}\n\t\t}\n\t\tchannel_garbage_collect(ssh, c);\n\t}\n\tif (unpause_secs != NULL && *unpause_secs != 0)\n\t\tdebug3(\"%s: first channel unpauses in %d seconds\",\n\t\t    __func__, (int)*unpause_secs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_is_rekeying",
          "args": [
            "ssh"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_is_rekeying",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "272-277",
          "snippet": "int\nssh_packet_is_rekeying(struct ssh *ssh)\n{\n\treturn ssh->state->rekeying ||\n\t    (ssh->kex != NULL && ssh->kex->done == 0);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_is_rekeying(struct ssh *ssh)\n{\n\treturn ssh->state->rekeying ||\n\t    (ssh->kex != NULL && ssh->kex->done == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "*writesetp",
            "0",
            "sz"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "*readsetp",
            "0",
            "sz"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xreallocarray",
          "args": [
            "*writesetp",
            "nfdset",
            "sizeof(fd_mask)"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "xreallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "68-78",
          "snippet": "void *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"channel_prepare_select: max_fd (%d) is too large\"",
            "n"
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "howmany",
          "args": [
            "n+1",
            "NFDBITS"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "*maxfdp",
            "ssh->chanctxt->channel_max_fd"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_before_prepare_select",
          "args": [
            "ssh"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "channel_before_prepare_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2458-2472",
          "snippet": "static void\nchannel_before_prepare_select(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tChannel *c;\n\tu_int i, oalloc;\n\n\tfor (i = 0, oalloc = sc->channels_alloc; i < oalloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tif (c->type == SSH_CHANNEL_RDYNAMIC_OPEN)\n\t\t\tchannel_before_prepare_select_rdynamic(ssh, c);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic void\nchannel_before_prepare_select(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tChannel *c;\n\tu_int i, oalloc;\n\n\tfor (i = 0, oalloc = sc->channels_alloc; i < oalloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tif (c->type == SSH_CHANNEL_RDYNAMIC_OPEN)\n\t\t\tchannel_before_prepare_select_rdynamic(ssh, c);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_prepare_select(struct ssh *ssh, fd_set **readsetp, fd_set **writesetp,\n    int *maxfdp, u_int *nallocp, time_t *minwait_secs)\n{\n\tu_int n, sz, nfdset;\n\n\tchannel_before_prepare_select(ssh); /* might update channel_max_fd */\n\n\tn = MAXIMUM(*maxfdp, ssh->chanctxt->channel_max_fd);\n\n\tnfdset = howmany(n+1, NFDBITS);\n\t/* Explicitly test here, because xrealloc isn't always called */\n\tif (nfdset && SIZE_MAX / nfdset < sizeof(fd_mask))\n\t\tfatal(\"channel_prepare_select: max_fd (%d) is too large\", n);\n\tsz = nfdset * sizeof(fd_mask);\n\n\t/* perhaps check sz < nalloc/2 and shrink? */\n\tif (*readsetp == NULL || sz > *nallocp) {\n\t\t*readsetp = xreallocarray(*readsetp, nfdset, sizeof(fd_mask));\n\t\t*writesetp = xreallocarray(*writesetp, nfdset, sizeof(fd_mask));\n\t\t*nallocp = sz;\n\t}\n\t*maxfdp = n;\n\tmemset(*readsetp, 0, sz);\n\tmemset(*writesetp, 0, sz);\n\n\tif (!ssh_packet_is_rekeying(ssh))\n\t\tchannel_handler(ssh, CHAN_PRE, *readsetp, *writesetp,\n\t\t    minwait_secs);\n}"
  },
  {
    "function_name": "channel_before_prepare_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2458-2472",
    "snippet": "static void\nchannel_before_prepare_select(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tChannel *c;\n\tu_int i, oalloc;\n\n\tfor (i = 0, oalloc = sc->channels_alloc; i < oalloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tif (c->type == SSH_CHANNEL_RDYNAMIC_OPEN)\n\t\t\tchannel_before_prepare_select_rdynamic(ssh, c);\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_before_prepare_select_rdynamic",
          "args": [
            "ssh",
            "c"
          ],
          "line": 2470
        },
        "resolved": true,
        "details": {
          "function_name": "channel_before_prepare_select_rdynamic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1572-1632",
          "snippet": "static void\nchannel_before_prepare_select_rdynamic(struct ssh *ssh, Channel *c)\n{\n\tconst u_char *p;\n\tu_int have, len;\n\tint r, ret;\n\n\thave = sshbuf_len(c->output);\n\tdebug2(\"channel %d: pre_rdynamic: have %d\", c->self, have);\n\t/* sshbuf_dump(c->output, stderr); */\n\t/* EOF received */\n\tif (c->flags & CHAN_EOF_RCVD) {\n\t\tif ((r = sshbuf_consume(c->output, have)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t\trdynamic_close(ssh, c);\n\t\treturn;\n\t}\n\t/* check if the fixed size part of the packet is in buffer. */\n\tif (have < 3)\n\t\treturn;\n\t/* try to guess the protocol */\n\tp = sshbuf_ptr(c->output);\n\tswitch (p[0]) {\n\tcase 0x04:\n\t\t/* switch input/output for reverse forwarding */\n\t\tret = channel_decode_socks4(c, c->output, c->input);\n\t\tbreak;\n\tcase 0x05:\n\t\tret = channel_decode_socks5(c, c->output, c->input);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\tif (ret < 0) {\n\t\trdynamic_close(ssh, c);\n\t} else if (ret == 0) {\n\t\tdebug2(\"channel %d: pre_rdynamic: need more\", c->self);\n\t\t/* send socks request to peer */\n\t\tlen = sshbuf_len(c->input);\n\t\tif (len > 0 && len < c->remote_window) {\n\t\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_DATA)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t\t    (r = sshpkt_put_stringb(ssh, c->input)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\t\tfatal(\"%s: channel %i: rdynamic: %s\", __func__,\n\t\t\t\t    c->self, ssh_err(r));\n\t\t\t}\n\t\t\tif ((r = sshbuf_consume(c->input, len)) != 0) {\n\t\t\t\tfatal(\"%s: channel %d: consume: %s\",\n\t\t\t\t    __func__, c->self, ssh_err(r));\n\t\t\t}\n\t\t\tc->remote_window -= len;\n\t\t}\n\t} else if (rdynamic_connect_finish(ssh, c) < 0) {\n\t\t/* the connect failed */\n\t\trdynamic_close(ssh, c);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_before_prepare_select_rdynamic(struct ssh *ssh, Channel *c)\n{\n\tconst u_char *p;\n\tu_int have, len;\n\tint r, ret;\n\n\thave = sshbuf_len(c->output);\n\tdebug2(\"channel %d: pre_rdynamic: have %d\", c->self, have);\n\t/* sshbuf_dump(c->output, stderr); */\n\t/* EOF received */\n\tif (c->flags & CHAN_EOF_RCVD) {\n\t\tif ((r = sshbuf_consume(c->output, have)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t\trdynamic_close(ssh, c);\n\t\treturn;\n\t}\n\t/* check if the fixed size part of the packet is in buffer. */\n\tif (have < 3)\n\t\treturn;\n\t/* try to guess the protocol */\n\tp = sshbuf_ptr(c->output);\n\tswitch (p[0]) {\n\tcase 0x04:\n\t\t/* switch input/output for reverse forwarding */\n\t\tret = channel_decode_socks4(c, c->output, c->input);\n\t\tbreak;\n\tcase 0x05:\n\t\tret = channel_decode_socks5(c, c->output, c->input);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\tif (ret < 0) {\n\t\trdynamic_close(ssh, c);\n\t} else if (ret == 0) {\n\t\tdebug2(\"channel %d: pre_rdynamic: need more\", c->self);\n\t\t/* send socks request to peer */\n\t\tlen = sshbuf_len(c->input);\n\t\tif (len > 0 && len < c->remote_window) {\n\t\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_DATA)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t\t    (r = sshpkt_put_stringb(ssh, c->input)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\t\tfatal(\"%s: channel %i: rdynamic: %s\", __func__,\n\t\t\t\t    c->self, ssh_err(r));\n\t\t\t}\n\t\t\tif ((r = sshbuf_consume(c->input, len)) != 0) {\n\t\t\t\tfatal(\"%s: channel %d: consume: %s\",\n\t\t\t\t    __func__, c->self, ssh_err(r));\n\t\t\t}\n\t\t\tc->remote_window -= len;\n\t\t}\n\t} else if (rdynamic_connect_finish(ssh, c) < 0) {\n\t\t/* the connect failed */\n\t\trdynamic_close(ssh, c);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic void\nchannel_before_prepare_select(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tChannel *c;\n\tu_int i, oalloc;\n\n\tfor (i = 0, oalloc = sc->channels_alloc; i < oalloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tif (c->type == SSH_CHANNEL_RDYNAMIC_OPEN)\n\t\t\tchannel_before_prepare_select_rdynamic(ssh, c);\n\t}\n}"
  },
  {
    "function_name": "channel_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2404-2451",
    "snippet": "static void\nchannel_handler(struct ssh *ssh, int table,\n    fd_set *readset, fd_set *writeset, time_t *unpause_secs)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchan_fn **ftab = table == CHAN_PRE ? sc->channel_pre : sc->channel_post;\n\tu_int i, oalloc;\n\tChannel *c;\n\ttime_t now;\n\n\tnow = monotime();\n\tif (unpause_secs != NULL)\n\t\t*unpause_secs = 0;\n\tfor (i = 0, oalloc = sc->channels_alloc; i < oalloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tif (c->delayed) {\n\t\t\tif (table == CHAN_PRE)\n\t\t\t\tc->delayed = 0;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (ftab[c->type] != NULL) {\n\t\t\t/*\n\t\t\t * Run handlers that are not paused.\n\t\t\t */\n\t\t\tif (c->notbefore <= now)\n\t\t\t\t(*ftab[c->type])(ssh, c, readset, writeset);\n\t\t\telse if (unpause_secs != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Collect the time that the earliest\n\t\t\t\t * channel comes off pause.\n\t\t\t\t */\n\t\t\t\tdebug3(\"%s: chan %d: skip for %d more seconds\",\n\t\t\t\t    __func__, c->self,\n\t\t\t\t    (int)(c->notbefore - now));\n\t\t\t\tif (*unpause_secs == 0 ||\n\t\t\t\t    (c->notbefore - now) < *unpause_secs)\n\t\t\t\t\t*unpause_secs = c->notbefore - now;\n\t\t\t}\n\t\t}\n\t\tchannel_garbage_collect(ssh, c);\n\t}\n\tif (unpause_secs != NULL && *unpause_secs != 0)\n\t\tdebug3(\"%s: first channel unpauses in %d seconds\",\n\t\t    __func__, (int)*unpause_secs);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: first channel unpauses in %d seconds\"",
            "__func__",
            "(int)*unpause_secs"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_garbage_collect",
          "args": [
            "ssh",
            "c"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "channel_garbage_collect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2380-2400",
          "snippet": "static void\nchannel_garbage_collect(struct ssh *ssh, Channel *c)\n{\n\tif (c == NULL)\n\t\treturn;\n\tif (c->detach_user != NULL) {\n\t\tif (!chan_is_dead(ssh, c, c->detach_close))\n\t\t\treturn;\n\n\t\tdebug2(\"channel %d: gc: notify user\", c->self);\n\t\tc->detach_user(ssh, c->self, NULL);\n\t\t/* if we still have a callback */\n\t\tif (c->detach_user != NULL)\n\t\t\treturn;\n\t\tdebug2(\"channel %d: gc: user detached\", c->self);\n\t}\n\tif (!chan_is_dead(ssh, c, 1))\n\t\treturn;\n\tdebug2(\"channel %d: garbage collecting\", c->self);\n\tchannel_free(ssh, c);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_garbage_collect(struct ssh *ssh, Channel *c)\n{\n\tif (c == NULL)\n\t\treturn;\n\tif (c->detach_user != NULL) {\n\t\tif (!chan_is_dead(ssh, c, c->detach_close))\n\t\t\treturn;\n\n\t\tdebug2(\"channel %d: gc: notify user\", c->self);\n\t\tc->detach_user(ssh, c->self, NULL);\n\t\t/* if we still have a callback */\n\t\tif (c->detach_user != NULL)\n\t\t\treturn;\n\t\tdebug2(\"channel %d: gc: user detached\", c->self);\n\t}\n\tif (!chan_is_dead(ssh, c, 1))\n\t\treturn;\n\tdebug2(\"channel %d: garbage collecting\", c->self);\n\tchannel_free(ssh, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "ssh",
            "c",
            "readset",
            "writeset"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "monotime",
          "args": [],
          "line": 2414
        },
        "resolved": true,
        "details": {
          "function_name": "monotime_double",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1324-1331",
          "snippet": "double\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\ndouble\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic void\nchannel_handler(struct ssh *ssh, int table,\n    fd_set *readset, fd_set *writeset, time_t *unpause_secs)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchan_fn **ftab = table == CHAN_PRE ? sc->channel_pre : sc->channel_post;\n\tu_int i, oalloc;\n\tChannel *c;\n\ttime_t now;\n\n\tnow = monotime();\n\tif (unpause_secs != NULL)\n\t\t*unpause_secs = 0;\n\tfor (i = 0, oalloc = sc->channels_alloc; i < oalloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tif (c->delayed) {\n\t\t\tif (table == CHAN_PRE)\n\t\t\t\tc->delayed = 0;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (ftab[c->type] != NULL) {\n\t\t\t/*\n\t\t\t * Run handlers that are not paused.\n\t\t\t */\n\t\t\tif (c->notbefore <= now)\n\t\t\t\t(*ftab[c->type])(ssh, c, readset, writeset);\n\t\t\telse if (unpause_secs != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Collect the time that the earliest\n\t\t\t\t * channel comes off pause.\n\t\t\t\t */\n\t\t\t\tdebug3(\"%s: chan %d: skip for %d more seconds\",\n\t\t\t\t    __func__, c->self,\n\t\t\t\t    (int)(c->notbefore - now));\n\t\t\t\tif (*unpause_secs == 0 ||\n\t\t\t\t    (c->notbefore - now) < *unpause_secs)\n\t\t\t\t\t*unpause_secs = c->notbefore - now;\n\t\t\t}\n\t\t}\n\t\tchannel_garbage_collect(ssh, c);\n\t}\n\tif (unpause_secs != NULL && *unpause_secs != 0)\n\t\tdebug3(\"%s: first channel unpauses in %d seconds\",\n\t\t    __func__, (int)*unpause_secs);\n}"
  },
  {
    "function_name": "channel_garbage_collect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2380-2400",
    "snippet": "static void\nchannel_garbage_collect(struct ssh *ssh, Channel *c)\n{\n\tif (c == NULL)\n\t\treturn;\n\tif (c->detach_user != NULL) {\n\t\tif (!chan_is_dead(ssh, c, c->detach_close))\n\t\t\treturn;\n\n\t\tdebug2(\"channel %d: gc: notify user\", c->self);\n\t\tc->detach_user(ssh, c->self, NULL);\n\t\t/* if we still have a callback */\n\t\tif (c->detach_user != NULL)\n\t\t\treturn;\n\t\tdebug2(\"channel %d: gc: user detached\", c->self);\n\t}\n\tif (!chan_is_dead(ssh, c, 1))\n\t\treturn;\n\tdebug2(\"channel %d: garbage collecting\", c->self);\n\tchannel_free(ssh, c);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_free",
          "args": [
            "ssh",
            "c"
          ],
          "line": 2399
        },
        "resolved": true,
        "details": {
          "function_name": "channel_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "582-640",
          "snippet": "void\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: garbage collecting\"",
            "c->self"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_is_dead",
          "args": [
            "ssh",
            "c",
            "1"
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "chan_is_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "330-369",
          "snippet": "int\nchan_is_dead(struct ssh *ssh, Channel *c, int do_send)\n{\n\tif (c->type == SSH_CHANNEL_ZOMBIE) {\n\t\tdebug2(\"channel %d: zombie\", c->self);\n\t\treturn 1;\n\t}\n\tif (c->istate != CHAN_INPUT_CLOSED || c->ostate != CHAN_OUTPUT_CLOSED)\n\t\treturn 0;\n\tif ((datafellows & SSH_BUG_EXTEOF) &&\n\t    c->extended_usage == CHAN_EXTENDED_WRITE &&\n\t    c->efd != -1 &&\n\t    sshbuf_len(c->extended) > 0) {\n\t\tdebug2(\"channel %d: active efd: %d len %zu\",\n\t\t    c->self, c->efd, sshbuf_len(c->extended));\n\t\treturn 0;\n\t}\n\tif (c->flags & CHAN_LOCAL) {\n\t\tdebug2(\"channel %d: is dead (local)\", c->self);\n\t\treturn 1;\n\t}\t\t\n\tif (!(c->flags & CHAN_CLOSE_SENT)) {\n\t\tif (do_send) {\n\t\t\tchan_send_close2(ssh, c);\n\t\t} else {\n\t\t\t/* channel would be dead if we sent a close */\n\t\t\tif (c->flags & CHAN_CLOSE_RCVD) {\n\t\t\t\tdebug2(\"channel %d: almost dead\",\n\t\t\t\t    c->self);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tif ((c->flags & CHAN_CLOSE_SENT) &&\n\t    (c->flags & CHAN_CLOSE_RCVD)) {\n\t\tdebug2(\"channel %d: is dead\", c->self);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nint\nchan_is_dead(struct ssh *ssh, Channel *c, int do_send)\n{\n\tif (c->type == SSH_CHANNEL_ZOMBIE) {\n\t\tdebug2(\"channel %d: zombie\", c->self);\n\t\treturn 1;\n\t}\n\tif (c->istate != CHAN_INPUT_CLOSED || c->ostate != CHAN_OUTPUT_CLOSED)\n\t\treturn 0;\n\tif ((datafellows & SSH_BUG_EXTEOF) &&\n\t    c->extended_usage == CHAN_EXTENDED_WRITE &&\n\t    c->efd != -1 &&\n\t    sshbuf_len(c->extended) > 0) {\n\t\tdebug2(\"channel %d: active efd: %d len %zu\",\n\t\t    c->self, c->efd, sshbuf_len(c->extended));\n\t\treturn 0;\n\t}\n\tif (c->flags & CHAN_LOCAL) {\n\t\tdebug2(\"channel %d: is dead (local)\", c->self);\n\t\treturn 1;\n\t}\t\t\n\tif (!(c->flags & CHAN_CLOSE_SENT)) {\n\t\tif (do_send) {\n\t\t\tchan_send_close2(ssh, c);\n\t\t} else {\n\t\t\t/* channel would be dead if we sent a close */\n\t\t\tif (c->flags & CHAN_CLOSE_RCVD) {\n\t\t\t\tdebug2(\"channel %d: almost dead\",\n\t\t\t\t    c->self);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tif ((c->flags & CHAN_CLOSE_SENT) &&\n\t    (c->flags & CHAN_CLOSE_RCVD)) {\n\t\tdebug2(\"channel %d: is dead\", c->self);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->detach_user",
          "args": [
            "ssh",
            "c->self",
            "NULL"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_garbage_collect(struct ssh *ssh, Channel *c)\n{\n\tif (c == NULL)\n\t\treturn;\n\tif (c->detach_user != NULL) {\n\t\tif (!chan_is_dead(ssh, c, c->detach_close))\n\t\t\treturn;\n\n\t\tdebug2(\"channel %d: gc: notify user\", c->self);\n\t\tc->detach_user(ssh, c->self, NULL);\n\t\t/* if we still have a callback */\n\t\tif (c->detach_user != NULL)\n\t\t\treturn;\n\t\tdebug2(\"channel %d: gc: user detached\", c->self);\n\t}\n\tif (!chan_is_dead(ssh, c, 1))\n\t\treturn;\n\tdebug2(\"channel %d: garbage collecting\", c->self);\n\tchannel_free(ssh, c);\n}"
  },
  {
    "function_name": "channel_handler_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2339-2377",
    "snippet": "static void\nchannel_handler_init(struct ssh_channels *sc)\n{\n\tchan_fn **pre, **post;\n\n\tif ((pre = calloc(SSH_CHANNEL_MAX_TYPE, sizeof(*pre))) == NULL ||\n\t   (post = calloc(SSH_CHANNEL_MAX_TYPE, sizeof(*post))) == NULL)\n\t\tfatal(\"%s: allocation failed\", __func__);\n\n\tpre[SSH_CHANNEL_OPEN] =\t\t\t&channel_pre_open;\n\tpre[SSH_CHANNEL_X11_OPEN] =\t\t&channel_pre_x11_open;\n\tpre[SSH_CHANNEL_PORT_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_RPORT_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_UNIX_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_RUNIX_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_X11_LISTENER] =\t\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_AUTH_SOCKET] =\t\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_CONNECTING] =\t\t&channel_pre_connecting;\n\tpre[SSH_CHANNEL_DYNAMIC] =\t\t&channel_pre_dynamic;\n\tpre[SSH_CHANNEL_RDYNAMIC_FINISH] =\t&channel_pre_connecting;\n\tpre[SSH_CHANNEL_MUX_LISTENER] =\t\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_MUX_CLIENT] =\t\t&channel_pre_mux_client;\n\n\tpost[SSH_CHANNEL_OPEN] =\t\t&channel_post_open;\n\tpost[SSH_CHANNEL_PORT_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_RPORT_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_UNIX_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_RUNIX_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_X11_LISTENER] =\t&channel_post_x11_listener;\n\tpost[SSH_CHANNEL_AUTH_SOCKET] =\t\t&channel_post_auth_listener;\n\tpost[SSH_CHANNEL_CONNECTING] =\t\t&channel_post_connecting;\n\tpost[SSH_CHANNEL_DYNAMIC] =\t\t&channel_post_open;\n\tpost[SSH_CHANNEL_RDYNAMIC_FINISH] =\t&channel_post_connecting;\n\tpost[SSH_CHANNEL_MUX_LISTENER] =\t&channel_post_mux_listener;\n\tpost[SSH_CHANNEL_MUX_CLIENT] =\t\t&channel_post_mux_client;\n\n\tsc->channel_pre = pre;\n\tsc->channel_post = post;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: allocation failed\"",
            "__func__"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "SSH_CHANNEL_MAX_TYPE",
            "sizeof(*post)"
          ],
          "line": 2345
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic void\nchannel_handler_init(struct ssh_channels *sc)\n{\n\tchan_fn **pre, **post;\n\n\tif ((pre = calloc(SSH_CHANNEL_MAX_TYPE, sizeof(*pre))) == NULL ||\n\t   (post = calloc(SSH_CHANNEL_MAX_TYPE, sizeof(*post))) == NULL)\n\t\tfatal(\"%s: allocation failed\", __func__);\n\n\tpre[SSH_CHANNEL_OPEN] =\t\t\t&channel_pre_open;\n\tpre[SSH_CHANNEL_X11_OPEN] =\t\t&channel_pre_x11_open;\n\tpre[SSH_CHANNEL_PORT_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_RPORT_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_UNIX_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_RUNIX_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_X11_LISTENER] =\t\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_AUTH_SOCKET] =\t\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_CONNECTING] =\t\t&channel_pre_connecting;\n\tpre[SSH_CHANNEL_DYNAMIC] =\t\t&channel_pre_dynamic;\n\tpre[SSH_CHANNEL_RDYNAMIC_FINISH] =\t&channel_pre_connecting;\n\tpre[SSH_CHANNEL_MUX_LISTENER] =\t\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_MUX_CLIENT] =\t\t&channel_pre_mux_client;\n\n\tpost[SSH_CHANNEL_OPEN] =\t\t&channel_post_open;\n\tpost[SSH_CHANNEL_PORT_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_RPORT_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_UNIX_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_RUNIX_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_X11_LISTENER] =\t&channel_post_x11_listener;\n\tpost[SSH_CHANNEL_AUTH_SOCKET] =\t\t&channel_post_auth_listener;\n\tpost[SSH_CHANNEL_CONNECTING] =\t\t&channel_post_connecting;\n\tpost[SSH_CHANNEL_DYNAMIC] =\t\t&channel_post_open;\n\tpost[SSH_CHANNEL_RDYNAMIC_FINISH] =\t&channel_post_connecting;\n\tpost[SSH_CHANNEL_MUX_LISTENER] =\t&channel_post_mux_listener;\n\tpost[SSH_CHANNEL_MUX_CLIENT] =\t\t&channel_post_mux_client;\n\n\tsc->channel_pre = pre;\n\tsc->channel_post = post;\n}"
  },
  {
    "function_name": "channel_post_mux_listener",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2287-2337",
    "snippet": "static void\nchannel_post_mux_listener(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tChannel *nc;\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tint newsock;\n\tuid_t euid;\n\tgid_t egid;\n\n\tif (!FD_ISSET(c->sock, readset))\n\t\treturn;\n\n\tdebug(\"multiplexing control connection\");\n\n\t/*\n\t * Accept connection on control socket\n\t */\n\tmemset(&addr, 0, sizeof(addr));\n\taddrlen = sizeof(addr);\n\tif ((newsock = accept(c->sock, (struct sockaddr*)&addr,\n\t    &addrlen)) == -1) {\n\t\terror(\"%s accept: %s\", __func__, strerror(errno));\n\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\tc->notbefore = monotime() + 1;\n\t\treturn;\n\t}\n\n\tif (getpeereid(newsock, &euid, &egid) < 0) {\n\t\terror(\"%s getpeereid failed: %s\", __func__,\n\t\t    strerror(errno));\n\t\tclose(newsock);\n\t\treturn;\n\t}\n\tif ((euid != 0) && (getuid() != euid)) {\n\t\terror(\"multiplex uid mismatch: peer euid %u != uid %u\",\n\t\t    (u_int)euid, (u_int)getuid());\n\t\tclose(newsock);\n\t\treturn;\n\t}\n\tnc = channel_new(ssh, \"multiplex client\", SSH_CHANNEL_MUX_CLIENT,\n\t    newsock, newsock, -1, c->local_window_max,\n\t    c->local_maxpacket, 0, \"mux-control\", 1);\n\tnc->mux_rcb = c->mux_rcb;\n\tdebug3(\"%s: new mux channel %d fd %d\", __func__, nc->self, nc->sock);\n\t/* establish state */\n\tnc->mux_rcb(ssh, nc);\n\t/* mux state transitions must not elicit protocol messages */\n\tnc->flags |= CHAN_LOCAL;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nc->mux_rcb",
          "args": [
            "ssh",
            "nc"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: new mux channel %d fd %d\"",
            "__func__",
            "nc->self",
            "nc->sock"
          ],
          "line": 2332
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "\"multiplex client\"",
            "SSH_CHANNEL_MUX_CLIENT",
            "newsock",
            "newsock",
            "-1",
            "c->local_window_max",
            "c->local_maxpacket",
            "0",
            "\"mux-control\"",
            "1"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "newsock"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "channel_close_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "656-664",
          "snippet": "void\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"multiplex uid mismatch: peer euid %u != uid %u\"",
            "(u_int)euid",
            "(u_int)getuid()"
          ],
          "line": 2323
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpeereid",
          "args": [
            "newsock",
            "&euid",
            "&egid"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "getpeereid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-getpeereid.c",
          "lines": "63-70",
          "snippet": "int\ngetpeereid(int s, uid_t *euid, gid_t *gid)\n{\n\t*euid = geteuid();\n\t*gid = getgid();\n\n\treturn (0);\n}",
          "includes": [
            "# include <ucred.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <ucred.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ngetpeereid(int s, uid_t *euid, gid_t *gid)\n{\n\t*euid = geteuid();\n\t*gid = getgid();\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "monotime",
          "args": [],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "monotime_double",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1324-1331",
          "snippet": "double\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\ndouble\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "c->sock",
            "(struct sockaddr*)&addr",
            "&addrlen"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "input_userauth_service_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "419-449",
          "snippet": "int\ninput_userauth_service_accept(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r;\n\n\tif (ssh_packet_remaining(ssh) > 0) {\n\t\tchar *reply;\n\n\t\tif ((r = sshpkt_get_cstring(ssh, &reply, NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"service_accept: %s\", reply);\n\t\tfree(reply);\n\t} else {\n\t\tdebug2(\"buggy server: service_accept w/o service\");\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tdebug(\"SSH2_MSG_SERVICE_ACCEPT received\");\n\n\t/* initial userauth request */\n\tuserauth_none(authctxt);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);\n\tr = 0;\n out:\n\treturn r;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\n\nint\ninput_userauth_service_accept(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r;\n\n\tif (ssh_packet_remaining(ssh) > 0) {\n\t\tchar *reply;\n\n\t\tif ((r = sshpkt_get_cstring(ssh, &reply, NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"service_accept: %s\", reply);\n\t\tfree(reply);\n\t} else {\n\t\tdebug2(\"buggy server: service_accept w/o service\");\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tdebug(\"SSH2_MSG_SERVICE_ACCEPT received\");\n\n\t/* initial userauth request */\n\tuserauth_none(authctxt);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);\n\tr = 0;\n out:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&addr",
            "0",
            "sizeof(addr)"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "c->sock",
            "readset"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_ISSET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "22-24",
          "snippet": "int kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nint kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_post_mux_listener(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tChannel *nc;\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tint newsock;\n\tuid_t euid;\n\tgid_t egid;\n\n\tif (!FD_ISSET(c->sock, readset))\n\t\treturn;\n\n\tdebug(\"multiplexing control connection\");\n\n\t/*\n\t * Accept connection on control socket\n\t */\n\tmemset(&addr, 0, sizeof(addr));\n\taddrlen = sizeof(addr);\n\tif ((newsock = accept(c->sock, (struct sockaddr*)&addr,\n\t    &addrlen)) == -1) {\n\t\terror(\"%s accept: %s\", __func__, strerror(errno));\n\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\tc->notbefore = monotime() + 1;\n\t\treturn;\n\t}\n\n\tif (getpeereid(newsock, &euid, &egid) < 0) {\n\t\terror(\"%s getpeereid failed: %s\", __func__,\n\t\t    strerror(errno));\n\t\tclose(newsock);\n\t\treturn;\n\t}\n\tif ((euid != 0) && (getuid() != euid)) {\n\t\terror(\"multiplex uid mismatch: peer euid %u != uid %u\",\n\t\t    (u_int)euid, (u_int)getuid());\n\t\tclose(newsock);\n\t\treturn;\n\t}\n\tnc = channel_new(ssh, \"multiplex client\", SSH_CHANNEL_MUX_CLIENT,\n\t    newsock, newsock, -1, c->local_window_max,\n\t    c->local_maxpacket, 0, \"mux-control\", 1);\n\tnc->mux_rcb = c->mux_rcb;\n\tdebug3(\"%s: new mux channel %d fd %d\", __func__, nc->self, nc->sock);\n\t/* establish state */\n\tnc->mux_rcb(ssh, nc);\n\t/* mux state transitions must not elicit protocol messages */\n\tnc->flags |= CHAN_LOCAL;\n}"
  },
  {
    "function_name": "channel_post_mux_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2279-2285",
    "snippet": "static void\nchannel_post_mux_client(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tchannel_post_mux_client_read(ssh, c, readset, writeset);\n\tchannel_post_mux_client_write(ssh, c, readset, writeset);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_post_mux_client_write",
          "args": [
            "ssh",
            "c",
            "readset",
            "writeset"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "channel_post_mux_client_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2256-2277",
          "snippet": "static void\nchannel_post_mux_client_write(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tssize_t len;\n\tint r;\n\n\tif (c->wfd == -1 || !FD_ISSET(c->wfd, writeset) ||\n\t    sshbuf_len(c->output) == 0)\n\t\treturn;\n\n\tlen = write(c->wfd, sshbuf_ptr(c->output), sshbuf_len(c->output));\n\tif (len < 0 && (errno == EINTR || errno == EAGAIN))\n\t\treturn;\n\tif (len <= 0) {\n\t\tchan_mark_dead(ssh, c);\n\t\treturn;\n\t}\n\tif ((r = sshbuf_consume(c->output, len)) != 0)\n\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_post_mux_client_write(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tssize_t len;\n\tint r;\n\n\tif (c->wfd == -1 || !FD_ISSET(c->wfd, writeset) ||\n\t    sshbuf_len(c->output) == 0)\n\t\treturn;\n\n\tlen = write(c->wfd, sshbuf_ptr(c->output), sshbuf_len(c->output));\n\tif (len < 0 && (errno == EINTR || errno == EAGAIN))\n\t\treturn;\n\tif (len <= 0) {\n\t\tchan_mark_dead(ssh, c);\n\t\treturn;\n\t}\n\tif ((r = sshbuf_consume(c->output, len)) != 0)\n\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_post_mux_client_read",
          "args": [
            "ssh",
            "c",
            "readset",
            "writeset"
          ],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "channel_post_mux_client_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2219-2254",
          "snippet": "static void\nchannel_post_mux_client_read(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tu_int need;\n\n\tif (c->rfd == -1 || !FD_ISSET(c->rfd, readset))\n\t\treturn;\n\tif (c->istate != CHAN_INPUT_OPEN && c->istate != CHAN_INPUT_WAIT_DRAIN)\n\t\treturn;\n\tif (c->mux_pause)\n\t\treturn;\n\n\t/*\n\t * Don't not read past the precise end of packets to\n\t * avoid disrupting fd passing.\n\t */\n\tif (read_mux(ssh, c, 4) < 4) /* read header */\n\t\treturn;\n\t/* XXX sshbuf_peek_u32 */\n\tneed = PEEK_U32(sshbuf_ptr(c->input));\n#define CHANNEL_MUX_MAX_PACKET\t(256 * 1024)\n\tif (need > CHANNEL_MUX_MAX_PACKET) {\n\t\tdebug2(\"channel %d: packet too big %u > %u\",\n\t\t    c->self, CHANNEL_MUX_MAX_PACKET, need);\n\t\tchan_rcvd_oclose(ssh, c);\n\t\treturn;\n\t}\n\tif (read_mux(ssh, c, need + 4) < need + 4) /* read body */\n\t\treturn;\n\tif (c->mux_rcb(ssh, c) != 0) {\n\t\tdebug(\"channel %d: mux_rcb failed\", c->self);\n\t\tchan_mark_dead(ssh, c);\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CHANNEL_MUX_MAX_PACKET\t(256 * 1024)"
          ],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CHANNEL_MUX_MAX_PACKET\t(256 * 1024)\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_post_mux_client_read(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tu_int need;\n\n\tif (c->rfd == -1 || !FD_ISSET(c->rfd, readset))\n\t\treturn;\n\tif (c->istate != CHAN_INPUT_OPEN && c->istate != CHAN_INPUT_WAIT_DRAIN)\n\t\treturn;\n\tif (c->mux_pause)\n\t\treturn;\n\n\t/*\n\t * Don't not read past the precise end of packets to\n\t * avoid disrupting fd passing.\n\t */\n\tif (read_mux(ssh, c, 4) < 4) /* read header */\n\t\treturn;\n\t/* XXX sshbuf_peek_u32 */\n\tneed = PEEK_U32(sshbuf_ptr(c->input));\n#define CHANNEL_MUX_MAX_PACKET\t(256 * 1024)\n\tif (need > CHANNEL_MUX_MAX_PACKET) {\n\t\tdebug2(\"channel %d: packet too big %u > %u\",\n\t\t    c->self, CHANNEL_MUX_MAX_PACKET, need);\n\t\tchan_rcvd_oclose(ssh, c);\n\t\treturn;\n\t}\n\tif (read_mux(ssh, c, need + 4) < need + 4) /* read body */\n\t\treturn;\n\tif (c->mux_rcb(ssh, c) != 0) {\n\t\tdebug(\"channel %d: mux_rcb failed\", c->self);\n\t\tchan_mark_dead(ssh, c);\n\t\treturn;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_post_mux_client(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tchannel_post_mux_client_read(ssh, c, readset, writeset);\n\tchannel_post_mux_client_write(ssh, c, readset, writeset);\n}"
  },
  {
    "function_name": "channel_post_mux_client_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2256-2277",
    "snippet": "static void\nchannel_post_mux_client_write(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tssize_t len;\n\tint r;\n\n\tif (c->wfd == -1 || !FD_ISSET(c->wfd, writeset) ||\n\t    sshbuf_len(c->output) == 0)\n\t\treturn;\n\n\tlen = write(c->wfd, sshbuf_ptr(c->output), sshbuf_len(c->output));\n\tif (len < 0 && (errno == EINTR || errno == EAGAIN))\n\t\treturn;\n\tif (len <= 0) {\n\t\tchan_mark_dead(ssh, c);\n\t\treturn;\n\t}\n\tif ((r = sshbuf_consume(c->output, len)) != 0)\n\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %d: consume: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "c->output",
            "len"
          ],
          "line": 2274
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_mark_dead",
          "args": [
            "ssh",
            "c"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "chan_mark_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "324-328",
          "snippet": "void\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "c->wfd",
            "sshbuf_ptr(c->output)",
            "sshbuf_len(c->output)"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "c->output"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "c->output"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "c->wfd",
            "writeset"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_ISSET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "22-24",
          "snippet": "int kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nint kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_post_mux_client_write(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tssize_t len;\n\tint r;\n\n\tif (c->wfd == -1 || !FD_ISSET(c->wfd, writeset) ||\n\t    sshbuf_len(c->output) == 0)\n\t\treturn;\n\n\tlen = write(c->wfd, sshbuf_ptr(c->output), sshbuf_len(c->output));\n\tif (len < 0 && (errno == EINTR || errno == EAGAIN))\n\t\treturn;\n\tif (len <= 0) {\n\t\tchan_mark_dead(ssh, c);\n\t\treturn;\n\t}\n\tif ((r = sshbuf_consume(c->output, len)) != 0)\n\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n}"
  },
  {
    "function_name": "channel_post_mux_client_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2219-2254",
    "snippet": "static void\nchannel_post_mux_client_read(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tu_int need;\n\n\tif (c->rfd == -1 || !FD_ISSET(c->rfd, readset))\n\t\treturn;\n\tif (c->istate != CHAN_INPUT_OPEN && c->istate != CHAN_INPUT_WAIT_DRAIN)\n\t\treturn;\n\tif (c->mux_pause)\n\t\treturn;\n\n\t/*\n\t * Don't not read past the precise end of packets to\n\t * avoid disrupting fd passing.\n\t */\n\tif (read_mux(ssh, c, 4) < 4) /* read header */\n\t\treturn;\n\t/* XXX sshbuf_peek_u32 */\n\tneed = PEEK_U32(sshbuf_ptr(c->input));\n#define CHANNEL_MUX_MAX_PACKET\t(256 * 1024)\n\tif (need > CHANNEL_MUX_MAX_PACKET) {\n\t\tdebug2(\"channel %d: packet too big %u > %u\",\n\t\t    c->self, CHANNEL_MUX_MAX_PACKET, need);\n\t\tchan_rcvd_oclose(ssh, c);\n\t\treturn;\n\t}\n\tif (read_mux(ssh, c, need + 4) < need + 4) /* read body */\n\t\treturn;\n\tif (c->mux_rcb(ssh, c) != 0) {\n\t\tdebug(\"channel %d: mux_rcb failed\", c->self);\n\t\tchan_mark_dead(ssh, c);\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define CHANNEL_MUX_MAX_PACKET\t(256 * 1024)"
    ],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "chan_mark_dead",
          "args": [
            "ssh",
            "c"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "chan_mark_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "324-328",
          "snippet": "void\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"channel %d: mux_rcb failed\"",
            "c->self"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->mux_rcb",
          "args": [
            "ssh",
            "c"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mux",
          "args": [
            "ssh",
            "c",
            "need + 4"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "read_mux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2193-2217",
          "snippet": "static u_int\nread_mux(struct ssh *ssh, Channel *c, u_int need)\n{\n\tchar buf[CHAN_RBUF];\n\tssize_t len;\n\tu_int rlen;\n\tint r;\n\n\tif (sshbuf_len(c->input) < need) {\n\t\trlen = need - sshbuf_len(c->input);\n\t\tlen = read(c->rfd, buf, MINIMUM(rlen, CHAN_RBUF));\n\t\tif (len < 0 && (errno == EINTR || errno == EAGAIN))\n\t\t\treturn sshbuf_len(c->input);\n\t\tif (len <= 0) {\n\t\t\tdebug2(\"channel %d: ctl read<=0 rfd %d len %zd\",\n\t\t\t    c->self, c->rfd, len);\n\t\t\tchan_read_failed(ssh, c);\n\t\t\treturn 0;\n\t\t} else if ((r = sshbuf_put(c->input, buf, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: append: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t}\n\treturn sshbuf_len(c->input);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic u_int\nread_mux(struct ssh *ssh, Channel *c, u_int need)\n{\n\tchar buf[CHAN_RBUF];\n\tssize_t len;\n\tu_int rlen;\n\tint r;\n\n\tif (sshbuf_len(c->input) < need) {\n\t\trlen = need - sshbuf_len(c->input);\n\t\tlen = read(c->rfd, buf, MINIMUM(rlen, CHAN_RBUF));\n\t\tif (len < 0 && (errno == EINTR || errno == EAGAIN))\n\t\t\treturn sshbuf_len(c->input);\n\t\tif (len <= 0) {\n\t\t\tdebug2(\"channel %d: ctl read<=0 rfd %d len %zd\",\n\t\t\t    c->self, c->rfd, len);\n\t\t\tchan_read_failed(ssh, c);\n\t\t\treturn 0;\n\t\t} else if ((r = sshbuf_put(c->input, buf, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: append: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t}\n\treturn sshbuf_len(c->input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_rcvd_oclose",
          "args": [
            "ssh",
            "c"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "chan_rcvd_oclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "265-303",
          "snippet": "void\nchan_rcvd_oclose(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: rcvd close\", c->self);\n\tif (!(c->flags & CHAN_LOCAL)) {\n\t\tif (c->flags & CHAN_CLOSE_RCVD)\n\t\t\terror(\"channel %d: protocol error: close rcvd twice\",\n\t\t\t    c->self);\n\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t}\n\tif (c->type == SSH_CHANNEL_LARVAL) {\n\t\t/* tear down larval channels immediately */\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\treturn;\n\t}\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\t\t/*\n\t\t * wait until a data from the channel is consumed if a CLOSE\n\t\t * is received\n\t\t */\n\t\tchan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);\n\t\tbreak;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_shutdown_extended_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & CHAN_LOCAL))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_shutdown_extended_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_rcvd_oclose(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: rcvd close\", c->self);\n\tif (!(c->flags & CHAN_LOCAL)) {\n\t\tif (c->flags & CHAN_CLOSE_RCVD)\n\t\t\terror(\"channel %d: protocol error: close rcvd twice\",\n\t\t\t    c->self);\n\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t}\n\tif (c->type == SSH_CHANNEL_LARVAL) {\n\t\t/* tear down larval channels immediately */\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\treturn;\n\t}\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\t\t/*\n\t\t * wait until a data from the channel is consumed if a CLOSE\n\t\t * is received\n\t\t */\n\t\tchan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);\n\t\tbreak;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_shutdown_extended_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & CHAN_LOCAL))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_shutdown_extended_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: packet too big %u > %u\"",
            "c->self",
            "CHANNEL_MUX_MAX_PACKET",
            "need"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PEEK_U32",
          "args": [
            "sshbuf_ptr(c->input)"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "c->input"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "c->rfd",
            "readset"
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_ISSET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "22-24",
          "snippet": "int kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nint kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CHANNEL_MUX_MAX_PACKET\t(256 * 1024)\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_post_mux_client_read(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tu_int need;\n\n\tif (c->rfd == -1 || !FD_ISSET(c->rfd, readset))\n\t\treturn;\n\tif (c->istate != CHAN_INPUT_OPEN && c->istate != CHAN_INPUT_WAIT_DRAIN)\n\t\treturn;\n\tif (c->mux_pause)\n\t\treturn;\n\n\t/*\n\t * Don't not read past the precise end of packets to\n\t * avoid disrupting fd passing.\n\t */\n\tif (read_mux(ssh, c, 4) < 4) /* read header */\n\t\treturn;\n\t/* XXX sshbuf_peek_u32 */\n\tneed = PEEK_U32(sshbuf_ptr(c->input));\n#define CHANNEL_MUX_MAX_PACKET\t(256 * 1024)\n\tif (need > CHANNEL_MUX_MAX_PACKET) {\n\t\tdebug2(\"channel %d: packet too big %u > %u\",\n\t\t    c->self, CHANNEL_MUX_MAX_PACKET, need);\n\t\tchan_rcvd_oclose(ssh, c);\n\t\treturn;\n\t}\n\tif (read_mux(ssh, c, need + 4) < need + 4) /* read body */\n\t\treturn;\n\tif (c->mux_rcb(ssh, c) != 0) {\n\t\tdebug(\"channel %d: mux_rcb failed\", c->self);\n\t\tchan_mark_dead(ssh, c);\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "read_mux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2193-2217",
    "snippet": "static u_int\nread_mux(struct ssh *ssh, Channel *c, u_int need)\n{\n\tchar buf[CHAN_RBUF];\n\tssize_t len;\n\tu_int rlen;\n\tint r;\n\n\tif (sshbuf_len(c->input) < need) {\n\t\trlen = need - sshbuf_len(c->input);\n\t\tlen = read(c->rfd, buf, MINIMUM(rlen, CHAN_RBUF));\n\t\tif (len < 0 && (errno == EINTR || errno == EAGAIN))\n\t\t\treturn sshbuf_len(c->input);\n\t\tif (len <= 0) {\n\t\t\tdebug2(\"channel %d: ctl read<=0 rfd %d len %zd\",\n\t\t\t    c->self, c->rfd, len);\n\t\t\tchan_read_failed(ssh, c);\n\t\t\treturn 0;\n\t\t} else if ((r = sshbuf_put(c->input, buf, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: append: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t}\n\treturn sshbuf_len(c->input);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "c->input"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %d: append: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "c->input",
            "buf",
            "len"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_read_failed",
          "args": [
            "ssh",
            "c"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "chan_read_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "108-122",
          "snippet": "void\nchan_read_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: read failed\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_WAIT_DRAIN);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_read_failed for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_read_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: read failed\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_WAIT_DRAIN);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_read_failed for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: ctl read<=0 rfd %d len %zd\"",
            "c->self",
            "c->rfd",
            "len"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "c->rfd",
            "buf",
            "MINIMUM(rlen, CHAN_RBUF)"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "read_mux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2193-2217",
          "snippet": "static u_int\nread_mux(struct ssh *ssh, Channel *c, u_int need)\n{\n\tchar buf[CHAN_RBUF];\n\tssize_t len;\n\tu_int rlen;\n\tint r;\n\n\tif (sshbuf_len(c->input) < need) {\n\t\trlen = need - sshbuf_len(c->input);\n\t\tlen = read(c->rfd, buf, MINIMUM(rlen, CHAN_RBUF));\n\t\tif (len < 0 && (errno == EINTR || errno == EAGAIN))\n\t\t\treturn sshbuf_len(c->input);\n\t\tif (len <= 0) {\n\t\t\tdebug2(\"channel %d: ctl read<=0 rfd %d len %zd\",\n\t\t\t    c->self, c->rfd, len);\n\t\t\tchan_read_failed(ssh, c);\n\t\t\treturn 0;\n\t\t} else if ((r = sshbuf_put(c->input, buf, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: append: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t}\n\treturn sshbuf_len(c->input);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "rlen",
            "CHAN_RBUF"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic u_int\nread_mux(struct ssh *ssh, Channel *c, u_int need)\n{\n\tchar buf[CHAN_RBUF];\n\tssize_t len;\n\tu_int rlen;\n\tint r;\n\n\tif (sshbuf_len(c->input) < need) {\n\t\trlen = need - sshbuf_len(c->input);\n\t\tlen = read(c->rfd, buf, MINIMUM(rlen, CHAN_RBUF));\n\t\tif (len < 0 && (errno == EINTR || errno == EAGAIN))\n\t\t\treturn sshbuf_len(c->input);\n\t\tif (len <= 0) {\n\t\t\tdebug2(\"channel %d: ctl read<=0 rfd %d len %zd\",\n\t\t\t    c->self, c->rfd, len);\n\t\t\tchan_read_failed(ssh, c);\n\t\t\treturn 0;\n\t\t} else if ((r = sshbuf_put(c->input, buf, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: append: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t}\n\treturn sshbuf_len(c->input);\n}"
  },
  {
    "function_name": "channel_post_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2183-2191",
    "snippet": "static void\nchannel_post_open(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tchannel_handle_rfd(ssh, c, readset, writeset);\n\tchannel_handle_wfd(ssh, c, readset, writeset);\n\tchannel_handle_efd(ssh, c, readset, writeset);\n\tchannel_check_window(ssh, c);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_check_window",
          "args": [
            "ssh",
            "c"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "channel_check_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2152-2181",
          "snippet": "static int\nchannel_check_window(struct ssh *ssh, Channel *c)\n{\n\tint r;\n\n\tif (c->type == SSH_CHANNEL_OPEN &&\n\t    !(c->flags & (CHAN_CLOSE_SENT|CHAN_CLOSE_RCVD)) &&\n\t    ((c->local_window_max - c->local_window >\n\t    c->local_maxpacket*3) ||\n\t    c->local_window < c->local_window_max/2) &&\n\t    c->local_consumed > 0) {\n\t\tif (!c->have_remote_id)\n\t\t\tfatal(\":%s: channel %d: no remote id\",\n\t\t\t    __func__, c->self);\n\t\tif ((r = sshpkt_start(ssh,\n\t\t    SSH2_MSG_CHANNEL_WINDOW_ADJUST)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->local_consumed)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\tfatal(\"%s: channel %i: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\tdebug2(\"channel %d: window %d sent adjust %d\",\n\t\t    c->self, c->local_window,\n\t\t    c->local_consumed);\n\t\tc->local_window += c->local_consumed;\n\t\tc->local_consumed = 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_check_window(struct ssh *ssh, Channel *c)\n{\n\tint r;\n\n\tif (c->type == SSH_CHANNEL_OPEN &&\n\t    !(c->flags & (CHAN_CLOSE_SENT|CHAN_CLOSE_RCVD)) &&\n\t    ((c->local_window_max - c->local_window >\n\t    c->local_maxpacket*3) ||\n\t    c->local_window < c->local_window_max/2) &&\n\t    c->local_consumed > 0) {\n\t\tif (!c->have_remote_id)\n\t\t\tfatal(\":%s: channel %d: no remote id\",\n\t\t\t    __func__, c->self);\n\t\tif ((r = sshpkt_start(ssh,\n\t\t    SSH2_MSG_CHANNEL_WINDOW_ADJUST)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->local_consumed)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\tfatal(\"%s: channel %i: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\tdebug2(\"channel %d: window %d sent adjust %d\",\n\t\t    c->self, c->local_window,\n\t\t    c->local_consumed);\n\t\tc->local_window += c->local_consumed;\n\t\tc->local_consumed = 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_handle_efd",
          "args": [
            "ssh",
            "c",
            "readset",
            "writeset"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "channel_handle_efd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2134-2150",
          "snippet": "static int\nchannel_handle_efd(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tif (c->efd == -1)\n\t\treturn 1;\n\n\t/** XXX handle drain efd, too */\n\n\tif (c->extended_usage == CHAN_EXTENDED_WRITE)\n\t\treturn channel_handle_efd_write(ssh, c, readset, writeset);\n\telse if (c->extended_usage == CHAN_EXTENDED_READ ||\n\t    c->extended_usage == CHAN_EXTENDED_IGNORE)\n\t\treturn channel_handle_efd_read(ssh, c, readset, writeset);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_handle_efd(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tif (c->efd == -1)\n\t\treturn 1;\n\n\t/** XXX handle drain efd, too */\n\n\tif (c->extended_usage == CHAN_EXTENDED_WRITE)\n\t\treturn channel_handle_efd_write(ssh, c, readset, writeset);\n\telse if (c->extended_usage == CHAN_EXTENDED_READ ||\n\t    c->extended_usage == CHAN_EXTENDED_IGNORE)\n\t\treturn channel_handle_efd_read(ssh, c, readset, writeset);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_handle_wfd",
          "args": [
            "ssh",
            "c",
            "readset",
            "writeset"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "channel_handle_wfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1979-2071",
          "snippet": "static int\nchannel_handle_wfd(struct ssh *ssh, Channel *c,\n   fd_set *readset, fd_set *writeset)\n{\n\tstruct termios tio;\n\tu_char *data = NULL, *buf; /* XXX const; need filter API change */\n\tsize_t dlen, olen = 0;\n\tint r, len;\n\n\tif (c->wfd == -1 || !FD_ISSET(c->wfd, writeset) ||\n\t    sshbuf_len(c->output) == 0)\n\t\treturn 1;\n\n\t/* Send buffered output data to the socket. */\n\tolen = sshbuf_len(c->output);\n\tif (c->output_filter != NULL) {\n\t\tif ((buf = c->output_filter(ssh, c, &data, &dlen)) == NULL) {\n\t\t\tdebug2(\"channel %d: filter stops\", c->self);\n\t\t\tif (c->type != SSH_CHANNEL_OPEN)\n\t\t\t\tchan_mark_dead(ssh, c);\n\t\t\telse\n\t\t\t\tchan_write_failed(ssh, c);\n\t\t\treturn -1;\n\t\t}\n\t} else if (c->datagram) {\n\t\tif ((r = sshbuf_get_string(c->output, &data, &dlen)) != 0)\n\t\t\tfatal(\"%s: channel %d: get datagram: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\tbuf = data;\n\t} else {\n\t\tbuf = data = sshbuf_mutable_ptr(c->output);\n\t\tdlen = sshbuf_len(c->output);\n\t}\n\n\tif (c->datagram) {\n\t\t/* ignore truncated writes, datagrams might get lost */\n\t\tlen = write(c->wfd, buf, dlen);\n\t\tfree(data);\n\t\tif (len < 0 && (errno == EINTR || errno == EAGAIN ||\n\t\t    errno == EWOULDBLOCK))\n\t\t\treturn 1;\n\t\tif (len <= 0)\n\t\t\tgoto write_fail;\n\t\tgoto out;\n\t}\n\n#ifdef _AIX\n\t/* XXX: Later AIX versions can't push as much data to tty */\n\tif (c->wfd_isatty)\n\t\tdlen = MIN(dlen, 8*1024);\n#endif\n\n\tlen = write(c->wfd, buf, dlen);\n\tif (len < 0 &&\n\t    (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK))\n\t\treturn 1;\n\tif (len <= 0) {\n write_fail:\n\t\tif (c->type != SSH_CHANNEL_OPEN) {\n\t\t\tdebug2(\"channel %d: not open\", c->self);\n\t\t\tchan_mark_dead(ssh, c);\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tchan_write_failed(ssh, c);\n\t\t}\n\t\treturn -1;\n\t}\n#ifndef BROKEN_TCGETATTR_ICANON\n\tif (c->isatty && dlen >= 1 && buf[0] != '\\r') {\n\t\tif (tcgetattr(c->wfd, &tio) == 0 &&\n\t\t    !(tio.c_lflag & ECHO) && (tio.c_lflag & ICANON)) {\n\t\t\t/*\n\t\t\t * Simulate echo to reduce the impact of\n\t\t\t * traffic analysis. We need to match the\n\t\t\t * size of a SSH2_MSG_CHANNEL_DATA message\n\t\t\t * (4 byte channel id + buf)\n\t\t\t */\n\t\t\tif ((r = sshpkt_msg_ignore(ssh, 4+len)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: channel %d: ignore: %s\",\n\t\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t}\n#endif /* BROKEN_TCGETATTR_ICANON */\n\tif ((r = sshbuf_consume(c->output, len)) != 0) {\n\t\tfatal(\"%s: channel %d: consume: %s\",\n\t\t    __func__, c->self, ssh_err(r));\n\t}\n out:\n\tc->local_consumed += olen - sshbuf_len(c->output);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_handle_wfd(struct ssh *ssh, Channel *c,\n   fd_set *readset, fd_set *writeset)\n{\n\tstruct termios tio;\n\tu_char *data = NULL, *buf; /* XXX const; need filter API change */\n\tsize_t dlen, olen = 0;\n\tint r, len;\n\n\tif (c->wfd == -1 || !FD_ISSET(c->wfd, writeset) ||\n\t    sshbuf_len(c->output) == 0)\n\t\treturn 1;\n\n\t/* Send buffered output data to the socket. */\n\tolen = sshbuf_len(c->output);\n\tif (c->output_filter != NULL) {\n\t\tif ((buf = c->output_filter(ssh, c, &data, &dlen)) == NULL) {\n\t\t\tdebug2(\"channel %d: filter stops\", c->self);\n\t\t\tif (c->type != SSH_CHANNEL_OPEN)\n\t\t\t\tchan_mark_dead(ssh, c);\n\t\t\telse\n\t\t\t\tchan_write_failed(ssh, c);\n\t\t\treturn -1;\n\t\t}\n\t} else if (c->datagram) {\n\t\tif ((r = sshbuf_get_string(c->output, &data, &dlen)) != 0)\n\t\t\tfatal(\"%s: channel %d: get datagram: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\tbuf = data;\n\t} else {\n\t\tbuf = data = sshbuf_mutable_ptr(c->output);\n\t\tdlen = sshbuf_len(c->output);\n\t}\n\n\tif (c->datagram) {\n\t\t/* ignore truncated writes, datagrams might get lost */\n\t\tlen = write(c->wfd, buf, dlen);\n\t\tfree(data);\n\t\tif (len < 0 && (errno == EINTR || errno == EAGAIN ||\n\t\t    errno == EWOULDBLOCK))\n\t\t\treturn 1;\n\t\tif (len <= 0)\n\t\t\tgoto write_fail;\n\t\tgoto out;\n\t}\n\n#ifdef _AIX\n\t/* XXX: Later AIX versions can't push as much data to tty */\n\tif (c->wfd_isatty)\n\t\tdlen = MIN(dlen, 8*1024);\n#endif\n\n\tlen = write(c->wfd, buf, dlen);\n\tif (len < 0 &&\n\t    (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK))\n\t\treturn 1;\n\tif (len <= 0) {\n write_fail:\n\t\tif (c->type != SSH_CHANNEL_OPEN) {\n\t\t\tdebug2(\"channel %d: not open\", c->self);\n\t\t\tchan_mark_dead(ssh, c);\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tchan_write_failed(ssh, c);\n\t\t}\n\t\treturn -1;\n\t}\n#ifndef BROKEN_TCGETATTR_ICANON\n\tif (c->isatty && dlen >= 1 && buf[0] != '\\r') {\n\t\tif (tcgetattr(c->wfd, &tio) == 0 &&\n\t\t    !(tio.c_lflag & ECHO) && (tio.c_lflag & ICANON)) {\n\t\t\t/*\n\t\t\t * Simulate echo to reduce the impact of\n\t\t\t * traffic analysis. We need to match the\n\t\t\t * size of a SSH2_MSG_CHANNEL_DATA message\n\t\t\t * (4 byte channel id + buf)\n\t\t\t */\n\t\t\tif ((r = sshpkt_msg_ignore(ssh, 4+len)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: channel %d: ignore: %s\",\n\t\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t}\n#endif /* BROKEN_TCGETATTR_ICANON */\n\tif ((r = sshbuf_consume(c->output, len)) != 0) {\n\t\tfatal(\"%s: channel %d: consume: %s\",\n\t\t    __func__, c->self, ssh_err(r));\n\t}\n out:\n\tc->local_consumed += olen - sshbuf_len(c->output);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_handle_rfd",
          "args": [
            "ssh",
            "c",
            "readset",
            "writeset"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_post_open(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tchannel_handle_rfd(ssh, c, readset, writeset);\n\tchannel_handle_wfd(ssh, c, readset, writeset);\n\tchannel_handle_efd(ssh, c, readset, writeset);\n\tchannel_check_window(ssh, c);\n}"
  },
  {
    "function_name": "channel_check_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2152-2181",
    "snippet": "static int\nchannel_check_window(struct ssh *ssh, Channel *c)\n{\n\tint r;\n\n\tif (c->type == SSH_CHANNEL_OPEN &&\n\t    !(c->flags & (CHAN_CLOSE_SENT|CHAN_CLOSE_RCVD)) &&\n\t    ((c->local_window_max - c->local_window >\n\t    c->local_maxpacket*3) ||\n\t    c->local_window < c->local_window_max/2) &&\n\t    c->local_consumed > 0) {\n\t\tif (!c->have_remote_id)\n\t\t\tfatal(\":%s: channel %d: no remote id\",\n\t\t\t    __func__, c->self);\n\t\tif ((r = sshpkt_start(ssh,\n\t\t    SSH2_MSG_CHANNEL_WINDOW_ADJUST)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->local_consumed)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\tfatal(\"%s: channel %i: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\tdebug2(\"channel %d: window %d sent adjust %d\",\n\t\t    c->self, c->local_window,\n\t\t    c->local_consumed);\n\t\tc->local_window += c->local_consumed;\n\t\tc->local_consumed = 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: window %d sent adjust %d\"",
            "c->self",
            "c->local_window",
            "c->local_consumed"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %i: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "c->local_consumed"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_CHANNEL_WINDOW_ADJUST"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_check_window(struct ssh *ssh, Channel *c)\n{\n\tint r;\n\n\tif (c->type == SSH_CHANNEL_OPEN &&\n\t    !(c->flags & (CHAN_CLOSE_SENT|CHAN_CLOSE_RCVD)) &&\n\t    ((c->local_window_max - c->local_window >\n\t    c->local_maxpacket*3) ||\n\t    c->local_window < c->local_window_max/2) &&\n\t    c->local_consumed > 0) {\n\t\tif (!c->have_remote_id)\n\t\t\tfatal(\":%s: channel %d: no remote id\",\n\t\t\t    __func__, c->self);\n\t\tif ((r = sshpkt_start(ssh,\n\t\t    SSH2_MSG_CHANNEL_WINDOW_ADJUST)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->local_consumed)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\tfatal(\"%s: channel %i: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\tdebug2(\"channel %d: window %d sent adjust %d\",\n\t\t    c->self, c->local_window,\n\t\t    c->local_consumed);\n\t\tc->local_window += c->local_consumed;\n\t\tc->local_consumed = 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "channel_handle_efd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2134-2150",
    "snippet": "static int\nchannel_handle_efd(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tif (c->efd == -1)\n\t\treturn 1;\n\n\t/** XXX handle drain efd, too */\n\n\tif (c->extended_usage == CHAN_EXTENDED_WRITE)\n\t\treturn channel_handle_efd_write(ssh, c, readset, writeset);\n\telse if (c->extended_usage == CHAN_EXTENDED_READ ||\n\t    c->extended_usage == CHAN_EXTENDED_IGNORE)\n\t\treturn channel_handle_efd_read(ssh, c, readset, writeset);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_handle_efd_read",
          "args": [
            "ssh",
            "c",
            "readset",
            "writeset"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "channel_handle_efd_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2102-2132",
          "snippet": "static int\nchannel_handle_efd_read(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tchar buf[CHAN_RBUF];\n\tint r;\n\tssize_t len;\n\n\tif (!c->detach_close && !FD_ISSET(c->efd, readset))\n\t\treturn 1;\n\n\tlen = read(c->efd, buf, sizeof(buf));\n\tdebug2(\"channel %d: read %zd from efd %d\", c->self, len, c->efd);\n\tif (len < 0 && (errno == EINTR || ((errno == EAGAIN ||\n\t    errno == EWOULDBLOCK) && !c->detach_close)))\n\t\treturn 1;\n\tif (len <= 0) {\n\t\tdebug2(\"channel %d: closing read-efd %d\",\n\t\t    c->self, c->efd);\n\t\tchannel_close_fd(ssh, &c->efd);\n\t} else {\n\t\tif (c->extended_usage == CHAN_EXTENDED_IGNORE) {\n\t\t\tdebug3(\"channel %d: discard efd\",\n\t\t\t    c->self);\n\t\t} else if ((r = sshbuf_put(c->extended, buf, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: append: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_handle_efd_read(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tchar buf[CHAN_RBUF];\n\tint r;\n\tssize_t len;\n\n\tif (!c->detach_close && !FD_ISSET(c->efd, readset))\n\t\treturn 1;\n\n\tlen = read(c->efd, buf, sizeof(buf));\n\tdebug2(\"channel %d: read %zd from efd %d\", c->self, len, c->efd);\n\tif (len < 0 && (errno == EINTR || ((errno == EAGAIN ||\n\t    errno == EWOULDBLOCK) && !c->detach_close)))\n\t\treturn 1;\n\tif (len <= 0) {\n\t\tdebug2(\"channel %d: closing read-efd %d\",\n\t\t    c->self, c->efd);\n\t\tchannel_close_fd(ssh, &c->efd);\n\t} else {\n\t\tif (c->extended_usage == CHAN_EXTENDED_IGNORE) {\n\t\t\tdebug3(\"channel %d: discard efd\",\n\t\t\t    c->self);\n\t\t} else if ((r = sshbuf_put(c->extended, buf, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: append: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_handle_efd_write",
          "args": [
            "ssh",
            "c",
            "readset",
            "writeset"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "channel_handle_efd_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2073-2100",
          "snippet": "static int\nchannel_handle_efd_write(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tint r;\n\tssize_t len;\n\n\tif (!FD_ISSET(c->efd, writeset) || sshbuf_len(c->extended) == 0)\n\t\treturn 1;\n\n\tlen = write(c->efd, sshbuf_ptr(c->extended),\n\t    sshbuf_len(c->extended));\n\tdebug2(\"channel %d: written %zd to efd %d\", c->self, len, c->efd);\n\tif (len < 0 && (errno == EINTR || errno == EAGAIN ||\n\t    errno == EWOULDBLOCK))\n\t\treturn 1;\n\tif (len <= 0) {\n\t\tdebug2(\"channel %d: closing write-efd %d\", c->self, c->efd);\n\t\tchannel_close_fd(ssh, &c->efd);\n\t} else {\n\t\tif ((r = sshbuf_consume(c->extended, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t\tc->local_consumed += len;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_handle_efd_write(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tint r;\n\tssize_t len;\n\n\tif (!FD_ISSET(c->efd, writeset) || sshbuf_len(c->extended) == 0)\n\t\treturn 1;\n\n\tlen = write(c->efd, sshbuf_ptr(c->extended),\n\t    sshbuf_len(c->extended));\n\tdebug2(\"channel %d: written %zd to efd %d\", c->self, len, c->efd);\n\tif (len < 0 && (errno == EINTR || errno == EAGAIN ||\n\t    errno == EWOULDBLOCK))\n\t\treturn 1;\n\tif (len <= 0) {\n\t\tdebug2(\"channel %d: closing write-efd %d\", c->self, c->efd);\n\t\tchannel_close_fd(ssh, &c->efd);\n\t} else {\n\t\tif ((r = sshbuf_consume(c->extended, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t\tc->local_consumed += len;\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_handle_efd(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tif (c->efd == -1)\n\t\treturn 1;\n\n\t/** XXX handle drain efd, too */\n\n\tif (c->extended_usage == CHAN_EXTENDED_WRITE)\n\t\treturn channel_handle_efd_write(ssh, c, readset, writeset);\n\telse if (c->extended_usage == CHAN_EXTENDED_READ ||\n\t    c->extended_usage == CHAN_EXTENDED_IGNORE)\n\t\treturn channel_handle_efd_read(ssh, c, readset, writeset);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "channel_handle_efd_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2102-2132",
    "snippet": "static int\nchannel_handle_efd_read(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tchar buf[CHAN_RBUF];\n\tint r;\n\tssize_t len;\n\n\tif (!c->detach_close && !FD_ISSET(c->efd, readset))\n\t\treturn 1;\n\n\tlen = read(c->efd, buf, sizeof(buf));\n\tdebug2(\"channel %d: read %zd from efd %d\", c->self, len, c->efd);\n\tif (len < 0 && (errno == EINTR || ((errno == EAGAIN ||\n\t    errno == EWOULDBLOCK) && !c->detach_close)))\n\t\treturn 1;\n\tif (len <= 0) {\n\t\tdebug2(\"channel %d: closing read-efd %d\",\n\t\t    c->self, c->efd);\n\t\tchannel_close_fd(ssh, &c->efd);\n\t} else {\n\t\tif (c->extended_usage == CHAN_EXTENDED_IGNORE) {\n\t\t\tdebug3(\"channel %d: discard efd\",\n\t\t\t    c->self);\n\t\t} else if ((r = sshbuf_put(c->extended, buf, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: append: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %d: append: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "c->extended",
            "buf",
            "len"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"channel %d: discard efd\"",
            "c->self"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_close_fd",
          "args": [
            "ssh",
            "&c->efd"
          ],
          "line": 2121
        },
        "resolved": true,
        "details": {
          "function_name": "channel_close_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "441-453",
          "snippet": "static void\nchannel_close_fds(struct ssh *ssh, Channel *c)\n{\n\tint sock = c->sock, rfd = c->rfd, wfd = c->wfd, efd = c->efd;\n\n\tchannel_close_fd(ssh, &c->sock);\n\tif (rfd != sock)\n\t\tchannel_close_fd(ssh, &c->rfd);\n\tif (wfd != sock && wfd != rfd)\n\t\tchannel_close_fd(ssh, &c->wfd);\n\tif (efd != sock && efd != rfd && efd != wfd)\n\t\tchannel_close_fd(ssh, &c->efd);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_close_fds(struct ssh *ssh, Channel *c)\n{\n\tint sock = c->sock, rfd = c->rfd, wfd = c->wfd, efd = c->efd;\n\n\tchannel_close_fd(ssh, &c->sock);\n\tif (rfd != sock)\n\t\tchannel_close_fd(ssh, &c->rfd);\n\tif (wfd != sock && wfd != rfd)\n\t\tchannel_close_fd(ssh, &c->wfd);\n\tif (efd != sock && efd != rfd && efd != wfd)\n\t\tchannel_close_fd(ssh, &c->efd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: closing read-efd %d\"",
            "c->self",
            "c->efd"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "c->efd",
            "buf",
            "sizeof(buf)"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "read_mux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2193-2217",
          "snippet": "static u_int\nread_mux(struct ssh *ssh, Channel *c, u_int need)\n{\n\tchar buf[CHAN_RBUF];\n\tssize_t len;\n\tu_int rlen;\n\tint r;\n\n\tif (sshbuf_len(c->input) < need) {\n\t\trlen = need - sshbuf_len(c->input);\n\t\tlen = read(c->rfd, buf, MINIMUM(rlen, CHAN_RBUF));\n\t\tif (len < 0 && (errno == EINTR || errno == EAGAIN))\n\t\t\treturn sshbuf_len(c->input);\n\t\tif (len <= 0) {\n\t\t\tdebug2(\"channel %d: ctl read<=0 rfd %d len %zd\",\n\t\t\t    c->self, c->rfd, len);\n\t\t\tchan_read_failed(ssh, c);\n\t\t\treturn 0;\n\t\t} else if ((r = sshbuf_put(c->input, buf, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: append: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t}\n\treturn sshbuf_len(c->input);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic u_int\nread_mux(struct ssh *ssh, Channel *c, u_int need)\n{\n\tchar buf[CHAN_RBUF];\n\tssize_t len;\n\tu_int rlen;\n\tint r;\n\n\tif (sshbuf_len(c->input) < need) {\n\t\trlen = need - sshbuf_len(c->input);\n\t\tlen = read(c->rfd, buf, MINIMUM(rlen, CHAN_RBUF));\n\t\tif (len < 0 && (errno == EINTR || errno == EAGAIN))\n\t\t\treturn sshbuf_len(c->input);\n\t\tif (len <= 0) {\n\t\t\tdebug2(\"channel %d: ctl read<=0 rfd %d len %zd\",\n\t\t\t    c->self, c->rfd, len);\n\t\t\tchan_read_failed(ssh, c);\n\t\t\treturn 0;\n\t\t} else if ((r = sshbuf_put(c->input, buf, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: append: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t}\n\treturn sshbuf_len(c->input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "c->efd",
            "readset"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_ISSET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "22-24",
          "snippet": "int kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nint kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_handle_efd_read(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tchar buf[CHAN_RBUF];\n\tint r;\n\tssize_t len;\n\n\tif (!c->detach_close && !FD_ISSET(c->efd, readset))\n\t\treturn 1;\n\n\tlen = read(c->efd, buf, sizeof(buf));\n\tdebug2(\"channel %d: read %zd from efd %d\", c->self, len, c->efd);\n\tif (len < 0 && (errno == EINTR || ((errno == EAGAIN ||\n\t    errno == EWOULDBLOCK) && !c->detach_close)))\n\t\treturn 1;\n\tif (len <= 0) {\n\t\tdebug2(\"channel %d: closing read-efd %d\",\n\t\t    c->self, c->efd);\n\t\tchannel_close_fd(ssh, &c->efd);\n\t} else {\n\t\tif (c->extended_usage == CHAN_EXTENDED_IGNORE) {\n\t\t\tdebug3(\"channel %d: discard efd\",\n\t\t\t    c->self);\n\t\t} else if ((r = sshbuf_put(c->extended, buf, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: append: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "channel_handle_efd_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "2073-2100",
    "snippet": "static int\nchannel_handle_efd_write(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tint r;\n\tssize_t len;\n\n\tif (!FD_ISSET(c->efd, writeset) || sshbuf_len(c->extended) == 0)\n\t\treturn 1;\n\n\tlen = write(c->efd, sshbuf_ptr(c->extended),\n\t    sshbuf_len(c->extended));\n\tdebug2(\"channel %d: written %zd to efd %d\", c->self, len, c->efd);\n\tif (len < 0 && (errno == EINTR || errno == EAGAIN ||\n\t    errno == EWOULDBLOCK))\n\t\treturn 1;\n\tif (len <= 0) {\n\t\tdebug2(\"channel %d: closing write-efd %d\", c->self, c->efd);\n\t\tchannel_close_fd(ssh, &c->efd);\n\t} else {\n\t\tif ((r = sshbuf_consume(c->extended, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t\tc->local_consumed += len;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %d: consume: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "c->extended",
            "len"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_close_fd",
          "args": [
            "ssh",
            "&c->efd"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "channel_close_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "441-453",
          "snippet": "static void\nchannel_close_fds(struct ssh *ssh, Channel *c)\n{\n\tint sock = c->sock, rfd = c->rfd, wfd = c->wfd, efd = c->efd;\n\n\tchannel_close_fd(ssh, &c->sock);\n\tif (rfd != sock)\n\t\tchannel_close_fd(ssh, &c->rfd);\n\tif (wfd != sock && wfd != rfd)\n\t\tchannel_close_fd(ssh, &c->wfd);\n\tif (efd != sock && efd != rfd && efd != wfd)\n\t\tchannel_close_fd(ssh, &c->efd);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_close_fds(struct ssh *ssh, Channel *c)\n{\n\tint sock = c->sock, rfd = c->rfd, wfd = c->wfd, efd = c->efd;\n\n\tchannel_close_fd(ssh, &c->sock);\n\tif (rfd != sock)\n\t\tchannel_close_fd(ssh, &c->rfd);\n\tif (wfd != sock && wfd != rfd)\n\t\tchannel_close_fd(ssh, &c->wfd);\n\tif (efd != sock && efd != rfd && efd != wfd)\n\t\tchannel_close_fd(ssh, &c->efd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: closing write-efd %d\"",
            "c->self",
            "c->efd"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "c->efd",
            "sshbuf_ptr(c->extended)",
            "sshbuf_len(c->extended)"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "c->extended"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "c->extended"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "c->efd",
            "writeset"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_ISSET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "22-24",
          "snippet": "int kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nint kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_handle_efd_write(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tint r;\n\tssize_t len;\n\n\tif (!FD_ISSET(c->efd, writeset) || sshbuf_len(c->extended) == 0)\n\t\treturn 1;\n\n\tlen = write(c->efd, sshbuf_ptr(c->extended),\n\t    sshbuf_len(c->extended));\n\tdebug2(\"channel %d: written %zd to efd %d\", c->self, len, c->efd);\n\tif (len < 0 && (errno == EINTR || errno == EAGAIN ||\n\t    errno == EWOULDBLOCK))\n\t\treturn 1;\n\tif (len <= 0) {\n\t\tdebug2(\"channel %d: closing write-efd %d\", c->self, c->efd);\n\t\tchannel_close_fd(ssh, &c->efd);\n\t} else {\n\t\tif ((r = sshbuf_consume(c->extended, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t\tc->local_consumed += len;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "channel_handle_wfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1979-2071",
    "snippet": "static int\nchannel_handle_wfd(struct ssh *ssh, Channel *c,\n   fd_set *readset, fd_set *writeset)\n{\n\tstruct termios tio;\n\tu_char *data = NULL, *buf; /* XXX const; need filter API change */\n\tsize_t dlen, olen = 0;\n\tint r, len;\n\n\tif (c->wfd == -1 || !FD_ISSET(c->wfd, writeset) ||\n\t    sshbuf_len(c->output) == 0)\n\t\treturn 1;\n\n\t/* Send buffered output data to the socket. */\n\tolen = sshbuf_len(c->output);\n\tif (c->output_filter != NULL) {\n\t\tif ((buf = c->output_filter(ssh, c, &data, &dlen)) == NULL) {\n\t\t\tdebug2(\"channel %d: filter stops\", c->self);\n\t\t\tif (c->type != SSH_CHANNEL_OPEN)\n\t\t\t\tchan_mark_dead(ssh, c);\n\t\t\telse\n\t\t\t\tchan_write_failed(ssh, c);\n\t\t\treturn -1;\n\t\t}\n\t} else if (c->datagram) {\n\t\tif ((r = sshbuf_get_string(c->output, &data, &dlen)) != 0)\n\t\t\tfatal(\"%s: channel %d: get datagram: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\tbuf = data;\n\t} else {\n\t\tbuf = data = sshbuf_mutable_ptr(c->output);\n\t\tdlen = sshbuf_len(c->output);\n\t}\n\n\tif (c->datagram) {\n\t\t/* ignore truncated writes, datagrams might get lost */\n\t\tlen = write(c->wfd, buf, dlen);\n\t\tfree(data);\n\t\tif (len < 0 && (errno == EINTR || errno == EAGAIN ||\n\t\t    errno == EWOULDBLOCK))\n\t\t\treturn 1;\n\t\tif (len <= 0)\n\t\t\tgoto write_fail;\n\t\tgoto out;\n\t}\n\n#ifdef _AIX\n\t/* XXX: Later AIX versions can't push as much data to tty */\n\tif (c->wfd_isatty)\n\t\tdlen = MIN(dlen, 8*1024);\n#endif\n\n\tlen = write(c->wfd, buf, dlen);\n\tif (len < 0 &&\n\t    (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK))\n\t\treturn 1;\n\tif (len <= 0) {\n write_fail:\n\t\tif (c->type != SSH_CHANNEL_OPEN) {\n\t\t\tdebug2(\"channel %d: not open\", c->self);\n\t\t\tchan_mark_dead(ssh, c);\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tchan_write_failed(ssh, c);\n\t\t}\n\t\treturn -1;\n\t}\n#ifndef BROKEN_TCGETATTR_ICANON\n\tif (c->isatty && dlen >= 1 && buf[0] != '\\r') {\n\t\tif (tcgetattr(c->wfd, &tio) == 0 &&\n\t\t    !(tio.c_lflag & ECHO) && (tio.c_lflag & ICANON)) {\n\t\t\t/*\n\t\t\t * Simulate echo to reduce the impact of\n\t\t\t * traffic analysis. We need to match the\n\t\t\t * size of a SSH2_MSG_CHANNEL_DATA message\n\t\t\t * (4 byte channel id + buf)\n\t\t\t */\n\t\t\tif ((r = sshpkt_msg_ignore(ssh, 4+len)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: channel %d: ignore: %s\",\n\t\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t}\n#endif /* BROKEN_TCGETATTR_ICANON */\n\tif ((r = sshbuf_consume(c->output, len)) != 0) {\n\t\tfatal(\"%s: channel %d: consume: %s\",\n\t\t    __func__, c->self, ssh_err(r));\n\t}\n out:\n\tc->local_consumed += olen - sshbuf_len(c->output);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "c->output"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %d: consume: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "c->output",
            "len"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_msg_ignore",
          "args": [
            "ssh",
            "4+len"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_msg_ignore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2626-2644",
          "snippet": "int\nsshpkt_msg_ignore(struct ssh *ssh, u_int nbytes)\n{\n\tu_int32_t rnd = 0;\n\tint r;\n\tu_int i;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, nbytes)) != 0)\n\t\treturn r;\n\tfor (i = 0; i < nbytes; i++) {\n\t\tif (i % 4 == 0)\n\t\t\trnd = arc4random();\n\t\tif ((r = sshpkt_put_u8(ssh, (u_char)rnd & 0xff)) != 0)\n\t\t\treturn r;\n\t\trnd >>= 8;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_msg_ignore(struct ssh *ssh, u_int nbytes)\n{\n\tu_int32_t rnd = 0;\n\tint r;\n\tu_int i;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, nbytes)) != 0)\n\t\treturn r;\n\tfor (i = 0; i < nbytes; i++) {\n\t\tif (i % 4 == 0)\n\t\t\trnd = arc4random();\n\t\tif ((r = sshpkt_put_u8(ssh, (u_char)rnd & 0xff)) != 0)\n\t\t\treturn r;\n\t\trnd >>= 8;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcgetattr",
          "args": [
            "c->wfd",
            "&tio"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "tcgetattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-nextstep.c",
          "lines": "46-50",
          "snippet": "int\ntcgetattr(int fd, struct termios *t)\n{\n\treturn (ioctl(fd, TIOCGETA, t));\n}",
          "includes": [
            "#include \"bsd-nextstep.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-nextstep.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint\ntcgetattr(int fd, struct termios *t)\n{\n\treturn (ioctl(fd, TIOCGETA, t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_write_failed",
          "args": [
            "ssh",
            "c"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "chan_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "305-322",
          "snippet": "void\nchan_write_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: write failed\", c->self);\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tif (strcmp(c->ctype, \"session\") == 0)\n\t\t\tchan_send_eow2(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_write_failed for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_write_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: write failed\", c->self);\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tif (strcmp(c->ctype, \"session\") == 0)\n\t\t\tchan_send_eow2(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_write_failed for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_mark_dead",
          "args": [
            "ssh",
            "c"
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "chan_mark_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "324-328",
          "snippet": "void\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: not open\"",
            "c->self"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "c->wfd",
            "buf",
            "dlen"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "dlen",
            "8*1024"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "_SPLAY_MINMAX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sys-tree.h",
          "lines": "247-278",
          "snippet": "void name##_SPLAY_MINMAX(struct name *head, int __comp) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type __node, *__left, *__right, *__tmp;\t\t\t\\\n\\\n\tSPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\\n\t__left = __right = &__node;\t\t\t\t\t\\\n\\\n\twhile (1) {\t\t\t\t\t\t\t\\\n\t\tif (__comp < 0) {\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_LEFT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp < 0){\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_RIGHT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKLEFT(head, __right, field);\t\t\\\n\t\t} else if (__comp > 0) {\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp > 0) {\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_LEFT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKRIGHT(head, __left, field);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSPLAY_ASSEMBLE(head, &__node, __left, __right, field);\t\t\\\n}",
          "includes": [
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n\nvoid name##_SPLAY_MINMAX(struct name *head, int __comp) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type __node, *__left, *__right, *__tmp;\t\t\t\\\n\\\n\tSPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\\n\t__left = __right = &__node;\t\t\t\t\t\\\n\\\n\twhile (1) {\t\t\t\t\t\t\t\\\n\t\tif (__comp < 0) {\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_LEFT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp < 0){\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_RIGHT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKLEFT(head, __right, field);\t\t\\\n\t\t} else if (__comp > 0) {\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp > 0) {\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_LEFT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKRIGHT(head, __left, field);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSPLAY_ASSEMBLE(head, &__node, __left, __right, field);\t\t\\\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "data"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4195-4206",
          "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "c->wfd",
            "buf",
            "dlen"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_mutable_ptr",
          "args": [
            "c->output"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_mutable_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "276-282",
          "snippet": "u_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "c->output",
            "&data",
            "&dlen"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->output_filter",
          "args": [
            "ssh",
            "c",
            "&data",
            "&dlen"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "c->wfd",
            "writeset"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_ISSET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "22-24",
          "snippet": "int kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nint kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_handle_wfd(struct ssh *ssh, Channel *c,\n   fd_set *readset, fd_set *writeset)\n{\n\tstruct termios tio;\n\tu_char *data = NULL, *buf; /* XXX const; need filter API change */\n\tsize_t dlen, olen = 0;\n\tint r, len;\n\n\tif (c->wfd == -1 || !FD_ISSET(c->wfd, writeset) ||\n\t    sshbuf_len(c->output) == 0)\n\t\treturn 1;\n\n\t/* Send buffered output data to the socket. */\n\tolen = sshbuf_len(c->output);\n\tif (c->output_filter != NULL) {\n\t\tif ((buf = c->output_filter(ssh, c, &data, &dlen)) == NULL) {\n\t\t\tdebug2(\"channel %d: filter stops\", c->self);\n\t\t\tif (c->type != SSH_CHANNEL_OPEN)\n\t\t\t\tchan_mark_dead(ssh, c);\n\t\t\telse\n\t\t\t\tchan_write_failed(ssh, c);\n\t\t\treturn -1;\n\t\t}\n\t} else if (c->datagram) {\n\t\tif ((r = sshbuf_get_string(c->output, &data, &dlen)) != 0)\n\t\t\tfatal(\"%s: channel %d: get datagram: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\tbuf = data;\n\t} else {\n\t\tbuf = data = sshbuf_mutable_ptr(c->output);\n\t\tdlen = sshbuf_len(c->output);\n\t}\n\n\tif (c->datagram) {\n\t\t/* ignore truncated writes, datagrams might get lost */\n\t\tlen = write(c->wfd, buf, dlen);\n\t\tfree(data);\n\t\tif (len < 0 && (errno == EINTR || errno == EAGAIN ||\n\t\t    errno == EWOULDBLOCK))\n\t\t\treturn 1;\n\t\tif (len <= 0)\n\t\t\tgoto write_fail;\n\t\tgoto out;\n\t}\n\n#ifdef _AIX\n\t/* XXX: Later AIX versions can't push as much data to tty */\n\tif (c->wfd_isatty)\n\t\tdlen = MIN(dlen, 8*1024);\n#endif\n\n\tlen = write(c->wfd, buf, dlen);\n\tif (len < 0 &&\n\t    (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK))\n\t\treturn 1;\n\tif (len <= 0) {\n write_fail:\n\t\tif (c->type != SSH_CHANNEL_OPEN) {\n\t\t\tdebug2(\"channel %d: not open\", c->self);\n\t\t\tchan_mark_dead(ssh, c);\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tchan_write_failed(ssh, c);\n\t\t}\n\t\treturn -1;\n\t}\n#ifndef BROKEN_TCGETATTR_ICANON\n\tif (c->isatty && dlen >= 1 && buf[0] != '\\r') {\n\t\tif (tcgetattr(c->wfd, &tio) == 0 &&\n\t\t    !(tio.c_lflag & ECHO) && (tio.c_lflag & ICANON)) {\n\t\t\t/*\n\t\t\t * Simulate echo to reduce the impact of\n\t\t\t * traffic analysis. We need to match the\n\t\t\t * size of a SSH2_MSG_CHANNEL_DATA message\n\t\t\t * (4 byte channel id + buf)\n\t\t\t */\n\t\t\tif ((r = sshpkt_msg_ignore(ssh, 4+len)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: channel %d: ignore: %s\",\n\t\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t}\n#endif /* BROKEN_TCGETATTR_ICANON */\n\tif ((r = sshbuf_consume(c->output, len)) != 0) {\n\t\tfatal(\"%s: channel %d: consume: %s\",\n\t\t    __func__, c->self, ssh_err(r));\n\t}\n out:\n\tc->local_consumed += olen - sshbuf_len(c->output);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "channel_post_connecting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1855-1926",
    "snippet": "static void\nchannel_post_connecting(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tint err = 0, sock, isopen, r;\n\tsocklen_t sz = sizeof(err);\n\n\tif (!FD_ISSET(c->sock, writeset))\n\t\treturn;\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\t/* for rdynamic the OPEN_CONFIRMATION has been sent already */\n\tisopen = (c->type == SSH_CHANNEL_RDYNAMIC_FINISH);\n\tif (getsockopt(c->sock, SOL_SOCKET, SO_ERROR, &err, &sz) < 0) {\n\t\terr = errno;\n\t\terror(\"getsockopt SO_ERROR failed\");\n\t}\n\tif (err == 0) {\n\t\tdebug(\"channel %d: connected to %s port %d\",\n\t\t    c->self, c->connect_ctx.host, c->connect_ctx.port);\n\t\tchannel_connect_ctx_free(&c->connect_ctx);\n\t\tc->type = SSH_CHANNEL_OPEN;\n\t\tif (isopen) {\n\t\t\t/* no message necessary */\n\t\t} else {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket))\n\t\t\t    != 0)\n\t\t\t\tfatal(\"%s: channel %i: confirm: %s\", __func__,\n\t\t\t\t    c->self, ssh_err(r));\n\t\t\tif ((r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: channel %i: %s\", __func__, c->self,\n\t\t\t\t    ssh_err(r));\n\t\t}\n\t} else {\n\t\tdebug(\"channel %d: connection failed: %s\",\n\t\t    c->self, strerror(err));\n\t\t/* Try next address, if any */\n\t\tif ((sock = connect_next(&c->connect_ctx)) > 0) {\n\t\t\tclose(c->sock);\n\t\t\tc->sock = c->rfd = c->wfd = sock;\n\t\t\tchannel_find_maxfd(ssh->chanctxt);\n\t\t\treturn;\n\t\t}\n\t\t/* Exhausted all addresses */\n\t\terror(\"connect_to %.100s port %d: failed.\",\n\t\t    c->connect_ctx.host, c->connect_ctx.port);\n\t\tchannel_connect_ctx_free(&c->connect_ctx);\n\t\tif (isopen) {\n\t\t\trdynamic_close(ssh, c);\n\t\t} else {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_CHANNEL_OPEN_FAILURE)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh,\n\t\t\t    SSH2_OPEN_CONNECT_FAILED)) != 0 ||\n\t\t\t    (r = sshpkt_put_cstring(ssh, strerror(err))) != 0 ||\n\t\t\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0) {\n\t\t\t\tfatal(\"%s: channel %i: failure: %s\", __func__,\n\t\t\t\t    c->self, ssh_err(r));\n\t\t\t}\n\t\t\tif ((r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: channel %i: %s\", __func__, c->self,\n\t\t\t\t    ssh_err(r));\n\t\t\tchan_mark_dead(ssh, c);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "chan_mark_dead",
          "args": [
            "ssh",
            "c"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "chan_mark_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "324-328",
          "snippet": "void\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %i: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "\"\""
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "err"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "SSH2_OPEN_CONNECT_FAILED"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_CHANNEL_OPEN_FAILURE"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdynamic_close",
          "args": [
            "ssh",
            "c"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "rdynamic_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1560-1569",
          "snippet": "static void\nrdynamic_close(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_OPEN;\n\tchan_read_failed(ssh, c);\n\tsshbuf_reset(c->input);\n\tchan_ibuf_empty(ssh, c);\n\tsshbuf_reset(c->output);\n\tchan_write_failed(ssh, c);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nrdynamic_close(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_OPEN;\n\tchan_read_failed(ssh, c);\n\tsshbuf_reset(c->input);\n\tchan_ibuf_empty(ssh, c);\n\tsshbuf_reset(c->output);\n\tchan_write_failed(ssh, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_connect_ctx_free",
          "args": [
            "&c->connect_ctx"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4195-4206",
          "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"connect_to %.100s port %d: failed.\"",
            "c->connect_ctx.host",
            "c->connect_ctx.port"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_find_maxfd",
          "args": [
            "ssh->chanctxt"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "channel_find_maxfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "407-423",
          "snippet": "static void\nchannel_find_maxfd(struct ssh_channels *sc)\n{\n\tu_int i;\n\tint max = 0;\n\tChannel *c;\n\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c != NULL) {\n\t\t\tmax = MAXIMUM(max, c->rfd);\n\t\t\tmax = MAXIMUM(max, c->wfd);\n\t\t\tmax = MAXIMUM(max, c->efd);\n\t\t}\n\t}\n\tsc->channel_max_fd = max;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic void\nchannel_find_maxfd(struct ssh_channels *sc)\n{\n\tu_int i;\n\tint max = 0;\n\tChannel *c;\n\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c != NULL) {\n\t\t\tmax = MAXIMUM(max, c->rfd);\n\t\t\tmax = MAXIMUM(max, c->wfd);\n\t\t\tmax = MAXIMUM(max, c->efd);\n\t\t}\n\t}\n\tsc->channel_max_fd = max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "c->sock"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "channel_close_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "656-664",
          "snippet": "void\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect_next",
          "args": [
            "&c->connect_ctx"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "connect_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4137-4193",
          "snippet": "static int\nconnect_next(struct channel_connect *cctx)\n{\n\tint sock, saved_errno;\n\tstruct sockaddr_un *sunaddr;\n\tchar ntop[NI_MAXHOST];\n\tchar strport[MAXIMUM(NI_MAXSERV, sizeof(sunaddr->sun_path))];\n\n\tfor (; cctx->ai; cctx->ai = cctx->ai->ai_next) {\n\t\tswitch (cctx->ai->ai_family) {\n\t\tcase AF_UNIX:\n\t\t\t/* unix:pathname instead of host:port */\n\t\t\tsunaddr = (struct sockaddr_un *)cctx->ai->ai_addr;\n\t\t\tstrlcpy(ntop, \"unix\", sizeof(ntop));\n\t\t\tstrlcpy(strport, sunaddr->sun_path, sizeof(strport));\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\tcase AF_INET6:\n\t\t\tif (getnameinfo(cctx->ai->ai_addr, cctx->ai->ai_addrlen,\n\t\t\t    ntop, sizeof(ntop), strport, sizeof(strport),\n\t\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\t\terror(\"connect_next: getnameinfo failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif ((sock = socket(cctx->ai->ai_family, cctx->ai->ai_socktype,\n\t\t    cctx->ai->ai_protocol)) == -1) {\n\t\t\tif (cctx->ai->ai_next == NULL)\n\t\t\t\terror(\"socket: %.100s\", strerror(errno));\n\t\t\telse\n\t\t\t\tverbose(\"socket: %.100s\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\tif (set_nonblock(sock) == -1)\n\t\t\tfatal(\"%s: set_nonblock(%d)\", __func__, sock);\n\t\tif (connect(sock, cctx->ai->ai_addr,\n\t\t    cctx->ai->ai_addrlen) == -1 && errno != EINPROGRESS) {\n\t\t\tdebug(\"connect_next: host %.100s ([%.100s]:%s): \"\n\t\t\t    \"%.100s\", cctx->host, ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tsaved_errno = errno;\n\t\t\tclose(sock);\n\t\t\terrno = saved_errno;\n\t\t\tcontinue;\t/* fail -- try next */\n\t\t}\n\t\tif (cctx->ai->ai_family != AF_UNIX)\n\t\t\tset_nodelay(sock);\n\t\tdebug(\"connect_next: host %.100s ([%.100s]:%s) \"\n\t\t    \"in progress, fd=%d\", cctx->host, ntop, strport, sock);\n\t\tcctx->ai = cctx->ai->ai_next;\n\t\treturn sock;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic int\nconnect_next(struct channel_connect *cctx)\n{\n\tint sock, saved_errno;\n\tstruct sockaddr_un *sunaddr;\n\tchar ntop[NI_MAXHOST];\n\tchar strport[MAXIMUM(NI_MAXSERV, sizeof(sunaddr->sun_path))];\n\n\tfor (; cctx->ai; cctx->ai = cctx->ai->ai_next) {\n\t\tswitch (cctx->ai->ai_family) {\n\t\tcase AF_UNIX:\n\t\t\t/* unix:pathname instead of host:port */\n\t\t\tsunaddr = (struct sockaddr_un *)cctx->ai->ai_addr;\n\t\t\tstrlcpy(ntop, \"unix\", sizeof(ntop));\n\t\t\tstrlcpy(strport, sunaddr->sun_path, sizeof(strport));\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\tcase AF_INET6:\n\t\t\tif (getnameinfo(cctx->ai->ai_addr, cctx->ai->ai_addrlen,\n\t\t\t    ntop, sizeof(ntop), strport, sizeof(strport),\n\t\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\t\terror(\"connect_next: getnameinfo failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif ((sock = socket(cctx->ai->ai_family, cctx->ai->ai_socktype,\n\t\t    cctx->ai->ai_protocol)) == -1) {\n\t\t\tif (cctx->ai->ai_next == NULL)\n\t\t\t\terror(\"socket: %.100s\", strerror(errno));\n\t\t\telse\n\t\t\t\tverbose(\"socket: %.100s\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\tif (set_nonblock(sock) == -1)\n\t\t\tfatal(\"%s: set_nonblock(%d)\", __func__, sock);\n\t\tif (connect(sock, cctx->ai->ai_addr,\n\t\t    cctx->ai->ai_addrlen) == -1 && errno != EINPROGRESS) {\n\t\t\tdebug(\"connect_next: host %.100s ([%.100s]:%s): \"\n\t\t\t    \"%.100s\", cctx->host, ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tsaved_errno = errno;\n\t\t\tclose(sock);\n\t\t\terrno = saved_errno;\n\t\t\tcontinue;\t/* fail -- try next */\n\t\t}\n\t\tif (cctx->ai->ai_family != AF_UNIX)\n\t\t\tset_nodelay(sock);\n\t\tdebug(\"connect_next: host %.100s ([%.100s]:%s) \"\n\t\t    \"in progress, fd=%d\", cctx->host, ntop, strport, sock);\n\t\tcctx->ai = cctx->ai->ai_next;\n\t\treturn sock;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"channel %d: connection failed: %s\"",
            "c->self",
            "strerror(err)"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsockopt",
          "args": [
            "c->sock",
            "SOL_SOCKET",
            "SO_ERROR",
            "&err",
            "&sz"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "c->sock",
            "writeset"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_ISSET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "22-24",
          "snippet": "int kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nint kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_post_connecting(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tint err = 0, sock, isopen, r;\n\tsocklen_t sz = sizeof(err);\n\n\tif (!FD_ISSET(c->sock, writeset))\n\t\treturn;\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\t/* for rdynamic the OPEN_CONFIRMATION has been sent already */\n\tisopen = (c->type == SSH_CHANNEL_RDYNAMIC_FINISH);\n\tif (getsockopt(c->sock, SOL_SOCKET, SO_ERROR, &err, &sz) < 0) {\n\t\terr = errno;\n\t\terror(\"getsockopt SO_ERROR failed\");\n\t}\n\tif (err == 0) {\n\t\tdebug(\"channel %d: connected to %s port %d\",\n\t\t    c->self, c->connect_ctx.host, c->connect_ctx.port);\n\t\tchannel_connect_ctx_free(&c->connect_ctx);\n\t\tc->type = SSH_CHANNEL_OPEN;\n\t\tif (isopen) {\n\t\t\t/* no message necessary */\n\t\t} else {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket))\n\t\t\t    != 0)\n\t\t\t\tfatal(\"%s: channel %i: confirm: %s\", __func__,\n\t\t\t\t    c->self, ssh_err(r));\n\t\t\tif ((r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: channel %i: %s\", __func__, c->self,\n\t\t\t\t    ssh_err(r));\n\t\t}\n\t} else {\n\t\tdebug(\"channel %d: connection failed: %s\",\n\t\t    c->self, strerror(err));\n\t\t/* Try next address, if any */\n\t\tif ((sock = connect_next(&c->connect_ctx)) > 0) {\n\t\t\tclose(c->sock);\n\t\t\tc->sock = c->rfd = c->wfd = sock;\n\t\t\tchannel_find_maxfd(ssh->chanctxt);\n\t\t\treturn;\n\t\t}\n\t\t/* Exhausted all addresses */\n\t\terror(\"connect_to %.100s port %d: failed.\",\n\t\t    c->connect_ctx.host, c->connect_ctx.port);\n\t\tchannel_connect_ctx_free(&c->connect_ctx);\n\t\tif (isopen) {\n\t\t\trdynamic_close(ssh, c);\n\t\t} else {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_CHANNEL_OPEN_FAILURE)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh,\n\t\t\t    SSH2_OPEN_CONNECT_FAILED)) != 0 ||\n\t\t\t    (r = sshpkt_put_cstring(ssh, strerror(err))) != 0 ||\n\t\t\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0) {\n\t\t\t\tfatal(\"%s: channel %i: failure: %s\", __func__,\n\t\t\t\t    c->self, ssh_err(r));\n\t\t\t}\n\t\t\tif ((r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: channel %i: %s\", __func__, c->self,\n\t\t\t\t    ssh_err(r));\n\t\t\tchan_mark_dead(ssh, c);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "channel_post_auth_listener",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1826-1853",
    "snippet": "static void\nchannel_post_auth_listener(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tChannel *nc;\n\tint r, newsock;\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\n\tif (!FD_ISSET(c->sock, readset))\n\t\treturn;\n\n\taddrlen = sizeof(addr);\n\tnewsock = accept(c->sock, (struct sockaddr *)&addr, &addrlen);\n\tif (newsock < 0) {\n\t\terror(\"accept from auth socket: %.100s\", strerror(errno));\n\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\tc->notbefore = monotime() + 1;\n\t\treturn;\n\t}\n\tnc = channel_new(ssh, \"accepted auth socket\",\n\t    SSH_CHANNEL_OPENING, newsock, newsock, -1,\n\t    c->local_window_max, c->local_maxpacket,\n\t    0, \"accepted auth socket\", 1);\n\topen_preamble(ssh, __func__, nc, \"auth-agent@openssh.com\");\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %i: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_preamble",
          "args": [
            "ssh",
            "__func__",
            "nc",
            "\"auth-agent@openssh.com\""
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "open_preamble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "902-914",
          "snippet": "static void\nopen_preamble(struct ssh *ssh, const char *where, Channel *c, const char *type)\n{\n\tint r;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, type)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: open: %s\", where, c->self, ssh_err(r));\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nopen_preamble(struct ssh *ssh, const char *where, Channel *c, const char *type)\n{\n\tint r;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, type)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: open: %s\", where, c->self, ssh_err(r));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "\"accepted auth socket\"",
            "SSH_CHANNEL_OPENING",
            "newsock",
            "newsock",
            "-1",
            "c->local_window_max",
            "c->local_maxpacket",
            "0",
            "\"accepted auth socket\"",
            "1"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "monotime",
          "args": [],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "monotime_double",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1324-1331",
          "snippet": "double\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\ndouble\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"accept from auth socket: %.100s\"",
            "strerror(errno)"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "c->sock",
            "(struct sockaddr *)&addr",
            "&addrlen"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "input_userauth_service_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "419-449",
          "snippet": "int\ninput_userauth_service_accept(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r;\n\n\tif (ssh_packet_remaining(ssh) > 0) {\n\t\tchar *reply;\n\n\t\tif ((r = sshpkt_get_cstring(ssh, &reply, NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"service_accept: %s\", reply);\n\t\tfree(reply);\n\t} else {\n\t\tdebug2(\"buggy server: service_accept w/o service\");\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tdebug(\"SSH2_MSG_SERVICE_ACCEPT received\");\n\n\t/* initial userauth request */\n\tuserauth_none(authctxt);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);\n\tr = 0;\n out:\n\treturn r;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\n\nint\ninput_userauth_service_accept(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r;\n\n\tif (ssh_packet_remaining(ssh) > 0) {\n\t\tchar *reply;\n\n\t\tif ((r = sshpkt_get_cstring(ssh, &reply, NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"service_accept: %s\", reply);\n\t\tfree(reply);\n\t} else {\n\t\tdebug2(\"buggy server: service_accept w/o service\");\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tdebug(\"SSH2_MSG_SERVICE_ACCEPT received\");\n\n\t/* initial userauth request */\n\tuserauth_none(authctxt);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);\n\tr = 0;\n out:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "c->sock",
            "readset"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_ISSET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "22-24",
          "snippet": "int kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nint kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_post_auth_listener(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tChannel *nc;\n\tint r, newsock;\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\n\tif (!FD_ISSET(c->sock, readset))\n\t\treturn;\n\n\taddrlen = sizeof(addr);\n\tnewsock = accept(c->sock, (struct sockaddr *)&addr, &addrlen);\n\tif (newsock < 0) {\n\t\terror(\"accept from auth socket: %.100s\", strerror(errno));\n\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\tc->notbefore = monotime() + 1;\n\t\treturn;\n\t}\n\tnc = channel_new(ssh, \"accepted auth socket\",\n\t    SSH_CHANNEL_OPENING, newsock, newsock, -1,\n\t    c->local_window_max, c->local_maxpacket,\n\t    0, \"accepted auth socket\", 1);\n\topen_preamble(ssh, __func__, nc, \"auth-agent@openssh.com\");\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n}"
  },
  {
    "function_name": "channel_post_port_listener",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1766-1820",
    "snippet": "static void\nchannel_post_port_listener(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tChannel *nc;\n\tstruct sockaddr_storage addr;\n\tint newsock, nextstate;\n\tsocklen_t addrlen;\n\tchar *rtype;\n\n\tif (!FD_ISSET(c->sock, readset))\n\t\treturn;\n\n\tdebug(\"Connection to port %d forwarding to %.100s port %d requested.\",\n\t    c->listening_port, c->path, c->host_port);\n\n\tif (c->type == SSH_CHANNEL_RPORT_LISTENER) {\n\t\tnextstate = SSH_CHANNEL_OPENING;\n\t\trtype = \"forwarded-tcpip\";\n\t} else if (c->type == SSH_CHANNEL_RUNIX_LISTENER) {\n\t\tnextstate = SSH_CHANNEL_OPENING;\n\t\trtype = \"forwarded-streamlocal@openssh.com\";\n\t} else if (c->host_port == PORT_STREAMLOCAL) {\n\t\tnextstate = SSH_CHANNEL_OPENING;\n\t\trtype = \"direct-streamlocal@openssh.com\";\n\t} else if (c->host_port == 0) {\n\t\tnextstate = SSH_CHANNEL_DYNAMIC;\n\t\trtype = \"dynamic-tcpip\";\n\t} else {\n\t\tnextstate = SSH_CHANNEL_OPENING;\n\t\trtype = \"direct-tcpip\";\n\t}\n\n\taddrlen = sizeof(addr);\n\tnewsock = accept(c->sock, (struct sockaddr *)&addr, &addrlen);\n\tif (newsock < 0) {\n\t\tif (errno != EINTR && errno != EWOULDBLOCK &&\n\t\t    errno != ECONNABORTED)\n\t\t\terror(\"accept: %.100s\", strerror(errno));\n\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\tc->notbefore = monotime() + 1;\n\t\treturn;\n\t}\n\tif (c->host_port != PORT_STREAMLOCAL)\n\t\tset_nodelay(newsock);\n\tnc = channel_new(ssh, rtype, nextstate, newsock, newsock, -1,\n\t    c->local_window_max, c->local_maxpacket, 0, rtype, 1);\n\tnc->listening_port = c->listening_port;\n\tnc->host_port = c->host_port;\n\tif (c->path != NULL)\n\t\tnc->path = xstrdup(c->path);\n\n\tif (nextstate != SSH_CHANNEL_DYNAMIC)\n\t\tport_open_helper(ssh, nc, rtype);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void port_open_helper(struct ssh *ssh, Channel *c, char *rtype);",
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "port_open_helper",
          "args": [
            "ssh",
            "nc",
            "rtype"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "port_open_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1686-1755",
          "snippet": "static void\nport_open_helper(struct ssh *ssh, Channel *c, char *rtype)\n{\n\tchar *local_ipaddr = get_local_ipaddr(c->sock);\n\tint local_port = c->sock == -1 ? 65536 : get_local_port(c->sock);\n\tchar *remote_ipaddr = get_peer_ipaddr(c->sock);\n\tint remote_port = get_peer_port(c->sock);\n\tint r;\n\n\tif (remote_port == -1) {\n\t\t/* Fake addr/port to appease peers that validate it (Tectia) */\n\t\tfree(remote_ipaddr);\n\t\tremote_ipaddr = xstrdup(\"127.0.0.1\");\n\t\tremote_port = 65535;\n\t}\n\n\tfree(c->remote_name);\n\txasprintf(&c->remote_name,\n\t    \"%s: listening port %d for %.100s port %d, \"\n\t    \"connect from %.200s port %d to %.100s port %d\",\n\t    rtype, c->listening_port, c->path, c->host_port,\n\t    remote_ipaddr, remote_port, local_ipaddr, local_port);\n\n\topen_preamble(ssh, __func__, c, rtype);\n\tif (strcmp(rtype, \"direct-tcpip\") == 0) {\n\t\t/* target host, port */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->host_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else if (strcmp(rtype, \"direct-streamlocal@openssh.com\") == 0) {\n\t\t/* target path */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else if (strcmp(rtype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\t/* listen path */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else {\n\t\t/* listen address, port */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, local_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif (strcmp(rtype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\t/* reserved for future owner/mode info */\n\t\tif ((r = sshpkt_put_cstring(ssh, \"\")) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else {\n\t\t/* originator host and port */\n\t\tif ((r = sshpkt_put_cstring(ssh, remote_ipaddr)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)remote_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: send %s\", __func__, c->self, ssh_err(r));\n\tfree(remote_ipaddr);\n\tfree(local_ipaddr);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void port_open_helper(struct ssh *ssh, Channel *c, char *rtype);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void port_open_helper(struct ssh *ssh, Channel *c, char *rtype);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nport_open_helper(struct ssh *ssh, Channel *c, char *rtype)\n{\n\tchar *local_ipaddr = get_local_ipaddr(c->sock);\n\tint local_port = c->sock == -1 ? 65536 : get_local_port(c->sock);\n\tchar *remote_ipaddr = get_peer_ipaddr(c->sock);\n\tint remote_port = get_peer_port(c->sock);\n\tint r;\n\n\tif (remote_port == -1) {\n\t\t/* Fake addr/port to appease peers that validate it (Tectia) */\n\t\tfree(remote_ipaddr);\n\t\tremote_ipaddr = xstrdup(\"127.0.0.1\");\n\t\tremote_port = 65535;\n\t}\n\n\tfree(c->remote_name);\n\txasprintf(&c->remote_name,\n\t    \"%s: listening port %d for %.100s port %d, \"\n\t    \"connect from %.200s port %d to %.100s port %d\",\n\t    rtype, c->listening_port, c->path, c->host_port,\n\t    remote_ipaddr, remote_port, local_ipaddr, local_port);\n\n\topen_preamble(ssh, __func__, c, rtype);\n\tif (strcmp(rtype, \"direct-tcpip\") == 0) {\n\t\t/* target host, port */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->host_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else if (strcmp(rtype, \"direct-streamlocal@openssh.com\") == 0) {\n\t\t/* target path */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else if (strcmp(rtype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\t/* listen path */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else {\n\t\t/* listen address, port */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, local_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif (strcmp(rtype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\t/* reserved for future owner/mode info */\n\t\tif ((r = sshpkt_put_cstring(ssh, \"\")) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else {\n\t\t/* originator host and port */\n\t\tif ((r = sshpkt_put_cstring(ssh, remote_ipaddr)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)remote_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: send %s\", __func__, c->self, ssh_err(r));\n\tfree(remote_ipaddr);\n\tfree(local_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "c->path"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "rtype",
            "nextstate",
            "newsock",
            "newsock",
            "-1",
            "c->local_window_max",
            "c->local_maxpacket",
            "0",
            "rtype",
            "1"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nodelay",
          "args": [
            "newsock"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "set_nodelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "149-168",
          "snippet": "void\nset_nodelay(int fd)\n{\n\tint opt;\n\tsocklen_t optlen;\n\n\toptlen = sizeof opt;\n\tif (getsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, &optlen) == -1) {\n\t\tdebug(\"getsockopt TCP_NODELAY: %.100s\", strerror(errno));\n\t\treturn;\n\t}\n\tif (opt == 1) {\n\t\tdebug2(\"fd %d is TCP_NODELAY\", fd);\n\t\treturn;\n\t}\n\topt = 1;\n\tdebug2(\"fd %d setting TCP_NODELAY\", fd);\n\tif (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof opt) == -1)\n\t\terror(\"setsockopt TCP_NODELAY: %.100s\", strerror(errno));\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nset_nodelay(int fd)\n{\n\tint opt;\n\tsocklen_t optlen;\n\n\toptlen = sizeof opt;\n\tif (getsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, &optlen) == -1) {\n\t\tdebug(\"getsockopt TCP_NODELAY: %.100s\", strerror(errno));\n\t\treturn;\n\t}\n\tif (opt == 1) {\n\t\tdebug2(\"fd %d is TCP_NODELAY\", fd);\n\t\treturn;\n\t}\n\topt = 1;\n\tdebug2(\"fd %d setting TCP_NODELAY\", fd);\n\tif (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof opt) == -1)\n\t\terror(\"setsockopt TCP_NODELAY: %.100s\", strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "monotime",
          "args": [],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "monotime_double",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1324-1331",
          "snippet": "double\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\ndouble\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"accept: %.100s\"",
            "strerror(errno)"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "c->sock",
            "(struct sockaddr *)&addr",
            "&addrlen"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "input_userauth_service_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "419-449",
          "snippet": "int\ninput_userauth_service_accept(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r;\n\n\tif (ssh_packet_remaining(ssh) > 0) {\n\t\tchar *reply;\n\n\t\tif ((r = sshpkt_get_cstring(ssh, &reply, NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"service_accept: %s\", reply);\n\t\tfree(reply);\n\t} else {\n\t\tdebug2(\"buggy server: service_accept w/o service\");\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tdebug(\"SSH2_MSG_SERVICE_ACCEPT received\");\n\n\t/* initial userauth request */\n\tuserauth_none(authctxt);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);\n\tr = 0;\n out:\n\treturn r;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\n\nint\ninput_userauth_service_accept(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r;\n\n\tif (ssh_packet_remaining(ssh) > 0) {\n\t\tchar *reply;\n\n\t\tif ((r = sshpkt_get_cstring(ssh, &reply, NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"service_accept: %s\", reply);\n\t\tfree(reply);\n\t} else {\n\t\tdebug2(\"buggy server: service_accept w/o service\");\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tdebug(\"SSH2_MSG_SERVICE_ACCEPT received\");\n\n\t/* initial userauth request */\n\tuserauth_none(authctxt);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);\n\tr = 0;\n out:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Connection to port %d forwarding to %.100s port %d requested.\"",
            "c->listening_port",
            "c->path",
            "c->host_port"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "c->sock",
            "readset"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_ISSET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "22-24",
          "snippet": "int kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nint kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void port_open_helper(struct ssh *ssh, Channel *c, char *rtype);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_post_port_listener(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tChannel *nc;\n\tstruct sockaddr_storage addr;\n\tint newsock, nextstate;\n\tsocklen_t addrlen;\n\tchar *rtype;\n\n\tif (!FD_ISSET(c->sock, readset))\n\t\treturn;\n\n\tdebug(\"Connection to port %d forwarding to %.100s port %d requested.\",\n\t    c->listening_port, c->path, c->host_port);\n\n\tif (c->type == SSH_CHANNEL_RPORT_LISTENER) {\n\t\tnextstate = SSH_CHANNEL_OPENING;\n\t\trtype = \"forwarded-tcpip\";\n\t} else if (c->type == SSH_CHANNEL_RUNIX_LISTENER) {\n\t\tnextstate = SSH_CHANNEL_OPENING;\n\t\trtype = \"forwarded-streamlocal@openssh.com\";\n\t} else if (c->host_port == PORT_STREAMLOCAL) {\n\t\tnextstate = SSH_CHANNEL_OPENING;\n\t\trtype = \"direct-streamlocal@openssh.com\";\n\t} else if (c->host_port == 0) {\n\t\tnextstate = SSH_CHANNEL_DYNAMIC;\n\t\trtype = \"dynamic-tcpip\";\n\t} else {\n\t\tnextstate = SSH_CHANNEL_OPENING;\n\t\trtype = \"direct-tcpip\";\n\t}\n\n\taddrlen = sizeof(addr);\n\tnewsock = accept(c->sock, (struct sockaddr *)&addr, &addrlen);\n\tif (newsock < 0) {\n\t\tif (errno != EINTR && errno != EWOULDBLOCK &&\n\t\t    errno != ECONNABORTED)\n\t\t\terror(\"accept: %.100s\", strerror(errno));\n\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\tc->notbefore = monotime() + 1;\n\t\treturn;\n\t}\n\tif (c->host_port != PORT_STREAMLOCAL)\n\t\tset_nodelay(newsock);\n\tnc = channel_new(ssh, rtype, nextstate, newsock, newsock, -1,\n\t    c->local_window_max, c->local_maxpacket, 0, rtype, 1);\n\tnc->listening_port = c->listening_port;\n\tnc->host_port = c->host_port;\n\tif (c->path != NULL)\n\t\tnc->path = xstrdup(c->path);\n\n\tif (nextstate != SSH_CHANNEL_DYNAMIC)\n\t\tport_open_helper(ssh, nc, rtype);\n}"
  },
  {
    "function_name": "channel_set_x11_refuse_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1757-1761",
    "snippet": "void\nchannel_set_x11_refuse_time(struct ssh *ssh, u_int refuse_time)\n{\n\tssh->chanctxt->x11_refuse_time = refuse_time;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_set_x11_refuse_time(struct ssh *ssh, u_int refuse_time)\n{\n\tssh->chanctxt->x11_refuse_time = refuse_time;\n}"
  },
  {
    "function_name": "port_open_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1686-1755",
    "snippet": "static void\nport_open_helper(struct ssh *ssh, Channel *c, char *rtype)\n{\n\tchar *local_ipaddr = get_local_ipaddr(c->sock);\n\tint local_port = c->sock == -1 ? 65536 : get_local_port(c->sock);\n\tchar *remote_ipaddr = get_peer_ipaddr(c->sock);\n\tint remote_port = get_peer_port(c->sock);\n\tint r;\n\n\tif (remote_port == -1) {\n\t\t/* Fake addr/port to appease peers that validate it (Tectia) */\n\t\tfree(remote_ipaddr);\n\t\tremote_ipaddr = xstrdup(\"127.0.0.1\");\n\t\tremote_port = 65535;\n\t}\n\n\tfree(c->remote_name);\n\txasprintf(&c->remote_name,\n\t    \"%s: listening port %d for %.100s port %d, \"\n\t    \"connect from %.200s port %d to %.100s port %d\",\n\t    rtype, c->listening_port, c->path, c->host_port,\n\t    remote_ipaddr, remote_port, local_ipaddr, local_port);\n\n\topen_preamble(ssh, __func__, c, rtype);\n\tif (strcmp(rtype, \"direct-tcpip\") == 0) {\n\t\t/* target host, port */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->host_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else if (strcmp(rtype, \"direct-streamlocal@openssh.com\") == 0) {\n\t\t/* target path */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else if (strcmp(rtype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\t/* listen path */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else {\n\t\t/* listen address, port */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, local_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif (strcmp(rtype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\t/* reserved for future owner/mode info */\n\t\tif ((r = sshpkt_put_cstring(ssh, \"\")) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else {\n\t\t/* originator host and port */\n\t\tif ((r = sshpkt_put_cstring(ssh, remote_ipaddr)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)remote_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: send %s\", __func__, c->self, ssh_err(r));\n\tfree(remote_ipaddr);\n\tfree(local_ipaddr);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void port_open_helper(struct ssh *ssh, Channel *c, char *rtype);",
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "local_ipaddr"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4195-4206",
          "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %i: send %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "(u_int)remote_port"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "remote_ipaddr"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rtype",
            "\"forwarded-streamlocal@openssh.com\""
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_preamble",
          "args": [
            "ssh",
            "__func__",
            "c",
            "rtype"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "open_preamble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "902-914",
          "snippet": "static void\nopen_preamble(struct ssh *ssh, const char *where, Channel *c, const char *type)\n{\n\tint r;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, type)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: open: %s\", where, c->self, ssh_err(r));\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nopen_preamble(struct ssh *ssh, const char *where, Channel *c, const char *type)\n{\n\tint r;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, type)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: open: %s\", where, c->self, ssh_err(r));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&c->remote_name",
            "\"%s: listening port %d for %.100s port %d, \"\n\t    \"connect from %.200s port %d to %.100s port %d\"",
            "rtype",
            "c->listening_port",
            "c->path",
            "c->host_port",
            "remote_ipaddr",
            "remote_port",
            "local_ipaddr",
            "local_port"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "\"127.0.0.1\""
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_peer_port",
          "args": [
            "c->sock"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "get_peer_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "194-198",
          "snippet": "int\nget_peer_port(int sock)\n{\n\treturn get_sock_port(sock, 0);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nget_peer_port(int sock)\n{\n\treturn get_sock_port(sock, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_peer_ipaddr",
          "args": [
            "c->sock"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "get_peer_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "113-121",
          "snippet": "char *\nget_peer_ipaddr(int sock)\n{\n\tchar *p;\n\n\tif ((p = get_socket_address(sock, 1, NI_NUMERICHOST)) != NULL)\n\t\treturn p;\n\treturn xstrdup(\"UNKNOWN\");\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nget_peer_ipaddr(int sock)\n{\n\tchar *p;\n\n\tif ((p = get_socket_address(sock, 1, NI_NUMERICHOST)) != NULL)\n\t\treturn p;\n\treturn xstrdup(\"UNKNOWN\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_local_port",
          "args": [
            "c->sock"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "get_local_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "200-204",
          "snippet": "int\nget_local_port(int sock)\n{\n\treturn get_sock_port(sock, 1);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nget_local_port(int sock)\n{\n\treturn get_sock_port(sock, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_local_ipaddr",
          "args": [
            "c->sock"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "get_local_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "123-131",
          "snippet": "char *\nget_local_ipaddr(int sock)\n{\n\tchar *p;\n\n\tif ((p = get_socket_address(sock, 0, NI_NUMERICHOST)) != NULL)\n\t\treturn p;\n\treturn xstrdup(\"UNKNOWN\");\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nget_local_ipaddr(int sock)\n{\n\tchar *p;\n\n\tif ((p = get_socket_address(sock, 0, NI_NUMERICHOST)) != NULL)\n\t\treturn p;\n\treturn xstrdup(\"UNKNOWN\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void port_open_helper(struct ssh *ssh, Channel *c, char *rtype);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nport_open_helper(struct ssh *ssh, Channel *c, char *rtype)\n{\n\tchar *local_ipaddr = get_local_ipaddr(c->sock);\n\tint local_port = c->sock == -1 ? 65536 : get_local_port(c->sock);\n\tchar *remote_ipaddr = get_peer_ipaddr(c->sock);\n\tint remote_port = get_peer_port(c->sock);\n\tint r;\n\n\tif (remote_port == -1) {\n\t\t/* Fake addr/port to appease peers that validate it (Tectia) */\n\t\tfree(remote_ipaddr);\n\t\tremote_ipaddr = xstrdup(\"127.0.0.1\");\n\t\tremote_port = 65535;\n\t}\n\n\tfree(c->remote_name);\n\txasprintf(&c->remote_name,\n\t    \"%s: listening port %d for %.100s port %d, \"\n\t    \"connect from %.200s port %d to %.100s port %d\",\n\t    rtype, c->listening_port, c->path, c->host_port,\n\t    remote_ipaddr, remote_port, local_ipaddr, local_port);\n\n\topen_preamble(ssh, __func__, c, rtype);\n\tif (strcmp(rtype, \"direct-tcpip\") == 0) {\n\t\t/* target host, port */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->host_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else if (strcmp(rtype, \"direct-streamlocal@openssh.com\") == 0) {\n\t\t/* target path */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else if (strcmp(rtype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\t/* listen path */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else {\n\t\t/* listen address, port */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, local_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif (strcmp(rtype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\t/* reserved for future owner/mode info */\n\t\tif ((r = sshpkt_put_cstring(ssh, \"\")) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else {\n\t\t/* originator host and port */\n\t\tif ((r = sshpkt_put_cstring(ssh, remote_ipaddr)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)remote_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: send %s\", __func__, c->self, ssh_err(r));\n\tfree(remote_ipaddr);\n\tfree(local_ipaddr);\n}"
  },
  {
    "function_name": "channel_post_x11_listener",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1635-1684",
    "snippet": "static void\nchannel_post_x11_listener(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tChannel *nc;\n\tstruct sockaddr_storage addr;\n\tint r, newsock, oerrno, remote_port;\n\tsocklen_t addrlen;\n\tchar buf[16384], *remote_ipaddr;\n\n\tif (!FD_ISSET(c->sock, readset))\n\t\treturn;\n\n\tdebug(\"X11 connection requested.\");\n\taddrlen = sizeof(addr);\n\tnewsock = accept(c->sock, (struct sockaddr *)&addr, &addrlen);\n\tif (c->single_connection) {\n\t\toerrno = errno;\n\t\tdebug2(\"single_connection: closing X11 listener.\");\n\t\tchannel_close_fd(ssh, &c->sock);\n\t\tchan_mark_dead(ssh, c);\n\t\terrno = oerrno;\n\t}\n\tif (newsock < 0) {\n\t\tif (errno != EINTR && errno != EWOULDBLOCK &&\n\t\t    errno != ECONNABORTED)\n\t\t\terror(\"accept: %.100s\", strerror(errno));\n\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\tc->notbefore = monotime() + 1;\n\t\treturn;\n\t}\n\tset_nodelay(newsock);\n\tremote_ipaddr = get_peer_ipaddr(newsock);\n\tremote_port = get_peer_port(newsock);\n\tsnprintf(buf, sizeof buf, \"X11 connection from %.200s port %d\",\n\t    remote_ipaddr, remote_port);\n\n\tnc = channel_new(ssh, \"accepted x11 socket\",\n\t    SSH_CHANNEL_OPENING, newsock, newsock, -1,\n\t    c->local_window_max, c->local_maxpacket, 0, buf, 1);\n\topen_preamble(ssh, __func__, nc, \"x11\");\n\tif ((r = sshpkt_put_cstring(ssh, remote_ipaddr)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, remote_port)) != 0) {\n\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: send %s\", __func__, c->self, ssh_err(r));\n\tfree(remote_ipaddr);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "remote_ipaddr"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4195-4206",
          "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %i: send %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "remote_port"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "remote_ipaddr"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_preamble",
          "args": [
            "ssh",
            "__func__",
            "nc",
            "\"x11\""
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "open_preamble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "902-914",
          "snippet": "static void\nopen_preamble(struct ssh *ssh, const char *where, Channel *c, const char *type)\n{\n\tint r;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, type)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: open: %s\", where, c->self, ssh_err(r));\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nopen_preamble(struct ssh *ssh, const char *where, Channel *c, const char *type)\n{\n\tint r;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, type)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: open: %s\", where, c->self, ssh_err(r));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "\"accepted x11 socket\"",
            "SSH_CHANNEL_OPENING",
            "newsock",
            "newsock",
            "-1",
            "c->local_window_max",
            "c->local_maxpacket",
            "0",
            "buf",
            "1"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof buf",
            "\"X11 connection from %.200s port %d\"",
            "remote_ipaddr",
            "remote_port"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_peer_port",
          "args": [
            "newsock"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "get_peer_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "194-198",
          "snippet": "int\nget_peer_port(int sock)\n{\n\treturn get_sock_port(sock, 0);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nget_peer_port(int sock)\n{\n\treturn get_sock_port(sock, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_peer_ipaddr",
          "args": [
            "newsock"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "get_peer_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "113-121",
          "snippet": "char *\nget_peer_ipaddr(int sock)\n{\n\tchar *p;\n\n\tif ((p = get_socket_address(sock, 1, NI_NUMERICHOST)) != NULL)\n\t\treturn p;\n\treturn xstrdup(\"UNKNOWN\");\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nget_peer_ipaddr(int sock)\n{\n\tchar *p;\n\n\tif ((p = get_socket_address(sock, 1, NI_NUMERICHOST)) != NULL)\n\t\treturn p;\n\treturn xstrdup(\"UNKNOWN\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nodelay",
          "args": [
            "newsock"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "set_nodelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "149-168",
          "snippet": "void\nset_nodelay(int fd)\n{\n\tint opt;\n\tsocklen_t optlen;\n\n\toptlen = sizeof opt;\n\tif (getsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, &optlen) == -1) {\n\t\tdebug(\"getsockopt TCP_NODELAY: %.100s\", strerror(errno));\n\t\treturn;\n\t}\n\tif (opt == 1) {\n\t\tdebug2(\"fd %d is TCP_NODELAY\", fd);\n\t\treturn;\n\t}\n\topt = 1;\n\tdebug2(\"fd %d setting TCP_NODELAY\", fd);\n\tif (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof opt) == -1)\n\t\terror(\"setsockopt TCP_NODELAY: %.100s\", strerror(errno));\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nset_nodelay(int fd)\n{\n\tint opt;\n\tsocklen_t optlen;\n\n\toptlen = sizeof opt;\n\tif (getsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, &optlen) == -1) {\n\t\tdebug(\"getsockopt TCP_NODELAY: %.100s\", strerror(errno));\n\t\treturn;\n\t}\n\tif (opt == 1) {\n\t\tdebug2(\"fd %d is TCP_NODELAY\", fd);\n\t\treturn;\n\t}\n\topt = 1;\n\tdebug2(\"fd %d setting TCP_NODELAY\", fd);\n\tif (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof opt) == -1)\n\t\terror(\"setsockopt TCP_NODELAY: %.100s\", strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "monotime",
          "args": [],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "monotime_double",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1324-1331",
          "snippet": "double\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\ndouble\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"accept: %.100s\"",
            "strerror(errno)"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_mark_dead",
          "args": [
            "ssh",
            "c"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "chan_mark_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "324-328",
          "snippet": "void\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_close_fd",
          "args": [
            "ssh",
            "&c->sock"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "channel_close_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "441-453",
          "snippet": "static void\nchannel_close_fds(struct ssh *ssh, Channel *c)\n{\n\tint sock = c->sock, rfd = c->rfd, wfd = c->wfd, efd = c->efd;\n\n\tchannel_close_fd(ssh, &c->sock);\n\tif (rfd != sock)\n\t\tchannel_close_fd(ssh, &c->rfd);\n\tif (wfd != sock && wfd != rfd)\n\t\tchannel_close_fd(ssh, &c->wfd);\n\tif (efd != sock && efd != rfd && efd != wfd)\n\t\tchannel_close_fd(ssh, &c->efd);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_close_fds(struct ssh *ssh, Channel *c)\n{\n\tint sock = c->sock, rfd = c->rfd, wfd = c->wfd, efd = c->efd;\n\n\tchannel_close_fd(ssh, &c->sock);\n\tif (rfd != sock)\n\t\tchannel_close_fd(ssh, &c->rfd);\n\tif (wfd != sock && wfd != rfd)\n\t\tchannel_close_fd(ssh, &c->wfd);\n\tif (efd != sock && efd != rfd && efd != wfd)\n\t\tchannel_close_fd(ssh, &c->efd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"single_connection: closing X11 listener.\""
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "c->sock",
            "(struct sockaddr *)&addr",
            "&addrlen"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "input_userauth_service_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "419-449",
          "snippet": "int\ninput_userauth_service_accept(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r;\n\n\tif (ssh_packet_remaining(ssh) > 0) {\n\t\tchar *reply;\n\n\t\tif ((r = sshpkt_get_cstring(ssh, &reply, NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"service_accept: %s\", reply);\n\t\tfree(reply);\n\t} else {\n\t\tdebug2(\"buggy server: service_accept w/o service\");\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tdebug(\"SSH2_MSG_SERVICE_ACCEPT received\");\n\n\t/* initial userauth request */\n\tuserauth_none(authctxt);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);\n\tr = 0;\n out:\n\treturn r;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\n\nint\ninput_userauth_service_accept(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r;\n\n\tif (ssh_packet_remaining(ssh) > 0) {\n\t\tchar *reply;\n\n\t\tif ((r = sshpkt_get_cstring(ssh, &reply, NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"service_accept: %s\", reply);\n\t\tfree(reply);\n\t} else {\n\t\tdebug2(\"buggy server: service_accept w/o service\");\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tdebug(\"SSH2_MSG_SERVICE_ACCEPT received\");\n\n\t/* initial userauth request */\n\tuserauth_none(authctxt);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);\n\tr = 0;\n out:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"X11 connection requested.\""
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "c->sock",
            "readset"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_ISSET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "22-24",
          "snippet": "int kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nint kludge_FD_ISSET(int n, fd_set *set) {\n\treturn FD_ISSET(n, set);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_post_x11_listener(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tChannel *nc;\n\tstruct sockaddr_storage addr;\n\tint r, newsock, oerrno, remote_port;\n\tsocklen_t addrlen;\n\tchar buf[16384], *remote_ipaddr;\n\n\tif (!FD_ISSET(c->sock, readset))\n\t\treturn;\n\n\tdebug(\"X11 connection requested.\");\n\taddrlen = sizeof(addr);\n\tnewsock = accept(c->sock, (struct sockaddr *)&addr, &addrlen);\n\tif (c->single_connection) {\n\t\toerrno = errno;\n\t\tdebug2(\"single_connection: closing X11 listener.\");\n\t\tchannel_close_fd(ssh, &c->sock);\n\t\tchan_mark_dead(ssh, c);\n\t\terrno = oerrno;\n\t}\n\tif (newsock < 0) {\n\t\tif (errno != EINTR && errno != EWOULDBLOCK &&\n\t\t    errno != ECONNABORTED)\n\t\t\terror(\"accept: %.100s\", strerror(errno));\n\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\tc->notbefore = monotime() + 1;\n\t\treturn;\n\t}\n\tset_nodelay(newsock);\n\tremote_ipaddr = get_peer_ipaddr(newsock);\n\tremote_port = get_peer_port(newsock);\n\tsnprintf(buf, sizeof buf, \"X11 connection from %.200s port %d\",\n\t    remote_ipaddr, remote_port);\n\n\tnc = channel_new(ssh, \"accepted x11 socket\",\n\t    SSH_CHANNEL_OPENING, newsock, newsock, -1,\n\t    c->local_window_max, c->local_maxpacket, 0, buf, 1);\n\topen_preamble(ssh, __func__, nc, \"x11\");\n\tif ((r = sshpkt_put_cstring(ssh, remote_ipaddr)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, remote_port)) != 0) {\n\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: send %s\", __func__, c->self, ssh_err(r));\n\tfree(remote_ipaddr);\n}"
  },
  {
    "function_name": "channel_before_prepare_select_rdynamic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1572-1632",
    "snippet": "static void\nchannel_before_prepare_select_rdynamic(struct ssh *ssh, Channel *c)\n{\n\tconst u_char *p;\n\tu_int have, len;\n\tint r, ret;\n\n\thave = sshbuf_len(c->output);\n\tdebug2(\"channel %d: pre_rdynamic: have %d\", c->self, have);\n\t/* sshbuf_dump(c->output, stderr); */\n\t/* EOF received */\n\tif (c->flags & CHAN_EOF_RCVD) {\n\t\tif ((r = sshbuf_consume(c->output, have)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t\trdynamic_close(ssh, c);\n\t\treturn;\n\t}\n\t/* check if the fixed size part of the packet is in buffer. */\n\tif (have < 3)\n\t\treturn;\n\t/* try to guess the protocol */\n\tp = sshbuf_ptr(c->output);\n\tswitch (p[0]) {\n\tcase 0x04:\n\t\t/* switch input/output for reverse forwarding */\n\t\tret = channel_decode_socks4(c, c->output, c->input);\n\t\tbreak;\n\tcase 0x05:\n\t\tret = channel_decode_socks5(c, c->output, c->input);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\tif (ret < 0) {\n\t\trdynamic_close(ssh, c);\n\t} else if (ret == 0) {\n\t\tdebug2(\"channel %d: pre_rdynamic: need more\", c->self);\n\t\t/* send socks request to peer */\n\t\tlen = sshbuf_len(c->input);\n\t\tif (len > 0 && len < c->remote_window) {\n\t\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_DATA)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t\t    (r = sshpkt_put_stringb(ssh, c->input)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\t\tfatal(\"%s: channel %i: rdynamic: %s\", __func__,\n\t\t\t\t    c->self, ssh_err(r));\n\t\t\t}\n\t\t\tif ((r = sshbuf_consume(c->input, len)) != 0) {\n\t\t\t\tfatal(\"%s: channel %d: consume: %s\",\n\t\t\t\t    __func__, c->self, ssh_err(r));\n\t\t\t}\n\t\t\tc->remote_window -= len;\n\t\t}\n\t} else if (rdynamic_connect_finish(ssh, c) < 0) {\n\t\t/* the connect failed */\n\t\trdynamic_close(ssh, c);\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rdynamic_close",
          "args": [
            "ssh",
            "c"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "rdynamic_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1560-1569",
          "snippet": "static void\nrdynamic_close(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_OPEN;\n\tchan_read_failed(ssh, c);\n\tsshbuf_reset(c->input);\n\tchan_ibuf_empty(ssh, c);\n\tsshbuf_reset(c->output);\n\tchan_write_failed(ssh, c);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nrdynamic_close(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_OPEN;\n\tchan_read_failed(ssh, c);\n\tsshbuf_reset(c->input);\n\tchan_ibuf_empty(ssh, c);\n\tsshbuf_reset(c->output);\n\tchan_write_failed(ssh, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdynamic_connect_finish",
          "args": [
            "ssh",
            "c"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "rdynamic_connect_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4509-4527",
          "snippet": "static int\nrdynamic_connect_finish(struct ssh *ssh, Channel *c)\n{\n\tstruct channel_connect cctx;\n\tint sock;\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, c->path, c->host_port, SOCK_STREAM, NULL,\n\t    NULL, &cctx, NULL, NULL);\n\tif (sock == -1)\n\t\tchannel_connect_ctx_free(&cctx);\n\telse {\n\t\t/* similar to SSH_CHANNEL_CONNECTING but we've already sent the open */\n\t\tc->type = SSH_CHANNEL_RDYNAMIC_FINISH;\n\t\tc->connect_ctx = cctx;\n\t\tchannel_register_fds(ssh, c, sock, sock, -1, 0, 1, 0);\n\t}\n\treturn sock;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nrdynamic_connect_finish(struct ssh *ssh, Channel *c)\n{\n\tstruct channel_connect cctx;\n\tint sock;\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, c->path, c->host_port, SOCK_STREAM, NULL,\n\t    NULL, &cctx, NULL, NULL);\n\tif (sock == -1)\n\t\tchannel_connect_ctx_free(&cctx);\n\telse {\n\t\t/* similar to SSH_CHANNEL_CONNECTING but we've already sent the open */\n\t\tc->type = SSH_CHANNEL_RDYNAMIC_FINISH;\n\t\tc->connect_ctx = cctx;\n\t\tchannel_register_fds(ssh, c, sock, sock, -1, 0, 1, 0);\n\t}\n\treturn sock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %d: consume: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "c->input",
            "len"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_stringb",
          "args": [
            "ssh",
            "c->input"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2465-2469",
          "snippet": "int\nsshpkt_put_stringb(struct ssh *ssh, const struct sshbuf *v)\n{\n\treturn sshbuf_put_stringb(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_stringb(struct ssh *ssh, const struct sshbuf *v)\n{\n\treturn sshbuf_put_stringb(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "c->remote_id"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_CHANNEL_DATA"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "c->input"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: pre_rdynamic: need more\"",
            "c->self"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_decode_socks5",
          "args": [
            "c",
            "c->output",
            "c->input"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "channel_decode_socks5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1353-1487",
          "snippet": "static int\nchannel_decode_socks5(Channel *c, struct sshbuf *input, struct sshbuf *output)\n{\n\t/* XXX use get/put_u8 instead of trusting struct padding */\n\tstruct {\n\t\tu_int8_t version;\n\t\tu_int8_t command;\n\t\tu_int8_t reserved;\n\t\tu_int8_t atyp;\n\t} s5_req, s5_rsp;\n\tu_int16_t dest_port;\n\tchar dest_addr[255+1], ntop[INET6_ADDRSTRLEN];\n\tconst u_char *p;\n\tu_int have, need, i, found, nmethods, addrlen, af;\n\tint r;\n\n\tdebug2(\"channel %d: decode socks5\", c->self);\n\tp = sshbuf_ptr(input);\n\tif (p[0] != 0x05)\n\t\treturn -1;\n\thave = sshbuf_len(input);\n\tif (!(c->flags & SSH_SOCKS5_AUTHDONE)) {\n\t\t/* format: ver | nmethods | methods */\n\t\tif (have < 2)\n\t\t\treturn 0;\n\t\tnmethods = p[1];\n\t\tif (have < nmethods + 2)\n\t\t\treturn 0;\n\t\t/* look for method: \"NO AUTHENTICATION REQUIRED\" */\n\t\tfor (found = 0, i = 2; i < nmethods + 2; i++) {\n\t\t\tif (p[i] == SSH_SOCKS5_NOAUTH) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tdebug(\"channel %d: method SSH_SOCKS5_NOAUTH not found\",\n\t\t\t    c->self);\n\t\t\treturn -1;\n\t\t}\n\t\tif ((r = sshbuf_consume(input, nmethods + 2)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\t/* version, method */\n\t\tif ((r = sshbuf_put_u8(output, 0x05)) != 0 ||\n\t\t    (r = sshbuf_put_u8(output, SSH_SOCKS5_NOAUTH)) != 0) {\n\t\t\tfatal(\"%s: channel %d: append reply: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\tc->flags |= SSH_SOCKS5_AUTHDONE;\n\t\tdebug2(\"channel %d: socks5 auth done\", c->self);\n\t\treturn 0;\t\t\t\t/* need more */\n\t}\n\tdebug2(\"channel %d: socks5 post auth\", c->self);\n\tif (have < sizeof(s5_req)+1)\n\t\treturn 0;\t\t\t/* need more */\n\tmemcpy(&s5_req, p, sizeof(s5_req));\n\tif (s5_req.version != 0x05 ||\n\t    s5_req.command != SSH_SOCKS5_CONNECT ||\n\t    s5_req.reserved != 0x00) {\n\t\tdebug2(\"channel %d: only socks5 connect supported\", c->self);\n\t\treturn -1;\n\t}\n\tswitch (s5_req.atyp){\n\tcase SSH_SOCKS5_IPV4:\n\t\taddrlen = 4;\n\t\taf = AF_INET;\n\t\tbreak;\n\tcase SSH_SOCKS5_DOMAIN:\n\t\taddrlen = p[sizeof(s5_req)];\n\t\taf = -1;\n\t\tbreak;\n\tcase SSH_SOCKS5_IPV6:\n\t\taddrlen = 16;\n\t\taf = AF_INET6;\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"channel %d: bad socks5 atyp %d\", c->self, s5_req.atyp);\n\t\treturn -1;\n\t}\n\tneed = sizeof(s5_req) + addrlen + 2;\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN)\n\t\tneed++;\n\tif (have < need)\n\t\treturn 0;\n\tif ((r = sshbuf_consume(input, sizeof(s5_req))) != 0) {\n\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN) {\n\t\t/* host string length */\n\t\tif ((r = sshbuf_consume(input, 1)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif ((r = sshbuf_get(input, &dest_addr, addrlen)) != 0 ||\n\t    (r = sshbuf_get(input, &dest_port, 2)) != 0) {\n\t\tdebug(\"channel %d: parse addr/port: %s\", c->self, ssh_err(r));\n\t\treturn -1;\n\t}\n\tdest_addr[addrlen] = '\\0';\n\tfree(c->path);\n\tc->path = NULL;\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN) {\n\t\tif (addrlen >= NI_MAXHOST) {\n\t\t\terror(\"channel %d: dynamic request: socks5 hostname \"\n\t\t\t    \"\\\"%.100s\\\" too long\", c->self, dest_addr);\n\t\t\treturn -1;\n\t\t}\n\t\tc->path = xstrdup(dest_addr);\n\t} else {\n\t\tif (inet_ntop(af, dest_addr, ntop, sizeof(ntop)) == NULL)\n\t\t\treturn -1;\n\t\tc->path = xstrdup(ntop);\n\t}\n\tc->host_port = ntohs(dest_port);\n\n\tdebug2(\"channel %d: dynamic request: socks5 host %s port %u command %u\",\n\t    c->self, c->path, c->host_port, s5_req.command);\n\n\ts5_rsp.version = 0x05;\n\ts5_rsp.command = SSH_SOCKS5_SUCCESS;\n\ts5_rsp.reserved = 0;\t\t\t/* ignored */\n\ts5_rsp.atyp = SSH_SOCKS5_IPV4;\n\tdest_port = 0;\t\t\t\t/* ignored */\n\n\tif ((r = sshbuf_put(output, &s5_rsp, sizeof(s5_rsp))) != 0 ||\n\t    (r = sshbuf_put_u32(output, ntohl(INADDR_ANY))) != 0 ||\n\t    (r = sshbuf_put(output, &dest_port, sizeof(dest_port))) != 0)\n\t\tfatal(\"%s: channel %d: append reply: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SSH_SOCKS5_SUCCESS\t0x00",
            "#define SSH_SOCKS5_CONNECT\t0x01",
            "#define SSH_SOCKS5_IPV6\t\t0x04",
            "#define SSH_SOCKS5_DOMAIN\t0x03",
            "#define SSH_SOCKS5_IPV4\t\t0x01",
            "#define SSH_SOCKS5_NOAUTH\t0x00",
            "#define SSH_SOCKS5_AUTHDONE\t0x1000"
          ],
          "globals_used": [
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SSH_SOCKS5_SUCCESS\t0x00\n#define SSH_SOCKS5_CONNECT\t0x01\n#define SSH_SOCKS5_IPV6\t\t0x04\n#define SSH_SOCKS5_DOMAIN\t0x03\n#define SSH_SOCKS5_IPV4\t\t0x01\n#define SSH_SOCKS5_NOAUTH\t0x00\n#define SSH_SOCKS5_AUTHDONE\t0x1000\n\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_decode_socks5(Channel *c, struct sshbuf *input, struct sshbuf *output)\n{\n\t/* XXX use get/put_u8 instead of trusting struct padding */\n\tstruct {\n\t\tu_int8_t version;\n\t\tu_int8_t command;\n\t\tu_int8_t reserved;\n\t\tu_int8_t atyp;\n\t} s5_req, s5_rsp;\n\tu_int16_t dest_port;\n\tchar dest_addr[255+1], ntop[INET6_ADDRSTRLEN];\n\tconst u_char *p;\n\tu_int have, need, i, found, nmethods, addrlen, af;\n\tint r;\n\n\tdebug2(\"channel %d: decode socks5\", c->self);\n\tp = sshbuf_ptr(input);\n\tif (p[0] != 0x05)\n\t\treturn -1;\n\thave = sshbuf_len(input);\n\tif (!(c->flags & SSH_SOCKS5_AUTHDONE)) {\n\t\t/* format: ver | nmethods | methods */\n\t\tif (have < 2)\n\t\t\treturn 0;\n\t\tnmethods = p[1];\n\t\tif (have < nmethods + 2)\n\t\t\treturn 0;\n\t\t/* look for method: \"NO AUTHENTICATION REQUIRED\" */\n\t\tfor (found = 0, i = 2; i < nmethods + 2; i++) {\n\t\t\tif (p[i] == SSH_SOCKS5_NOAUTH) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tdebug(\"channel %d: method SSH_SOCKS5_NOAUTH not found\",\n\t\t\t    c->self);\n\t\t\treturn -1;\n\t\t}\n\t\tif ((r = sshbuf_consume(input, nmethods + 2)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\t/* version, method */\n\t\tif ((r = sshbuf_put_u8(output, 0x05)) != 0 ||\n\t\t    (r = sshbuf_put_u8(output, SSH_SOCKS5_NOAUTH)) != 0) {\n\t\t\tfatal(\"%s: channel %d: append reply: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\tc->flags |= SSH_SOCKS5_AUTHDONE;\n\t\tdebug2(\"channel %d: socks5 auth done\", c->self);\n\t\treturn 0;\t\t\t\t/* need more */\n\t}\n\tdebug2(\"channel %d: socks5 post auth\", c->self);\n\tif (have < sizeof(s5_req)+1)\n\t\treturn 0;\t\t\t/* need more */\n\tmemcpy(&s5_req, p, sizeof(s5_req));\n\tif (s5_req.version != 0x05 ||\n\t    s5_req.command != SSH_SOCKS5_CONNECT ||\n\t    s5_req.reserved != 0x00) {\n\t\tdebug2(\"channel %d: only socks5 connect supported\", c->self);\n\t\treturn -1;\n\t}\n\tswitch (s5_req.atyp){\n\tcase SSH_SOCKS5_IPV4:\n\t\taddrlen = 4;\n\t\taf = AF_INET;\n\t\tbreak;\n\tcase SSH_SOCKS5_DOMAIN:\n\t\taddrlen = p[sizeof(s5_req)];\n\t\taf = -1;\n\t\tbreak;\n\tcase SSH_SOCKS5_IPV6:\n\t\taddrlen = 16;\n\t\taf = AF_INET6;\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"channel %d: bad socks5 atyp %d\", c->self, s5_req.atyp);\n\t\treturn -1;\n\t}\n\tneed = sizeof(s5_req) + addrlen + 2;\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN)\n\t\tneed++;\n\tif (have < need)\n\t\treturn 0;\n\tif ((r = sshbuf_consume(input, sizeof(s5_req))) != 0) {\n\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN) {\n\t\t/* host string length */\n\t\tif ((r = sshbuf_consume(input, 1)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif ((r = sshbuf_get(input, &dest_addr, addrlen)) != 0 ||\n\t    (r = sshbuf_get(input, &dest_port, 2)) != 0) {\n\t\tdebug(\"channel %d: parse addr/port: %s\", c->self, ssh_err(r));\n\t\treturn -1;\n\t}\n\tdest_addr[addrlen] = '\\0';\n\tfree(c->path);\n\tc->path = NULL;\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN) {\n\t\tif (addrlen >= NI_MAXHOST) {\n\t\t\terror(\"channel %d: dynamic request: socks5 hostname \"\n\t\t\t    \"\\\"%.100s\\\" too long\", c->self, dest_addr);\n\t\t\treturn -1;\n\t\t}\n\t\tc->path = xstrdup(dest_addr);\n\t} else {\n\t\tif (inet_ntop(af, dest_addr, ntop, sizeof(ntop)) == NULL)\n\t\t\treturn -1;\n\t\tc->path = xstrdup(ntop);\n\t}\n\tc->host_port = ntohs(dest_port);\n\n\tdebug2(\"channel %d: dynamic request: socks5 host %s port %u command %u\",\n\t    c->self, c->path, c->host_port, s5_req.command);\n\n\ts5_rsp.version = 0x05;\n\ts5_rsp.command = SSH_SOCKS5_SUCCESS;\n\ts5_rsp.reserved = 0;\t\t\t/* ignored */\n\ts5_rsp.atyp = SSH_SOCKS5_IPV4;\n\tdest_port = 0;\t\t\t\t/* ignored */\n\n\tif ((r = sshbuf_put(output, &s5_rsp, sizeof(s5_rsp))) != 0 ||\n\t    (r = sshbuf_put_u32(output, ntohl(INADDR_ANY))) != 0 ||\n\t    (r = sshbuf_put(output, &dest_port, sizeof(dest_port))) != 0)\n\t\tfatal(\"%s: channel %d: append reply: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_decode_socks4",
          "args": [
            "c",
            "c->output",
            "c->input"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "channel_decode_socks4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1227-1342",
          "snippet": "static int\nchannel_decode_socks4(Channel *c, struct sshbuf *input, struct sshbuf *output)\n{\n\tconst u_char *p;\n\tchar *host;\n\tu_int len, have, i, found, need;\n\tchar username[256];\n\tstruct {\n\t\tu_int8_t version;\n\t\tu_int8_t command;\n\t\tu_int16_t dest_port;\n\t\tstruct in_addr dest_addr;\n\t} s4_req, s4_rsp;\n\tint r;\n\n\tdebug2(\"channel %d: decode socks4\", c->self);\n\n\thave = sshbuf_len(input);\n\tlen = sizeof(s4_req);\n\tif (have < len)\n\t\treturn 0;\n\tp = sshbuf_ptr(input);\n\n\tneed = 1;\n\t/* SOCKS4A uses an invalid IP address 0.0.0.x */\n\tif (p[4] == 0 && p[5] == 0 && p[6] == 0 && p[7] != 0) {\n\t\tdebug2(\"channel %d: socks4a request\", c->self);\n\t\t/* ... and needs an extra string (the hostname) */\n\t\tneed = 2;\n\t}\n\t/* Check for terminating NUL on the string(s) */\n\tfor (found = 0, i = len; i < have; i++) {\n\t\tif (p[i] == '\\0') {\n\t\t\tfound++;\n\t\t\tif (found == need)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i > 1024) {\n\t\t\t/* the peer is probably sending garbage */\n\t\t\tdebug(\"channel %d: decode socks4: too long\",\n\t\t\t    c->self);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (found < need)\n\t\treturn 0;\n\tif ((r = sshbuf_get(input, &s4_req.version, 1)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.command, 1)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.dest_port, 2)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.dest_addr, 4)) != 0) {\n\t\tdebug(\"channels %d: decode socks4: %s\", c->self, ssh_err(r));\n\t\treturn -1;\n\t}\n\thave = sshbuf_len(input);\n\tp = sshbuf_ptr(input);\n\tif (memchr(p, '\\0', have) == NULL) {\n\t\terror(\"channel %d: decode socks4: user not nul terminated\",\n\t\t    c->self);\n\t\treturn -1;\n\t}\n\tlen = strlen(p);\n\tdebug2(\"channel %d: decode socks4: user %s/%d\", c->self, p, len);\n\tlen++; /* trailing '\\0' */\n\tstrlcpy(username, p, sizeof(username));\n\tif ((r = sshbuf_consume(input, len)) != 0) {\n\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tfree(c->path);\n\tc->path = NULL;\n\tif (need == 1) {\t\t\t/* SOCKS4: one string */\n\t\thost = inet_ntoa(s4_req.dest_addr);\n\t\tc->path = xstrdup(host);\n\t} else {\t\t\t\t/* SOCKS4A: two strings */\n\t\thave = sshbuf_len(input);\n\t\tp = sshbuf_ptr(input);\n\t\tif (memchr(p, '\\0', have) == NULL) {\n\t\t\terror(\"channel %d: decode socks4a: host not nul \"\n\t\t\t    \"terminated\", c->self);\n\t\t\treturn -1;\n\t\t}\n\t\tlen = strlen(p);\n\t\tdebug2(\"channel %d: decode socks4a: host %s/%d\",\n\t\t    c->self, p, len);\n\t\tlen++;\t\t\t\t/* trailing '\\0' */\n\t\tif (len > NI_MAXHOST) {\n\t\t\terror(\"channel %d: hostname \\\"%.100s\\\" too long\",\n\t\t\t    c->self, p);\n\t\t\treturn -1;\n\t\t}\n\t\tc->path = xstrdup(p);\n\t\tif ((r = sshbuf_consume(input, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tc->host_port = ntohs(s4_req.dest_port);\n\n\tdebug2(\"channel %d: dynamic request: socks4 host %s port %u command %u\",\n\t    c->self, c->path, c->host_port, s4_req.command);\n\n\tif (s4_req.command != 1) {\n\t\tdebug(\"channel %d: cannot handle: %s cn %d\",\n\t\t    c->self, need == 1 ? \"SOCKS4\" : \"SOCKS4A\", s4_req.command);\n\t\treturn -1;\n\t}\n\ts4_rsp.version = 0;\t\t\t/* vn: 0 for reply */\n\ts4_rsp.command = 90;\t\t\t/* cd: req granted */\n\ts4_rsp.dest_port = 0;\t\t\t/* ignored */\n\ts4_rsp.dest_addr.s_addr = INADDR_ANY;\t/* ignored */\n\tif ((r = sshbuf_put(output, &s4_rsp, sizeof(s4_rsp))) != 0) {\n\t\tfatal(\"%s: channel %d: append reply: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_decode_socks4(Channel *c, struct sshbuf *input, struct sshbuf *output)\n{\n\tconst u_char *p;\n\tchar *host;\n\tu_int len, have, i, found, need;\n\tchar username[256];\n\tstruct {\n\t\tu_int8_t version;\n\t\tu_int8_t command;\n\t\tu_int16_t dest_port;\n\t\tstruct in_addr dest_addr;\n\t} s4_req, s4_rsp;\n\tint r;\n\n\tdebug2(\"channel %d: decode socks4\", c->self);\n\n\thave = sshbuf_len(input);\n\tlen = sizeof(s4_req);\n\tif (have < len)\n\t\treturn 0;\n\tp = sshbuf_ptr(input);\n\n\tneed = 1;\n\t/* SOCKS4A uses an invalid IP address 0.0.0.x */\n\tif (p[4] == 0 && p[5] == 0 && p[6] == 0 && p[7] != 0) {\n\t\tdebug2(\"channel %d: socks4a request\", c->self);\n\t\t/* ... and needs an extra string (the hostname) */\n\t\tneed = 2;\n\t}\n\t/* Check for terminating NUL on the string(s) */\n\tfor (found = 0, i = len; i < have; i++) {\n\t\tif (p[i] == '\\0') {\n\t\t\tfound++;\n\t\t\tif (found == need)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i > 1024) {\n\t\t\t/* the peer is probably sending garbage */\n\t\t\tdebug(\"channel %d: decode socks4: too long\",\n\t\t\t    c->self);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (found < need)\n\t\treturn 0;\n\tif ((r = sshbuf_get(input, &s4_req.version, 1)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.command, 1)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.dest_port, 2)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.dest_addr, 4)) != 0) {\n\t\tdebug(\"channels %d: decode socks4: %s\", c->self, ssh_err(r));\n\t\treturn -1;\n\t}\n\thave = sshbuf_len(input);\n\tp = sshbuf_ptr(input);\n\tif (memchr(p, '\\0', have) == NULL) {\n\t\terror(\"channel %d: decode socks4: user not nul terminated\",\n\t\t    c->self);\n\t\treturn -1;\n\t}\n\tlen = strlen(p);\n\tdebug2(\"channel %d: decode socks4: user %s/%d\", c->self, p, len);\n\tlen++; /* trailing '\\0' */\n\tstrlcpy(username, p, sizeof(username));\n\tif ((r = sshbuf_consume(input, len)) != 0) {\n\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tfree(c->path);\n\tc->path = NULL;\n\tif (need == 1) {\t\t\t/* SOCKS4: one string */\n\t\thost = inet_ntoa(s4_req.dest_addr);\n\t\tc->path = xstrdup(host);\n\t} else {\t\t\t\t/* SOCKS4A: two strings */\n\t\thave = sshbuf_len(input);\n\t\tp = sshbuf_ptr(input);\n\t\tif (memchr(p, '\\0', have) == NULL) {\n\t\t\terror(\"channel %d: decode socks4a: host not nul \"\n\t\t\t    \"terminated\", c->self);\n\t\t\treturn -1;\n\t\t}\n\t\tlen = strlen(p);\n\t\tdebug2(\"channel %d: decode socks4a: host %s/%d\",\n\t\t    c->self, p, len);\n\t\tlen++;\t\t\t\t/* trailing '\\0' */\n\t\tif (len > NI_MAXHOST) {\n\t\t\terror(\"channel %d: hostname \\\"%.100s\\\" too long\",\n\t\t\t    c->self, p);\n\t\t\treturn -1;\n\t\t}\n\t\tc->path = xstrdup(p);\n\t\tif ((r = sshbuf_consume(input, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tc->host_port = ntohs(s4_req.dest_port);\n\n\tdebug2(\"channel %d: dynamic request: socks4 host %s port %u command %u\",\n\t    c->self, c->path, c->host_port, s4_req.command);\n\n\tif (s4_req.command != 1) {\n\t\tdebug(\"channel %d: cannot handle: %s cn %d\",\n\t\t    c->self, need == 1 ? \"SOCKS4\" : \"SOCKS4A\", s4_req.command);\n\t\treturn -1;\n\t}\n\ts4_rsp.version = 0;\t\t\t/* vn: 0 for reply */\n\ts4_rsp.command = 90;\t\t\t/* cd: req granted */\n\ts4_rsp.dest_port = 0;\t\t\t/* ignored */\n\ts4_rsp.dest_addr.s_addr = INADDR_ANY;\t/* ignored */\n\tif ((r = sshbuf_put(output, &s4_rsp, sizeof(s4_rsp))) != 0) {\n\t\tfatal(\"%s: channel %d: append reply: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "c->output"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_before_prepare_select_rdynamic(struct ssh *ssh, Channel *c)\n{\n\tconst u_char *p;\n\tu_int have, len;\n\tint r, ret;\n\n\thave = sshbuf_len(c->output);\n\tdebug2(\"channel %d: pre_rdynamic: have %d\", c->self, have);\n\t/* sshbuf_dump(c->output, stderr); */\n\t/* EOF received */\n\tif (c->flags & CHAN_EOF_RCVD) {\n\t\tif ((r = sshbuf_consume(c->output, have)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\",\n\t\t\t    __func__, c->self, ssh_err(r));\n\t\t}\n\t\trdynamic_close(ssh, c);\n\t\treturn;\n\t}\n\t/* check if the fixed size part of the packet is in buffer. */\n\tif (have < 3)\n\t\treturn;\n\t/* try to guess the protocol */\n\tp = sshbuf_ptr(c->output);\n\tswitch (p[0]) {\n\tcase 0x04:\n\t\t/* switch input/output for reverse forwarding */\n\t\tret = channel_decode_socks4(c, c->output, c->input);\n\t\tbreak;\n\tcase 0x05:\n\t\tret = channel_decode_socks5(c, c->output, c->input);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\tif (ret < 0) {\n\t\trdynamic_close(ssh, c);\n\t} else if (ret == 0) {\n\t\tdebug2(\"channel %d: pre_rdynamic: need more\", c->self);\n\t\t/* send socks request to peer */\n\t\tlen = sshbuf_len(c->input);\n\t\tif (len > 0 && len < c->remote_window) {\n\t\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_DATA)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t\t    (r = sshpkt_put_stringb(ssh, c->input)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\t\tfatal(\"%s: channel %i: rdynamic: %s\", __func__,\n\t\t\t\t    c->self, ssh_err(r));\n\t\t\t}\n\t\t\tif ((r = sshbuf_consume(c->input, len)) != 0) {\n\t\t\t\tfatal(\"%s: channel %d: consume: %s\",\n\t\t\t\t    __func__, c->self, ssh_err(r));\n\t\t\t}\n\t\t\tc->remote_window -= len;\n\t\t}\n\t} else if (rdynamic_connect_finish(ssh, c) < 0) {\n\t\t/* the connect failed */\n\t\trdynamic_close(ssh, c);\n\t}\n}"
  },
  {
    "function_name": "rdynamic_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1560-1569",
    "snippet": "static void\nrdynamic_close(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_OPEN;\n\tchan_read_failed(ssh, c);\n\tsshbuf_reset(c->input);\n\tchan_ibuf_empty(ssh, c);\n\tsshbuf_reset(c->output);\n\tchan_write_failed(ssh, c);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "chan_write_failed",
          "args": [
            "ssh",
            "c"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "chan_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "305-322",
          "snippet": "void\nchan_write_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: write failed\", c->self);\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tif (strcmp(c->ctype, \"session\") == 0)\n\t\t\tchan_send_eow2(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_write_failed for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_write_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: write failed\", c->self);\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tif (strcmp(c->ctype, \"session\") == 0)\n\t\t\tchan_send_eow2(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_write_failed for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "c->output"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_ibuf_empty",
          "args": [
            "ssh",
            "c"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "chan_ibuf_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "124-144",
          "snippet": "void\nchan_ibuf_empty(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: ibuf empty\", c->self);\n\tif (sshbuf_len(c->input)) {\n\t\terror(\"channel %d: chan_ibuf_empty for non empty buffer\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & (CHAN_CLOSE_SENT|CHAN_LOCAL)))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_ibuf_empty for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_ibuf_empty(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: ibuf empty\", c->self);\n\tif (sshbuf_len(c->input)) {\n\t\terror(\"channel %d: chan_ibuf_empty for non empty buffer\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & (CHAN_CLOSE_SENT|CHAN_LOCAL)))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_ibuf_empty for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_read_failed",
          "args": [
            "ssh",
            "c"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "chan_read_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "108-122",
          "snippet": "void\nchan_read_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: read failed\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_WAIT_DRAIN);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_read_failed for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_read_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: read failed\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_WAIT_DRAIN);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_read_failed for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nrdynamic_close(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_OPEN;\n\tchan_read_failed(ssh, c);\n\tsshbuf_reset(c->input);\n\tchan_ibuf_empty(ssh, c);\n\tsshbuf_reset(c->output);\n\tchan_write_failed(ssh, c);\n}"
  },
  {
    "function_name": "channel_pre_dynamic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1513-1557",
    "snippet": "static void\nchannel_pre_dynamic(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tconst u_char *p;\n\tu_int have;\n\tint ret;\n\n\thave = sshbuf_len(c->input);\n\tdebug2(\"channel %d: pre_dynamic: have %d\", c->self, have);\n\t/* sshbuf_dump(c->input, stderr); */\n\t/* check if the fixed size part of the packet is in buffer. */\n\tif (have < 3) {\n\t\t/* need more */\n\t\tFD_SET(c->sock, readset);\n\t\treturn;\n\t}\n\t/* try to guess the protocol */\n\tp = sshbuf_ptr(c->input);\n\t/* XXX sshbuf_peek_u8? */\n\tswitch (p[0]) {\n\tcase 0x04:\n\t\tret = channel_decode_socks4(c, c->input, c->output);\n\t\tbreak;\n\tcase 0x05:\n\t\tret = channel_decode_socks5(c, c->input, c->output);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\tif (ret < 0) {\n\t\tchan_mark_dead(ssh, c);\n\t} else if (ret == 0) {\n\t\tdebug2(\"channel %d: pre_dynamic: need more\", c->self);\n\t\t/* need more */\n\t\tFD_SET(c->sock, readset);\n\t\tif (sshbuf_len(c->output))\n\t\t\tFD_SET(c->sock, writeset);\n\t} else {\n\t\t/* switch to the next state */\n\t\tc->type = SSH_CHANNEL_OPENING;\n\t\tport_open_helper(ssh, c, \"direct-tcpip\");\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "port_open_helper",
          "args": [
            "ssh",
            "c",
            "\"direct-tcpip\""
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "port_open_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1686-1755",
          "snippet": "static void\nport_open_helper(struct ssh *ssh, Channel *c, char *rtype)\n{\n\tchar *local_ipaddr = get_local_ipaddr(c->sock);\n\tint local_port = c->sock == -1 ? 65536 : get_local_port(c->sock);\n\tchar *remote_ipaddr = get_peer_ipaddr(c->sock);\n\tint remote_port = get_peer_port(c->sock);\n\tint r;\n\n\tif (remote_port == -1) {\n\t\t/* Fake addr/port to appease peers that validate it (Tectia) */\n\t\tfree(remote_ipaddr);\n\t\tremote_ipaddr = xstrdup(\"127.0.0.1\");\n\t\tremote_port = 65535;\n\t}\n\n\tfree(c->remote_name);\n\txasprintf(&c->remote_name,\n\t    \"%s: listening port %d for %.100s port %d, \"\n\t    \"connect from %.200s port %d to %.100s port %d\",\n\t    rtype, c->listening_port, c->path, c->host_port,\n\t    remote_ipaddr, remote_port, local_ipaddr, local_port);\n\n\topen_preamble(ssh, __func__, c, rtype);\n\tif (strcmp(rtype, \"direct-tcpip\") == 0) {\n\t\t/* target host, port */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->host_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else if (strcmp(rtype, \"direct-streamlocal@openssh.com\") == 0) {\n\t\t/* target path */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else if (strcmp(rtype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\t/* listen path */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else {\n\t\t/* listen address, port */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, local_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif (strcmp(rtype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\t/* reserved for future owner/mode info */\n\t\tif ((r = sshpkt_put_cstring(ssh, \"\")) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else {\n\t\t/* originator host and port */\n\t\tif ((r = sshpkt_put_cstring(ssh, remote_ipaddr)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)remote_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: send %s\", __func__, c->self, ssh_err(r));\n\tfree(remote_ipaddr);\n\tfree(local_ipaddr);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void port_open_helper(struct ssh *ssh, Channel *c, char *rtype);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void port_open_helper(struct ssh *ssh, Channel *c, char *rtype);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nport_open_helper(struct ssh *ssh, Channel *c, char *rtype)\n{\n\tchar *local_ipaddr = get_local_ipaddr(c->sock);\n\tint local_port = c->sock == -1 ? 65536 : get_local_port(c->sock);\n\tchar *remote_ipaddr = get_peer_ipaddr(c->sock);\n\tint remote_port = get_peer_port(c->sock);\n\tint r;\n\n\tif (remote_port == -1) {\n\t\t/* Fake addr/port to appease peers that validate it (Tectia) */\n\t\tfree(remote_ipaddr);\n\t\tremote_ipaddr = xstrdup(\"127.0.0.1\");\n\t\tremote_port = 65535;\n\t}\n\n\tfree(c->remote_name);\n\txasprintf(&c->remote_name,\n\t    \"%s: listening port %d for %.100s port %d, \"\n\t    \"connect from %.200s port %d to %.100s port %d\",\n\t    rtype, c->listening_port, c->path, c->host_port,\n\t    remote_ipaddr, remote_port, local_ipaddr, local_port);\n\n\topen_preamble(ssh, __func__, c, rtype);\n\tif (strcmp(rtype, \"direct-tcpip\") == 0) {\n\t\t/* target host, port */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->host_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else if (strcmp(rtype, \"direct-streamlocal@openssh.com\") == 0) {\n\t\t/* target path */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else if (strcmp(rtype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\t/* listen path */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else {\n\t\t/* listen address, port */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, local_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif (strcmp(rtype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\t/* reserved for future owner/mode info */\n\t\tif ((r = sshpkt_put_cstring(ssh, \"\")) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else {\n\t\t/* originator host and port */\n\t\tif ((r = sshpkt_put_cstring(ssh, remote_ipaddr)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)remote_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: send %s\", __func__, c->self, ssh_err(r));\n\tfree(remote_ipaddr);\n\tfree(local_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "c->sock",
            "writeset"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_SET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "19-21",
          "snippet": "void kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nvoid kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "c->output"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: pre_dynamic: need more\"",
            "c->self"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_mark_dead",
          "args": [
            "ssh",
            "c"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "chan_mark_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "324-328",
          "snippet": "void\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_decode_socks5",
          "args": [
            "c",
            "c->input",
            "c->output"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "channel_decode_socks5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1353-1487",
          "snippet": "static int\nchannel_decode_socks5(Channel *c, struct sshbuf *input, struct sshbuf *output)\n{\n\t/* XXX use get/put_u8 instead of trusting struct padding */\n\tstruct {\n\t\tu_int8_t version;\n\t\tu_int8_t command;\n\t\tu_int8_t reserved;\n\t\tu_int8_t atyp;\n\t} s5_req, s5_rsp;\n\tu_int16_t dest_port;\n\tchar dest_addr[255+1], ntop[INET6_ADDRSTRLEN];\n\tconst u_char *p;\n\tu_int have, need, i, found, nmethods, addrlen, af;\n\tint r;\n\n\tdebug2(\"channel %d: decode socks5\", c->self);\n\tp = sshbuf_ptr(input);\n\tif (p[0] != 0x05)\n\t\treturn -1;\n\thave = sshbuf_len(input);\n\tif (!(c->flags & SSH_SOCKS5_AUTHDONE)) {\n\t\t/* format: ver | nmethods | methods */\n\t\tif (have < 2)\n\t\t\treturn 0;\n\t\tnmethods = p[1];\n\t\tif (have < nmethods + 2)\n\t\t\treturn 0;\n\t\t/* look for method: \"NO AUTHENTICATION REQUIRED\" */\n\t\tfor (found = 0, i = 2; i < nmethods + 2; i++) {\n\t\t\tif (p[i] == SSH_SOCKS5_NOAUTH) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tdebug(\"channel %d: method SSH_SOCKS5_NOAUTH not found\",\n\t\t\t    c->self);\n\t\t\treturn -1;\n\t\t}\n\t\tif ((r = sshbuf_consume(input, nmethods + 2)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\t/* version, method */\n\t\tif ((r = sshbuf_put_u8(output, 0x05)) != 0 ||\n\t\t    (r = sshbuf_put_u8(output, SSH_SOCKS5_NOAUTH)) != 0) {\n\t\t\tfatal(\"%s: channel %d: append reply: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\tc->flags |= SSH_SOCKS5_AUTHDONE;\n\t\tdebug2(\"channel %d: socks5 auth done\", c->self);\n\t\treturn 0;\t\t\t\t/* need more */\n\t}\n\tdebug2(\"channel %d: socks5 post auth\", c->self);\n\tif (have < sizeof(s5_req)+1)\n\t\treturn 0;\t\t\t/* need more */\n\tmemcpy(&s5_req, p, sizeof(s5_req));\n\tif (s5_req.version != 0x05 ||\n\t    s5_req.command != SSH_SOCKS5_CONNECT ||\n\t    s5_req.reserved != 0x00) {\n\t\tdebug2(\"channel %d: only socks5 connect supported\", c->self);\n\t\treturn -1;\n\t}\n\tswitch (s5_req.atyp){\n\tcase SSH_SOCKS5_IPV4:\n\t\taddrlen = 4;\n\t\taf = AF_INET;\n\t\tbreak;\n\tcase SSH_SOCKS5_DOMAIN:\n\t\taddrlen = p[sizeof(s5_req)];\n\t\taf = -1;\n\t\tbreak;\n\tcase SSH_SOCKS5_IPV6:\n\t\taddrlen = 16;\n\t\taf = AF_INET6;\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"channel %d: bad socks5 atyp %d\", c->self, s5_req.atyp);\n\t\treturn -1;\n\t}\n\tneed = sizeof(s5_req) + addrlen + 2;\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN)\n\t\tneed++;\n\tif (have < need)\n\t\treturn 0;\n\tif ((r = sshbuf_consume(input, sizeof(s5_req))) != 0) {\n\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN) {\n\t\t/* host string length */\n\t\tif ((r = sshbuf_consume(input, 1)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif ((r = sshbuf_get(input, &dest_addr, addrlen)) != 0 ||\n\t    (r = sshbuf_get(input, &dest_port, 2)) != 0) {\n\t\tdebug(\"channel %d: parse addr/port: %s\", c->self, ssh_err(r));\n\t\treturn -1;\n\t}\n\tdest_addr[addrlen] = '\\0';\n\tfree(c->path);\n\tc->path = NULL;\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN) {\n\t\tif (addrlen >= NI_MAXHOST) {\n\t\t\terror(\"channel %d: dynamic request: socks5 hostname \"\n\t\t\t    \"\\\"%.100s\\\" too long\", c->self, dest_addr);\n\t\t\treturn -1;\n\t\t}\n\t\tc->path = xstrdup(dest_addr);\n\t} else {\n\t\tif (inet_ntop(af, dest_addr, ntop, sizeof(ntop)) == NULL)\n\t\t\treturn -1;\n\t\tc->path = xstrdup(ntop);\n\t}\n\tc->host_port = ntohs(dest_port);\n\n\tdebug2(\"channel %d: dynamic request: socks5 host %s port %u command %u\",\n\t    c->self, c->path, c->host_port, s5_req.command);\n\n\ts5_rsp.version = 0x05;\n\ts5_rsp.command = SSH_SOCKS5_SUCCESS;\n\ts5_rsp.reserved = 0;\t\t\t/* ignored */\n\ts5_rsp.atyp = SSH_SOCKS5_IPV4;\n\tdest_port = 0;\t\t\t\t/* ignored */\n\n\tif ((r = sshbuf_put(output, &s5_rsp, sizeof(s5_rsp))) != 0 ||\n\t    (r = sshbuf_put_u32(output, ntohl(INADDR_ANY))) != 0 ||\n\t    (r = sshbuf_put(output, &dest_port, sizeof(dest_port))) != 0)\n\t\tfatal(\"%s: channel %d: append reply: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SSH_SOCKS5_SUCCESS\t0x00",
            "#define SSH_SOCKS5_CONNECT\t0x01",
            "#define SSH_SOCKS5_IPV6\t\t0x04",
            "#define SSH_SOCKS5_DOMAIN\t0x03",
            "#define SSH_SOCKS5_IPV4\t\t0x01",
            "#define SSH_SOCKS5_NOAUTH\t0x00",
            "#define SSH_SOCKS5_AUTHDONE\t0x1000"
          ],
          "globals_used": [
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SSH_SOCKS5_SUCCESS\t0x00\n#define SSH_SOCKS5_CONNECT\t0x01\n#define SSH_SOCKS5_IPV6\t\t0x04\n#define SSH_SOCKS5_DOMAIN\t0x03\n#define SSH_SOCKS5_IPV4\t\t0x01\n#define SSH_SOCKS5_NOAUTH\t0x00\n#define SSH_SOCKS5_AUTHDONE\t0x1000\n\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_decode_socks5(Channel *c, struct sshbuf *input, struct sshbuf *output)\n{\n\t/* XXX use get/put_u8 instead of trusting struct padding */\n\tstruct {\n\t\tu_int8_t version;\n\t\tu_int8_t command;\n\t\tu_int8_t reserved;\n\t\tu_int8_t atyp;\n\t} s5_req, s5_rsp;\n\tu_int16_t dest_port;\n\tchar dest_addr[255+1], ntop[INET6_ADDRSTRLEN];\n\tconst u_char *p;\n\tu_int have, need, i, found, nmethods, addrlen, af;\n\tint r;\n\n\tdebug2(\"channel %d: decode socks5\", c->self);\n\tp = sshbuf_ptr(input);\n\tif (p[0] != 0x05)\n\t\treturn -1;\n\thave = sshbuf_len(input);\n\tif (!(c->flags & SSH_SOCKS5_AUTHDONE)) {\n\t\t/* format: ver | nmethods | methods */\n\t\tif (have < 2)\n\t\t\treturn 0;\n\t\tnmethods = p[1];\n\t\tif (have < nmethods + 2)\n\t\t\treturn 0;\n\t\t/* look for method: \"NO AUTHENTICATION REQUIRED\" */\n\t\tfor (found = 0, i = 2; i < nmethods + 2; i++) {\n\t\t\tif (p[i] == SSH_SOCKS5_NOAUTH) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tdebug(\"channel %d: method SSH_SOCKS5_NOAUTH not found\",\n\t\t\t    c->self);\n\t\t\treturn -1;\n\t\t}\n\t\tif ((r = sshbuf_consume(input, nmethods + 2)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\t/* version, method */\n\t\tif ((r = sshbuf_put_u8(output, 0x05)) != 0 ||\n\t\t    (r = sshbuf_put_u8(output, SSH_SOCKS5_NOAUTH)) != 0) {\n\t\t\tfatal(\"%s: channel %d: append reply: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\tc->flags |= SSH_SOCKS5_AUTHDONE;\n\t\tdebug2(\"channel %d: socks5 auth done\", c->self);\n\t\treturn 0;\t\t\t\t/* need more */\n\t}\n\tdebug2(\"channel %d: socks5 post auth\", c->self);\n\tif (have < sizeof(s5_req)+1)\n\t\treturn 0;\t\t\t/* need more */\n\tmemcpy(&s5_req, p, sizeof(s5_req));\n\tif (s5_req.version != 0x05 ||\n\t    s5_req.command != SSH_SOCKS5_CONNECT ||\n\t    s5_req.reserved != 0x00) {\n\t\tdebug2(\"channel %d: only socks5 connect supported\", c->self);\n\t\treturn -1;\n\t}\n\tswitch (s5_req.atyp){\n\tcase SSH_SOCKS5_IPV4:\n\t\taddrlen = 4;\n\t\taf = AF_INET;\n\t\tbreak;\n\tcase SSH_SOCKS5_DOMAIN:\n\t\taddrlen = p[sizeof(s5_req)];\n\t\taf = -1;\n\t\tbreak;\n\tcase SSH_SOCKS5_IPV6:\n\t\taddrlen = 16;\n\t\taf = AF_INET6;\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"channel %d: bad socks5 atyp %d\", c->self, s5_req.atyp);\n\t\treturn -1;\n\t}\n\tneed = sizeof(s5_req) + addrlen + 2;\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN)\n\t\tneed++;\n\tif (have < need)\n\t\treturn 0;\n\tif ((r = sshbuf_consume(input, sizeof(s5_req))) != 0) {\n\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN) {\n\t\t/* host string length */\n\t\tif ((r = sshbuf_consume(input, 1)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif ((r = sshbuf_get(input, &dest_addr, addrlen)) != 0 ||\n\t    (r = sshbuf_get(input, &dest_port, 2)) != 0) {\n\t\tdebug(\"channel %d: parse addr/port: %s\", c->self, ssh_err(r));\n\t\treturn -1;\n\t}\n\tdest_addr[addrlen] = '\\0';\n\tfree(c->path);\n\tc->path = NULL;\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN) {\n\t\tif (addrlen >= NI_MAXHOST) {\n\t\t\terror(\"channel %d: dynamic request: socks5 hostname \"\n\t\t\t    \"\\\"%.100s\\\" too long\", c->self, dest_addr);\n\t\t\treturn -1;\n\t\t}\n\t\tc->path = xstrdup(dest_addr);\n\t} else {\n\t\tif (inet_ntop(af, dest_addr, ntop, sizeof(ntop)) == NULL)\n\t\t\treturn -1;\n\t\tc->path = xstrdup(ntop);\n\t}\n\tc->host_port = ntohs(dest_port);\n\n\tdebug2(\"channel %d: dynamic request: socks5 host %s port %u command %u\",\n\t    c->self, c->path, c->host_port, s5_req.command);\n\n\ts5_rsp.version = 0x05;\n\ts5_rsp.command = SSH_SOCKS5_SUCCESS;\n\ts5_rsp.reserved = 0;\t\t\t/* ignored */\n\ts5_rsp.atyp = SSH_SOCKS5_IPV4;\n\tdest_port = 0;\t\t\t\t/* ignored */\n\n\tif ((r = sshbuf_put(output, &s5_rsp, sizeof(s5_rsp))) != 0 ||\n\t    (r = sshbuf_put_u32(output, ntohl(INADDR_ANY))) != 0 ||\n\t    (r = sshbuf_put(output, &dest_port, sizeof(dest_port))) != 0)\n\t\tfatal(\"%s: channel %d: append reply: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_decode_socks4",
          "args": [
            "c",
            "c->input",
            "c->output"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "channel_decode_socks4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1227-1342",
          "snippet": "static int\nchannel_decode_socks4(Channel *c, struct sshbuf *input, struct sshbuf *output)\n{\n\tconst u_char *p;\n\tchar *host;\n\tu_int len, have, i, found, need;\n\tchar username[256];\n\tstruct {\n\t\tu_int8_t version;\n\t\tu_int8_t command;\n\t\tu_int16_t dest_port;\n\t\tstruct in_addr dest_addr;\n\t} s4_req, s4_rsp;\n\tint r;\n\n\tdebug2(\"channel %d: decode socks4\", c->self);\n\n\thave = sshbuf_len(input);\n\tlen = sizeof(s4_req);\n\tif (have < len)\n\t\treturn 0;\n\tp = sshbuf_ptr(input);\n\n\tneed = 1;\n\t/* SOCKS4A uses an invalid IP address 0.0.0.x */\n\tif (p[4] == 0 && p[5] == 0 && p[6] == 0 && p[7] != 0) {\n\t\tdebug2(\"channel %d: socks4a request\", c->self);\n\t\t/* ... and needs an extra string (the hostname) */\n\t\tneed = 2;\n\t}\n\t/* Check for terminating NUL on the string(s) */\n\tfor (found = 0, i = len; i < have; i++) {\n\t\tif (p[i] == '\\0') {\n\t\t\tfound++;\n\t\t\tif (found == need)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i > 1024) {\n\t\t\t/* the peer is probably sending garbage */\n\t\t\tdebug(\"channel %d: decode socks4: too long\",\n\t\t\t    c->self);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (found < need)\n\t\treturn 0;\n\tif ((r = sshbuf_get(input, &s4_req.version, 1)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.command, 1)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.dest_port, 2)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.dest_addr, 4)) != 0) {\n\t\tdebug(\"channels %d: decode socks4: %s\", c->self, ssh_err(r));\n\t\treturn -1;\n\t}\n\thave = sshbuf_len(input);\n\tp = sshbuf_ptr(input);\n\tif (memchr(p, '\\0', have) == NULL) {\n\t\terror(\"channel %d: decode socks4: user not nul terminated\",\n\t\t    c->self);\n\t\treturn -1;\n\t}\n\tlen = strlen(p);\n\tdebug2(\"channel %d: decode socks4: user %s/%d\", c->self, p, len);\n\tlen++; /* trailing '\\0' */\n\tstrlcpy(username, p, sizeof(username));\n\tif ((r = sshbuf_consume(input, len)) != 0) {\n\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tfree(c->path);\n\tc->path = NULL;\n\tif (need == 1) {\t\t\t/* SOCKS4: one string */\n\t\thost = inet_ntoa(s4_req.dest_addr);\n\t\tc->path = xstrdup(host);\n\t} else {\t\t\t\t/* SOCKS4A: two strings */\n\t\thave = sshbuf_len(input);\n\t\tp = sshbuf_ptr(input);\n\t\tif (memchr(p, '\\0', have) == NULL) {\n\t\t\terror(\"channel %d: decode socks4a: host not nul \"\n\t\t\t    \"terminated\", c->self);\n\t\t\treturn -1;\n\t\t}\n\t\tlen = strlen(p);\n\t\tdebug2(\"channel %d: decode socks4a: host %s/%d\",\n\t\t    c->self, p, len);\n\t\tlen++;\t\t\t\t/* trailing '\\0' */\n\t\tif (len > NI_MAXHOST) {\n\t\t\terror(\"channel %d: hostname \\\"%.100s\\\" too long\",\n\t\t\t    c->self, p);\n\t\t\treturn -1;\n\t\t}\n\t\tc->path = xstrdup(p);\n\t\tif ((r = sshbuf_consume(input, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tc->host_port = ntohs(s4_req.dest_port);\n\n\tdebug2(\"channel %d: dynamic request: socks4 host %s port %u command %u\",\n\t    c->self, c->path, c->host_port, s4_req.command);\n\n\tif (s4_req.command != 1) {\n\t\tdebug(\"channel %d: cannot handle: %s cn %d\",\n\t\t    c->self, need == 1 ? \"SOCKS4\" : \"SOCKS4A\", s4_req.command);\n\t\treturn -1;\n\t}\n\ts4_rsp.version = 0;\t\t\t/* vn: 0 for reply */\n\ts4_rsp.command = 90;\t\t\t/* cd: req granted */\n\ts4_rsp.dest_port = 0;\t\t\t/* ignored */\n\ts4_rsp.dest_addr.s_addr = INADDR_ANY;\t/* ignored */\n\tif ((r = sshbuf_put(output, &s4_rsp, sizeof(s4_rsp))) != 0) {\n\t\tfatal(\"%s: channel %d: append reply: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_decode_socks4(Channel *c, struct sshbuf *input, struct sshbuf *output)\n{\n\tconst u_char *p;\n\tchar *host;\n\tu_int len, have, i, found, need;\n\tchar username[256];\n\tstruct {\n\t\tu_int8_t version;\n\t\tu_int8_t command;\n\t\tu_int16_t dest_port;\n\t\tstruct in_addr dest_addr;\n\t} s4_req, s4_rsp;\n\tint r;\n\n\tdebug2(\"channel %d: decode socks4\", c->self);\n\n\thave = sshbuf_len(input);\n\tlen = sizeof(s4_req);\n\tif (have < len)\n\t\treturn 0;\n\tp = sshbuf_ptr(input);\n\n\tneed = 1;\n\t/* SOCKS4A uses an invalid IP address 0.0.0.x */\n\tif (p[4] == 0 && p[5] == 0 && p[6] == 0 && p[7] != 0) {\n\t\tdebug2(\"channel %d: socks4a request\", c->self);\n\t\t/* ... and needs an extra string (the hostname) */\n\t\tneed = 2;\n\t}\n\t/* Check for terminating NUL on the string(s) */\n\tfor (found = 0, i = len; i < have; i++) {\n\t\tif (p[i] == '\\0') {\n\t\t\tfound++;\n\t\t\tif (found == need)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i > 1024) {\n\t\t\t/* the peer is probably sending garbage */\n\t\t\tdebug(\"channel %d: decode socks4: too long\",\n\t\t\t    c->self);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (found < need)\n\t\treturn 0;\n\tif ((r = sshbuf_get(input, &s4_req.version, 1)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.command, 1)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.dest_port, 2)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.dest_addr, 4)) != 0) {\n\t\tdebug(\"channels %d: decode socks4: %s\", c->self, ssh_err(r));\n\t\treturn -1;\n\t}\n\thave = sshbuf_len(input);\n\tp = sshbuf_ptr(input);\n\tif (memchr(p, '\\0', have) == NULL) {\n\t\terror(\"channel %d: decode socks4: user not nul terminated\",\n\t\t    c->self);\n\t\treturn -1;\n\t}\n\tlen = strlen(p);\n\tdebug2(\"channel %d: decode socks4: user %s/%d\", c->self, p, len);\n\tlen++; /* trailing '\\0' */\n\tstrlcpy(username, p, sizeof(username));\n\tif ((r = sshbuf_consume(input, len)) != 0) {\n\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tfree(c->path);\n\tc->path = NULL;\n\tif (need == 1) {\t\t\t/* SOCKS4: one string */\n\t\thost = inet_ntoa(s4_req.dest_addr);\n\t\tc->path = xstrdup(host);\n\t} else {\t\t\t\t/* SOCKS4A: two strings */\n\t\thave = sshbuf_len(input);\n\t\tp = sshbuf_ptr(input);\n\t\tif (memchr(p, '\\0', have) == NULL) {\n\t\t\terror(\"channel %d: decode socks4a: host not nul \"\n\t\t\t    \"terminated\", c->self);\n\t\t\treturn -1;\n\t\t}\n\t\tlen = strlen(p);\n\t\tdebug2(\"channel %d: decode socks4a: host %s/%d\",\n\t\t    c->self, p, len);\n\t\tlen++;\t\t\t\t/* trailing '\\0' */\n\t\tif (len > NI_MAXHOST) {\n\t\t\terror(\"channel %d: hostname \\\"%.100s\\\" too long\",\n\t\t\t    c->self, p);\n\t\t\treturn -1;\n\t\t}\n\t\tc->path = xstrdup(p);\n\t\tif ((r = sshbuf_consume(input, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tc->host_port = ntohs(s4_req.dest_port);\n\n\tdebug2(\"channel %d: dynamic request: socks4 host %s port %u command %u\",\n\t    c->self, c->path, c->host_port, s4_req.command);\n\n\tif (s4_req.command != 1) {\n\t\tdebug(\"channel %d: cannot handle: %s cn %d\",\n\t\t    c->self, need == 1 ? \"SOCKS4\" : \"SOCKS4A\", s4_req.command);\n\t\treturn -1;\n\t}\n\ts4_rsp.version = 0;\t\t\t/* vn: 0 for reply */\n\ts4_rsp.command = 90;\t\t\t/* cd: req granted */\n\ts4_rsp.dest_port = 0;\t\t\t/* ignored */\n\ts4_rsp.dest_addr.s_addr = INADDR_ANY;\t/* ignored */\n\tif ((r = sshbuf_put(output, &s4_rsp, sizeof(s4_rsp))) != 0) {\n\t\tfatal(\"%s: channel %d: append reply: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "c->input"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_pre_dynamic(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tconst u_char *p;\n\tu_int have;\n\tint ret;\n\n\thave = sshbuf_len(c->input);\n\tdebug2(\"channel %d: pre_dynamic: have %d\", c->self, have);\n\t/* sshbuf_dump(c->input, stderr); */\n\t/* check if the fixed size part of the packet is in buffer. */\n\tif (have < 3) {\n\t\t/* need more */\n\t\tFD_SET(c->sock, readset);\n\t\treturn;\n\t}\n\t/* try to guess the protocol */\n\tp = sshbuf_ptr(c->input);\n\t/* XXX sshbuf_peek_u8? */\n\tswitch (p[0]) {\n\tcase 0x04:\n\t\tret = channel_decode_socks4(c, c->input, c->output);\n\t\tbreak;\n\tcase 0x05:\n\t\tret = channel_decode_socks5(c, c->input, c->output);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\tif (ret < 0) {\n\t\tchan_mark_dead(ssh, c);\n\t} else if (ret == 0) {\n\t\tdebug2(\"channel %d: pre_dynamic: need more\", c->self);\n\t\t/* need more */\n\t\tFD_SET(c->sock, readset);\n\t\tif (sshbuf_len(c->output))\n\t\t\tFD_SET(c->sock, writeset);\n\t} else {\n\t\t/* switch to the next state */\n\t\tc->type = SSH_CHANNEL_OPENING;\n\t\tport_open_helper(ssh, c, \"direct-tcpip\");\n\t}\n}"
  },
  {
    "function_name": "channel_connect_stdio_fwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1489-1510",
    "snippet": "Channel *\nchannel_connect_stdio_fwd(struct ssh *ssh,\n    const char *host_to_connect, u_short port_to_connect, int in, int out)\n{\n\tChannel *c;\n\n\tdebug(\"%s %s:%d\", __func__, host_to_connect, port_to_connect);\n\n\tc = channel_new(ssh, \"stdio-forward\", SSH_CHANNEL_OPENING, in, out,\n\t    -1, CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, \"stdio-forward\", /*nonblock*/0);\n\n\tc->path = xstrdup(host_to_connect);\n\tc->host_port = port_to_connect;\n\tc->listening_port = 0;\n\tc->force_drain = 1;\n\n\tchannel_register_fds(ssh, c, in, out, -1, 0, 1, 0);\n\tport_open_helper(ssh, c, \"direct-tcpip\");\n\n\treturn c;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "port_open_helper",
          "args": [
            "ssh",
            "c",
            "\"direct-tcpip\""
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "port_open_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1686-1755",
          "snippet": "static void\nport_open_helper(struct ssh *ssh, Channel *c, char *rtype)\n{\n\tchar *local_ipaddr = get_local_ipaddr(c->sock);\n\tint local_port = c->sock == -1 ? 65536 : get_local_port(c->sock);\n\tchar *remote_ipaddr = get_peer_ipaddr(c->sock);\n\tint remote_port = get_peer_port(c->sock);\n\tint r;\n\n\tif (remote_port == -1) {\n\t\t/* Fake addr/port to appease peers that validate it (Tectia) */\n\t\tfree(remote_ipaddr);\n\t\tremote_ipaddr = xstrdup(\"127.0.0.1\");\n\t\tremote_port = 65535;\n\t}\n\n\tfree(c->remote_name);\n\txasprintf(&c->remote_name,\n\t    \"%s: listening port %d for %.100s port %d, \"\n\t    \"connect from %.200s port %d to %.100s port %d\",\n\t    rtype, c->listening_port, c->path, c->host_port,\n\t    remote_ipaddr, remote_port, local_ipaddr, local_port);\n\n\topen_preamble(ssh, __func__, c, rtype);\n\tif (strcmp(rtype, \"direct-tcpip\") == 0) {\n\t\t/* target host, port */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->host_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else if (strcmp(rtype, \"direct-streamlocal@openssh.com\") == 0) {\n\t\t/* target path */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else if (strcmp(rtype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\t/* listen path */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else {\n\t\t/* listen address, port */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, local_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif (strcmp(rtype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\t/* reserved for future owner/mode info */\n\t\tif ((r = sshpkt_put_cstring(ssh, \"\")) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else {\n\t\t/* originator host and port */\n\t\tif ((r = sshpkt_put_cstring(ssh, remote_ipaddr)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)remote_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: send %s\", __func__, c->self, ssh_err(r));\n\tfree(remote_ipaddr);\n\tfree(local_ipaddr);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void port_open_helper(struct ssh *ssh, Channel *c, char *rtype);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void port_open_helper(struct ssh *ssh, Channel *c, char *rtype);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nport_open_helper(struct ssh *ssh, Channel *c, char *rtype)\n{\n\tchar *local_ipaddr = get_local_ipaddr(c->sock);\n\tint local_port = c->sock == -1 ? 65536 : get_local_port(c->sock);\n\tchar *remote_ipaddr = get_peer_ipaddr(c->sock);\n\tint remote_port = get_peer_port(c->sock);\n\tint r;\n\n\tif (remote_port == -1) {\n\t\t/* Fake addr/port to appease peers that validate it (Tectia) */\n\t\tfree(remote_ipaddr);\n\t\tremote_ipaddr = xstrdup(\"127.0.0.1\");\n\t\tremote_port = 65535;\n\t}\n\n\tfree(c->remote_name);\n\txasprintf(&c->remote_name,\n\t    \"%s: listening port %d for %.100s port %d, \"\n\t    \"connect from %.200s port %d to %.100s port %d\",\n\t    rtype, c->listening_port, c->path, c->host_port,\n\t    remote_ipaddr, remote_port, local_ipaddr, local_port);\n\n\topen_preamble(ssh, __func__, c, rtype);\n\tif (strcmp(rtype, \"direct-tcpip\") == 0) {\n\t\t/* target host, port */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->host_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else if (strcmp(rtype, \"direct-streamlocal@openssh.com\") == 0) {\n\t\t/* target path */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else if (strcmp(rtype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\t/* listen path */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else {\n\t\t/* listen address, port */\n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, local_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif (strcmp(rtype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\t/* reserved for future owner/mode info */\n\t\tif ((r = sshpkt_put_cstring(ssh, \"\")) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t} else {\n\t\t/* originator host and port */\n\t\tif ((r = sshpkt_put_cstring(ssh, remote_ipaddr)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)remote_port)) != 0) {\n\t\t\tfatal(\"%s: channel %i: reply %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: send %s\", __func__, c->self, ssh_err(r));\n\tfree(remote_ipaddr);\n\tfree(local_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_register_fds",
          "args": [
            "ssh",
            "c",
            "in",
            "out",
            "-1",
            "0",
            "1",
            "0"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "308-348",
          "snippet": "static void\nchannel_register_fds(struct ssh *ssh, Channel *c, int rfd, int wfd, int efd,\n    int extusage, int nonblock, int is_tty)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\t/* Update the maximum file descriptor value. */\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, rfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, wfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, efd);\n\n\tif (rfd != -1)\n\t\tfcntl(rfd, F_SETFD, FD_CLOEXEC);\n\tif (wfd != -1 && wfd != rfd)\n\t\tfcntl(wfd, F_SETFD, FD_CLOEXEC);\n\tif (efd != -1 && efd != rfd && efd != wfd)\n\t\tfcntl(efd, F_SETFD, FD_CLOEXEC);\n\n\tc->rfd = rfd;\n\tc->wfd = wfd;\n\tc->sock = (rfd == wfd) ? rfd : -1;\n\tc->efd = efd;\n\tc->extended_usage = extusage;\n\n\tif ((c->isatty = is_tty) != 0)\n\t\tdebug2(\"channel %d: rfd %d isatty\", c->self, c->rfd);\n#ifdef _AIX\n\t/* XXX: Later AIX versions can't push as much data to tty */\n\tc->wfd_isatty = is_tty || isatty(c->wfd);\n#endif\n\n\t/* enable nonblocking mode */\n\tif (nonblock) {\n\t\tif (rfd != -1)\n\t\t\tset_nonblock(rfd);\n\t\tif (wfd != -1)\n\t\t\tset_nonblock(wfd);\n\t\tif (efd != -1)\n\t\t\tset_nonblock(efd);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic void\nchannel_register_fds(struct ssh *ssh, Channel *c, int rfd, int wfd, int efd,\n    int extusage, int nonblock, int is_tty)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\t/* Update the maximum file descriptor value. */\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, rfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, wfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, efd);\n\n\tif (rfd != -1)\n\t\tfcntl(rfd, F_SETFD, FD_CLOEXEC);\n\tif (wfd != -1 && wfd != rfd)\n\t\tfcntl(wfd, F_SETFD, FD_CLOEXEC);\n\tif (efd != -1 && efd != rfd && efd != wfd)\n\t\tfcntl(efd, F_SETFD, FD_CLOEXEC);\n\n\tc->rfd = rfd;\n\tc->wfd = wfd;\n\tc->sock = (rfd == wfd) ? rfd : -1;\n\tc->efd = efd;\n\tc->extended_usage = extusage;\n\n\tif ((c->isatty = is_tty) != 0)\n\t\tdebug2(\"channel %d: rfd %d isatty\", c->self, c->rfd);\n#ifdef _AIX\n\t/* XXX: Later AIX versions can't push as much data to tty */\n\tc->wfd_isatty = is_tty || isatty(c->wfd);\n#endif\n\n\t/* enable nonblocking mode */\n\tif (nonblock) {\n\t\tif (rfd != -1)\n\t\t\tset_nonblock(rfd);\n\t\tif (wfd != -1)\n\t\t\tset_nonblock(wfd);\n\t\tif (efd != -1)\n\t\t\tset_nonblock(efd);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "host_to_connect"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "\"stdio-forward\"",
            "SSH_CHANNEL_OPENING",
            "in",
            "out",
            "-1",
            "CHAN_TCP_WINDOW_DEFAULT",
            "CHAN_TCP_PACKET_DEFAULT",
            "0",
            "\"stdio-forward\"",
            "/*nonblock*/0"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s %s:%d\"",
            "__func__",
            "host_to_connect",
            "port_to_connect"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_connect_stdio_fwd(struct ssh *ssh,\n    const char *host_to_connect, u_short port_to_connect, int in, int out)\n{\n\tChannel *c;\n\n\tdebug(\"%s %s:%d\", __func__, host_to_connect, port_to_connect);\n\n\tc = channel_new(ssh, \"stdio-forward\", SSH_CHANNEL_OPENING, in, out,\n\t    -1, CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, \"stdio-forward\", /*nonblock*/0);\n\n\tc->path = xstrdup(host_to_connect);\n\tc->host_port = port_to_connect;\n\tc->listening_port = 0;\n\tc->force_drain = 1;\n\n\tchannel_register_fds(ssh, c, in, out, -1, 0, 1, 0);\n\tport_open_helper(ssh, c, \"direct-tcpip\");\n\n\treturn c;\n}"
  },
  {
    "function_name": "channel_decode_socks5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1353-1487",
    "snippet": "static int\nchannel_decode_socks5(Channel *c, struct sshbuf *input, struct sshbuf *output)\n{\n\t/* XXX use get/put_u8 instead of trusting struct padding */\n\tstruct {\n\t\tu_int8_t version;\n\t\tu_int8_t command;\n\t\tu_int8_t reserved;\n\t\tu_int8_t atyp;\n\t} s5_req, s5_rsp;\n\tu_int16_t dest_port;\n\tchar dest_addr[255+1], ntop[INET6_ADDRSTRLEN];\n\tconst u_char *p;\n\tu_int have, need, i, found, nmethods, addrlen, af;\n\tint r;\n\n\tdebug2(\"channel %d: decode socks5\", c->self);\n\tp = sshbuf_ptr(input);\n\tif (p[0] != 0x05)\n\t\treturn -1;\n\thave = sshbuf_len(input);\n\tif (!(c->flags & SSH_SOCKS5_AUTHDONE)) {\n\t\t/* format: ver | nmethods | methods */\n\t\tif (have < 2)\n\t\t\treturn 0;\n\t\tnmethods = p[1];\n\t\tif (have < nmethods + 2)\n\t\t\treturn 0;\n\t\t/* look for method: \"NO AUTHENTICATION REQUIRED\" */\n\t\tfor (found = 0, i = 2; i < nmethods + 2; i++) {\n\t\t\tif (p[i] == SSH_SOCKS5_NOAUTH) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tdebug(\"channel %d: method SSH_SOCKS5_NOAUTH not found\",\n\t\t\t    c->self);\n\t\t\treturn -1;\n\t\t}\n\t\tif ((r = sshbuf_consume(input, nmethods + 2)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\t/* version, method */\n\t\tif ((r = sshbuf_put_u8(output, 0x05)) != 0 ||\n\t\t    (r = sshbuf_put_u8(output, SSH_SOCKS5_NOAUTH)) != 0) {\n\t\t\tfatal(\"%s: channel %d: append reply: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\tc->flags |= SSH_SOCKS5_AUTHDONE;\n\t\tdebug2(\"channel %d: socks5 auth done\", c->self);\n\t\treturn 0;\t\t\t\t/* need more */\n\t}\n\tdebug2(\"channel %d: socks5 post auth\", c->self);\n\tif (have < sizeof(s5_req)+1)\n\t\treturn 0;\t\t\t/* need more */\n\tmemcpy(&s5_req, p, sizeof(s5_req));\n\tif (s5_req.version != 0x05 ||\n\t    s5_req.command != SSH_SOCKS5_CONNECT ||\n\t    s5_req.reserved != 0x00) {\n\t\tdebug2(\"channel %d: only socks5 connect supported\", c->self);\n\t\treturn -1;\n\t}\n\tswitch (s5_req.atyp){\n\tcase SSH_SOCKS5_IPV4:\n\t\taddrlen = 4;\n\t\taf = AF_INET;\n\t\tbreak;\n\tcase SSH_SOCKS5_DOMAIN:\n\t\taddrlen = p[sizeof(s5_req)];\n\t\taf = -1;\n\t\tbreak;\n\tcase SSH_SOCKS5_IPV6:\n\t\taddrlen = 16;\n\t\taf = AF_INET6;\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"channel %d: bad socks5 atyp %d\", c->self, s5_req.atyp);\n\t\treturn -1;\n\t}\n\tneed = sizeof(s5_req) + addrlen + 2;\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN)\n\t\tneed++;\n\tif (have < need)\n\t\treturn 0;\n\tif ((r = sshbuf_consume(input, sizeof(s5_req))) != 0) {\n\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN) {\n\t\t/* host string length */\n\t\tif ((r = sshbuf_consume(input, 1)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif ((r = sshbuf_get(input, &dest_addr, addrlen)) != 0 ||\n\t    (r = sshbuf_get(input, &dest_port, 2)) != 0) {\n\t\tdebug(\"channel %d: parse addr/port: %s\", c->self, ssh_err(r));\n\t\treturn -1;\n\t}\n\tdest_addr[addrlen] = '\\0';\n\tfree(c->path);\n\tc->path = NULL;\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN) {\n\t\tif (addrlen >= NI_MAXHOST) {\n\t\t\terror(\"channel %d: dynamic request: socks5 hostname \"\n\t\t\t    \"\\\"%.100s\\\" too long\", c->self, dest_addr);\n\t\t\treturn -1;\n\t\t}\n\t\tc->path = xstrdup(dest_addr);\n\t} else {\n\t\tif (inet_ntop(af, dest_addr, ntop, sizeof(ntop)) == NULL)\n\t\t\treturn -1;\n\t\tc->path = xstrdup(ntop);\n\t}\n\tc->host_port = ntohs(dest_port);\n\n\tdebug2(\"channel %d: dynamic request: socks5 host %s port %u command %u\",\n\t    c->self, c->path, c->host_port, s5_req.command);\n\n\ts5_rsp.version = 0x05;\n\ts5_rsp.command = SSH_SOCKS5_SUCCESS;\n\ts5_rsp.reserved = 0;\t\t\t/* ignored */\n\ts5_rsp.atyp = SSH_SOCKS5_IPV4;\n\tdest_port = 0;\t\t\t\t/* ignored */\n\n\tif ((r = sshbuf_put(output, &s5_rsp, sizeof(s5_rsp))) != 0 ||\n\t    (r = sshbuf_put_u32(output, ntohl(INADDR_ANY))) != 0 ||\n\t    (r = sshbuf_put(output, &dest_port, sizeof(dest_port))) != 0)\n\t\tfatal(\"%s: channel %d: append reply: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\treturn 1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SSH_SOCKS5_SUCCESS\t0x00",
      "#define SSH_SOCKS5_CONNECT\t0x01",
      "#define SSH_SOCKS5_IPV6\t\t0x04",
      "#define SSH_SOCKS5_DOMAIN\t0x03",
      "#define SSH_SOCKS5_IPV4\t\t0x01",
      "#define SSH_SOCKS5_NOAUTH\t0x00",
      "#define SSH_SOCKS5_AUTHDONE\t0x1000"
    ],
    "globals_used": [
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %d: append reply: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "output",
            "&dest_port",
            "sizeof(dest_port)"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "output",
            "ntohl(INADDR_ANY)"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "INADDR_ANY"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: dynamic request: socks5 host %s port %u command %u\"",
            "c->self",
            "c->path",
            "c->host_port",
            "s5_req.command"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "dest_port"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "ntop"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_ntop",
          "args": [
            "af",
            "dest_addr",
            "ntop",
            "sizeof(ntop)"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "inet_ntop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/inet_ntop.c",
          "lines": "59-72",
          "snippet": "const char *\ninet_ntop(int af, const void *src, char *dst, socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn (inet_ntop4(src, dst, (size_t)size));\n\tcase AF_INET6:\n\t\treturn (inet_ntop6(src, dst, (size_t)size));\n\tdefault:\n\t\terrno = EAFNOSUPPORT;\n\t\treturn (NULL);\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <arpa/nameser.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <arpa/nameser.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nconst char *\ninet_ntop(int af, const void *src, char *dst, socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn (inet_ntop4(src, dst, (size_t)size));\n\tcase AF_INET6:\n\t\treturn (inet_ntop6(src, dst, (size_t)size));\n\tdefault:\n\t\terrno = EAFNOSUPPORT;\n\t\treturn (NULL);\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"channel %d: dynamic request: socks5 hostname \"\n\t\t\t    \"\\\"%.100s\\\" too long\"",
            "c->self",
            "dest_addr"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "c->path"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4195-4206",
          "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"channel %d: parse addr/port: %s\"",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get",
          "args": [
            "input",
            "&dest_port",
            "2"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_bignum2_bytes_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "430-464",
          "snippet": "int\nsshbuf_get_bignum2_bytes_direct(struct sshbuf *buf,\n    const u_char **valp, size_t *lenp)\n{\n\tconst u_char *d;\n\tsize_t len, olen;\n\tint r;\n\n\tif ((r = sshbuf_peek_string_direct(buf, &d, &olen)) < 0)\n\t\treturn r;\n\tlen = olen;\n\t/* Refuse negative (MSB set) bignums */\n\tif ((len != 0 && (*d & 0x80) != 0))\n\t\treturn SSH_ERR_BIGNUM_IS_NEGATIVE;\n\t/* Refuse overlong bignums, allow prepended \\0 to avoid MSB set */\n\tif (len > SSHBUF_MAX_BIGNUM + 1 ||\n\t    (len == SSHBUF_MAX_BIGNUM + 1 && *d != 0))\n\t\treturn SSH_ERR_BIGNUM_TOO_LARGE;\n\t/* Trim leading zeros */\n\twhile (len > 0 && *d == 0x00) {\n\t\td++;\n\t\tlen--;\n\t}\n\tif (valp != NULL)\n\t\t*valp = d;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, olen + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_bignum2_bytes_direct(struct sshbuf *buf,\n    const u_char **valp, size_t *lenp)\n{\n\tconst u_char *d;\n\tsize_t len, olen;\n\tint r;\n\n\tif ((r = sshbuf_peek_string_direct(buf, &d, &olen)) < 0)\n\t\treturn r;\n\tlen = olen;\n\t/* Refuse negative (MSB set) bignums */\n\tif ((len != 0 && (*d & 0x80) != 0))\n\t\treturn SSH_ERR_BIGNUM_IS_NEGATIVE;\n\t/* Refuse overlong bignums, allow prepended \\0 to avoid MSB set */\n\tif (len > SSHBUF_MAX_BIGNUM + 1 ||\n\t    (len == SSHBUF_MAX_BIGNUM + 1 && *d != 0))\n\t\treturn SSH_ERR_BIGNUM_TOO_LARGE;\n\t/* Trim leading zeros */\n\twhile (len > 0 && *d == 0x00) {\n\t\td++;\n\t\tlen--;\n\t}\n\tif (valp != NULL)\n\t\t*valp = d;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, olen + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "input",
            "1"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&s5_req",
            "p",
            "sizeof(s5_req)"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "output",
            "SSH_SOCKS5_NOAUTH"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "input"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "input"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SSH_SOCKS5_SUCCESS\t0x00\n#define SSH_SOCKS5_CONNECT\t0x01\n#define SSH_SOCKS5_IPV6\t\t0x04\n#define SSH_SOCKS5_DOMAIN\t0x03\n#define SSH_SOCKS5_IPV4\t\t0x01\n#define SSH_SOCKS5_NOAUTH\t0x00\n#define SSH_SOCKS5_AUTHDONE\t0x1000\n\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_decode_socks5(Channel *c, struct sshbuf *input, struct sshbuf *output)\n{\n\t/* XXX use get/put_u8 instead of trusting struct padding */\n\tstruct {\n\t\tu_int8_t version;\n\t\tu_int8_t command;\n\t\tu_int8_t reserved;\n\t\tu_int8_t atyp;\n\t} s5_req, s5_rsp;\n\tu_int16_t dest_port;\n\tchar dest_addr[255+1], ntop[INET6_ADDRSTRLEN];\n\tconst u_char *p;\n\tu_int have, need, i, found, nmethods, addrlen, af;\n\tint r;\n\n\tdebug2(\"channel %d: decode socks5\", c->self);\n\tp = sshbuf_ptr(input);\n\tif (p[0] != 0x05)\n\t\treturn -1;\n\thave = sshbuf_len(input);\n\tif (!(c->flags & SSH_SOCKS5_AUTHDONE)) {\n\t\t/* format: ver | nmethods | methods */\n\t\tif (have < 2)\n\t\t\treturn 0;\n\t\tnmethods = p[1];\n\t\tif (have < nmethods + 2)\n\t\t\treturn 0;\n\t\t/* look for method: \"NO AUTHENTICATION REQUIRED\" */\n\t\tfor (found = 0, i = 2; i < nmethods + 2; i++) {\n\t\t\tif (p[i] == SSH_SOCKS5_NOAUTH) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tdebug(\"channel %d: method SSH_SOCKS5_NOAUTH not found\",\n\t\t\t    c->self);\n\t\t\treturn -1;\n\t\t}\n\t\tif ((r = sshbuf_consume(input, nmethods + 2)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\t/* version, method */\n\t\tif ((r = sshbuf_put_u8(output, 0x05)) != 0 ||\n\t\t    (r = sshbuf_put_u8(output, SSH_SOCKS5_NOAUTH)) != 0) {\n\t\t\tfatal(\"%s: channel %d: append reply: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\tc->flags |= SSH_SOCKS5_AUTHDONE;\n\t\tdebug2(\"channel %d: socks5 auth done\", c->self);\n\t\treturn 0;\t\t\t\t/* need more */\n\t}\n\tdebug2(\"channel %d: socks5 post auth\", c->self);\n\tif (have < sizeof(s5_req)+1)\n\t\treturn 0;\t\t\t/* need more */\n\tmemcpy(&s5_req, p, sizeof(s5_req));\n\tif (s5_req.version != 0x05 ||\n\t    s5_req.command != SSH_SOCKS5_CONNECT ||\n\t    s5_req.reserved != 0x00) {\n\t\tdebug2(\"channel %d: only socks5 connect supported\", c->self);\n\t\treturn -1;\n\t}\n\tswitch (s5_req.atyp){\n\tcase SSH_SOCKS5_IPV4:\n\t\taddrlen = 4;\n\t\taf = AF_INET;\n\t\tbreak;\n\tcase SSH_SOCKS5_DOMAIN:\n\t\taddrlen = p[sizeof(s5_req)];\n\t\taf = -1;\n\t\tbreak;\n\tcase SSH_SOCKS5_IPV6:\n\t\taddrlen = 16;\n\t\taf = AF_INET6;\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"channel %d: bad socks5 atyp %d\", c->self, s5_req.atyp);\n\t\treturn -1;\n\t}\n\tneed = sizeof(s5_req) + addrlen + 2;\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN)\n\t\tneed++;\n\tif (have < need)\n\t\treturn 0;\n\tif ((r = sshbuf_consume(input, sizeof(s5_req))) != 0) {\n\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN) {\n\t\t/* host string length */\n\t\tif ((r = sshbuf_consume(input, 1)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tif ((r = sshbuf_get(input, &dest_addr, addrlen)) != 0 ||\n\t    (r = sshbuf_get(input, &dest_port, 2)) != 0) {\n\t\tdebug(\"channel %d: parse addr/port: %s\", c->self, ssh_err(r));\n\t\treturn -1;\n\t}\n\tdest_addr[addrlen] = '\\0';\n\tfree(c->path);\n\tc->path = NULL;\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN) {\n\t\tif (addrlen >= NI_MAXHOST) {\n\t\t\terror(\"channel %d: dynamic request: socks5 hostname \"\n\t\t\t    \"\\\"%.100s\\\" too long\", c->self, dest_addr);\n\t\t\treturn -1;\n\t\t}\n\t\tc->path = xstrdup(dest_addr);\n\t} else {\n\t\tif (inet_ntop(af, dest_addr, ntop, sizeof(ntop)) == NULL)\n\t\t\treturn -1;\n\t\tc->path = xstrdup(ntop);\n\t}\n\tc->host_port = ntohs(dest_port);\n\n\tdebug2(\"channel %d: dynamic request: socks5 host %s port %u command %u\",\n\t    c->self, c->path, c->host_port, s5_req.command);\n\n\ts5_rsp.version = 0x05;\n\ts5_rsp.command = SSH_SOCKS5_SUCCESS;\n\ts5_rsp.reserved = 0;\t\t\t/* ignored */\n\ts5_rsp.atyp = SSH_SOCKS5_IPV4;\n\tdest_port = 0;\t\t\t\t/* ignored */\n\n\tif ((r = sshbuf_put(output, &s5_rsp, sizeof(s5_rsp))) != 0 ||\n\t    (r = sshbuf_put_u32(output, ntohl(INADDR_ANY))) != 0 ||\n\t    (r = sshbuf_put(output, &dest_port, sizeof(dest_port))) != 0)\n\t\tfatal(\"%s: channel %d: append reply: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\treturn 1;\n}"
  },
  {
    "function_name": "channel_decode_socks4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1227-1342",
    "snippet": "static int\nchannel_decode_socks4(Channel *c, struct sshbuf *input, struct sshbuf *output)\n{\n\tconst u_char *p;\n\tchar *host;\n\tu_int len, have, i, found, need;\n\tchar username[256];\n\tstruct {\n\t\tu_int8_t version;\n\t\tu_int8_t command;\n\t\tu_int16_t dest_port;\n\t\tstruct in_addr dest_addr;\n\t} s4_req, s4_rsp;\n\tint r;\n\n\tdebug2(\"channel %d: decode socks4\", c->self);\n\n\thave = sshbuf_len(input);\n\tlen = sizeof(s4_req);\n\tif (have < len)\n\t\treturn 0;\n\tp = sshbuf_ptr(input);\n\n\tneed = 1;\n\t/* SOCKS4A uses an invalid IP address 0.0.0.x */\n\tif (p[4] == 0 && p[5] == 0 && p[6] == 0 && p[7] != 0) {\n\t\tdebug2(\"channel %d: socks4a request\", c->self);\n\t\t/* ... and needs an extra string (the hostname) */\n\t\tneed = 2;\n\t}\n\t/* Check for terminating NUL on the string(s) */\n\tfor (found = 0, i = len; i < have; i++) {\n\t\tif (p[i] == '\\0') {\n\t\t\tfound++;\n\t\t\tif (found == need)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i > 1024) {\n\t\t\t/* the peer is probably sending garbage */\n\t\t\tdebug(\"channel %d: decode socks4: too long\",\n\t\t\t    c->self);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (found < need)\n\t\treturn 0;\n\tif ((r = sshbuf_get(input, &s4_req.version, 1)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.command, 1)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.dest_port, 2)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.dest_addr, 4)) != 0) {\n\t\tdebug(\"channels %d: decode socks4: %s\", c->self, ssh_err(r));\n\t\treturn -1;\n\t}\n\thave = sshbuf_len(input);\n\tp = sshbuf_ptr(input);\n\tif (memchr(p, '\\0', have) == NULL) {\n\t\terror(\"channel %d: decode socks4: user not nul terminated\",\n\t\t    c->self);\n\t\treturn -1;\n\t}\n\tlen = strlen(p);\n\tdebug2(\"channel %d: decode socks4: user %s/%d\", c->self, p, len);\n\tlen++; /* trailing '\\0' */\n\tstrlcpy(username, p, sizeof(username));\n\tif ((r = sshbuf_consume(input, len)) != 0) {\n\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tfree(c->path);\n\tc->path = NULL;\n\tif (need == 1) {\t\t\t/* SOCKS4: one string */\n\t\thost = inet_ntoa(s4_req.dest_addr);\n\t\tc->path = xstrdup(host);\n\t} else {\t\t\t\t/* SOCKS4A: two strings */\n\t\thave = sshbuf_len(input);\n\t\tp = sshbuf_ptr(input);\n\t\tif (memchr(p, '\\0', have) == NULL) {\n\t\t\terror(\"channel %d: decode socks4a: host not nul \"\n\t\t\t    \"terminated\", c->self);\n\t\t\treturn -1;\n\t\t}\n\t\tlen = strlen(p);\n\t\tdebug2(\"channel %d: decode socks4a: host %s/%d\",\n\t\t    c->self, p, len);\n\t\tlen++;\t\t\t\t/* trailing '\\0' */\n\t\tif (len > NI_MAXHOST) {\n\t\t\terror(\"channel %d: hostname \\\"%.100s\\\" too long\",\n\t\t\t    c->self, p);\n\t\t\treturn -1;\n\t\t}\n\t\tc->path = xstrdup(p);\n\t\tif ((r = sshbuf_consume(input, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tc->host_port = ntohs(s4_req.dest_port);\n\n\tdebug2(\"channel %d: dynamic request: socks4 host %s port %u command %u\",\n\t    c->self, c->path, c->host_port, s4_req.command);\n\n\tif (s4_req.command != 1) {\n\t\tdebug(\"channel %d: cannot handle: %s cn %d\",\n\t\t    c->self, need == 1 ? \"SOCKS4\" : \"SOCKS4A\", s4_req.command);\n\t\treturn -1;\n\t}\n\ts4_rsp.version = 0;\t\t\t/* vn: 0 for reply */\n\ts4_rsp.command = 90;\t\t\t/* cd: req granted */\n\ts4_rsp.dest_port = 0;\t\t\t/* ignored */\n\ts4_rsp.dest_addr.s_addr = INADDR_ANY;\t/* ignored */\n\tif ((r = sshbuf_put(output, &s4_rsp, sizeof(s4_rsp))) != 0) {\n\t\tfatal(\"%s: channel %d: append reply: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %d: append reply: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "output",
            "&s4_rsp",
            "sizeof(s4_rsp)"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"channel %d: cannot handle: %s cn %d\"",
            "c->self",
            "need == 1 ? \"SOCKS4\" : \"SOCKS4A\"",
            "s4_req.command"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: dynamic request: socks4 host %s port %u command %u\"",
            "c->self",
            "c->path",
            "c->host_port",
            "s4_req.command"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "s4_req.dest_port"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "input",
            "len"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "p"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"channel %d: hostname \\\"%.100s\\\" too long\"",
            "c->self",
            "p"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "p",
            "'\\0'",
            "have"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "input"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "input"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_ntoa",
          "args": [
            "s4_req.dest_addr"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "inet_ntoa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/inet_ntoa.c",
          "lines": "46-57",
          "snippet": "char *\ninet_ntoa(struct in_addr in)\n{\n\tstatic char b[18];\n\tchar *p;\n\n\tp = (char *)&in;\n#define\tUC(b)\t(((int)b)&0xff)\n\t(void)snprintf(b, sizeof(b),\n\t    \"%u.%u.%u.%u\", UC(p[0]), UC(p[1]), UC(p[2]), UC(p[3]));\n\treturn (b);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ninet_ntoa(struct in_addr in)\n{\n\tstatic char b[18];\n\tchar *p;\n\n\tp = (char *)&in;\n#define\tUC(b)\t(((int)b)&0xff)\n\t(void)snprintf(b, sizeof(b),\n\t    \"%u.%u.%u.%u\", UC(p[0]), UC(p[1]), UC(p[2]), UC(p[3]));\n\treturn (b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "c->path"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4195-4206",
          "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "username",
            "p",
            "sizeof(username)"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "p",
            "'\\0'",
            "have"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get",
          "args": [
            "input",
            "&s4_req.dest_addr",
            "4"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_bignum2_bytes_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "430-464",
          "snippet": "int\nsshbuf_get_bignum2_bytes_direct(struct sshbuf *buf,\n    const u_char **valp, size_t *lenp)\n{\n\tconst u_char *d;\n\tsize_t len, olen;\n\tint r;\n\n\tif ((r = sshbuf_peek_string_direct(buf, &d, &olen)) < 0)\n\t\treturn r;\n\tlen = olen;\n\t/* Refuse negative (MSB set) bignums */\n\tif ((len != 0 && (*d & 0x80) != 0))\n\t\treturn SSH_ERR_BIGNUM_IS_NEGATIVE;\n\t/* Refuse overlong bignums, allow prepended \\0 to avoid MSB set */\n\tif (len > SSHBUF_MAX_BIGNUM + 1 ||\n\t    (len == SSHBUF_MAX_BIGNUM + 1 && *d != 0))\n\t\treturn SSH_ERR_BIGNUM_TOO_LARGE;\n\t/* Trim leading zeros */\n\twhile (len > 0 && *d == 0x00) {\n\t\td++;\n\t\tlen--;\n\t}\n\tif (valp != NULL)\n\t\t*valp = d;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, olen + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_bignum2_bytes_direct(struct sshbuf *buf,\n    const u_char **valp, size_t *lenp)\n{\n\tconst u_char *d;\n\tsize_t len, olen;\n\tint r;\n\n\tif ((r = sshbuf_peek_string_direct(buf, &d, &olen)) < 0)\n\t\treturn r;\n\tlen = olen;\n\t/* Refuse negative (MSB set) bignums */\n\tif ((len != 0 && (*d & 0x80) != 0))\n\t\treturn SSH_ERR_BIGNUM_IS_NEGATIVE;\n\t/* Refuse overlong bignums, allow prepended \\0 to avoid MSB set */\n\tif (len > SSHBUF_MAX_BIGNUM + 1 ||\n\t    (len == SSHBUF_MAX_BIGNUM + 1 && *d != 0))\n\t\treturn SSH_ERR_BIGNUM_TOO_LARGE;\n\t/* Trim leading zeros */\n\twhile (len > 0 && *d == 0x00) {\n\t\td++;\n\t\tlen--;\n\t}\n\tif (valp != NULL)\n\t\t*valp = d;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, olen + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\nchannel_decode_socks4(Channel *c, struct sshbuf *input, struct sshbuf *output)\n{\n\tconst u_char *p;\n\tchar *host;\n\tu_int len, have, i, found, need;\n\tchar username[256];\n\tstruct {\n\t\tu_int8_t version;\n\t\tu_int8_t command;\n\t\tu_int16_t dest_port;\n\t\tstruct in_addr dest_addr;\n\t} s4_req, s4_rsp;\n\tint r;\n\n\tdebug2(\"channel %d: decode socks4\", c->self);\n\n\thave = sshbuf_len(input);\n\tlen = sizeof(s4_req);\n\tif (have < len)\n\t\treturn 0;\n\tp = sshbuf_ptr(input);\n\n\tneed = 1;\n\t/* SOCKS4A uses an invalid IP address 0.0.0.x */\n\tif (p[4] == 0 && p[5] == 0 && p[6] == 0 && p[7] != 0) {\n\t\tdebug2(\"channel %d: socks4a request\", c->self);\n\t\t/* ... and needs an extra string (the hostname) */\n\t\tneed = 2;\n\t}\n\t/* Check for terminating NUL on the string(s) */\n\tfor (found = 0, i = len; i < have; i++) {\n\t\tif (p[i] == '\\0') {\n\t\t\tfound++;\n\t\t\tif (found == need)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i > 1024) {\n\t\t\t/* the peer is probably sending garbage */\n\t\t\tdebug(\"channel %d: decode socks4: too long\",\n\t\t\t    c->self);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (found < need)\n\t\treturn 0;\n\tif ((r = sshbuf_get(input, &s4_req.version, 1)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.command, 1)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.dest_port, 2)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.dest_addr, 4)) != 0) {\n\t\tdebug(\"channels %d: decode socks4: %s\", c->self, ssh_err(r));\n\t\treturn -1;\n\t}\n\thave = sshbuf_len(input);\n\tp = sshbuf_ptr(input);\n\tif (memchr(p, '\\0', have) == NULL) {\n\t\terror(\"channel %d: decode socks4: user not nul terminated\",\n\t\t    c->self);\n\t\treturn -1;\n\t}\n\tlen = strlen(p);\n\tdebug2(\"channel %d: decode socks4: user %s/%d\", c->self, p, len);\n\tlen++; /* trailing '\\0' */\n\tstrlcpy(username, p, sizeof(username));\n\tif ((r = sshbuf_consume(input, len)) != 0) {\n\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\tfree(c->path);\n\tc->path = NULL;\n\tif (need == 1) {\t\t\t/* SOCKS4: one string */\n\t\thost = inet_ntoa(s4_req.dest_addr);\n\t\tc->path = xstrdup(host);\n\t} else {\t\t\t\t/* SOCKS4A: two strings */\n\t\thave = sshbuf_len(input);\n\t\tp = sshbuf_ptr(input);\n\t\tif (memchr(p, '\\0', have) == NULL) {\n\t\t\terror(\"channel %d: decode socks4a: host not nul \"\n\t\t\t    \"terminated\", c->self);\n\t\t\treturn -1;\n\t\t}\n\t\tlen = strlen(p);\n\t\tdebug2(\"channel %d: decode socks4a: host %s/%d\",\n\t\t    c->self, p, len);\n\t\tlen++;\t\t\t\t/* trailing '\\0' */\n\t\tif (len > NI_MAXHOST) {\n\t\t\terror(\"channel %d: hostname \\\"%.100s\\\" too long\",\n\t\t\t    c->self, p);\n\t\t\treturn -1;\n\t\t}\n\t\tc->path = xstrdup(p);\n\t\tif ((r = sshbuf_consume(input, len)) != 0) {\n\t\t\tfatal(\"%s: channel %d: consume: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t}\n\tc->host_port = ntohs(s4_req.dest_port);\n\n\tdebug2(\"channel %d: dynamic request: socks4 host %s port %u command %u\",\n\t    c->self, c->path, c->host_port, s4_req.command);\n\n\tif (s4_req.command != 1) {\n\t\tdebug(\"channel %d: cannot handle: %s cn %d\",\n\t\t    c->self, need == 1 ? \"SOCKS4\" : \"SOCKS4A\", s4_req.command);\n\t\treturn -1;\n\t}\n\ts4_rsp.version = 0;\t\t\t/* vn: 0 for reply */\n\ts4_rsp.command = 90;\t\t\t/* cd: req granted */\n\ts4_rsp.dest_port = 0;\t\t\t/* ignored */\n\ts4_rsp.dest_addr.s_addr = INADDR_ANY;\t/* ignored */\n\tif ((r = sshbuf_put(output, &s4_rsp, sizeof(s4_rsp))) != 0) {\n\t\tfatal(\"%s: channel %d: append reply: %s\", __func__,\n\t\t    c->self, ssh_err(r));\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "channel_pre_mux_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1203-1224",
    "snippet": "static void\nchannel_pre_mux_client(struct ssh *ssh,\n    Channel *c, fd_set *readset, fd_set *writeset)\n{\n\tif (c->istate == CHAN_INPUT_OPEN && !c->mux_pause &&\n\t    sshbuf_check_reserve(c->input, CHAN_RBUF) == 0)\n\t\tFD_SET(c->rfd, readset);\n\tif (c->istate == CHAN_INPUT_WAIT_DRAIN) {\n\t\t/* clear buffer immediately (discard any partial packet) */\n\t\tsshbuf_reset(c->input);\n\t\tchan_ibuf_empty(ssh, c);\n\t\t/* Start output drain. XXX just kill chan? */\n\t\tchan_rcvd_oclose(ssh, c);\n\t}\n\tif (c->ostate == CHAN_OUTPUT_OPEN ||\n\t    c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {\n\t\tif (sshbuf_len(c->output) > 0)\n\t\t\tFD_SET(c->wfd, writeset);\n\t\telse if (c->ostate == CHAN_OUTPUT_WAIT_DRAIN)\n\t\t\tchan_obuf_empty(ssh, c);\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "chan_obuf_empty",
          "args": [
            "ssh",
            "c"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "chan_obuf_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "146-165",
          "snippet": "void\nchan_obuf_empty(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: obuf empty\", c->self);\n\tif (sshbuf_len(c->output)) {\n\t\terror(\"channel %d: chan_obuf_empty for non empty buffer\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: internal error: obuf_empty for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_obuf_empty(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: obuf empty\", c->self);\n\tif (sshbuf_len(c->output)) {\n\t\terror(\"channel %d: chan_obuf_empty for non empty buffer\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: internal error: obuf_empty for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "c->wfd",
            "writeset"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_SET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "19-21",
          "snippet": "void kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nvoid kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "c->output"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_rcvd_oclose",
          "args": [
            "ssh",
            "c"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "chan_rcvd_oclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "265-303",
          "snippet": "void\nchan_rcvd_oclose(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: rcvd close\", c->self);\n\tif (!(c->flags & CHAN_LOCAL)) {\n\t\tif (c->flags & CHAN_CLOSE_RCVD)\n\t\t\terror(\"channel %d: protocol error: close rcvd twice\",\n\t\t\t    c->self);\n\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t}\n\tif (c->type == SSH_CHANNEL_LARVAL) {\n\t\t/* tear down larval channels immediately */\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\treturn;\n\t}\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\t\t/*\n\t\t * wait until a data from the channel is consumed if a CLOSE\n\t\t * is received\n\t\t */\n\t\tchan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);\n\t\tbreak;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_shutdown_extended_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & CHAN_LOCAL))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_shutdown_extended_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_rcvd_oclose(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: rcvd close\", c->self);\n\tif (!(c->flags & CHAN_LOCAL)) {\n\t\tif (c->flags & CHAN_CLOSE_RCVD)\n\t\t\terror(\"channel %d: protocol error: close rcvd twice\",\n\t\t\t    c->self);\n\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t}\n\tif (c->type == SSH_CHANNEL_LARVAL) {\n\t\t/* tear down larval channels immediately */\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\treturn;\n\t}\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\t\t/*\n\t\t * wait until a data from the channel is consumed if a CLOSE\n\t\t * is received\n\t\t */\n\t\tchan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);\n\t\tbreak;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_shutdown_extended_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & CHAN_LOCAL))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_shutdown_extended_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_ibuf_empty",
          "args": [
            "ssh",
            "c"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "chan_ibuf_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "124-144",
          "snippet": "void\nchan_ibuf_empty(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: ibuf empty\", c->self);\n\tif (sshbuf_len(c->input)) {\n\t\terror(\"channel %d: chan_ibuf_empty for non empty buffer\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & (CHAN_CLOSE_SENT|CHAN_LOCAL)))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_ibuf_empty for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_ibuf_empty(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: ibuf empty\", c->self);\n\tif (sshbuf_len(c->input)) {\n\t\terror(\"channel %d: chan_ibuf_empty for non empty buffer\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & (CHAN_CLOSE_SENT|CHAN_LOCAL)))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_ibuf_empty for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "c->input"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_check_reserve",
          "args": [
            "c->input",
            "CHAN_RBUF"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_check_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "284-298",
          "snippet": "int\nsshbuf_check_reserve(const struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (buf->readonly || buf->refcount > 1)\n\t\treturn SSH_ERR_BUFFER_READ_ONLY;\n\tSSHBUF_TELL(\"check\");\n\t/* Check that len is reasonable and that max_size + available < len */\n\tif (len > buf->max_size || buf->max_size - len < buf->size - buf->off)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_check_reserve(const struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (buf->readonly || buf->refcount > 1)\n\t\treturn SSH_ERR_BUFFER_READ_ONLY;\n\tSSHBUF_TELL(\"check\");\n\t/* Check that len is reasonable and that max_size + available < len */\n\tif (len > buf->max_size || buf->max_size - len < buf->size - buf->off)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_pre_mux_client(struct ssh *ssh,\n    Channel *c, fd_set *readset, fd_set *writeset)\n{\n\tif (c->istate == CHAN_INPUT_OPEN && !c->mux_pause &&\n\t    sshbuf_check_reserve(c->input, CHAN_RBUF) == 0)\n\t\tFD_SET(c->rfd, readset);\n\tif (c->istate == CHAN_INPUT_WAIT_DRAIN) {\n\t\t/* clear buffer immediately (discard any partial packet) */\n\t\tsshbuf_reset(c->input);\n\t\tchan_ibuf_empty(ssh, c);\n\t\t/* Start output drain. XXX just kill chan? */\n\t\tchan_rcvd_oclose(ssh, c);\n\t}\n\tif (c->ostate == CHAN_OUTPUT_OPEN ||\n\t    c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {\n\t\tif (sshbuf_len(c->output) > 0)\n\t\t\tFD_SET(c->wfd, writeset);\n\t\telse if (c->ostate == CHAN_OUTPUT_WAIT_DRAIN)\n\t\t\tchan_obuf_empty(ssh, c);\n\t}\n}"
  },
  {
    "function_name": "channel_pre_x11_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1179-1201",
    "snippet": "static void\nchannel_pre_x11_open(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tint ret = x11_open_helper(ssh, c->output);\n\n\t/* c->force_drain = 1; */\n\n\tif (ret == 1) {\n\t\tc->type = SSH_CHANNEL_OPEN;\n\t\tchannel_pre_open(ssh, c, readset, writeset);\n\t} else if (ret == -1) {\n\t\tlogit(\"X11 connection rejected because of wrong authentication.\");\n\t\tdebug2(\"X11 rejected %d i%d/o%d\",\n\t\t    c->self, c->istate, c->ostate);\n\t\tchan_read_failed(ssh, c);\n\t\tsshbuf_reset(c->input);\n\t\tchan_ibuf_empty(ssh, c);\n\t\tsshbuf_reset(c->output);\n\t\tchan_write_failed(ssh, c);\n\t\tdebug2(\"X11 closed %d i%d/o%d\", c->self, c->istate, c->ostate);\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"X11 closed %d i%d/o%d\"",
            "c->self",
            "c->istate",
            "c->ostate"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_write_failed",
          "args": [
            "ssh",
            "c"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "chan_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "305-322",
          "snippet": "void\nchan_write_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: write failed\", c->self);\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tif (strcmp(c->ctype, \"session\") == 0)\n\t\t\tchan_send_eow2(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_write_failed for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_write_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: write failed\", c->self);\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tif (strcmp(c->ctype, \"session\") == 0)\n\t\t\tchan_send_eow2(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_write_failed for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "c->output"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_ibuf_empty",
          "args": [
            "ssh",
            "c"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "chan_ibuf_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "124-144",
          "snippet": "void\nchan_ibuf_empty(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: ibuf empty\", c->self);\n\tif (sshbuf_len(c->input)) {\n\t\terror(\"channel %d: chan_ibuf_empty for non empty buffer\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & (CHAN_CLOSE_SENT|CHAN_LOCAL)))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_ibuf_empty for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_ibuf_empty(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: ibuf empty\", c->self);\n\tif (sshbuf_len(c->input)) {\n\t\terror(\"channel %d: chan_ibuf_empty for non empty buffer\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & (CHAN_CLOSE_SENT|CHAN_LOCAL)))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_ibuf_empty for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_read_failed",
          "args": [
            "ssh",
            "c"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "chan_read_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "108-122",
          "snippet": "void\nchan_read_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: read failed\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_WAIT_DRAIN);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_read_failed for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_read_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: read failed\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_WAIT_DRAIN);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_read_failed for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"X11 connection rejected because of wrong authentication.\""
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_pre_open",
          "args": [
            "ssh",
            "c",
            "readset",
            "writeset"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "channel_pre_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1066-1101",
          "snippet": "static void\nchannel_pre_open(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tif (c->istate == CHAN_INPUT_OPEN &&\n\t    c->remote_window > 0 &&\n\t    sshbuf_len(c->input) < c->remote_window &&\n\t    sshbuf_check_reserve(c->input, CHAN_RBUF) == 0)\n\t\tFD_SET(c->rfd, readset);\n\tif (c->ostate == CHAN_OUTPUT_OPEN ||\n\t    c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {\n\t\tif (sshbuf_len(c->output) > 0) {\n\t\t\tFD_SET(c->wfd, writeset);\n\t\t} else if (c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {\n\t\t\tif (CHANNEL_EFD_OUTPUT_ACTIVE(c))\n\t\t\t\tdebug2(\"channel %d: \"\n\t\t\t\t    \"obuf_empty delayed efd %d/(%zu)\", c->self,\n\t\t\t\t    c->efd, sshbuf_len(c->extended));\n\t\t\telse\n\t\t\t\tchan_obuf_empty(ssh, c);\n\t\t}\n\t}\n\t/** XXX check close conditions, too */\n\tif (c->efd != -1 && !(c->istate == CHAN_INPUT_CLOSED &&\n\t    c->ostate == CHAN_OUTPUT_CLOSED)) {\n\t\tif (c->extended_usage == CHAN_EXTENDED_WRITE &&\n\t\t    sshbuf_len(c->extended) > 0)\n\t\t\tFD_SET(c->efd, writeset);\n\t\telse if (c->efd != -1 && !(c->flags & CHAN_EOF_SENT) &&\n\t\t    (c->extended_usage == CHAN_EXTENDED_READ ||\n\t\t    c->extended_usage == CHAN_EXTENDED_IGNORE) &&\n\t\t    sshbuf_len(c->extended) < c->remote_window)\n\t\t\tFD_SET(c->efd, readset);\n\t}\n\t/* XXX: What about efd? races? */\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_pre_open(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tif (c->istate == CHAN_INPUT_OPEN &&\n\t    c->remote_window > 0 &&\n\t    sshbuf_len(c->input) < c->remote_window &&\n\t    sshbuf_check_reserve(c->input, CHAN_RBUF) == 0)\n\t\tFD_SET(c->rfd, readset);\n\tif (c->ostate == CHAN_OUTPUT_OPEN ||\n\t    c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {\n\t\tif (sshbuf_len(c->output) > 0) {\n\t\t\tFD_SET(c->wfd, writeset);\n\t\t} else if (c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {\n\t\t\tif (CHANNEL_EFD_OUTPUT_ACTIVE(c))\n\t\t\t\tdebug2(\"channel %d: \"\n\t\t\t\t    \"obuf_empty delayed efd %d/(%zu)\", c->self,\n\t\t\t\t    c->efd, sshbuf_len(c->extended));\n\t\t\telse\n\t\t\t\tchan_obuf_empty(ssh, c);\n\t\t}\n\t}\n\t/** XXX check close conditions, too */\n\tif (c->efd != -1 && !(c->istate == CHAN_INPUT_CLOSED &&\n\t    c->ostate == CHAN_OUTPUT_CLOSED)) {\n\t\tif (c->extended_usage == CHAN_EXTENDED_WRITE &&\n\t\t    sshbuf_len(c->extended) > 0)\n\t\t\tFD_SET(c->efd, writeset);\n\t\telse if (c->efd != -1 && !(c->flags & CHAN_EOF_SENT) &&\n\t\t    (c->extended_usage == CHAN_EXTENDED_READ ||\n\t\t    c->extended_usage == CHAN_EXTENDED_IGNORE) &&\n\t\t    sshbuf_len(c->extended) < c->remote_window)\n\t\t\tFD_SET(c->efd, readset);\n\t}\n\t/* XXX: What about efd? races? */\n}"
        }
      },
      {
        "call_info": {
          "callee": "x11_open_helper",
          "args": [
            "ssh",
            "c->output"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "x11_open_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1112-1177",
          "snippet": "static int\nx11_open_helper(struct ssh *ssh, struct sshbuf *b)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_char *ucp;\n\tu_int proto_len, data_len;\n\n\t/* Is this being called after the refusal deadline? */\n\tif (sc->x11_refuse_time != 0 &&\n\t    (u_int)monotime() >= sc->x11_refuse_time) {\n\t\tverbose(\"Rejected X11 connection after ForwardX11Timeout \"\n\t\t    \"expired\");\n\t\treturn -1;\n\t}\n\n\t/* Check if the fixed size part of the packet is in buffer. */\n\tif (sshbuf_len(b) < 12)\n\t\treturn 0;\n\n\t/* Parse the lengths of variable-length fields. */\n\tucp = sshbuf_mutable_ptr(b);\n\tif (ucp[0] == 0x42) {\t/* Byte order MSB first. */\n\t\tproto_len = 256 * ucp[6] + ucp[7];\n\t\tdata_len = 256 * ucp[8] + ucp[9];\n\t} else if (ucp[0] == 0x6c) {\t/* Byte order LSB first. */\n\t\tproto_len = ucp[6] + 256 * ucp[7];\n\t\tdata_len = ucp[8] + 256 * ucp[9];\n\t} else {\n\t\tdebug2(\"Initial X11 packet contains bad byte order byte: 0x%x\",\n\t\t    ucp[0]);\n\t\treturn -1;\n\t}\n\n\t/* Check if the whole packet is in buffer. */\n\tif (sshbuf_len(b) <\n\t    12 + ((proto_len + 3) & ~3) + ((data_len + 3) & ~3))\n\t\treturn 0;\n\n\t/* Check if authentication protocol matches. */\n\tif (proto_len != strlen(sc->x11_saved_proto) ||\n\t    memcmp(ucp + 12, sc->x11_saved_proto, proto_len) != 0) {\n\t\tdebug2(\"X11 connection uses different authentication protocol.\");\n\t\treturn -1;\n\t}\n\t/* Check if authentication data matches our fake data. */\n\tif (data_len != sc->x11_fake_data_len ||\n\t    timingsafe_bcmp(ucp + 12 + ((proto_len + 3) & ~3),\n\t\tsc->x11_fake_data, sc->x11_fake_data_len) != 0) {\n\t\tdebug2(\"X11 auth data does not match fake data.\");\n\t\treturn -1;\n\t}\n\t/* Check fake data length */\n\tif (sc->x11_fake_data_len != sc->x11_saved_data_len) {\n\t\terror(\"X11 fake_data_len %d != saved_data_len %d\",\n\t\t    sc->x11_fake_data_len, sc->x11_saved_data_len);\n\t\treturn -1;\n\t}\n\t/*\n\t * Received authentication protocol and data match\n\t * our fake data. Substitute the fake data with real\n\t * data.\n\t */\n\tmemcpy(ucp + 12 + ((proto_len + 3) & ~3),\n\t    sc->x11_saved_data, sc->x11_saved_data_len);\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic int\nx11_open_helper(struct ssh *ssh, struct sshbuf *b)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_char *ucp;\n\tu_int proto_len, data_len;\n\n\t/* Is this being called after the refusal deadline? */\n\tif (sc->x11_refuse_time != 0 &&\n\t    (u_int)monotime() >= sc->x11_refuse_time) {\n\t\tverbose(\"Rejected X11 connection after ForwardX11Timeout \"\n\t\t    \"expired\");\n\t\treturn -1;\n\t}\n\n\t/* Check if the fixed size part of the packet is in buffer. */\n\tif (sshbuf_len(b) < 12)\n\t\treturn 0;\n\n\t/* Parse the lengths of variable-length fields. */\n\tucp = sshbuf_mutable_ptr(b);\n\tif (ucp[0] == 0x42) {\t/* Byte order MSB first. */\n\t\tproto_len = 256 * ucp[6] + ucp[7];\n\t\tdata_len = 256 * ucp[8] + ucp[9];\n\t} else if (ucp[0] == 0x6c) {\t/* Byte order LSB first. */\n\t\tproto_len = ucp[6] + 256 * ucp[7];\n\t\tdata_len = ucp[8] + 256 * ucp[9];\n\t} else {\n\t\tdebug2(\"Initial X11 packet contains bad byte order byte: 0x%x\",\n\t\t    ucp[0]);\n\t\treturn -1;\n\t}\n\n\t/* Check if the whole packet is in buffer. */\n\tif (sshbuf_len(b) <\n\t    12 + ((proto_len + 3) & ~3) + ((data_len + 3) & ~3))\n\t\treturn 0;\n\n\t/* Check if authentication protocol matches. */\n\tif (proto_len != strlen(sc->x11_saved_proto) ||\n\t    memcmp(ucp + 12, sc->x11_saved_proto, proto_len) != 0) {\n\t\tdebug2(\"X11 connection uses different authentication protocol.\");\n\t\treturn -1;\n\t}\n\t/* Check if authentication data matches our fake data. */\n\tif (data_len != sc->x11_fake_data_len ||\n\t    timingsafe_bcmp(ucp + 12 + ((proto_len + 3) & ~3),\n\t\tsc->x11_fake_data, sc->x11_fake_data_len) != 0) {\n\t\tdebug2(\"X11 auth data does not match fake data.\");\n\t\treturn -1;\n\t}\n\t/* Check fake data length */\n\tif (sc->x11_fake_data_len != sc->x11_saved_data_len) {\n\t\terror(\"X11 fake_data_len %d != saved_data_len %d\",\n\t\t    sc->x11_fake_data_len, sc->x11_saved_data_len);\n\t\treturn -1;\n\t}\n\t/*\n\t * Received authentication protocol and data match\n\t * our fake data. Substitute the fake data with real\n\t * data.\n\t */\n\tmemcpy(ucp + 12 + ((proto_len + 3) & ~3),\n\t    sc->x11_saved_data, sc->x11_saved_data_len);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_pre_x11_open(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tint ret = x11_open_helper(ssh, c->output);\n\n\t/* c->force_drain = 1; */\n\n\tif (ret == 1) {\n\t\tc->type = SSH_CHANNEL_OPEN;\n\t\tchannel_pre_open(ssh, c, readset, writeset);\n\t} else if (ret == -1) {\n\t\tlogit(\"X11 connection rejected because of wrong authentication.\");\n\t\tdebug2(\"X11 rejected %d i%d/o%d\",\n\t\t    c->self, c->istate, c->ostate);\n\t\tchan_read_failed(ssh, c);\n\t\tsshbuf_reset(c->input);\n\t\tchan_ibuf_empty(ssh, c);\n\t\tsshbuf_reset(c->output);\n\t\tchan_write_failed(ssh, c);\n\t\tdebug2(\"X11 closed %d i%d/o%d\", c->self, c->istate, c->ostate);\n\t}\n}"
  },
  {
    "function_name": "x11_open_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1112-1177",
    "snippet": "static int\nx11_open_helper(struct ssh *ssh, struct sshbuf *b)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_char *ucp;\n\tu_int proto_len, data_len;\n\n\t/* Is this being called after the refusal deadline? */\n\tif (sc->x11_refuse_time != 0 &&\n\t    (u_int)monotime() >= sc->x11_refuse_time) {\n\t\tverbose(\"Rejected X11 connection after ForwardX11Timeout \"\n\t\t    \"expired\");\n\t\treturn -1;\n\t}\n\n\t/* Check if the fixed size part of the packet is in buffer. */\n\tif (sshbuf_len(b) < 12)\n\t\treturn 0;\n\n\t/* Parse the lengths of variable-length fields. */\n\tucp = sshbuf_mutable_ptr(b);\n\tif (ucp[0] == 0x42) {\t/* Byte order MSB first. */\n\t\tproto_len = 256 * ucp[6] + ucp[7];\n\t\tdata_len = 256 * ucp[8] + ucp[9];\n\t} else if (ucp[0] == 0x6c) {\t/* Byte order LSB first. */\n\t\tproto_len = ucp[6] + 256 * ucp[7];\n\t\tdata_len = ucp[8] + 256 * ucp[9];\n\t} else {\n\t\tdebug2(\"Initial X11 packet contains bad byte order byte: 0x%x\",\n\t\t    ucp[0]);\n\t\treturn -1;\n\t}\n\n\t/* Check if the whole packet is in buffer. */\n\tif (sshbuf_len(b) <\n\t    12 + ((proto_len + 3) & ~3) + ((data_len + 3) & ~3))\n\t\treturn 0;\n\n\t/* Check if authentication protocol matches. */\n\tif (proto_len != strlen(sc->x11_saved_proto) ||\n\t    memcmp(ucp + 12, sc->x11_saved_proto, proto_len) != 0) {\n\t\tdebug2(\"X11 connection uses different authentication protocol.\");\n\t\treturn -1;\n\t}\n\t/* Check if authentication data matches our fake data. */\n\tif (data_len != sc->x11_fake_data_len ||\n\t    timingsafe_bcmp(ucp + 12 + ((proto_len + 3) & ~3),\n\t\tsc->x11_fake_data, sc->x11_fake_data_len) != 0) {\n\t\tdebug2(\"X11 auth data does not match fake data.\");\n\t\treturn -1;\n\t}\n\t/* Check fake data length */\n\tif (sc->x11_fake_data_len != sc->x11_saved_data_len) {\n\t\terror(\"X11 fake_data_len %d != saved_data_len %d\",\n\t\t    sc->x11_fake_data_len, sc->x11_saved_data_len);\n\t\treturn -1;\n\t}\n\t/*\n\t * Received authentication protocol and data match\n\t * our fake data. Substitute the fake data with real\n\t * data.\n\t */\n\tmemcpy(ucp + 12 + ((proto_len + 3) & ~3),\n\t    sc->x11_saved_data, sc->x11_saved_data_len);\n\treturn 1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ucp + 12 + ((proto_len + 3) & ~3)",
            "sc->x11_saved_data",
            "sc->x11_saved_data_len"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"X11 fake_data_len %d != saved_data_len %d\"",
            "sc->x11_fake_data_len",
            "sc->x11_saved_data_len"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"X11 auth data does not match fake data.\""
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timingsafe_bcmp",
          "args": [
            "ucp + 12 + ((proto_len + 3) & ~3)",
            "sc->x11_fake_data",
            "sc->x11_fake_data_len"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "timingsafe_bcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/timingsafe_bcmp.c",
          "lines": "23-32",
          "snippet": "int\ntimingsafe_bcmp(const void *b1, const void *b2, size_t n)\n{\n\tconst unsigned char *p1 = b1, *p2 = b2;\n\tint ret = 0;\n\n\tfor (; n > 0; n--)\n\t\tret |= *p1++ ^ *p2++;\n\treturn (ret != 0);\n}",
          "includes": [
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"includes.h\"\n\nint\ntimingsafe_bcmp(const void *b1, const void *b2, size_t n)\n{\n\tconst unsigned char *p1 = b1, *p2 = b2;\n\tint ret = 0;\n\n\tfor (; n > 0; n--)\n\t\tret |= *p1++ ^ *p2++;\n\treturn (ret != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ucp + 12",
            "sc->x11_saved_proto",
            "proto_len"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sc->x11_saved_proto"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_mutable_ptr",
          "args": [
            "b"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_mutable_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "276-282",
          "snippet": "u_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Rejected X11 connection after ForwardX11Timeout \"\n\t\t    \"expired\""
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "monotime",
          "args": [],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "monotime_double",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1324-1331",
          "snippet": "double\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\ndouble\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic int\nx11_open_helper(struct ssh *ssh, struct sshbuf *b)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_char *ucp;\n\tu_int proto_len, data_len;\n\n\t/* Is this being called after the refusal deadline? */\n\tif (sc->x11_refuse_time != 0 &&\n\t    (u_int)monotime() >= sc->x11_refuse_time) {\n\t\tverbose(\"Rejected X11 connection after ForwardX11Timeout \"\n\t\t    \"expired\");\n\t\treturn -1;\n\t}\n\n\t/* Check if the fixed size part of the packet is in buffer. */\n\tif (sshbuf_len(b) < 12)\n\t\treturn 0;\n\n\t/* Parse the lengths of variable-length fields. */\n\tucp = sshbuf_mutable_ptr(b);\n\tif (ucp[0] == 0x42) {\t/* Byte order MSB first. */\n\t\tproto_len = 256 * ucp[6] + ucp[7];\n\t\tdata_len = 256 * ucp[8] + ucp[9];\n\t} else if (ucp[0] == 0x6c) {\t/* Byte order LSB first. */\n\t\tproto_len = ucp[6] + 256 * ucp[7];\n\t\tdata_len = ucp[8] + 256 * ucp[9];\n\t} else {\n\t\tdebug2(\"Initial X11 packet contains bad byte order byte: 0x%x\",\n\t\t    ucp[0]);\n\t\treturn -1;\n\t}\n\n\t/* Check if the whole packet is in buffer. */\n\tif (sshbuf_len(b) <\n\t    12 + ((proto_len + 3) & ~3) + ((data_len + 3) & ~3))\n\t\treturn 0;\n\n\t/* Check if authentication protocol matches. */\n\tif (proto_len != strlen(sc->x11_saved_proto) ||\n\t    memcmp(ucp + 12, sc->x11_saved_proto, proto_len) != 0) {\n\t\tdebug2(\"X11 connection uses different authentication protocol.\");\n\t\treturn -1;\n\t}\n\t/* Check if authentication data matches our fake data. */\n\tif (data_len != sc->x11_fake_data_len ||\n\t    timingsafe_bcmp(ucp + 12 + ((proto_len + 3) & ~3),\n\t\tsc->x11_fake_data, sc->x11_fake_data_len) != 0) {\n\t\tdebug2(\"X11 auth data does not match fake data.\");\n\t\treturn -1;\n\t}\n\t/* Check fake data length */\n\tif (sc->x11_fake_data_len != sc->x11_saved_data_len) {\n\t\terror(\"X11 fake_data_len %d != saved_data_len %d\",\n\t\t    sc->x11_fake_data_len, sc->x11_saved_data_len);\n\t\treturn -1;\n\t}\n\t/*\n\t * Received authentication protocol and data match\n\t * our fake data. Substitute the fake data with real\n\t * data.\n\t */\n\tmemcpy(ucp + 12 + ((proto_len + 3) & ~3),\n\t    sc->x11_saved_data, sc->x11_saved_data_len);\n\treturn 1;\n}"
  },
  {
    "function_name": "channel_pre_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1066-1101",
    "snippet": "static void\nchannel_pre_open(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tif (c->istate == CHAN_INPUT_OPEN &&\n\t    c->remote_window > 0 &&\n\t    sshbuf_len(c->input) < c->remote_window &&\n\t    sshbuf_check_reserve(c->input, CHAN_RBUF) == 0)\n\t\tFD_SET(c->rfd, readset);\n\tif (c->ostate == CHAN_OUTPUT_OPEN ||\n\t    c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {\n\t\tif (sshbuf_len(c->output) > 0) {\n\t\t\tFD_SET(c->wfd, writeset);\n\t\t} else if (c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {\n\t\t\tif (CHANNEL_EFD_OUTPUT_ACTIVE(c))\n\t\t\t\tdebug2(\"channel %d: \"\n\t\t\t\t    \"obuf_empty delayed efd %d/(%zu)\", c->self,\n\t\t\t\t    c->efd, sshbuf_len(c->extended));\n\t\t\telse\n\t\t\t\tchan_obuf_empty(ssh, c);\n\t\t}\n\t}\n\t/** XXX check close conditions, too */\n\tif (c->efd != -1 && !(c->istate == CHAN_INPUT_CLOSED &&\n\t    c->ostate == CHAN_OUTPUT_CLOSED)) {\n\t\tif (c->extended_usage == CHAN_EXTENDED_WRITE &&\n\t\t    sshbuf_len(c->extended) > 0)\n\t\t\tFD_SET(c->efd, writeset);\n\t\telse if (c->efd != -1 && !(c->flags & CHAN_EOF_SENT) &&\n\t\t    (c->extended_usage == CHAN_EXTENDED_READ ||\n\t\t    c->extended_usage == CHAN_EXTENDED_IGNORE) &&\n\t\t    sshbuf_len(c->extended) < c->remote_window)\n\t\t\tFD_SET(c->efd, readset);\n\t}\n\t/* XXX: What about efd? races? */\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "c->efd",
            "readset"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_SET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "19-21",
          "snippet": "void kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nvoid kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "c->extended"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan_obuf_empty",
          "args": [
            "ssh",
            "c"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "chan_obuf_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "146-165",
          "snippet": "void\nchan_obuf_empty(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: obuf empty\", c->self);\n\tif (sshbuf_len(c->output)) {\n\t\terror(\"channel %d: chan_obuf_empty for non empty buffer\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: internal error: obuf_empty for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_obuf_empty(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: obuf empty\", c->self);\n\tif (sshbuf_len(c->output)) {\n\t\terror(\"channel %d: chan_obuf_empty for non empty buffer\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: internal error: obuf_empty for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: \"\n\t\t\t\t    \"obuf_empty delayed efd %d/(%zu)\"",
            "c->self",
            "c->efd",
            "sshbuf_len(c->extended)"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHANNEL_EFD_OUTPUT_ACTIVE",
          "args": [
            "c"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_check_reserve",
          "args": [
            "c->input",
            "CHAN_RBUF"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_check_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "284-298",
          "snippet": "int\nsshbuf_check_reserve(const struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (buf->readonly || buf->refcount > 1)\n\t\treturn SSH_ERR_BUFFER_READ_ONLY;\n\tSSHBUF_TELL(\"check\");\n\t/* Check that len is reasonable and that max_size + available < len */\n\tif (len > buf->max_size || buf->max_size - len < buf->size - buf->off)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_check_reserve(const struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (buf->readonly || buf->refcount > 1)\n\t\treturn SSH_ERR_BUFFER_READ_ONLY;\n\tSSHBUF_TELL(\"check\");\n\t/* Check that len is reasonable and that max_size + available < len */\n\tif (len > buf->max_size || buf->max_size - len < buf->size - buf->off)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_pre_open(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tif (c->istate == CHAN_INPUT_OPEN &&\n\t    c->remote_window > 0 &&\n\t    sshbuf_len(c->input) < c->remote_window &&\n\t    sshbuf_check_reserve(c->input, CHAN_RBUF) == 0)\n\t\tFD_SET(c->rfd, readset);\n\tif (c->ostate == CHAN_OUTPUT_OPEN ||\n\t    c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {\n\t\tif (sshbuf_len(c->output) > 0) {\n\t\t\tFD_SET(c->wfd, writeset);\n\t\t} else if (c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {\n\t\t\tif (CHANNEL_EFD_OUTPUT_ACTIVE(c))\n\t\t\t\tdebug2(\"channel %d: \"\n\t\t\t\t    \"obuf_empty delayed efd %d/(%zu)\", c->self,\n\t\t\t\t    c->efd, sshbuf_len(c->extended));\n\t\t\telse\n\t\t\t\tchan_obuf_empty(ssh, c);\n\t\t}\n\t}\n\t/** XXX check close conditions, too */\n\tif (c->efd != -1 && !(c->istate == CHAN_INPUT_CLOSED &&\n\t    c->ostate == CHAN_OUTPUT_CLOSED)) {\n\t\tif (c->extended_usage == CHAN_EXTENDED_WRITE &&\n\t\t    sshbuf_len(c->extended) > 0)\n\t\t\tFD_SET(c->efd, writeset);\n\t\telse if (c->efd != -1 && !(c->flags & CHAN_EOF_SENT) &&\n\t\t    (c->extended_usage == CHAN_EXTENDED_READ ||\n\t\t    c->extended_usage == CHAN_EXTENDED_IGNORE) &&\n\t\t    sshbuf_len(c->extended) < c->remote_window)\n\t\t\tFD_SET(c->efd, readset);\n\t}\n\t/* XXX: What about efd? races? */\n}"
  },
  {
    "function_name": "channel_pre_connecting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1058-1064",
    "snippet": "static void\nchannel_pre_connecting(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tdebug3(\"channel %d: waiting for connection\", c->self);\n\tFD_SET(c->sock, writeset);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "c->sock",
            "writeset"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_SET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "19-21",
          "snippet": "void kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nvoid kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"channel %d: waiting for connection\"",
            "c->self"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_pre_connecting(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tdebug3(\"channel %d: waiting for connection\", c->self);\n\tFD_SET(c->sock, writeset);\n}"
  },
  {
    "function_name": "channel_pre_listener",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1051-1056",
    "snippet": "static void\nchannel_pre_listener(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tFD_SET(c->sock, readset);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "c->sock",
            "readset"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "kludge_FD_SET",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/kludge-fd_set.c",
          "lines": "19-21",
          "snippet": "void kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}",
          "includes": [
            "#   include <sys/socket.h>",
            "# include <features.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/socket.h>\n# include <features.h>\n#include \"config.h\"\n\nvoid kludge_FD_SET(int n, fd_set *set) {\n\tFD_SET(n, set);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_pre_listener(struct ssh *ssh, Channel *c,\n    fd_set *readset, fd_set *writeset)\n{\n\tFD_SET(c->sock, readset);\n}"
  },
  {
    "function_name": "channel_set_fds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1028-1049",
    "snippet": "void\nchannel_set_fds(struct ssh *ssh, int id, int rfd, int wfd, int efd,\n    int extusage, int nonblock, int is_tty, u_int window_max)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL || c->type != SSH_CHANNEL_LARVAL)\n\t\tfatal(\"channel_activate for non-larval channel %d.\", id);\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, is_tty);\n\tc->type = SSH_CHANNEL_OPEN;\n\tc->local_window = c->local_window_max = window_max;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_WINDOW_ADJUST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %i: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "c->local_window"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_CHANNEL_WINDOW_ADJUST"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_register_fds",
          "args": [
            "ssh",
            "c",
            "rfd",
            "wfd",
            "efd",
            "extusage",
            "nonblock",
            "is_tty"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "308-348",
          "snippet": "static void\nchannel_register_fds(struct ssh *ssh, Channel *c, int rfd, int wfd, int efd,\n    int extusage, int nonblock, int is_tty)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\t/* Update the maximum file descriptor value. */\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, rfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, wfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, efd);\n\n\tif (rfd != -1)\n\t\tfcntl(rfd, F_SETFD, FD_CLOEXEC);\n\tif (wfd != -1 && wfd != rfd)\n\t\tfcntl(wfd, F_SETFD, FD_CLOEXEC);\n\tif (efd != -1 && efd != rfd && efd != wfd)\n\t\tfcntl(efd, F_SETFD, FD_CLOEXEC);\n\n\tc->rfd = rfd;\n\tc->wfd = wfd;\n\tc->sock = (rfd == wfd) ? rfd : -1;\n\tc->efd = efd;\n\tc->extended_usage = extusage;\n\n\tif ((c->isatty = is_tty) != 0)\n\t\tdebug2(\"channel %d: rfd %d isatty\", c->self, c->rfd);\n#ifdef _AIX\n\t/* XXX: Later AIX versions can't push as much data to tty */\n\tc->wfd_isatty = is_tty || isatty(c->wfd);\n#endif\n\n\t/* enable nonblocking mode */\n\tif (nonblock) {\n\t\tif (rfd != -1)\n\t\t\tset_nonblock(rfd);\n\t\tif (wfd != -1)\n\t\t\tset_nonblock(wfd);\n\t\tif (efd != -1)\n\t\t\tset_nonblock(efd);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic void\nchannel_register_fds(struct ssh *ssh, Channel *c, int rfd, int wfd, int efd,\n    int extusage, int nonblock, int is_tty)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\t/* Update the maximum file descriptor value. */\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, rfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, wfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, efd);\n\n\tif (rfd != -1)\n\t\tfcntl(rfd, F_SETFD, FD_CLOEXEC);\n\tif (wfd != -1 && wfd != rfd)\n\t\tfcntl(wfd, F_SETFD, FD_CLOEXEC);\n\tif (efd != -1 && efd != rfd && efd != wfd)\n\t\tfcntl(efd, F_SETFD, FD_CLOEXEC);\n\n\tc->rfd = rfd;\n\tc->wfd = wfd;\n\tc->sock = (rfd == wfd) ? rfd : -1;\n\tc->efd = efd;\n\tc->extended_usage = extusage;\n\n\tif ((c->isatty = is_tty) != 0)\n\t\tdebug2(\"channel %d: rfd %d isatty\", c->self, c->rfd);\n#ifdef _AIX\n\t/* XXX: Later AIX versions can't push as much data to tty */\n\tc->wfd_isatty = is_tty || isatty(c->wfd);\n#endif\n\n\t/* enable nonblocking mode */\n\tif (nonblock) {\n\t\tif (rfd != -1)\n\t\t\tset_nonblock(rfd);\n\t\tif (wfd != -1)\n\t\t\tset_nonblock(wfd);\n\t\tif (efd != -1)\n\t\t\tset_nonblock(efd);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"channel_activate for non-larval channel %d.\"",
            "id"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_lookup",
          "args": [
            "ssh",
            "id"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "channel_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "279-302",
          "snippet": "Channel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_set_fds(struct ssh *ssh, int id, int rfd, int wfd, int efd,\n    int extusage, int nonblock, int is_tty, u_int window_max)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL || c->type != SSH_CHANNEL_LARVAL)\n\t\tfatal(\"channel_activate for non-larval channel %d.\", id);\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, is_tty);\n\tc->type = SSH_CHANNEL_OPEN;\n\tc->local_window = c->local_window_max = window_max;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_WINDOW_ADJUST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n}"
  },
  {
    "function_name": "channel_register_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "1012-1026",
    "snippet": "void\nchannel_register_filter(struct ssh *ssh, int id, channel_infilter_fn *ifn,\n    channel_outfilter_fn *ofn, channel_filter_cleanup_fn *cfn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->input_filter = ifn;\n\tc->output_filter = ofn;\n\tc->filter_ctx = ctx;\n\tc->filter_cleanup = cfn;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s: %d: bad id\"",
            "__func__",
            "id"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_lookup",
          "args": [
            "ssh",
            "id"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "channel_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "279-302",
          "snippet": "Channel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_filter(struct ssh *ssh, int id, channel_infilter_fn *ifn,\n    channel_outfilter_fn *ofn, channel_filter_cleanup_fn *cfn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->input_filter = ifn;\n\tc->output_filter = ofn;\n\tc->filter_ctx = ctx;\n\tc->filter_cleanup = cfn;\n}"
  },
  {
    "function_name": "channel_cancel_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "999-1010",
    "snippet": "void\nchannel_cancel_cleanup(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = NULL;\n\tc->detach_close = 0;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s: %d: bad id\"",
            "__func__",
            "id"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_by_id",
          "args": [
            "ssh",
            "id"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "channel_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "244-259",
          "snippet": "Channel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_cancel_cleanup(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = NULL;\n\tc->detach_close = 0;\n}"
  },
  {
    "function_name": "channel_register_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "985-997",
    "snippet": "void\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s: %d: bad id\"",
            "__func__",
            "id"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_by_id",
          "args": [
            "ssh",
            "id"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "channel_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "244-259",
          "snippet": "Channel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}"
  },
  {
    "function_name": "channel_register_open_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "971-983",
    "snippet": "void\nchannel_register_open_confirm(struct ssh *ssh, int id,\n    channel_open_fn *fn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->open_confirm = fn;\n\tc->open_confirm_ctx = ctx;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s: %d: bad id\"",
            "__func__",
            "id"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_lookup",
          "args": [
            "ssh",
            "id"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "channel_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "279-302",
          "snippet": "Channel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_open_confirm(struct ssh *ssh, int id,\n    channel_open_fn *fn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->open_confirm = fn;\n\tc->open_confirm_ctx = ctx;\n}"
  },
  {
    "function_name": "channel_register_status_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "954-969",
    "snippet": "void\nchannel_register_status_confirm(struct ssh *ssh, int id,\n    channel_confirm_cb *cb, channel_confirm_abandon_cb *abandon_cb, void *ctx)\n{\n\tstruct channel_confirm *cc;\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL)\n\t\tfatal(\"%s: %d: bad id\", __func__, id);\n\n\tcc = xcalloc(1, sizeof(*cc));\n\tcc->cb = cb;\n\tcc->abandon_cb = abandon_cb;\n\tcc->ctx = ctx;\n\tTAILQ_INSERT_TAIL(&c->status_confirms, cc, entry);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&c->status_confirms",
            "cc",
            "entry"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(*cc)"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %d: bad id\"",
            "__func__",
            "id"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_lookup",
          "args": [
            "ssh",
            "id"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "channel_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "279-302",
          "snippet": "Channel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_status_confirm(struct ssh *ssh, int id,\n    channel_confirm_cb *cb, channel_confirm_abandon_cb *abandon_cb, void *ctx)\n{\n\tstruct channel_confirm *cc;\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL)\n\t\tfatal(\"%s: %d: bad id\", __func__, id);\n\n\tcc = xcalloc(1, sizeof(*cc));\n\tcc->cb = cb;\n\tcc->abandon_cb = abandon_cb;\n\tcc->ctx = ctx;\n\tTAILQ_INSERT_TAIL(&c->status_confirms, cc, entry);\n}"
  },
  {
    "function_name": "channel_request_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "932-952",
    "snippet": "void\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: unknown channel id\", __func__, id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %i: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u8",
          "args": [
            "ssh",
            "wantconfirm"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2435-2439",
          "snippet": "int\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "service"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "c->remote_id"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_CHANNEL_REQUEST"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: request %s confirm %d\"",
            "id",
            "service",
            "wantconfirm"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s: %d: unknown channel id\"",
            "__func__",
            "id"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_lookup",
          "args": [
            "ssh",
            "id"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "channel_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "279-302",
          "snippet": "Channel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: unknown channel id\", __func__, id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n\t}\n}"
  },
  {
    "function_name": "channel_send_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "916-930",
    "snippet": "void\nchannel_send_open(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"channel_send_open: %d: bad id\", id);\n\t\treturn;\n\t}\n\tdebug2(\"channel %d: send open\", id);\n\topen_preamble(ssh, __func__, c, c->ctype);\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %i: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_preamble",
          "args": [
            "ssh",
            "__func__",
            "c",
            "c->ctype"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "open_preamble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "902-914",
          "snippet": "static void\nopen_preamble(struct ssh *ssh, const char *where, Channel *c, const char *type)\n{\n\tint r;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, type)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: open: %s\", where, c->self, ssh_err(r));\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nopen_preamble(struct ssh *ssh, const char *where, Channel *c, const char *type)\n{\n\tint r;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, type)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: open: %s\", where, c->self, ssh_err(r));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: send open\"",
            "id"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"channel_send_open: %d: bad id\"",
            "id"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_lookup",
          "args": [
            "ssh",
            "id"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "channel_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "279-302",
          "snippet": "Channel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_send_open(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"channel_send_open: %d: bad id\", id);\n\t\treturn;\n\t}\n\tdebug2(\"channel %d: send open\", id);\n\topen_preamble(ssh, __func__, c, c->ctype);\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n}"
  },
  {
    "function_name": "open_preamble",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "902-914",
    "snippet": "static void\nopen_preamble(struct ssh *ssh, const char *where, Channel *c, const char *type)\n{\n\tint r;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, type)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: open: %s\", where, c->self, ssh_err(r));\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %i: open: %s\"",
            "where",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "c->local_maxpacket"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "type"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_CHANNEL_OPEN"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nopen_preamble(struct ssh *ssh, const char *where, Channel *c, const char *type)\n{\n\tint r;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, type)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal(\"%s: channel %i: open: %s\", where, c->self, ssh_err(r));\n\t}\n}"
  },
  {
    "function_name": "channel_open_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "842-900",
    "snippet": "char *\nchannel_open_message(struct ssh *ssh)\n{\n\tstruct sshbuf *buf;\n\tChannel *c;\n\tu_int i;\n\tint r;\n\tchar *cp, *ret;\n\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_putf(buf,\n\t    \"The following connections are open:\\r\\n\")) != 0)\n\t\tfatal(\"%s: sshbuf_putf: %s\", __func__, ssh_err(r));\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\t\tcp = channel_format_status(c);\n\t\t\tif ((r = sshbuf_putf(buf, \"  #%d %.300s (%s)\\r\\n\",\n\t\t\t    c->self, c->remote_name, cp)) != 0) {\n\t\t\t\tfree(cp);\n\t\t\t\tfatal(\"%s: sshbuf_putf: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tfatal(\"%s: bad channel type %d\", __func__, c->type);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\tif ((ret = sshbuf_dup_string(buf)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string\", __func__);\n\tsshbuf_free(buf);\n\treturn ret;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "buf"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_dup_string\"",
            "__func__"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_dup_string",
          "args": [
            "buf"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_dup_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
          "lines": "139-160",
          "snippet": "char *\nsshbuf_dup_string(struct sshbuf *buf)\n{\n\tconst u_char *p = NULL, *s = sshbuf_ptr(buf);\n\tsize_t l = sshbuf_len(buf);\n\tchar *r;\n\n\tif (s == NULL || l > SIZE_MAX)\n\t\treturn NULL;\n\t/* accept a nul only as the last character in the buffer */\n\tif (l > 0 && (p = memchr(s, '\\0', l)) != NULL) {\n\t\tif (p != s + l - 1)\n\t\t\treturn NULL;\n\t\tl--; /* the nul is put back below */\n\t}\n\tif ((r = malloc(l + 1)) == NULL)\n\t\treturn NULL;\n\tif (l > 0)\n\t\tmemcpy(r, s, l);\n\tr[l] = '\\0';\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <ctype.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshbuf_dup_string(struct sshbuf *buf)\n{\n\tconst u_char *p = NULL, *s = sshbuf_ptr(buf);\n\tsize_t l = sshbuf_len(buf);\n\tchar *r;\n\n\tif (s == NULL || l > SIZE_MAX)\n\t\treturn NULL;\n\t/* accept a nul only as the last character in the buffer */\n\tif (l > 0 && (p = memchr(s, '\\0', l)) != NULL) {\n\t\tif (p != s + l - 1)\n\t\t\treturn NULL;\n\t\tl--; /* the nul is put back below */\n\t}\n\tif ((r = malloc(l + 1)) == NULL)\n\t\treturn NULL;\n\tif (l > 0)\n\t\tmemcpy(r, s, l);\n\tr[l] = '\\0';\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: bad channel type %d\"",
            "__func__",
            "c->type"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cp"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4195-4206",
          "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_putf",
          "args": [
            "buf",
            "\"  #%d %.300s (%s)\\r\\n\"",
            "c->self",
            "c->remote_name",
            "cp"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_format_status",
          "args": [
            "c"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "channel_format_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "821-835",
          "snippet": "static char *\nchannel_format_status(const Channel *c)\n{\n\tchar *ret = NULL;\n\n\txasprintf(&ret, \"t%d %s%u i%u/%zu o%u/%zu e[%s]/%zu \"\n\t    \"fd %d/%d/%d sock %d cc %d\",\n\t    c->type,\n\t    c->have_remote_id ? \"r\" : \"nr\", c->remote_id,\n\t    c->istate, sshbuf_len(c->input),\n\t    c->ostate, sshbuf_len(c->output),\n\t    channel_format_extended_usage(c), sshbuf_len(c->extended),\n\t    c->rfd, c->wfd, c->efd, c->sock, c->ctl_chan);\n\treturn ret;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic char *\nchannel_format_status(const Channel *c)\n{\n\tchar *ret = NULL;\n\n\txasprintf(&ret, \"t%d %s%u i%u/%zu o%u/%zu e[%s]/%zu \"\n\t    \"fd %d/%d/%d sock %d cc %d\",\n\t    c->type,\n\t    c->have_remote_id ? \"r\" : \"nr\", c->remote_id,\n\t    c->istate, sshbuf_len(c->input),\n\t    c->ostate, sshbuf_len(c->output),\n\t    channel_format_extended_usage(c), sshbuf_len(c->extended),\n\t    c->rfd, c->wfd, c->efd, c->sock, c->ctl_chan);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nchar *\nchannel_open_message(struct ssh *ssh)\n{\n\tstruct sshbuf *buf;\n\tChannel *c;\n\tu_int i;\n\tint r;\n\tchar *cp, *ret;\n\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_putf(buf,\n\t    \"The following connections are open:\\r\\n\")) != 0)\n\t\tfatal(\"%s: sshbuf_putf: %s\", __func__, ssh_err(r));\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\t\tcp = channel_format_status(c);\n\t\t\tif ((r = sshbuf_putf(buf, \"  #%d %.300s (%s)\\r\\n\",\n\t\t\t    c->self, c->remote_name, cp)) != 0) {\n\t\t\t\tfree(cp);\n\t\t\t\tfatal(\"%s: sshbuf_putf: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tfatal(\"%s: bad channel type %d\", __func__, c->type);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\tif ((ret = sshbuf_dup_string(buf)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string\", __func__);\n\tsshbuf_free(buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "channel_format_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "821-835",
    "snippet": "static char *\nchannel_format_status(const Channel *c)\n{\n\tchar *ret = NULL;\n\n\txasprintf(&ret, \"t%d %s%u i%u/%zu o%u/%zu e[%s]/%zu \"\n\t    \"fd %d/%d/%d sock %d cc %d\",\n\t    c->type,\n\t    c->have_remote_id ? \"r\" : \"nr\", c->remote_id,\n\t    c->istate, sshbuf_len(c->input),\n\t    c->ostate, sshbuf_len(c->output),\n\t    channel_format_extended_usage(c), sshbuf_len(c->extended),\n\t    c->rfd, c->wfd, c->efd, c->sock, c->ctl_chan);\n\treturn ret;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&ret",
            "\"t%d %s%u i%u/%zu o%u/%zu e[%s]/%zu \"\n\t    \"fd %d/%d/%d sock %d cc %d\"",
            "c->type",
            "c->have_remote_id ? \"r\" : \"nr\"",
            "c->remote_id",
            "c->istate",
            "sshbuf_len(c->input)",
            "c->ostate",
            "sshbuf_len(c->output)",
            "channel_format_extended_usage(c)",
            "sshbuf_len(c->extended)",
            "c->rfd",
            "c->wfd",
            "c->efd",
            "c->sock",
            "c->ctl_chan"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "c->extended"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_format_extended_usage",
          "args": [
            "c"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "channel_format_extended_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "803-819",
          "snippet": "const char *\nchannel_format_extended_usage(const Channel *c)\n{\n\tif (c->efd == -1)\n\t\treturn \"closed\";\n\n\tswitch (c->extended_usage) {\n\tcase CHAN_EXTENDED_WRITE:\n\t\treturn \"write\";\n\tcase CHAN_EXTENDED_READ:\n\t\treturn \"read\";\n\tcase CHAN_EXTENDED_IGNORE:\n\t\treturn \"ignore\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nconst char *\nchannel_format_extended_usage(const Channel *c)\n{\n\tif (c->efd == -1)\n\t\treturn \"closed\";\n\n\tswitch (c->extended_usage) {\n\tcase CHAN_EXTENDED_WRITE:\n\t\treturn \"write\";\n\tcase CHAN_EXTENDED_READ:\n\t\treturn \"read\";\n\tcase CHAN_EXTENDED_IGNORE:\n\t\treturn \"ignore\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic char *\nchannel_format_status(const Channel *c)\n{\n\tchar *ret = NULL;\n\n\txasprintf(&ret, \"t%d %s%u i%u/%zu o%u/%zu e[%s]/%zu \"\n\t    \"fd %d/%d/%d sock %d cc %d\",\n\t    c->type,\n\t    c->have_remote_id ? \"r\" : \"nr\", c->remote_id,\n\t    c->istate, sshbuf_len(c->input),\n\t    c->ostate, sshbuf_len(c->output),\n\t    channel_format_extended_usage(c), sshbuf_len(c->extended),\n\t    c->rfd, c->wfd, c->efd, c->sock, c->ctl_chan);\n\treturn ret;\n}"
  },
  {
    "function_name": "channel_format_extended_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "803-819",
    "snippet": "const char *\nchannel_format_extended_usage(const Channel *c)\n{\n\tif (c->efd == -1)\n\t\treturn \"closed\";\n\n\tswitch (c->extended_usage) {\n\tcase CHAN_EXTENDED_WRITE:\n\t\treturn \"write\";\n\tcase CHAN_EXTENDED_READ:\n\t\treturn \"read\";\n\tcase CHAN_EXTENDED_IGNORE:\n\t\treturn \"ignore\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nconst char *\nchannel_format_extended_usage(const Channel *c)\n{\n\tif (c->efd == -1)\n\t\treturn \"closed\";\n\n\tswitch (c->extended_usage) {\n\tcase CHAN_EXTENDED_WRITE:\n\t\treturn \"write\";\n\tcase CHAN_EXTENDED_READ:\n\t\treturn \"read\";\n\tcase CHAN_EXTENDED_IGNORE:\n\t\treturn \"ignore\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}"
  },
  {
    "function_name": "channel_find_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "761-800",
    "snippet": "int\nchannel_find_open(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || !c->have_remote_id)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\t\treturn i;\n\t\tdefault:\n\t\t\tfatal(\"%s: bad channel type %d\", __func__, c->type);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: bad channel type %d\"",
            "__func__",
            "c->type"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_find_open(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || !c->have_remote_id)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\t\treturn i;\n\t\tdefault:\n\t\t\tfatal(\"%s: bad channel type %d\", __func__, c->type);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "channel_still_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "718-758",
    "snippet": "int\nchannel_still_open(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tfatal(\"%s: bad channel type %d\", __func__, c->type);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: bad channel type %d\"",
            "__func__",
            "c->type"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_still_open(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tfatal(\"%s: bad channel type %d\", __func__, c->type);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "channel_not_very_much_buffered_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "697-715",
    "snippet": "int\nchannel_not_very_much_buffered_data(struct ssh *ssh)\n{\n\tu_int i;\n\tu_int maxsize = ssh_packet_get_maxsize(ssh);\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_OPEN)\n\t\t\tcontinue;\n\t\tif (sshbuf_len(c->output) > maxsize) {\n\t\t\tdebug2(\"channel %d: big output buffer %zu > %u\",\n\t\t\t    c->self, sshbuf_len(c->output), maxsize);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: big output buffer %zu > %u\"",
            "c->self",
            "sshbuf_len(c->output)",
            "maxsize"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "c->output"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_get_maxsize",
          "args": [
            "ssh"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_get_maxsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2097-2101",
          "snippet": "u_int\nssh_packet_get_maxsize(struct ssh *ssh)\n{\n\treturn ssh->state->max_packet_size;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\nssh_packet_get_maxsize(struct ssh *ssh)\n{\n\treturn ssh->state->max_packet_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nchannel_not_very_much_buffered_data(struct ssh *ssh)\n{\n\tu_int i;\n\tu_int maxsize = ssh_packet_get_maxsize(ssh);\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_OPEN)\n\t\t\tcontinue;\n\t\tif (sshbuf_len(c->output) > maxsize) {\n\t\t\tdebug2(\"channel %d: big output buffer %zu > %u\",\n\t\t\t    c->self, sshbuf_len(c->output), maxsize);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "channel_stop_listening",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "669-691",
    "snippet": "void\nchannel_stop_listening(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c != NULL) {\n\t\t\tswitch (c->type) {\n\t\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\t\tchannel_close_fd(ssh, &c->sock);\n\t\t\t\tchannel_free(ssh, c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_free",
          "args": [
            "ssh",
            "c"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "channel_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "582-640",
          "snippet": "void\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_close_fd",
          "args": [
            "ssh",
            "&c->sock"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "channel_close_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "441-453",
          "snippet": "static void\nchannel_close_fds(struct ssh *ssh, Channel *c)\n{\n\tint sock = c->sock, rfd = c->rfd, wfd = c->wfd, efd = c->efd;\n\n\tchannel_close_fd(ssh, &c->sock);\n\tif (rfd != sock)\n\t\tchannel_close_fd(ssh, &c->rfd);\n\tif (wfd != sock && wfd != rfd)\n\t\tchannel_close_fd(ssh, &c->wfd);\n\tif (efd != sock && efd != rfd && efd != wfd)\n\t\tchannel_close_fd(ssh, &c->efd);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_close_fds(struct ssh *ssh, Channel *c)\n{\n\tint sock = c->sock, rfd = c->rfd, wfd = c->wfd, efd = c->efd;\n\n\tchannel_close_fd(ssh, &c->sock);\n\tif (rfd != sock)\n\t\tchannel_close_fd(ssh, &c->rfd);\n\tif (wfd != sock && wfd != rfd)\n\t\tchannel_close_fd(ssh, &c->wfd);\n\tif (efd != sock && efd != rfd && efd != wfd)\n\t\tchannel_close_fd(ssh, &c->efd);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_stop_listening(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c != NULL) {\n\t\t\tswitch (c->type) {\n\t\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\t\tchannel_close_fd(ssh, &c->sock);\n\t\t\t\tchannel_free(ssh, c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "channel_close_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "656-664",
    "snippet": "void\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_close_fds",
          "args": [
            "ssh",
            "ssh->chanctxt->channels[i]"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "channel_close_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "441-453",
          "snippet": "static void\nchannel_close_fds(struct ssh *ssh, Channel *c)\n{\n\tint sock = c->sock, rfd = c->rfd, wfd = c->wfd, efd = c->efd;\n\n\tchannel_close_fd(ssh, &c->sock);\n\tif (rfd != sock)\n\t\tchannel_close_fd(ssh, &c->rfd);\n\tif (wfd != sock && wfd != rfd)\n\t\tchannel_close_fd(ssh, &c->wfd);\n\tif (efd != sock && efd != rfd && efd != wfd)\n\t\tchannel_close_fd(ssh, &c->efd);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_close_fds(struct ssh *ssh, Channel *c)\n{\n\tint sock = c->sock, rfd = c->rfd, wfd = c->wfd, efd = c->efd;\n\n\tchannel_close_fd(ssh, &c->sock);\n\tif (rfd != sock)\n\t\tchannel_close_fd(ssh, &c->rfd);\n\tif (wfd != sock && wfd != rfd)\n\t\tchannel_close_fd(ssh, &c->wfd);\n\tif (efd != sock && efd != rfd && efd != wfd)\n\t\tchannel_close_fd(ssh, &c->efd);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}"
  },
  {
    "function_name": "channel_free_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "642-650",
    "snippet": "void\nchannel_free_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_free(ssh, ssh->chanctxt->channels[i]);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_free",
          "args": [
            "ssh",
            "ssh->chanctxt->channels[i]"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "channel_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "582-640",
          "snippet": "void\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_free_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_free(ssh, ssh->chanctxt->channels[i]);\n}"
  },
  {
    "function_name": "channel_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "582-640",
    "snippet": "void\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "c"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4195-4206",
          "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "c",
            "sizeof(*c)"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->filter_cleanup",
          "args": [
            "ssh",
            "c->self",
            "c->filter_ctx"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&c->status_confirms",
            "cc",
            "entry"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cc->abandon_cb",
          "args": [
            "ssh",
            "c",
            "cc->ctx"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&c->status_confirms"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "c->extended"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_close_fds",
          "args": [
            "ssh",
            "c"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "channel_close_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "441-453",
          "snippet": "static void\nchannel_close_fds(struct ssh *ssh, Channel *c)\n{\n\tint sock = c->sock, rfd = c->rfd, wfd = c->wfd, efd = c->efd;\n\n\tchannel_close_fd(ssh, &c->sock);\n\tif (rfd != sock)\n\t\tchannel_close_fd(ssh, &c->rfd);\n\tif (wfd != sock && wfd != rfd)\n\t\tchannel_close_fd(ssh, &c->wfd);\n\tif (efd != sock && efd != rfd && efd != wfd)\n\t\tchannel_close_fd(ssh, &c->efd);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_close_fds(struct ssh *ssh, Channel *c)\n{\n\tint sock = c->sock, rfd = c->rfd, wfd = c->wfd, efd = c->efd;\n\n\tchannel_close_fd(ssh, &c->sock);\n\tif (rfd != sock)\n\t\tchannel_close_fd(ssh, &c->rfd);\n\tif (wfd != sock && wfd != rfd)\n\t\tchannel_close_fd(ssh, &c->wfd);\n\tif (efd != sock && efd != rfd && efd != wfd)\n\t\tchannel_close_fd(ssh, &c->efd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"channel %d: status: %s\"",
            "c->self",
            "s"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_open_message",
          "args": [
            "ssh"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "channel_open_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "842-900",
          "snippet": "char *\nchannel_open_message(struct ssh *ssh)\n{\n\tstruct sshbuf *buf;\n\tChannel *c;\n\tu_int i;\n\tint r;\n\tchar *cp, *ret;\n\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_putf(buf,\n\t    \"The following connections are open:\\r\\n\")) != 0)\n\t\tfatal(\"%s: sshbuf_putf: %s\", __func__, ssh_err(r));\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\t\tcp = channel_format_status(c);\n\t\t\tif ((r = sshbuf_putf(buf, \"  #%d %.300s (%s)\\r\\n\",\n\t\t\t    c->self, c->remote_name, cp)) != 0) {\n\t\t\t\tfree(cp);\n\t\t\t\tfatal(\"%s: sshbuf_putf: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tfatal(\"%s: bad channel type %d\", __func__, c->type);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\tif ((ret = sshbuf_dup_string(buf)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string\", __func__);\n\tsshbuf_free(buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nchar *\nchannel_open_message(struct ssh *ssh)\n{\n\tstruct sshbuf *buf;\n\tChannel *c;\n\tu_int i;\n\tint r;\n\tchar *cp, *ret;\n\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\tif ((r = sshbuf_putf(buf,\n\t    \"The following connections are open:\\r\\n\")) != 0)\n\t\tfatal(\"%s: sshbuf_putf: %s\", __func__, ssh_err(r));\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\t\tcp = channel_format_status(c);\n\t\t\tif ((r = sshbuf_putf(buf, \"  #%d %.300s (%s)\\r\\n\",\n\t\t\t    c->self, c->remote_name, cp)) != 0) {\n\t\t\t\tfree(cp);\n\t\t\t\tfatal(\"%s: sshbuf_putf: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tfatal(\"%s: bad channel type %d\", __func__, c->type);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\tif ((ret = sshbuf_dup_string(buf)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string\", __func__);\n\tsshbuf_free(buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_level_get",
          "args": [],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "log_level_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "108-112",
          "snippet": "LogLevel\nlog_level_get(void)\n{\n\treturn log_level;\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LogLevel log_level = SYSLOG_LEVEL_INFO;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic LogLevel log_level = SYSLOG_LEVEL_INFO;\n\nLogLevel\nlog_level_get(void)\n{\n\treturn log_level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mux_remove_remote_forwardings",
          "args": [
            "ssh",
            "c"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "mux_remove_remote_forwardings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "549-579",
          "snippet": "static void\nmux_remove_remote_forwardings(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tstruct permission *perm;\n\tint r;\n\tu_int i;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (perm->downstream != c)\n\t\t\tcontinue;\n\n\t\t/* cancel on the server, since mux client is gone */\n\t\tdebug(\"channel %d: cleanup remote forward for %s:%u\",\n\t\t    c->self, perm->listen_host, perm->listen_port);\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"cancel-tcpip-forward\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    channel_rfwd_bind_host(perm->listen_host))) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, perm->listen_port)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\tfatal(\"%s: channel %i: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\tfwd_perm_clear(perm); /* unregister */\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic void\nmux_remove_remote_forwardings(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tstruct permission *perm;\n\tint r;\n\tu_int i;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (perm->downstream != c)\n\t\t\tcontinue;\n\n\t\t/* cancel on the server, since mux client is gone */\n\t\tdebug(\"channel %d: cleanup remote forward for %s:%u\",\n\t\t    c->self, perm->listen_host, perm->listen_port);\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"cancel-tcpip-forward\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    channel_rfwd_bind_host(perm->listen_host))) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, perm->listen_port)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\tfatal(\"%s: channel %i: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\tfwd_perm_clear(perm); /* unregister */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t/* detach from mux client and prepare for closing */\n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT)\n\t\tmux_remove_remote_forwardings(ssh, c);\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\texplicit_bzero(cc, sizeof(*cc));\n\t\tfree(cc);\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\texplicit_bzero(c, sizeof(*c));\n\tfree(c);\n}"
  },
  {
    "function_name": "mux_remove_remote_forwardings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "549-579",
    "snippet": "static void\nmux_remove_remote_forwardings(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tstruct permission *perm;\n\tint r;\n\tu_int i;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (perm->downstream != c)\n\t\t\tcontinue;\n\n\t\t/* cancel on the server, since mux client is gone */\n\t\tdebug(\"channel %d: cleanup remote forward for %s:%u\",\n\t\t    c->self, perm->listen_host, perm->listen_port);\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"cancel-tcpip-forward\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    channel_rfwd_bind_host(perm->listen_host))) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, perm->listen_port)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\tfatal(\"%s: channel %i: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\tfwd_perm_clear(perm); /* unregister */\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *channel_rfwd_bind_host(const char *listen_host);",
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fwd_perm_clear",
          "args": [
            "perm"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "fwd_perm_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "455-462",
          "snippet": "static void\nfwd_perm_clear(struct permission *perm)\n{\n\tfree(perm->host_to_connect);\n\tfree(perm->listen_host);\n\tfree(perm->listen_path);\n\tbzero(perm, sizeof(*perm));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\n\nstatic void\nfwd_perm_clear(struct permission *perm)\n{\n\tfree(perm->host_to_connect);\n\tfree(perm->listen_host);\n\tfree(perm->listen_path);\n\tbzero(perm, sizeof(*perm));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: channel %i: %s\"",
            "__func__",
            "c->self",
            "ssh_err(r)"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "perm->listen_port"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "channel_rfwd_bind_host(perm->listen_host)"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_rfwd_bind_host",
          "args": [
            "perm->listen_host"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "channel_rfwd_bind_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3813-3822",
          "snippet": "static const char *\nchannel_rfwd_bind_host(const char *listen_host)\n{\n\tif (listen_host == NULL) {\n\t\treturn \"localhost\";\n\t} else if (*listen_host == '\\0' || strcmp(listen_host, \"*\") == 0) {\n\t\treturn \"\";\n\t} else\n\t\treturn listen_host;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\n\nstatic const char *\nchannel_rfwd_bind_host(const char *listen_host)\n{\n\tif (listen_host == NULL) {\n\t\treturn \"localhost\";\n\t} else if (*listen_host == '\\0' || strcmp(listen_host, \"*\") == 0) {\n\t\treturn \"\";\n\t} else\n\t\treturn listen_host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u8",
          "args": [
            "ssh",
            "0"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2435-2439",
          "snippet": "int\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_GLOBAL_REQUEST"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"channel %d: cleanup remote forward for %s:%u\"",
            "c->self",
            "perm->listen_host",
            "perm->listen_port"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic void\nmux_remove_remote_forwardings(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tstruct permission *perm;\n\tint r;\n\tu_int i;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (perm->downstream != c)\n\t\t\tcontinue;\n\n\t\t/* cancel on the server, since mux client is gone */\n\t\tdebug(\"channel %d: cleanup remote forward for %s:%u\",\n\t\t    c->self, perm->listen_host, perm->listen_port);\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"cancel-tcpip-forward\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    channel_rfwd_bind_host(perm->listen_host))) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, perm->listen_port)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\tfatal(\"%s: channel %i: %s\", __func__,\n\t\t\t    c->self, ssh_err(r));\n\t\t}\n\t\tfwd_perm_clear(perm); /* unregister */\n\t}\n}"
  },
  {
    "function_name": "permission_set_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "522-547",
    "snippet": "static int\npermission_set_add(struct ssh *ssh, int who, int where,\n    const char *host_to_connect, int port_to_connect,\n    const char *listen_host, const char *listen_path, int listen_port,\n    Channel *downstream)\n{\n\tstruct permission **permp;\n\tu_int n, *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\n\tif (*npermp >= INT_MAX)\n\t\tfatal(\"%s: %s overflow\", __func__, fwd_ident(who, where));\n\n\t*permp = xrecallocarray(*permp, *npermp, *npermp + 1, sizeof(**permp));\n\tn = (*npermp)++;\n#define MAYBE_DUP(s) ((s == NULL) ? NULL : xstrdup(s))\n\t(*permp)[n].host_to_connect = MAYBE_DUP(host_to_connect);\n\t(*permp)[n].port_to_connect = port_to_connect;\n\t(*permp)[n].listen_host = MAYBE_DUP(listen_host);\n\t(*permp)[n].listen_path = MAYBE_DUP(listen_path);\n\t(*permp)[n].listen_port = listen_port;\n\t(*permp)[n].downstream = downstream;\n#undef MAYBE_DUP\n\treturn (int)n;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *channel_rfwd_bind_host(const char *listen_host);",
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MAYBE_DUP",
          "args": [
            "listen_path"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAYBE_DUP",
          "args": [
            "listen_host"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAYBE_DUP",
          "args": [
            "host_to_connect"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xrecallocarray",
          "args": [
            "*permp",
            "*npermp",
            "*npermp + 1",
            "sizeof(**permp)"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s overflow\"",
            "__func__",
            "fwd_ident(who, where)"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fwd_ident",
          "args": [
            "who",
            "where"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "fwd_ident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "465-480",
          "snippet": "static const char *\nfwd_ident(int who, int where)\n{\n\tif (who == FORWARD_ADM) {\n\t\tif (where == FORWARD_LOCAL)\n\t\t\treturn \"admin local\";\n\t\telse if (where == FORWARD_REMOTE)\n\t\t\treturn \"admin remote\";\n\t} else if (who == FORWARD_USER) {\n\t\tif (where == FORWARD_LOCAL)\n\t\t\treturn \"user local\";\n\t\telse if (where == FORWARD_REMOTE)\n\t\t\treturn \"user remote\";\n\t}\n\tfatal(\"Unknown forward permission list %d/%d\", who, where);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfwd_ident(int who, int where)\n{\n\tif (who == FORWARD_ADM) {\n\t\tif (where == FORWARD_LOCAL)\n\t\t\treturn \"admin local\";\n\t\telse if (where == FORWARD_REMOTE)\n\t\t\treturn \"admin remote\";\n\t} else if (who == FORWARD_USER) {\n\t\tif (where == FORWARD_LOCAL)\n\t\t\treturn \"user local\";\n\t\telse if (where == FORWARD_REMOTE)\n\t\t\treturn \"user remote\";\n\t}\n\tfatal(\"Unknown forward permission list %d/%d\", who, where);\n}"
        }
      },
      {
        "call_info": {
          "callee": "permission_set_get_array",
          "args": [
            "ssh",
            "who",
            "where",
            "&permp",
            "&npermp"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "permission_set_get_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "501-519",
          "snippet": "static void\npermission_set_get_array(struct ssh *ssh, int who, int where,\n    struct permission ***permpp, u_int **npermpp)\n{\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tswitch (who) {\n\tcase FORWARD_USER:\n\t\t*permpp = &pset->permitted_user;\n\t\t*npermpp = &pset->num_permitted_user;\n\t\tbreak;\n\tcase FORWARD_ADM:\n\t\t*permpp = &pset->permitted_admin;\n\t\t*npermpp = &pset->num_permitted_admin;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: invalid forwarding client %d\", __func__, who);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nstatic void\npermission_set_get_array(struct ssh *ssh, int who, int where,\n    struct permission ***permpp, u_int **npermpp)\n{\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tswitch (who) {\n\tcase FORWARD_USER:\n\t\t*permpp = &pset->permitted_user;\n\t\t*npermpp = &pset->num_permitted_user;\n\t\tbreak;\n\tcase FORWARD_ADM:\n\t\t*permpp = &pset->permitted_admin;\n\t\t*npermpp = &pset->num_permitted_admin;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: invalid forwarding client %d\", __func__, who);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic int\npermission_set_add(struct ssh *ssh, int who, int where,\n    const char *host_to_connect, int port_to_connect,\n    const char *listen_host, const char *listen_path, int listen_port,\n    Channel *downstream)\n{\n\tstruct permission **permp;\n\tu_int n, *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\n\tif (*npermp >= INT_MAX)\n\t\tfatal(\"%s: %s overflow\", __func__, fwd_ident(who, where));\n\n\t*permp = xrecallocarray(*permp, *npermp, *npermp + 1, sizeof(**permp));\n\tn = (*npermp)++;\n#define MAYBE_DUP(s) ((s == NULL) ? NULL : xstrdup(s))\n\t(*permp)[n].host_to_connect = MAYBE_DUP(host_to_connect);\n\t(*permp)[n].port_to_connect = port_to_connect;\n\t(*permp)[n].listen_host = MAYBE_DUP(listen_host);\n\t(*permp)[n].listen_path = MAYBE_DUP(listen_path);\n\t(*permp)[n].listen_port = listen_port;\n\t(*permp)[n].downstream = downstream;\n#undef MAYBE_DUP\n\treturn (int)n;\n}"
  },
  {
    "function_name": "permission_set_get_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "501-519",
    "snippet": "static void\npermission_set_get_array(struct ssh *ssh, int who, int where,\n    struct permission ***permpp, u_int **npermpp)\n{\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tswitch (who) {\n\tcase FORWARD_USER:\n\t\t*permpp = &pset->permitted_user;\n\t\t*npermpp = &pset->num_permitted_user;\n\t\tbreak;\n\tcase FORWARD_ADM:\n\t\t*permpp = &pset->permitted_admin;\n\t\t*npermpp = &pset->num_permitted_admin;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: invalid forwarding client %d\", __func__, who);\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: invalid forwarding client %d\"",
            "__func__",
            "who"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "permission_set_get",
          "args": [
            "ssh",
            "where"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "permission_set_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "483-498",
          "snippet": "static struct permission_set *\npermission_set_get(struct ssh *ssh, int where)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\tswitch (where) {\n\tcase FORWARD_LOCAL:\n\t\treturn &sc->local_perms;\n\t\tbreak;\n\tcase FORWARD_REMOTE:\n\t\treturn &sc->remote_perms;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: invalid forwarding direction %d\", __func__, where);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic struct permission_set *\npermission_set_get(struct ssh *ssh, int where)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\tswitch (where) {\n\tcase FORWARD_LOCAL:\n\t\treturn &sc->local_perms;\n\t\tbreak;\n\tcase FORWARD_REMOTE:\n\t\treturn &sc->remote_perms;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: invalid forwarding direction %d\", __func__, where);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nstatic void\npermission_set_get_array(struct ssh *ssh, int who, int where,\n    struct permission ***permpp, u_int **npermpp)\n{\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tswitch (who) {\n\tcase FORWARD_USER:\n\t\t*permpp = &pset->permitted_user;\n\t\t*npermpp = &pset->num_permitted_user;\n\t\tbreak;\n\tcase FORWARD_ADM:\n\t\t*permpp = &pset->permitted_admin;\n\t\t*npermpp = &pset->num_permitted_admin;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: invalid forwarding client %d\", __func__, who);\n\t}\n}"
  },
  {
    "function_name": "permission_set_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "483-498",
    "snippet": "static struct permission_set *\npermission_set_get(struct ssh *ssh, int where)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\tswitch (where) {\n\tcase FORWARD_LOCAL:\n\t\treturn &sc->local_perms;\n\t\tbreak;\n\tcase FORWARD_REMOTE:\n\t\treturn &sc->remote_perms;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: invalid forwarding direction %d\", __func__, where);\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: invalid forwarding direction %d\"",
            "__func__",
            "where"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic struct permission_set *\npermission_set_get(struct ssh *ssh, int where)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\tswitch (where) {\n\tcase FORWARD_LOCAL:\n\t\treturn &sc->local_perms;\n\t\tbreak;\n\tcase FORWARD_REMOTE:\n\t\treturn &sc->remote_perms;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: invalid forwarding direction %d\", __func__, where);\n\t}\n}"
  },
  {
    "function_name": "fwd_ident",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "465-480",
    "snippet": "static const char *\nfwd_ident(int who, int where)\n{\n\tif (who == FORWARD_ADM) {\n\t\tif (where == FORWARD_LOCAL)\n\t\t\treturn \"admin local\";\n\t\telse if (where == FORWARD_REMOTE)\n\t\t\treturn \"admin remote\";\n\t} else if (who == FORWARD_USER) {\n\t\tif (where == FORWARD_LOCAL)\n\t\t\treturn \"user local\";\n\t\telse if (where == FORWARD_REMOTE)\n\t\t\treturn \"user remote\";\n\t}\n\tfatal(\"Unknown forward permission list %d/%d\", who, where);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Unknown forward permission list %d/%d\"",
            "who",
            "where"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfwd_ident(int who, int where)\n{\n\tif (who == FORWARD_ADM) {\n\t\tif (where == FORWARD_LOCAL)\n\t\t\treturn \"admin local\";\n\t\telse if (where == FORWARD_REMOTE)\n\t\t\treturn \"admin remote\";\n\t} else if (who == FORWARD_USER) {\n\t\tif (where == FORWARD_LOCAL)\n\t\t\treturn \"user local\";\n\t\telse if (where == FORWARD_REMOTE)\n\t\t\treturn \"user remote\";\n\t}\n\tfatal(\"Unknown forward permission list %d/%d\", who, where);\n}"
  },
  {
    "function_name": "fwd_perm_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "455-462",
    "snippet": "static void\nfwd_perm_clear(struct permission *perm)\n{\n\tfree(perm->host_to_connect);\n\tfree(perm->listen_host);\n\tfree(perm->listen_path);\n\tbzero(perm, sizeof(*perm));\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *channel_rfwd_bind_host(const char *listen_host);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "perm",
            "sizeof(*perm)"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "288-292",
          "snippet": "void\nbzero(void *b, size_t n)\n{\n\t(void)memset(b, 0, n);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nbzero(void *b, size_t n)\n{\n\t(void)memset(b, 0, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "perm->listen_path"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "channel_connect_ctx_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4195-4206",
          "snippet": "static void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int connect_next(struct channel_connect *);",
            "static void channel_connect_ctx_free(struct channel_connect *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\n\nstatic void\nfwd_perm_clear(struct permission *perm)\n{\n\tfree(perm->host_to_connect);\n\tfree(perm->listen_host);\n\tfree(perm->listen_path);\n\tbzero(perm, sizeof(*perm));\n}"
  },
  {
    "function_name": "channel_close_fds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "441-453",
    "snippet": "static void\nchannel_close_fds(struct ssh *ssh, Channel *c)\n{\n\tint sock = c->sock, rfd = c->rfd, wfd = c->wfd, efd = c->efd;\n\n\tchannel_close_fd(ssh, &c->sock);\n\tif (rfd != sock)\n\t\tchannel_close_fd(ssh, &c->rfd);\n\tif (wfd != sock && wfd != rfd)\n\t\tchannel_close_fd(ssh, &c->wfd);\n\tif (efd != sock && efd != rfd && efd != wfd)\n\t\tchannel_close_fd(ssh, &c->efd);\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_close_fd",
          "args": [
            "ssh",
            "&c->efd"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "channel_close_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "441-453",
          "snippet": "static void\nchannel_close_fds(struct ssh *ssh, Channel *c)\n{\n\tint sock = c->sock, rfd = c->rfd, wfd = c->wfd, efd = c->efd;\n\n\tchannel_close_fd(ssh, &c->sock);\n\tif (rfd != sock)\n\t\tchannel_close_fd(ssh, &c->rfd);\n\tif (wfd != sock && wfd != rfd)\n\t\tchannel_close_fd(ssh, &c->wfd);\n\tif (efd != sock && efd != rfd && efd != wfd)\n\t\tchannel_close_fd(ssh, &c->efd);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nstatic void\nchannel_close_fds(struct ssh *ssh, Channel *c)\n{\n\tint sock = c->sock, rfd = c->rfd, wfd = c->wfd, efd = c->efd;\n\n\tchannel_close_fd(ssh, &c->sock);\n\tif (rfd != sock)\n\t\tchannel_close_fd(ssh, &c->rfd);\n\tif (wfd != sock && wfd != rfd)\n\t\tchannel_close_fd(ssh, &c->wfd);\n\tif (efd != sock && efd != rfd && efd != wfd)\n\t\tchannel_close_fd(ssh, &c->efd);\n}"
  },
  {
    "function_name": "channel_close_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "425-438",
    "snippet": "int\nchannel_close_fd(struct ssh *ssh, int *fdp)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tint ret = 0, fd = *fdp;\n\n\tif (fd != -1) {\n\t\tret = close(fd);\n\t\t*fdp = -1;\n\t\tif (fd == sc->channel_max_fd)\n\t\t\tchannel_find_maxfd(sc);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_find_maxfd",
          "args": [
            "sc"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "channel_find_maxfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "407-423",
          "snippet": "static void\nchannel_find_maxfd(struct ssh_channels *sc)\n{\n\tu_int i;\n\tint max = 0;\n\tChannel *c;\n\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c != NULL) {\n\t\t\tmax = MAXIMUM(max, c->rfd);\n\t\t\tmax = MAXIMUM(max, c->wfd);\n\t\t\tmax = MAXIMUM(max, c->efd);\n\t\t}\n\t}\n\tsc->channel_max_fd = max;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic void\nchannel_find_maxfd(struct ssh_channels *sc)\n{\n\tu_int i;\n\tint max = 0;\n\tChannel *c;\n\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c != NULL) {\n\t\t\tmax = MAXIMUM(max, c->rfd);\n\t\t\tmax = MAXIMUM(max, c->wfd);\n\t\t\tmax = MAXIMUM(max, c->efd);\n\t\t}\n\t}\n\tsc->channel_max_fd = max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "channel_close_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "656-664",
          "snippet": "void\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nint\nchannel_close_fd(struct ssh *ssh, int *fdp)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tint ret = 0, fd = *fdp;\n\n\tif (fd != -1) {\n\t\tret = close(fd);\n\t\t*fdp = -1;\n\t\tif (fd == sc->channel_max_fd)\n\t\t\tchannel_find_maxfd(sc);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "channel_find_maxfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "407-423",
    "snippet": "static void\nchannel_find_maxfd(struct ssh_channels *sc)\n{\n\tu_int i;\n\tint max = 0;\n\tChannel *c;\n\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c != NULL) {\n\t\t\tmax = MAXIMUM(max, c->rfd);\n\t\t\tmax = MAXIMUM(max, c->wfd);\n\t\t\tmax = MAXIMUM(max, c->efd);\n\t\t}\n\t}\n\tsc->channel_max_fd = max;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int rdynamic_connect_finish(struct ssh *, Channel *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "max",
            "c->efd"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "max",
            "c->wfd"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "max",
            "c->rfd"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic void\nchannel_find_maxfd(struct ssh_channels *sc)\n{\n\tu_int i;\n\tint max = 0;\n\tChannel *c;\n\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c != NULL) {\n\t\t\tmax = MAXIMUM(max, c->rfd);\n\t\t\tmax = MAXIMUM(max, c->wfd);\n\t\t\tmax = MAXIMUM(max, c->efd);\n\t\t}\n\t}\n\tsc->channel_max_fd = max;\n}"
  },
  {
    "function_name": "channel_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "354-405",
    "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"channel %d: new [%s]\"",
            "found",
            "remote_name"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&c->status_confirms"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "remote_name"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_register_fds",
          "args": [
            "ssh",
            "c",
            "rfd",
            "wfd",
            "efd",
            "extusage",
            "nonblock",
            "0"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "308-348",
          "snippet": "static void\nchannel_register_fds(struct ssh *ssh, Channel *c, int rfd, int wfd, int efd,\n    int extusage, int nonblock, int is_tty)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\t/* Update the maximum file descriptor value. */\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, rfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, wfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, efd);\n\n\tif (rfd != -1)\n\t\tfcntl(rfd, F_SETFD, FD_CLOEXEC);\n\tif (wfd != -1 && wfd != rfd)\n\t\tfcntl(wfd, F_SETFD, FD_CLOEXEC);\n\tif (efd != -1 && efd != rfd && efd != wfd)\n\t\tfcntl(efd, F_SETFD, FD_CLOEXEC);\n\n\tc->rfd = rfd;\n\tc->wfd = wfd;\n\tc->sock = (rfd == wfd) ? rfd : -1;\n\tc->efd = efd;\n\tc->extended_usage = extusage;\n\n\tif ((c->isatty = is_tty) != 0)\n\t\tdebug2(\"channel %d: rfd %d isatty\", c->self, c->rfd);\n#ifdef _AIX\n\t/* XXX: Later AIX versions can't push as much data to tty */\n\tc->wfd_isatty = is_tty || isatty(c->wfd);\n#endif\n\n\t/* enable nonblocking mode */\n\tif (nonblock) {\n\t\tif (rfd != -1)\n\t\t\tset_nonblock(rfd);\n\t\tif (wfd != -1)\n\t\t\tset_nonblock(wfd);\n\t\tif (efd != -1)\n\t\t\tset_nonblock(efd);\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic void\nchannel_register_fds(struct ssh *ssh, Channel *c, int rfd, int wfd, int efd,\n    int extusage, int nonblock, int is_tty)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\t/* Update the maximum file descriptor value. */\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, rfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, wfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, efd);\n\n\tif (rfd != -1)\n\t\tfcntl(rfd, F_SETFD, FD_CLOEXEC);\n\tif (wfd != -1 && wfd != rfd)\n\t\tfcntl(wfd, F_SETFD, FD_CLOEXEC);\n\tif (efd != -1 && efd != rfd && efd != wfd)\n\t\tfcntl(efd, F_SETFD, FD_CLOEXEC);\n\n\tc->rfd = rfd;\n\tc->wfd = wfd;\n\tc->sock = (rfd == wfd) ? rfd : -1;\n\tc->efd = efd;\n\tc->extended_usage = extusage;\n\n\tif ((c->isatty = is_tty) != 0)\n\t\tdebug2(\"channel %d: rfd %d isatty\", c->self, c->rfd);\n#ifdef _AIX\n\t/* XXX: Later AIX versions can't push as much data to tty */\n\tc->wfd_isatty = is_tty || isatty(c->wfd);\n#endif\n\n\t/* enable nonblocking mode */\n\tif (nonblock) {\n\t\tif (rfd != -1)\n\t\t\tset_nonblock(rfd);\n\t\tif (wfd != -1)\n\t\t\tset_nonblock(wfd);\n\t\tif (efd != -1)\n\t\t\tset_nonblock(efd);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(Channel)"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel: expanding %d\"",
            "sc->channels_alloc"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xrecallocarray",
          "args": [
            "sc->channels",
            "sc->channels_alloc",
            "sc->channels_alloc + 10",
            "sizeof(*sc->channels)"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: internal error: channels_alloc %d too big\"",
            "__func__",
            "sc->channels_alloc"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
  },
  {
    "function_name": "channel_register_fds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "308-348",
    "snippet": "static void\nchannel_register_fds(struct ssh *ssh, Channel *c, int rfd, int wfd, int efd,\n    int extusage, int nonblock, int is_tty)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\t/* Update the maximum file descriptor value. */\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, rfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, wfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, efd);\n\n\tif (rfd != -1)\n\t\tfcntl(rfd, F_SETFD, FD_CLOEXEC);\n\tif (wfd != -1 && wfd != rfd)\n\t\tfcntl(wfd, F_SETFD, FD_CLOEXEC);\n\tif (efd != -1 && efd != rfd && efd != wfd)\n\t\tfcntl(efd, F_SETFD, FD_CLOEXEC);\n\n\tc->rfd = rfd;\n\tc->wfd = wfd;\n\tc->sock = (rfd == wfd) ? rfd : -1;\n\tc->efd = efd;\n\tc->extended_usage = extusage;\n\n\tif ((c->isatty = is_tty) != 0)\n\t\tdebug2(\"channel %d: rfd %d isatty\", c->self, c->rfd);\n#ifdef _AIX\n\t/* XXX: Later AIX versions can't push as much data to tty */\n\tc->wfd_isatty = is_tty || isatty(c->wfd);\n#endif\n\n\t/* enable nonblocking mode */\n\tif (nonblock) {\n\t\tif (rfd != -1)\n\t\t\tset_nonblock(rfd);\n\t\tif (wfd != -1)\n\t\t\tset_nonblock(wfd);\n\t\tif (efd != -1)\n\t\t\tset_nonblock(efd);\n\t}\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_nonblock",
          "args": [
            "efd"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "unset_nonblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "116-138",
          "snippet": "int\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "c->wfd"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"channel %d: rfd %d isatty\"",
            "c->self",
            "c->rfd"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "efd",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "wfd",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "rfd",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "sc->channel_max_fd",
            "efd"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "sc->channel_max_fd",
            "wfd"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "sc->channel_max_fd",
            "rfd"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic void\nchannel_register_fds(struct ssh *ssh, Channel *c, int rfd, int wfd, int efd,\n    int extusage, int nonblock, int is_tty)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\t/* Update the maximum file descriptor value. */\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, rfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, wfd);\n\tsc->channel_max_fd = MAXIMUM(sc->channel_max_fd, efd);\n\n\tif (rfd != -1)\n\t\tfcntl(rfd, F_SETFD, FD_CLOEXEC);\n\tif (wfd != -1 && wfd != rfd)\n\t\tfcntl(wfd, F_SETFD, FD_CLOEXEC);\n\tif (efd != -1 && efd != rfd && efd != wfd)\n\t\tfcntl(efd, F_SETFD, FD_CLOEXEC);\n\n\tc->rfd = rfd;\n\tc->wfd = wfd;\n\tc->sock = (rfd == wfd) ? rfd : -1;\n\tc->efd = efd;\n\tc->extended_usage = extusage;\n\n\tif ((c->isatty = is_tty) != 0)\n\t\tdebug2(\"channel %d: rfd %d isatty\", c->self, c->rfd);\n#ifdef _AIX\n\t/* XXX: Later AIX versions can't push as much data to tty */\n\tc->wfd_isatty = is_tty || isatty(c->wfd);\n#endif\n\n\t/* enable nonblocking mode */\n\tif (nonblock) {\n\t\tif (rfd != -1)\n\t\t\tset_nonblock(rfd);\n\t\tif (wfd != -1)\n\t\t\tset_nonblock(wfd);\n\t\tif (efd != -1)\n\t\t\tset_nonblock(efd);\n\t}\n}"
  },
  {
    "function_name": "channel_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "279-302",
    "snippet": "Channel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Non-public channel %d, type %d.\"",
            "id",
            "c->type"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_by_id",
          "args": [
            "ssh",
            "id"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "channel_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "244-259",
          "snippet": "Channel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}"
  },
  {
    "function_name": "channel_by_remote_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "261-273",
    "snippet": "Channel *\nchannel_by_remote_id(struct ssh *ssh, u_int remote_id)\n{\n\tChannel *c;\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c != NULL && c->have_remote_id && c->remote_id == remote_id)\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_by_remote_id(struct ssh *ssh, u_int remote_id)\n{\n\tChannel *c;\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c != NULL && c->have_remote_id && c->remote_id == remote_id)\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "channel_by_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "244-259",
    "snippet": "Channel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static int rdynamic_connect_finish(struct ssh *, Channel *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s: %d: bad id: channel free\"",
            "__func__",
            "id"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}"
  },
  {
    "function_name": "channel_init_channels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
    "lines": "225-242",
    "snippet": "void\nchannel_init_channels(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc;\n\n\tif ((sc = calloc(1, sizeof(*sc))) == NULL ||\n\t    (sc->channel_pre = calloc(SSH_CHANNEL_MAX_TYPE,\n\t    sizeof(*sc->channel_pre))) == NULL ||\n\t    (sc->channel_post = calloc(SSH_CHANNEL_MAX_TYPE,\n\t    sizeof(*sc->channel_post))) == NULL)\n\t\tfatal(\"%s: allocation failed\", __func__);\n\tsc->channels_alloc = 10;\n\tsc->channels = xcalloc(sc->channels_alloc, sizeof(*sc->channels));\n\tsc->IPv4or6 = AF_UNSPEC;\n\tchannel_handler_init(sc);\n\n\tssh->chanctxt = sc;\n}",
    "includes": [
      "#include \"match.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"compat.h\"",
      "#include \"channels.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/un.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
      "static void channel_handler_init(struct ssh_channels *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_handler_init",
          "args": [
            "sc"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "channel_handler_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "2339-2377",
          "snippet": "static void\nchannel_handler_init(struct ssh_channels *sc)\n{\n\tchan_fn **pre, **post;\n\n\tif ((pre = calloc(SSH_CHANNEL_MAX_TYPE, sizeof(*pre))) == NULL ||\n\t   (post = calloc(SSH_CHANNEL_MAX_TYPE, sizeof(*post))) == NULL)\n\t\tfatal(\"%s: allocation failed\", __func__);\n\n\tpre[SSH_CHANNEL_OPEN] =\t\t\t&channel_pre_open;\n\tpre[SSH_CHANNEL_X11_OPEN] =\t\t&channel_pre_x11_open;\n\tpre[SSH_CHANNEL_PORT_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_RPORT_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_UNIX_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_RUNIX_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_X11_LISTENER] =\t\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_AUTH_SOCKET] =\t\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_CONNECTING] =\t\t&channel_pre_connecting;\n\tpre[SSH_CHANNEL_DYNAMIC] =\t\t&channel_pre_dynamic;\n\tpre[SSH_CHANNEL_RDYNAMIC_FINISH] =\t&channel_pre_connecting;\n\tpre[SSH_CHANNEL_MUX_LISTENER] =\t\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_MUX_CLIENT] =\t\t&channel_pre_mux_client;\n\n\tpost[SSH_CHANNEL_OPEN] =\t\t&channel_post_open;\n\tpost[SSH_CHANNEL_PORT_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_RPORT_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_UNIX_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_RUNIX_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_X11_LISTENER] =\t&channel_post_x11_listener;\n\tpost[SSH_CHANNEL_AUTH_SOCKET] =\t\t&channel_post_auth_listener;\n\tpost[SSH_CHANNEL_CONNECTING] =\t\t&channel_post_connecting;\n\tpost[SSH_CHANNEL_DYNAMIC] =\t\t&channel_post_open;\n\tpost[SSH_CHANNEL_RDYNAMIC_FINISH] =\t&channel_post_connecting;\n\tpost[SSH_CHANNEL_MUX_LISTENER] =\t&channel_post_mux_listener;\n\tpost[SSH_CHANNEL_MUX_CLIENT] =\t\t&channel_post_mux_client;\n\n\tsc->channel_pre = pre;\n\tsc->channel_post = post;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nstatic void\nchannel_handler_init(struct ssh_channels *sc)\n{\n\tchan_fn **pre, **post;\n\n\tif ((pre = calloc(SSH_CHANNEL_MAX_TYPE, sizeof(*pre))) == NULL ||\n\t   (post = calloc(SSH_CHANNEL_MAX_TYPE, sizeof(*post))) == NULL)\n\t\tfatal(\"%s: allocation failed\", __func__);\n\n\tpre[SSH_CHANNEL_OPEN] =\t\t\t&channel_pre_open;\n\tpre[SSH_CHANNEL_X11_OPEN] =\t\t&channel_pre_x11_open;\n\tpre[SSH_CHANNEL_PORT_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_RPORT_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_UNIX_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_RUNIX_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_X11_LISTENER] =\t\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_AUTH_SOCKET] =\t\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_CONNECTING] =\t\t&channel_pre_connecting;\n\tpre[SSH_CHANNEL_DYNAMIC] =\t\t&channel_pre_dynamic;\n\tpre[SSH_CHANNEL_RDYNAMIC_FINISH] =\t&channel_pre_connecting;\n\tpre[SSH_CHANNEL_MUX_LISTENER] =\t\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_MUX_CLIENT] =\t\t&channel_pre_mux_client;\n\n\tpost[SSH_CHANNEL_OPEN] =\t\t&channel_post_open;\n\tpost[SSH_CHANNEL_PORT_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_RPORT_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_UNIX_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_RUNIX_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_X11_LISTENER] =\t&channel_post_x11_listener;\n\tpost[SSH_CHANNEL_AUTH_SOCKET] =\t\t&channel_post_auth_listener;\n\tpost[SSH_CHANNEL_CONNECTING] =\t\t&channel_post_connecting;\n\tpost[SSH_CHANNEL_DYNAMIC] =\t\t&channel_post_open;\n\tpost[SSH_CHANNEL_RDYNAMIC_FINISH] =\t&channel_post_connecting;\n\tpost[SSH_CHANNEL_MUX_LISTENER] =\t&channel_post_mux_listener;\n\tpost[SSH_CHANNEL_MUX_CLIENT] =\t\t&channel_post_mux_client;\n\n\tsc->channel_pre = pre;\n\tsc->channel_post = post;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "sc->channels_alloc",
            "sizeof(*sc->channels)"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: allocation failed\"",
            "__func__"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nvoid\nchannel_init_channels(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc;\n\n\tif ((sc = calloc(1, sizeof(*sc))) == NULL ||\n\t    (sc->channel_pre = calloc(SSH_CHANNEL_MAX_TYPE,\n\t    sizeof(*sc->channel_pre))) == NULL ||\n\t    (sc->channel_post = calloc(SSH_CHANNEL_MAX_TYPE,\n\t    sizeof(*sc->channel_post))) == NULL)\n\t\tfatal(\"%s: allocation failed\", __func__);\n\tsc->channels_alloc = 10;\n\tsc->channels = xcalloc(sc->channels_alloc, sizeof(*sc->channels));\n\tsc->IPv4or6 = AF_UNSPEC;\n\tchannel_handler_init(sc);\n\n\tssh->chanctxt = sc;\n}"
  }
]