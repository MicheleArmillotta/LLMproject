[
  {
    "function_name": "dump_client_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "2568-2757",
    "snippet": "void\ndump_client_config(Options *o, const char *host)\n{\n\tint i;\n\tchar buf[8], *all_key;\n\n\t/* This is normally prepared in ssh_kex2 */\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tif (kex_assemble_names( &o->hostkeyalgorithms,\n\t    KEX_DEFAULT_PK_ALG, all_key) != 0)\n\t\tfatal(\"%s: kex_assemble_names failed\", __func__);\n\tfree(all_key);\n\n\t/* Most interesting options first: user, host, port */\n\tdump_cfg_string(oUser, o->user);\n\tdump_cfg_string(oHostName, host);\n\tdump_cfg_int(oPort, o->port);\n\n\t/* Flag options */\n\tdump_cfg_fmtint(oAddKeysToAgent, o->add_keys_to_agent);\n\tdump_cfg_fmtint(oAddressFamily, o->address_family);\n\tdump_cfg_fmtint(oBatchMode, o->batch_mode);\n\tdump_cfg_fmtint(oCanonicalizeFallbackLocal, o->canonicalize_fallback_local);\n\tdump_cfg_fmtint(oCanonicalizeHostname, o->canonicalize_hostname);\n\tdump_cfg_fmtint(oChallengeResponseAuthentication, o->challenge_response_authentication);\n\tdump_cfg_fmtint(oCheckHostIP, o->check_host_ip);\n\tdump_cfg_fmtint(oCompression, o->compression);\n\tdump_cfg_fmtint(oControlMaster, o->control_master);\n\tdump_cfg_fmtint(oEnableSSHKeysign, o->enable_ssh_keysign);\n\tdump_cfg_fmtint(oClearAllForwardings, o->clear_forwardings);\n\tdump_cfg_fmtint(oExitOnForwardFailure, o->exit_on_forward_failure);\n\tdump_cfg_fmtint(oFingerprintHash, o->fingerprint_hash);\n\tdump_cfg_fmtint(oForwardAgent, o->forward_agent);\n\tdump_cfg_fmtint(oForwardX11, o->forward_x11);\n\tdump_cfg_fmtint(oForwardX11Trusted, o->forward_x11_trusted);\n\tdump_cfg_fmtint(oGatewayPorts, o->fwd_opts.gateway_ports);\n#ifdef GSSAPI\n\tdump_cfg_fmtint(oGssAuthentication, o->gss_authentication);\n\tdump_cfg_fmtint(oGssDelegateCreds, o->gss_deleg_creds);\n#endif /* GSSAPI */\n\tdump_cfg_fmtint(oHashKnownHosts, o->hash_known_hosts);\n\tdump_cfg_fmtint(oHostbasedAuthentication, o->hostbased_authentication);\n\tdump_cfg_fmtint(oIdentitiesOnly, o->identities_only);\n\tdump_cfg_fmtint(oKbdInteractiveAuthentication, o->kbd_interactive_authentication);\n\tdump_cfg_fmtint(oNoHostAuthenticationForLocalhost, o->no_host_authentication_for_localhost);\n\tdump_cfg_fmtint(oPasswordAuthentication, o->password_authentication);\n\tdump_cfg_fmtint(oPermitLocalCommand, o->permit_local_command);\n\tdump_cfg_fmtint(oProxyUseFdpass, o->proxy_use_fdpass);\n\tdump_cfg_fmtint(oPubkeyAuthentication, o->pubkey_authentication);\n\tdump_cfg_fmtint(oRequestTTY, o->request_tty);\n\tdump_cfg_fmtint(oStreamLocalBindUnlink, o->fwd_opts.streamlocal_bind_unlink);\n\tdump_cfg_fmtint(oStrictHostKeyChecking, o->strict_host_key_checking);\n\tdump_cfg_fmtint(oTCPKeepAlive, o->tcp_keep_alive);\n\tdump_cfg_fmtint(oTunnel, o->tun_open);\n\tdump_cfg_fmtint(oVerifyHostKeyDNS, o->verify_host_key_dns);\n\tdump_cfg_fmtint(oVisualHostKey, o->visual_host_key);\n\tdump_cfg_fmtint(oUpdateHostkeys, o->update_hostkeys);\n\n\t/* Integer options */\n\tdump_cfg_int(oCanonicalizeMaxDots, o->canonicalize_max_dots);\n\tdump_cfg_int(oConnectionAttempts, o->connection_attempts);\n\tdump_cfg_int(oForwardX11Timeout, o->forward_x11_timeout);\n\tdump_cfg_int(oNumberOfPasswordPrompts, o->number_of_password_prompts);\n\tdump_cfg_int(oServerAliveCountMax, o->server_alive_count_max);\n\tdump_cfg_int(oServerAliveInterval, o->server_alive_interval);\n\n\t/* String options */\n\tdump_cfg_string(oBindAddress, o->bind_address);\n\tdump_cfg_string(oBindInterface, o->bind_interface);\n\tdump_cfg_string(oCiphers, o->ciphers ? o->ciphers : KEX_CLIENT_ENCRYPT);\n\tdump_cfg_string(oControlPath, o->control_path);\n\tdump_cfg_string(oHostKeyAlgorithms, o->hostkeyalgorithms);\n\tdump_cfg_string(oHostKeyAlias, o->host_key_alias);\n\tdump_cfg_string(oHostbasedKeyTypes, o->hostbased_key_types);\n\tdump_cfg_string(oIdentityAgent, o->identity_agent);\n\tdump_cfg_string(oIgnoreUnknown, o->ignored_unknown);\n\tdump_cfg_string(oKbdInteractiveDevices, o->kbd_interactive_devices);\n\tdump_cfg_string(oKexAlgorithms, o->kex_algorithms ? o->kex_algorithms : KEX_CLIENT_KEX);\n\tdump_cfg_string(oCASignatureAlgorithms, o->ca_sign_algorithms ? o->ca_sign_algorithms : SSH_ALLOWED_CA_SIGALGS);\n\tdump_cfg_string(oLocalCommand, o->local_command);\n\tdump_cfg_string(oRemoteCommand, o->remote_command);\n\tdump_cfg_string(oLogLevel, log_level_name(o->log_level));\n\tdump_cfg_string(oMacs, o->macs ? o->macs : KEX_CLIENT_MAC);\n#ifdef ENABLE_PKCS11\n\tdump_cfg_string(oPKCS11Provider, o->pkcs11_provider);\n#endif\n\tdump_cfg_string(oPreferredAuthentications, o->preferred_authentications);\n\tdump_cfg_string(oPubkeyAcceptedKeyTypes, o->pubkey_key_types);\n\tdump_cfg_string(oRevokedHostKeys, o->revoked_host_keys);\n\tdump_cfg_string(oXAuthLocation, o->xauth_location);\n\n\t/* Forwards */\n\tdump_cfg_forwards(oDynamicForward, o->num_local_forwards, o->local_forwards);\n\tdump_cfg_forwards(oLocalForward, o->num_local_forwards, o->local_forwards);\n\tdump_cfg_forwards(oRemoteForward, o->num_remote_forwards, o->remote_forwards);\n\n\t/* String array options */\n\tdump_cfg_strarray(oIdentityFile, o->num_identity_files, o->identity_files);\n\tdump_cfg_strarray_oneline(oCanonicalDomains, o->num_canonical_domains, o->canonical_domains);\n\tdump_cfg_strarray(oCertificateFile, o->num_certificate_files, o->certificate_files);\n\tdump_cfg_strarray_oneline(oGlobalKnownHostsFile, o->num_system_hostfiles, o->system_hostfiles);\n\tdump_cfg_strarray_oneline(oUserKnownHostsFile, o->num_user_hostfiles, o->user_hostfiles);\n\tdump_cfg_strarray(oSendEnv, o->num_send_env, o->send_env);\n\tdump_cfg_strarray(oSetEnv, o->num_setenv, o->setenv);\n\n\t/* Special cases */\n\n\t/* oConnectTimeout */\n\tif (o->connection_timeout == -1)\n\t\tprintf(\"connecttimeout none\\n\");\n\telse\n\t\tdump_cfg_int(oConnectTimeout, o->connection_timeout);\n\n\t/* oTunnelDevice */\n\tprintf(\"tunneldevice\");\n\tif (o->tun_local == SSH_TUNID_ANY)\n\t\tprintf(\" any\");\n\telse\n\t\tprintf(\" %d\", o->tun_local);\n\tif (o->tun_remote == SSH_TUNID_ANY)\n\t\tprintf(\":any\");\n\telse\n\t\tprintf(\":%d\", o->tun_remote);\n\tprintf(\"\\n\");\n\n\t/* oCanonicalizePermittedCNAMEs */\n\tif ( o->num_permitted_cnames > 0) {\n\t\tprintf(\"canonicalizePermittedcnames\");\n\t\tfor (i = 0; i < o->num_permitted_cnames; i++) {\n\t\t\tprintf(\" %s:%s\", o->permitted_cnames[i].source_list,\n\t\t\t    o->permitted_cnames[i].target_list);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\t/* oControlPersist */\n\tif (o->control_persist == 0 || o->control_persist_timeout == 0)\n\t\tdump_cfg_fmtint(oControlPersist, o->control_persist);\n\telse\n\t\tdump_cfg_int(oControlPersist, o->control_persist_timeout);\n\n\t/* oEscapeChar */\n\tif (o->escape_char == SSH_ESCAPECHAR_NONE)\n\t\tprintf(\"escapechar none\\n\");\n\telse {\n\t\tvis(buf, o->escape_char, VIS_WHITE, 0);\n\t\tprintf(\"escapechar %s\\n\", buf);\n\t}\n\n\t/* oIPQoS */\n\tprintf(\"ipqos %s \", iptos2str(o->ip_qos_interactive));\n\tprintf(\"%s\\n\", iptos2str(o->ip_qos_bulk));\n\n\t/* oRekeyLimit */\n\tprintf(\"rekeylimit %llu %d\\n\",\n\t    (unsigned long long)o->rekey_limit, o->rekey_interval);\n\n\t/* oStreamLocalBindMask */\n\tprintf(\"streamlocalbindmask 0%o\\n\",\n\t    o->fwd_opts.streamlocal_bind_mask);\n\n\t/* oLogFacility */\n\tprintf(\"syslogfacility %s\\n\", log_facility_name(o->log_facility));\n\n\t/* oProxyCommand / oProxyJump */\n\tif (o->jump_host == NULL)\n\t\tdump_cfg_string(oProxyCommand, o->proxy_command);\n\telse {\n\t\t/* Check for numeric addresses */\n\t\ti = strchr(o->jump_host, ':') != NULL ||\n\t\t    strspn(o->jump_host, \"1234567890.\") == strlen(o->jump_host);\n\t\tsnprintf(buf, sizeof(buf), \"%d\", o->jump_port);\n\t\tprintf(\"proxyjump %s%s%s%s%s%s%s%s%s\\n\",\n\t\t    /* optional additional jump spec */\n\t\t    o->jump_extra == NULL ? \"\" : o->jump_extra,\n\t\t    o->jump_extra == NULL ? \"\" : \",\",\n\t\t    /* optional user */\n\t\t    o->jump_user == NULL ? \"\" : o->jump_user,\n\t\t    o->jump_user == NULL ? \"\" : \"@\",\n\t\t    /* opening [ if hostname is numeric */\n\t\t    i ? \"[\" : \"\",\n\t\t    /* mandatory hostname */\n\t\t    o->jump_host,\n\t\t    /* closing ] if hostname is numeric */\n\t\t    i ? \"]\" : \"\",\n\t\t    /* optional port number */\n\t\t    o->jump_port <= 0 ? \"\" : \":\",\n\t\t    o->jump_port <= 0 ? \"\" : buf);\n\t}\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"proxyjump %s%s%s%s%s%s%s%s%s\\n\"",
            "/* optional additional jump spec */o->jump_extra == NULL ? \"\" : o->jump_extra",
            "o->jump_extra == NULL ? \"\" : \",\"",
            "/* optional user */o->jump_user == NULL ? \"\" : o->jump_user",
            "o->jump_user == NULL ? \"\" : \"@\"",
            "/* opening [ if hostname is numeric */i ? \"[\" : \"\"",
            "/* mandatory hostname */o->jump_host",
            "/* closing ] if hostname is numeric */i ? \"]\" : \"\"",
            "/* optional port number */o->jump_port <= 0 ? \"\" : \":\"",
            "o->jump_port <= 0 ? \"\" : buf"
          ],
          "line": 2740
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%d\"",
            "o->jump_port"
          ],
          "line": 2739
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "o->jump_host"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "o->jump_host",
            "\"1234567890.\""
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "o->jump_host",
            "':'"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_cfg_string",
          "args": [
            "oProxyCommand",
            "o->proxy_command"
          ],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "dump_cfg_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2502-2508",
          "snippet": "static void\ndump_cfg_string(OpCodes code, const char *val)\n{\n\tif (val == NULL)\n\t\treturn;\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code), val);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_string(OpCodes code, const char *val)\n{\n\tif (val == NULL)\n\t\treturn;\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code), val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_facility_name",
          "args": [
            "o->log_facility"
          ],
          "line": 2730
        },
        "resolved": true,
        "details": {
          "function_name": "log_facility_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "126-135",
          "snippet": "const char *\nlog_facility_name(SyslogFacility facility)\n{\n\tu_int i;\n\n\tfor (i = 0;  log_facilities[i].name; i++)\n\t\tif (log_facilities[i].val == facility)\n\t\t\treturn log_facilities[i].name;\n\treturn NULL;\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tSyslogFacility val;\n} log_facilities[] = {\n\t{ \"DAEMON\",\tSYSLOG_FACILITY_DAEMON },\n\t{ \"USER\",\tSYSLOG_FACILITY_USER },\n\t{ \"AUTH\",\tSYSLOG_FACILITY_AUTH },\n#ifdef LOG_AUTHPRIV\n\t{ \"AUTHPRIV\",\tSYSLOG_FACILITY_AUTHPRIV },\n#endif\n\t{ \"LOCAL0\",\tSYSLOG_FACILITY_LOCAL0 },\n\t{ \"LOCAL1\",\tSYSLOG_FACILITY_LOCAL1 },\n\t{ \"LOCAL2\",\tSYSLOG_FACILITY_LOCAL2 },\n\t{ \"LOCAL3\",\tSYSLOG_FACILITY_LOCAL3 },\n\t{ \"LOCAL4\",\tSYSLOG_FACILITY_LOCAL4 },\n\t{ \"LOCAL5\",\tSYSLOG_FACILITY_LOCAL5 },\n\t{ \"LOCAL6\",\tSYSLOG_FACILITY_LOCAL6 },\n\t{ \"LOCAL7\",\tSYSLOG_FACILITY_LOCAL7 },\n\t{ NULL,\t\tSYSLOG_FACILITY_NOT_SET }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tSyslogFacility val;\n} log_facilities[] = {\n\t{ \"DAEMON\",\tSYSLOG_FACILITY_DAEMON },\n\t{ \"USER\",\tSYSLOG_FACILITY_USER },\n\t{ \"AUTH\",\tSYSLOG_FACILITY_AUTH },\n#ifdef LOG_AUTHPRIV\n\t{ \"AUTHPRIV\",\tSYSLOG_FACILITY_AUTHPRIV },\n#endif\n\t{ \"LOCAL0\",\tSYSLOG_FACILITY_LOCAL0 },\n\t{ \"LOCAL1\",\tSYSLOG_FACILITY_LOCAL1 },\n\t{ \"LOCAL2\",\tSYSLOG_FACILITY_LOCAL2 },\n\t{ \"LOCAL3\",\tSYSLOG_FACILITY_LOCAL3 },\n\t{ \"LOCAL4\",\tSYSLOG_FACILITY_LOCAL4 },\n\t{ \"LOCAL5\",\tSYSLOG_FACILITY_LOCAL5 },\n\t{ \"LOCAL6\",\tSYSLOG_FACILITY_LOCAL6 },\n\t{ \"LOCAL7\",\tSYSLOG_FACILITY_LOCAL7 },\n\t{ NULL,\t\tSYSLOG_FACILITY_NOT_SET }\n};\n\nconst char *\nlog_facility_name(SyslogFacility facility)\n{\n\tu_int i;\n\n\tfor (i = 0;  log_facilities[i].name; i++)\n\t\tif (log_facilities[i].val == facility)\n\t\t\treturn log_facilities[i].name;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptos2str",
          "args": [
            "o->ip_qos_bulk"
          ],
          "line": 2719
        },
        "resolved": true,
        "details": {
          "function_name": "iptos2str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1466-1478",
          "snippet": "const char *\niptos2str(int iptos)\n{\n\tint i;\n\tstatic char iptos_str[sizeof \"0xff\"];\n\n\tfor (i = 0; ipqos[i].name != NULL; i++) {\n\t\tif (ipqos[i].value == iptos)\n\t\t\treturn ipqos[i].name;\n\t}\n\tsnprintf(iptos_str, sizeof iptos_str, \"0x%02x\", iptos);\n\treturn iptos_str;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct {\n\tconst char *name;\n\tint value;\n} ipqos[] = {\n\t{ \"none\", INT_MAX },\t\t/* can't use 0 here; that's CS0 */\n\t{ \"af11\", IPTOS_DSCP_AF11 },\n\t{ \"af12\", IPTOS_DSCP_AF12 },\n\t{ \"af13\", IPTOS_DSCP_AF13 },\n\t{ \"af21\", IPTOS_DSCP_AF21 },\n\t{ \"af22\", IPTOS_DSCP_AF22 },\n\t{ \"af23\", IPTOS_DSCP_AF23 },\n\t{ \"af31\", IPTOS_DSCP_AF31 },\n\t{ \"af32\", IPTOS_DSCP_AF32 },\n\t{ \"af33\", IPTOS_DSCP_AF33 },\n\t{ \"af41\", IPTOS_DSCP_AF41 },\n\t{ \"af42\", IPTOS_DSCP_AF42 },\n\t{ \"af43\", IPTOS_DSCP_AF43 },\n\t{ \"cs0\", IPTOS_DSCP_CS0 },\n\t{ \"cs1\", IPTOS_DSCP_CS1 },\n\t{ \"cs2\", IPTOS_DSCP_CS2 },\n\t{ \"cs3\", IPTOS_DSCP_CS3 },\n\t{ \"cs4\", IPTOS_DSCP_CS4 },\n\t{ \"cs5\", IPTOS_DSCP_CS5 },\n\t{ \"cs6\", IPTOS_DSCP_CS6 },\n\t{ \"cs7\", IPTOS_DSCP_CS7 },\n\t{ \"ef\", IPTOS_DSCP_EF },\n\t{ \"lowdelay\", IPTOS_LOWDELAY },\n\t{ \"throughput\", IPTOS_THROUGHPUT },\n\t{ \"reliability\", IPTOS_RELIABILITY },\n\t{ NULL, -1 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct {\n\tconst char *name;\n\tint value;\n} ipqos[] = {\n\t{ \"none\", INT_MAX },\t\t/* can't use 0 here; that's CS0 */\n\t{ \"af11\", IPTOS_DSCP_AF11 },\n\t{ \"af12\", IPTOS_DSCP_AF12 },\n\t{ \"af13\", IPTOS_DSCP_AF13 },\n\t{ \"af21\", IPTOS_DSCP_AF21 },\n\t{ \"af22\", IPTOS_DSCP_AF22 },\n\t{ \"af23\", IPTOS_DSCP_AF23 },\n\t{ \"af31\", IPTOS_DSCP_AF31 },\n\t{ \"af32\", IPTOS_DSCP_AF32 },\n\t{ \"af33\", IPTOS_DSCP_AF33 },\n\t{ \"af41\", IPTOS_DSCP_AF41 },\n\t{ \"af42\", IPTOS_DSCP_AF42 },\n\t{ \"af43\", IPTOS_DSCP_AF43 },\n\t{ \"cs0\", IPTOS_DSCP_CS0 },\n\t{ \"cs1\", IPTOS_DSCP_CS1 },\n\t{ \"cs2\", IPTOS_DSCP_CS2 },\n\t{ \"cs3\", IPTOS_DSCP_CS3 },\n\t{ \"cs4\", IPTOS_DSCP_CS4 },\n\t{ \"cs5\", IPTOS_DSCP_CS5 },\n\t{ \"cs6\", IPTOS_DSCP_CS6 },\n\t{ \"cs7\", IPTOS_DSCP_CS7 },\n\t{ \"ef\", IPTOS_DSCP_EF },\n\t{ \"lowdelay\", IPTOS_LOWDELAY },\n\t{ \"throughput\", IPTOS_THROUGHPUT },\n\t{ \"reliability\", IPTOS_RELIABILITY },\n\t{ NULL, -1 }\n};\n\nconst char *\niptos2str(int iptos)\n{\n\tint i;\n\tstatic char iptos_str[sizeof \"0xff\"];\n\n\tfor (i = 0; ipqos[i].name != NULL; i++) {\n\t\tif (ipqos[i].value == iptos)\n\t\t\treturn ipqos[i].name;\n\t}\n\tsnprintf(iptos_str, sizeof iptos_str, \"0x%02x\", iptos);\n\treturn iptos_str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vis",
          "args": [
            "buf",
            "o->escape_char",
            "VIS_WHITE",
            "0"
          ],
          "line": 2713
        },
        "resolved": true,
        "details": {
          "function_name": "strvisx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/vis.c",
          "lines": "235-249",
          "snippet": "int\nstrvisx(char *dst, const char *src, size_t len, int flag)\n{\n\tchar c;\n\tchar *start;\n\n\tfor (start = dst; len > 1; len--) {\n\t\tc = *src;\n\t\tdst = vis(dst, c, flag, *++src);\n\t}\n\tif (len)\n\t\tdst = vis(dst, *src, flag, '\\0');\n\t*dst = '\\0';\n\treturn (dst - start);\n}",
          "includes": [
            "#include \"vis.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vis.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nstrvisx(char *dst, const char *src, size_t len, int flag)\n{\n\tchar c;\n\tchar *start;\n\n\tfor (start = dst; len > 1; len--) {\n\t\tc = *src;\n\t\tdst = vis(dst, c, flag, *++src);\n\t}\n\tif (len)\n\t\tdst = vis(dst, *src, flag, '\\0');\n\t*dst = '\\0';\n\treturn (dst - start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"escapechar none\\n\""
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_cfg_int",
          "args": [
            "oControlPersist",
            "o->control_persist_timeout"
          ],
          "line": 2707
        },
        "resolved": true,
        "details": {
          "function_name": "dump_cfg_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2490-2494",
          "snippet": "static void\ndump_cfg_int(OpCodes code, int val)\n{\n\tprintf(\"%s %d\\n\", lookup_opcode_name(code), val);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_int(OpCodes code, int val)\n{\n\tprintf(\"%s %d\\n\", lookup_opcode_name(code), val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_cfg_fmtint",
          "args": [
            "oControlPersist",
            "o->control_persist"
          ],
          "line": 2705
        },
        "resolved": true,
        "details": {
          "function_name": "dump_cfg_fmtint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2496-2500",
          "snippet": "static void\ndump_cfg_fmtint(OpCodes code, int val)\n{\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code), fmt_intarg(code, val));\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_fmtint(OpCodes code, int val)\n{\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code), fmt_intarg(code, val));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_cfg_strarray",
          "args": [
            "oSetEnv",
            "o->num_setenv",
            "o->setenv"
          ],
          "line": 2671
        },
        "resolved": true,
        "details": {
          "function_name": "dump_cfg_strarray_oneline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2519-2528",
          "snippet": "static void\ndump_cfg_strarray_oneline(OpCodes code, u_int count, char **vals)\n{\n\tu_int i;\n\n\tprintf(\"%s\", lookup_opcode_name(code));\n\tfor (i = 0; i < count; i++)\n\t\tprintf(\" %s\",  vals[i]);\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_strarray_oneline(OpCodes code, u_int count, char **vals)\n{\n\tu_int i;\n\n\tprintf(\"%s\", lookup_opcode_name(code));\n\tfor (i = 0; i < count; i++)\n\t\tprintf(\" %s\",  vals[i]);\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_cfg_forwards",
          "args": [
            "oRemoteForward",
            "o->num_remote_forwards",
            "o->remote_forwards"
          ],
          "line": 2662
        },
        "resolved": true,
        "details": {
          "function_name": "dump_cfg_forwards",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2530-2566",
          "snippet": "static void\ndump_cfg_forwards(OpCodes code, u_int count, const struct Forward *fwds)\n{\n\tconst struct Forward *fwd;\n\tu_int i;\n\n\t/* oDynamicForward */\n\tfor (i = 0; i < count; i++) {\n\t\tfwd = &fwds[i];\n\t\tif (code == oDynamicForward && fwd->connect_host != NULL &&\n\t\t    strcmp(fwd->connect_host, \"socks\") != 0)\n\t\t\tcontinue;\n\t\tif (code == oLocalForward && fwd->connect_host != NULL &&\n\t\t    strcmp(fwd->connect_host, \"socks\") == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s\", lookup_opcode_name(code));\n\t\tif (fwd->listen_port == PORT_STREAMLOCAL)\n\t\t\tprintf(\" %s\", fwd->listen_path);\n\t\telse if (fwd->listen_host == NULL)\n\t\t\tprintf(\" %d\", fwd->listen_port);\n\t\telse {\n\t\t\tprintf(\" [%s]:%d\",\n\t\t\t    fwd->listen_host, fwd->listen_port);\n\t\t}\n\t\tif (code != oDynamicForward) {\n\t\t\tif (fwd->connect_port == PORT_STREAMLOCAL)\n\t\t\t\tprintf(\" %s\", fwd->connect_path);\n\t\t\telse if (fwd->connect_host == NULL)\n\t\t\t\tprintf(\" %d\", fwd->connect_port);\n\t\t\telse {\n\t\t\t\tprintf(\" [%s]:%d\",\n\t\t\t\t    fwd->connect_host, fwd->connect_port);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_forwards(OpCodes code, u_int count, const struct Forward *fwds)\n{\n\tconst struct Forward *fwd;\n\tu_int i;\n\n\t/* oDynamicForward */\n\tfor (i = 0; i < count; i++) {\n\t\tfwd = &fwds[i];\n\t\tif (code == oDynamicForward && fwd->connect_host != NULL &&\n\t\t    strcmp(fwd->connect_host, \"socks\") != 0)\n\t\t\tcontinue;\n\t\tif (code == oLocalForward && fwd->connect_host != NULL &&\n\t\t    strcmp(fwd->connect_host, \"socks\") == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s\", lookup_opcode_name(code));\n\t\tif (fwd->listen_port == PORT_STREAMLOCAL)\n\t\t\tprintf(\" %s\", fwd->listen_path);\n\t\telse if (fwd->listen_host == NULL)\n\t\t\tprintf(\" %d\", fwd->listen_port);\n\t\telse {\n\t\t\tprintf(\" [%s]:%d\",\n\t\t\t    fwd->listen_host, fwd->listen_port);\n\t\t}\n\t\tif (code != oDynamicForward) {\n\t\t\tif (fwd->connect_port == PORT_STREAMLOCAL)\n\t\t\t\tprintf(\" %s\", fwd->connect_path);\n\t\t\telse if (fwd->connect_host == NULL)\n\t\t\t\tprintf(\" %d\", fwd->connect_port);\n\t\t\telse {\n\t\t\t\tprintf(\" [%s]:%d\",\n\t\t\t\t    fwd->connect_host, fwd->connect_port);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_level_name",
          "args": [
            "o->log_level"
          ],
          "line": 2649
        },
        "resolved": true,
        "details": {
          "function_name": "log_level_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "149-158",
          "snippet": "const char *\nlog_level_name(LogLevel level)\n{\n\tu_int i;\n\n\tfor (i = 0; log_levels[i].name != NULL; i++)\n\t\tif (log_levels[i].val == level)\n\t\t\treturn log_levels[i].name;\n\treturn NULL;\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tLogLevel val;\n} log_levels[] =\n{\n\t{ \"QUIET\",\tSYSLOG_LEVEL_QUIET },\n\t{ \"FATAL\",\tSYSLOG_LEVEL_FATAL },\n\t{ \"ERROR\",\tSYSLOG_LEVEL_ERROR },\n\t{ \"INFO\",\tSYSLOG_LEVEL_INFO },\n\t{ \"VERBOSE\",\tSYSLOG_LEVEL_VERBOSE },\n\t{ \"DEBUG\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG1\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG2\",\tSYSLOG_LEVEL_DEBUG2 },\n\t{ \"DEBUG3\",\tSYSLOG_LEVEL_DEBUG3 },\n\t{ NULL,\t\tSYSLOG_LEVEL_NOT_SET }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tLogLevel val;\n} log_levels[] =\n{\n\t{ \"QUIET\",\tSYSLOG_LEVEL_QUIET },\n\t{ \"FATAL\",\tSYSLOG_LEVEL_FATAL },\n\t{ \"ERROR\",\tSYSLOG_LEVEL_ERROR },\n\t{ \"INFO\",\tSYSLOG_LEVEL_INFO },\n\t{ \"VERBOSE\",\tSYSLOG_LEVEL_VERBOSE },\n\t{ \"DEBUG\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG1\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG2\",\tSYSLOG_LEVEL_DEBUG2 },\n\t{ \"DEBUG3\",\tSYSLOG_LEVEL_DEBUG3 },\n\t{ NULL,\t\tSYSLOG_LEVEL_NOT_SET }\n};\n\nconst char *\nlog_level_name(LogLevel level)\n{\n\tu_int i;\n\n\tfor (i = 0; log_levels[i].name != NULL; i++)\n\t\tif (log_levels[i].val == level)\n\t\t\treturn log_levels[i].name;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "all_key"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: kex_assemble_names failed\"",
            "__func__"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kex_assemble_names",
          "args": [
            "&o->hostkeyalgorithms",
            "KEX_DEFAULT_PK_ALG",
            "all_key"
          ],
          "line": 2576
        },
        "resolved": true,
        "details": {
          "function_name": "kex_assemble_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "211-294",
          "snippet": "int\nkex_assemble_names(char **listp, const char *def, const char *all)\n{\n\tchar *cp, *tmp, *patterns;\n\tchar *list = NULL, *ret = NULL, *matching = NULL, *opatterns = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (listp == NULL || *listp == NULL || **listp == '\\0') {\n\t\tif ((*listp = strdup(def)) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\treturn 0;\n\t}\n\n\tlist = *listp;\n\t*listp = NULL;\n\tif (*list == '+') {\n\t\t/* Append names to default list */\n\t\tif ((tmp = kex_names_cat(def, list + 1)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(list);\n\t\tlist = tmp;\n\t} else if (*list == '-') {\n\t\t/* Remove names from default list */\n\t\tif ((*listp = match_filter_blacklist(def, list + 1)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(list);\n\t\t/* filtering has already been done */\n\t\treturn 0;\n\t} else {\n\t\t/* Explicit list, overrides default - just use \"list\" as is */\n\t}\n\n\t/*\n\t * The supplied names may be a pattern-list. For the -list case,\n\t * the patterns are applied above. For the +list and explicit list\n\t * cases we need to do it now.\n\t */\n\tret = NULL;\n\tif ((patterns = opatterns = strdup(list)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto fail;\n\t}\n\t/* Apply positive (i.e. non-negated) patterns from the list */\n\twhile ((cp = strsep(&patterns, \",\")) != NULL) {\n\t\tif (*cp == '!') {\n\t\t\t/* negated matches are not supported here */\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(matching);\n\t\tif ((matching = match_filter_whitelist(all, cp)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((tmp = kex_names_cat(ret, matching)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(ret);\n\t\tret = tmp;\n\t}\n\tif (ret == NULL || *ret == '\\0') {\n\t\t/* An empty name-list is an error */\n\t\t/* XXX better error code? */\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto fail;\n\t}\n\n\t/* success */\n\t*listp = ret;\n\tret = NULL;\n\tr = 0;\n\n fail:\n\tfree(matching);\n\tfree(opatterns);\n\tfree(list);\n\tfree(ret);\n\treturn r;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nint\nkex_assemble_names(char **listp, const char *def, const char *all)\n{\n\tchar *cp, *tmp, *patterns;\n\tchar *list = NULL, *ret = NULL, *matching = NULL, *opatterns = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (listp == NULL || *listp == NULL || **listp == '\\0') {\n\t\tif ((*listp = strdup(def)) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\treturn 0;\n\t}\n\n\tlist = *listp;\n\t*listp = NULL;\n\tif (*list == '+') {\n\t\t/* Append names to default list */\n\t\tif ((tmp = kex_names_cat(def, list + 1)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(list);\n\t\tlist = tmp;\n\t} else if (*list == '-') {\n\t\t/* Remove names from default list */\n\t\tif ((*listp = match_filter_blacklist(def, list + 1)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(list);\n\t\t/* filtering has already been done */\n\t\treturn 0;\n\t} else {\n\t\t/* Explicit list, overrides default - just use \"list\" as is */\n\t}\n\n\t/*\n\t * The supplied names may be a pattern-list. For the -list case,\n\t * the patterns are applied above. For the +list and explicit list\n\t * cases we need to do it now.\n\t */\n\tret = NULL;\n\tif ((patterns = opatterns = strdup(list)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto fail;\n\t}\n\t/* Apply positive (i.e. non-negated) patterns from the list */\n\twhile ((cp = strsep(&patterns, \",\")) != NULL) {\n\t\tif (*cp == '!') {\n\t\t\t/* negated matches are not supported here */\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(matching);\n\t\tif ((matching = match_filter_whitelist(all, cp)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((tmp = kex_names_cat(ret, matching)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(ret);\n\t\tret = tmp;\n\t}\n\tif (ret == NULL || *ret == '\\0') {\n\t\t/* An empty name-list is an error */\n\t\t/* XXX better error code? */\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto fail;\n\t}\n\n\t/* success */\n\t*listp = ret;\n\tret = NULL;\n\tr = 0;\n\n fail:\n\tfree(matching);\n\tfree(opatterns);\n\tfree(list);\n\tfree(ret);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_alg_list",
          "args": [
            "0",
            "0",
            "1",
            "','"
          ],
          "line": 2575
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_alg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "218-244",
          "snippet": "char *\nsshkey_alg_list(int certs_only, int plain_only, int include_sigonly, char sep)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->name == NULL)\n\t\t\tcontinue;\n\t\tif (!include_sigonly && kt->sigonly)\n\t\t\tcontinue;\n\t\tif ((certs_only && !kt->cert) || (plain_only && kt->cert))\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(kt->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, kt->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nchar *\nsshkey_alg_list(int certs_only, int plain_only, int include_sigonly, char sep)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->name == NULL)\n\t\t\tcontinue;\n\t\tif (!include_sigonly && kt->sigonly)\n\t\t\tcontinue;\n\t\tif ((certs_only && !kt->cert) || (plain_only && kt->cert))\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(kt->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, kt->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndump_client_config(Options *o, const char *host)\n{\n\tint i;\n\tchar buf[8], *all_key;\n\n\t/* This is normally prepared in ssh_kex2 */\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tif (kex_assemble_names( &o->hostkeyalgorithms,\n\t    KEX_DEFAULT_PK_ALG, all_key) != 0)\n\t\tfatal(\"%s: kex_assemble_names failed\", __func__);\n\tfree(all_key);\n\n\t/* Most interesting options first: user, host, port */\n\tdump_cfg_string(oUser, o->user);\n\tdump_cfg_string(oHostName, host);\n\tdump_cfg_int(oPort, o->port);\n\n\t/* Flag options */\n\tdump_cfg_fmtint(oAddKeysToAgent, o->add_keys_to_agent);\n\tdump_cfg_fmtint(oAddressFamily, o->address_family);\n\tdump_cfg_fmtint(oBatchMode, o->batch_mode);\n\tdump_cfg_fmtint(oCanonicalizeFallbackLocal, o->canonicalize_fallback_local);\n\tdump_cfg_fmtint(oCanonicalizeHostname, o->canonicalize_hostname);\n\tdump_cfg_fmtint(oChallengeResponseAuthentication, o->challenge_response_authentication);\n\tdump_cfg_fmtint(oCheckHostIP, o->check_host_ip);\n\tdump_cfg_fmtint(oCompression, o->compression);\n\tdump_cfg_fmtint(oControlMaster, o->control_master);\n\tdump_cfg_fmtint(oEnableSSHKeysign, o->enable_ssh_keysign);\n\tdump_cfg_fmtint(oClearAllForwardings, o->clear_forwardings);\n\tdump_cfg_fmtint(oExitOnForwardFailure, o->exit_on_forward_failure);\n\tdump_cfg_fmtint(oFingerprintHash, o->fingerprint_hash);\n\tdump_cfg_fmtint(oForwardAgent, o->forward_agent);\n\tdump_cfg_fmtint(oForwardX11, o->forward_x11);\n\tdump_cfg_fmtint(oForwardX11Trusted, o->forward_x11_trusted);\n\tdump_cfg_fmtint(oGatewayPorts, o->fwd_opts.gateway_ports);\n#ifdef GSSAPI\n\tdump_cfg_fmtint(oGssAuthentication, o->gss_authentication);\n\tdump_cfg_fmtint(oGssDelegateCreds, o->gss_deleg_creds);\n#endif /* GSSAPI */\n\tdump_cfg_fmtint(oHashKnownHosts, o->hash_known_hosts);\n\tdump_cfg_fmtint(oHostbasedAuthentication, o->hostbased_authentication);\n\tdump_cfg_fmtint(oIdentitiesOnly, o->identities_only);\n\tdump_cfg_fmtint(oKbdInteractiveAuthentication, o->kbd_interactive_authentication);\n\tdump_cfg_fmtint(oNoHostAuthenticationForLocalhost, o->no_host_authentication_for_localhost);\n\tdump_cfg_fmtint(oPasswordAuthentication, o->password_authentication);\n\tdump_cfg_fmtint(oPermitLocalCommand, o->permit_local_command);\n\tdump_cfg_fmtint(oProxyUseFdpass, o->proxy_use_fdpass);\n\tdump_cfg_fmtint(oPubkeyAuthentication, o->pubkey_authentication);\n\tdump_cfg_fmtint(oRequestTTY, o->request_tty);\n\tdump_cfg_fmtint(oStreamLocalBindUnlink, o->fwd_opts.streamlocal_bind_unlink);\n\tdump_cfg_fmtint(oStrictHostKeyChecking, o->strict_host_key_checking);\n\tdump_cfg_fmtint(oTCPKeepAlive, o->tcp_keep_alive);\n\tdump_cfg_fmtint(oTunnel, o->tun_open);\n\tdump_cfg_fmtint(oVerifyHostKeyDNS, o->verify_host_key_dns);\n\tdump_cfg_fmtint(oVisualHostKey, o->visual_host_key);\n\tdump_cfg_fmtint(oUpdateHostkeys, o->update_hostkeys);\n\n\t/* Integer options */\n\tdump_cfg_int(oCanonicalizeMaxDots, o->canonicalize_max_dots);\n\tdump_cfg_int(oConnectionAttempts, o->connection_attempts);\n\tdump_cfg_int(oForwardX11Timeout, o->forward_x11_timeout);\n\tdump_cfg_int(oNumberOfPasswordPrompts, o->number_of_password_prompts);\n\tdump_cfg_int(oServerAliveCountMax, o->server_alive_count_max);\n\tdump_cfg_int(oServerAliveInterval, o->server_alive_interval);\n\n\t/* String options */\n\tdump_cfg_string(oBindAddress, o->bind_address);\n\tdump_cfg_string(oBindInterface, o->bind_interface);\n\tdump_cfg_string(oCiphers, o->ciphers ? o->ciphers : KEX_CLIENT_ENCRYPT);\n\tdump_cfg_string(oControlPath, o->control_path);\n\tdump_cfg_string(oHostKeyAlgorithms, o->hostkeyalgorithms);\n\tdump_cfg_string(oHostKeyAlias, o->host_key_alias);\n\tdump_cfg_string(oHostbasedKeyTypes, o->hostbased_key_types);\n\tdump_cfg_string(oIdentityAgent, o->identity_agent);\n\tdump_cfg_string(oIgnoreUnknown, o->ignored_unknown);\n\tdump_cfg_string(oKbdInteractiveDevices, o->kbd_interactive_devices);\n\tdump_cfg_string(oKexAlgorithms, o->kex_algorithms ? o->kex_algorithms : KEX_CLIENT_KEX);\n\tdump_cfg_string(oCASignatureAlgorithms, o->ca_sign_algorithms ? o->ca_sign_algorithms : SSH_ALLOWED_CA_SIGALGS);\n\tdump_cfg_string(oLocalCommand, o->local_command);\n\tdump_cfg_string(oRemoteCommand, o->remote_command);\n\tdump_cfg_string(oLogLevel, log_level_name(o->log_level));\n\tdump_cfg_string(oMacs, o->macs ? o->macs : KEX_CLIENT_MAC);\n#ifdef ENABLE_PKCS11\n\tdump_cfg_string(oPKCS11Provider, o->pkcs11_provider);\n#endif\n\tdump_cfg_string(oPreferredAuthentications, o->preferred_authentications);\n\tdump_cfg_string(oPubkeyAcceptedKeyTypes, o->pubkey_key_types);\n\tdump_cfg_string(oRevokedHostKeys, o->revoked_host_keys);\n\tdump_cfg_string(oXAuthLocation, o->xauth_location);\n\n\t/* Forwards */\n\tdump_cfg_forwards(oDynamicForward, o->num_local_forwards, o->local_forwards);\n\tdump_cfg_forwards(oLocalForward, o->num_local_forwards, o->local_forwards);\n\tdump_cfg_forwards(oRemoteForward, o->num_remote_forwards, o->remote_forwards);\n\n\t/* String array options */\n\tdump_cfg_strarray(oIdentityFile, o->num_identity_files, o->identity_files);\n\tdump_cfg_strarray_oneline(oCanonicalDomains, o->num_canonical_domains, o->canonical_domains);\n\tdump_cfg_strarray(oCertificateFile, o->num_certificate_files, o->certificate_files);\n\tdump_cfg_strarray_oneline(oGlobalKnownHostsFile, o->num_system_hostfiles, o->system_hostfiles);\n\tdump_cfg_strarray_oneline(oUserKnownHostsFile, o->num_user_hostfiles, o->user_hostfiles);\n\tdump_cfg_strarray(oSendEnv, o->num_send_env, o->send_env);\n\tdump_cfg_strarray(oSetEnv, o->num_setenv, o->setenv);\n\n\t/* Special cases */\n\n\t/* oConnectTimeout */\n\tif (o->connection_timeout == -1)\n\t\tprintf(\"connecttimeout none\\n\");\n\telse\n\t\tdump_cfg_int(oConnectTimeout, o->connection_timeout);\n\n\t/* oTunnelDevice */\n\tprintf(\"tunneldevice\");\n\tif (o->tun_local == SSH_TUNID_ANY)\n\t\tprintf(\" any\");\n\telse\n\t\tprintf(\" %d\", o->tun_local);\n\tif (o->tun_remote == SSH_TUNID_ANY)\n\t\tprintf(\":any\");\n\telse\n\t\tprintf(\":%d\", o->tun_remote);\n\tprintf(\"\\n\");\n\n\t/* oCanonicalizePermittedCNAMEs */\n\tif ( o->num_permitted_cnames > 0) {\n\t\tprintf(\"canonicalizePermittedcnames\");\n\t\tfor (i = 0; i < o->num_permitted_cnames; i++) {\n\t\t\tprintf(\" %s:%s\", o->permitted_cnames[i].source_list,\n\t\t\t    o->permitted_cnames[i].target_list);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\t/* oControlPersist */\n\tif (o->control_persist == 0 || o->control_persist_timeout == 0)\n\t\tdump_cfg_fmtint(oControlPersist, o->control_persist);\n\telse\n\t\tdump_cfg_int(oControlPersist, o->control_persist_timeout);\n\n\t/* oEscapeChar */\n\tif (o->escape_char == SSH_ESCAPECHAR_NONE)\n\t\tprintf(\"escapechar none\\n\");\n\telse {\n\t\tvis(buf, o->escape_char, VIS_WHITE, 0);\n\t\tprintf(\"escapechar %s\\n\", buf);\n\t}\n\n\t/* oIPQoS */\n\tprintf(\"ipqos %s \", iptos2str(o->ip_qos_interactive));\n\tprintf(\"%s\\n\", iptos2str(o->ip_qos_bulk));\n\n\t/* oRekeyLimit */\n\tprintf(\"rekeylimit %llu %d\\n\",\n\t    (unsigned long long)o->rekey_limit, o->rekey_interval);\n\n\t/* oStreamLocalBindMask */\n\tprintf(\"streamlocalbindmask 0%o\\n\",\n\t    o->fwd_opts.streamlocal_bind_mask);\n\n\t/* oLogFacility */\n\tprintf(\"syslogfacility %s\\n\", log_facility_name(o->log_facility));\n\n\t/* oProxyCommand / oProxyJump */\n\tif (o->jump_host == NULL)\n\t\tdump_cfg_string(oProxyCommand, o->proxy_command);\n\telse {\n\t\t/* Check for numeric addresses */\n\t\ti = strchr(o->jump_host, ':') != NULL ||\n\t\t    strspn(o->jump_host, \"1234567890.\") == strlen(o->jump_host);\n\t\tsnprintf(buf, sizeof(buf), \"%d\", o->jump_port);\n\t\tprintf(\"proxyjump %s%s%s%s%s%s%s%s%s\\n\",\n\t\t    /* optional additional jump spec */\n\t\t    o->jump_extra == NULL ? \"\" : o->jump_extra,\n\t\t    o->jump_extra == NULL ? \"\" : \",\",\n\t\t    /* optional user */\n\t\t    o->jump_user == NULL ? \"\" : o->jump_user,\n\t\t    o->jump_user == NULL ? \"\" : \"@\",\n\t\t    /* opening [ if hostname is numeric */\n\t\t    i ? \"[\" : \"\",\n\t\t    /* mandatory hostname */\n\t\t    o->jump_host,\n\t\t    /* closing ] if hostname is numeric */\n\t\t    i ? \"]\" : \"\",\n\t\t    /* optional port number */\n\t\t    o->jump_port <= 0 ? \"\" : \":\",\n\t\t    o->jump_port <= 0 ? \"\" : buf);\n\t}\n}"
  },
  {
    "function_name": "dump_cfg_forwards",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "2530-2566",
    "snippet": "static void\ndump_cfg_forwards(OpCodes code, u_int count, const struct Forward *fwds)\n{\n\tconst struct Forward *fwd;\n\tu_int i;\n\n\t/* oDynamicForward */\n\tfor (i = 0; i < count; i++) {\n\t\tfwd = &fwds[i];\n\t\tif (code == oDynamicForward && fwd->connect_host != NULL &&\n\t\t    strcmp(fwd->connect_host, \"socks\") != 0)\n\t\t\tcontinue;\n\t\tif (code == oLocalForward && fwd->connect_host != NULL &&\n\t\t    strcmp(fwd->connect_host, \"socks\") == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s\", lookup_opcode_name(code));\n\t\tif (fwd->listen_port == PORT_STREAMLOCAL)\n\t\t\tprintf(\" %s\", fwd->listen_path);\n\t\telse if (fwd->listen_host == NULL)\n\t\t\tprintf(\" %d\", fwd->listen_port);\n\t\telse {\n\t\t\tprintf(\" [%s]:%d\",\n\t\t\t    fwd->listen_host, fwd->listen_port);\n\t\t}\n\t\tif (code != oDynamicForward) {\n\t\t\tif (fwd->connect_port == PORT_STREAMLOCAL)\n\t\t\t\tprintf(\" %s\", fwd->connect_path);\n\t\t\telse if (fwd->connect_host == NULL)\n\t\t\t\tprintf(\" %d\", fwd->connect_port);\n\t\t\telse {\n\t\t\t\tprintf(\" [%s]:%d\",\n\t\t\t\t    fwd->connect_host, fwd->connect_port);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 2564
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" [%s]:%d\"",
            "fwd->connect_host",
            "fwd->connect_port"
          ],
          "line": 2560
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_opcode_name",
          "args": [
            "code"
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_opcode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2479-2488",
          "snippet": "static const char *\nlookup_opcode_name(OpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t/* Deprecated options */\n\t{ \"protocol\", oIgnore }, /* NB. silently ignored */\n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t/* Unsupported options */\n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\n\t/* Sometimes-unsupported options */\n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"smartcarddevice\", oPKCS11Provider },\n\t{ \"pkcs11provider\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t    /* alias */\n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"challengeresponseauthentication\", oChallengeResponseAuthentication },\n\t{ \"skeyauthentication\", oUnsupported },\n\t{ \"tisauthentication\", oChallengeResponseAuthentication },  /* alias */\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t/* obsolete */\n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostName },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t/* obsolete */\n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedkeytypes\", oHostbasedKeyTypes },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedKeyTypes },\n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\n\t{ NULL, oBadOption }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t/* Deprecated options */\n\t{ \"protocol\", oIgnore }, /* NB. silently ignored */\n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t/* Unsupported options */\n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\n\t/* Sometimes-unsupported options */\n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"smartcarddevice\", oPKCS11Provider },\n\t{ \"pkcs11provider\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t    /* alias */\n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"challengeresponseauthentication\", oChallengeResponseAuthentication },\n\t{ \"skeyauthentication\", oUnsupported },\n\t{ \"tisauthentication\", oChallengeResponseAuthentication },  /* alias */\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t/* obsolete */\n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostName },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t/* obsolete */\n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedkeytypes\", oHostbasedKeyTypes },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedKeyTypes },\n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\n\t{ NULL, oBadOption }\n};\n\nstatic const char *\nlookup_opcode_name(OpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fwd->connect_host",
            "\"socks\""
          ],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_forwards(OpCodes code, u_int count, const struct Forward *fwds)\n{\n\tconst struct Forward *fwd;\n\tu_int i;\n\n\t/* oDynamicForward */\n\tfor (i = 0; i < count; i++) {\n\t\tfwd = &fwds[i];\n\t\tif (code == oDynamicForward && fwd->connect_host != NULL &&\n\t\t    strcmp(fwd->connect_host, \"socks\") != 0)\n\t\t\tcontinue;\n\t\tif (code == oLocalForward && fwd->connect_host != NULL &&\n\t\t    strcmp(fwd->connect_host, \"socks\") == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s\", lookup_opcode_name(code));\n\t\tif (fwd->listen_port == PORT_STREAMLOCAL)\n\t\t\tprintf(\" %s\", fwd->listen_path);\n\t\telse if (fwd->listen_host == NULL)\n\t\t\tprintf(\" %d\", fwd->listen_port);\n\t\telse {\n\t\t\tprintf(\" [%s]:%d\",\n\t\t\t    fwd->listen_host, fwd->listen_port);\n\t\t}\n\t\tif (code != oDynamicForward) {\n\t\t\tif (fwd->connect_port == PORT_STREAMLOCAL)\n\t\t\t\tprintf(\" %s\", fwd->connect_path);\n\t\t\telse if (fwd->connect_host == NULL)\n\t\t\t\tprintf(\" %d\", fwd->connect_port);\n\t\t\telse {\n\t\t\t\tprintf(\" [%s]:%d\",\n\t\t\t\t    fwd->connect_host, fwd->connect_port);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "dump_cfg_strarray_oneline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "2519-2528",
    "snippet": "static void\ndump_cfg_strarray_oneline(OpCodes code, u_int count, char **vals)\n{\n\tu_int i;\n\n\tprintf(\"%s\", lookup_opcode_name(code));\n\tfor (i = 0; i < count; i++)\n\t\tprintf(\" %s\",  vals[i]);\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 2527
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" %s\"",
            "vals[i]"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_opcode_name",
          "args": [
            "code"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_opcode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2479-2488",
          "snippet": "static const char *\nlookup_opcode_name(OpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t/* Deprecated options */\n\t{ \"protocol\", oIgnore }, /* NB. silently ignored */\n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t/* Unsupported options */\n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\n\t/* Sometimes-unsupported options */\n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"smartcarddevice\", oPKCS11Provider },\n\t{ \"pkcs11provider\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t    /* alias */\n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"challengeresponseauthentication\", oChallengeResponseAuthentication },\n\t{ \"skeyauthentication\", oUnsupported },\n\t{ \"tisauthentication\", oChallengeResponseAuthentication },  /* alias */\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t/* obsolete */\n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostName },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t/* obsolete */\n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedkeytypes\", oHostbasedKeyTypes },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedKeyTypes },\n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\n\t{ NULL, oBadOption }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t/* Deprecated options */\n\t{ \"protocol\", oIgnore }, /* NB. silently ignored */\n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t/* Unsupported options */\n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\n\t/* Sometimes-unsupported options */\n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"smartcarddevice\", oPKCS11Provider },\n\t{ \"pkcs11provider\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t    /* alias */\n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"challengeresponseauthentication\", oChallengeResponseAuthentication },\n\t{ \"skeyauthentication\", oUnsupported },\n\t{ \"tisauthentication\", oChallengeResponseAuthentication },  /* alias */\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t/* obsolete */\n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostName },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t/* obsolete */\n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedkeytypes\", oHostbasedKeyTypes },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedKeyTypes },\n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\n\t{ NULL, oBadOption }\n};\n\nstatic const char *\nlookup_opcode_name(OpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_strarray_oneline(OpCodes code, u_int count, char **vals)\n{\n\tu_int i;\n\n\tprintf(\"%s\", lookup_opcode_name(code));\n\tfor (i = 0; i < count; i++)\n\t\tprintf(\" %s\",  vals[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "dump_cfg_strarray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "2510-2517",
    "snippet": "static void\ndump_cfg_strarray(OpCodes code, u_int count, char **vals)\n{\n\tu_int i;\n\n\tfor (i = 0; i < count; i++)\n\t\tprintf(\"%s %s\\n\", lookup_opcode_name(code), vals[i]);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "lookup_opcode_name(code)",
            "vals[i]"
          ],
          "line": 2516
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_opcode_name",
          "args": [
            "code"
          ],
          "line": 2516
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_opcode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2479-2488",
          "snippet": "static const char *\nlookup_opcode_name(OpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t/* Deprecated options */\n\t{ \"protocol\", oIgnore }, /* NB. silently ignored */\n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t/* Unsupported options */\n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\n\t/* Sometimes-unsupported options */\n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"smartcarddevice\", oPKCS11Provider },\n\t{ \"pkcs11provider\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t    /* alias */\n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"challengeresponseauthentication\", oChallengeResponseAuthentication },\n\t{ \"skeyauthentication\", oUnsupported },\n\t{ \"tisauthentication\", oChallengeResponseAuthentication },  /* alias */\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t/* obsolete */\n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostName },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t/* obsolete */\n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedkeytypes\", oHostbasedKeyTypes },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedKeyTypes },\n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\n\t{ NULL, oBadOption }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t/* Deprecated options */\n\t{ \"protocol\", oIgnore }, /* NB. silently ignored */\n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t/* Unsupported options */\n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\n\t/* Sometimes-unsupported options */\n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"smartcarddevice\", oPKCS11Provider },\n\t{ \"pkcs11provider\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t    /* alias */\n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"challengeresponseauthentication\", oChallengeResponseAuthentication },\n\t{ \"skeyauthentication\", oUnsupported },\n\t{ \"tisauthentication\", oChallengeResponseAuthentication },  /* alias */\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t/* obsolete */\n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostName },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t/* obsolete */\n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedkeytypes\", oHostbasedKeyTypes },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedKeyTypes },\n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\n\t{ NULL, oBadOption }\n};\n\nstatic const char *\nlookup_opcode_name(OpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_strarray(OpCodes code, u_int count, char **vals)\n{\n\tu_int i;\n\n\tfor (i = 0; i < count; i++)\n\t\tprintf(\"%s %s\\n\", lookup_opcode_name(code), vals[i]);\n}"
  },
  {
    "function_name": "dump_cfg_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "2502-2508",
    "snippet": "static void\ndump_cfg_string(OpCodes code, const char *val)\n{\n\tif (val == NULL)\n\t\treturn;\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code), val);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "lookup_opcode_name(code)",
            "val"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_opcode_name",
          "args": [
            "code"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_opcode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2479-2488",
          "snippet": "static const char *\nlookup_opcode_name(OpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t/* Deprecated options */\n\t{ \"protocol\", oIgnore }, /* NB. silently ignored */\n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t/* Unsupported options */\n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\n\t/* Sometimes-unsupported options */\n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"smartcarddevice\", oPKCS11Provider },\n\t{ \"pkcs11provider\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t    /* alias */\n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"challengeresponseauthentication\", oChallengeResponseAuthentication },\n\t{ \"skeyauthentication\", oUnsupported },\n\t{ \"tisauthentication\", oChallengeResponseAuthentication },  /* alias */\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t/* obsolete */\n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostName },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t/* obsolete */\n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedkeytypes\", oHostbasedKeyTypes },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedKeyTypes },\n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\n\t{ NULL, oBadOption }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t/* Deprecated options */\n\t{ \"protocol\", oIgnore }, /* NB. silently ignored */\n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t/* Unsupported options */\n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\n\t/* Sometimes-unsupported options */\n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"smartcarddevice\", oPKCS11Provider },\n\t{ \"pkcs11provider\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t    /* alias */\n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"challengeresponseauthentication\", oChallengeResponseAuthentication },\n\t{ \"skeyauthentication\", oUnsupported },\n\t{ \"tisauthentication\", oChallengeResponseAuthentication },  /* alias */\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t/* obsolete */\n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostName },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t/* obsolete */\n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedkeytypes\", oHostbasedKeyTypes },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedKeyTypes },\n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\n\t{ NULL, oBadOption }\n};\n\nstatic const char *\nlookup_opcode_name(OpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_string(OpCodes code, const char *val)\n{\n\tif (val == NULL)\n\t\treturn;\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code), val);\n}"
  },
  {
    "function_name": "dump_cfg_fmtint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "2496-2500",
    "snippet": "static void\ndump_cfg_fmtint(OpCodes code, int val)\n{\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code), fmt_intarg(code, val));\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "lookup_opcode_name(code)",
            "fmt_intarg(code, val)"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmt_intarg",
          "args": [
            "code",
            "val"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_intarg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2442-2477",
          "snippet": "static const char *\nfmt_intarg(OpCodes code, int val)\n{\n\tif (val == -1)\n\t\treturn \"unset\";\n\tswitch (code) {\n\tcase oAddressFamily:\n\t\treturn fmt_multistate_int(val, multistate_addressfamily);\n\tcase oVerifyHostKeyDNS:\n\tcase oUpdateHostkeys:\n\t\treturn fmt_multistate_int(val, multistate_yesnoask);\n\tcase oStrictHostKeyChecking:\n\t\treturn fmt_multistate_int(val, multistate_strict_hostkey);\n\tcase oControlMaster:\n\t\treturn fmt_multistate_int(val, multistate_controlmaster);\n\tcase oTunnel:\n\t\treturn fmt_multistate_int(val, multistate_tunnel);\n\tcase oRequestTTY:\n\t\treturn fmt_multistate_int(val, multistate_requesttty);\n\tcase oCanonicalizeHostname:\n\t\treturn fmt_multistate_int(val, multistate_canonicalizehostname);\n\tcase oAddKeysToAgent:\n\t\treturn fmt_multistate_int(val, multistate_yesnoaskconfirm);\n\tcase oFingerprintHash:\n\t\treturn ssh_digest_alg_name(val);\n\tdefault:\n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\treturn \"no\";\n\t\tcase 1:\n\t\t\treturn \"yes\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct multistate multistate_yesnoask[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_strict_hostkey[] = {\n\t{ \"true\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"false\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"yes\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"no\",\t\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"ask\",\t\t\tSSH_STRICT_HOSTKEY_ASK },\n\t{ \"off\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"accept-new\",\t\t\tSSH_STRICT_HOSTKEY_NEW },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_yesnoaskconfirm[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ \"confirm\",\t\t\t3 },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_controlmaster[] = {\n\t{ \"true\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"yes\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"false\",\t\t\tSSHCTL_MASTER_NO },\n\t{ \"no\",\t\t\t\tSSHCTL_MASTER_NO },\n\t{ \"auto\",\t\t\tSSHCTL_MASTER_AUTO },\n\t{ \"ask\",\t\t\tSSHCTL_MASTER_ASK },\n\t{ \"autoask\",\t\t\tSSHCTL_MASTER_AUTO_ASK },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_tunnel[] = {\n\t{ \"ethernet\",\t\t\tSSH_TUNMODE_ETHERNET },\n\t{ \"point-to-point\",\t\tSSH_TUNMODE_POINTOPOINT },\n\t{ \"true\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"yes\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"false\",\t\t\tSSH_TUNMODE_NO },\n\t{ \"no\",\t\t\t\tSSH_TUNMODE_NO },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_requesttty[] = {\n\t{ \"true\",\t\t\tREQUEST_TTY_YES },\n\t{ \"yes\",\t\t\tREQUEST_TTY_YES },\n\t{ \"false\",\t\t\tREQUEST_TTY_NO },\n\t{ \"no\",\t\t\t\tREQUEST_TTY_NO },\n\t{ \"force\",\t\t\tREQUEST_TTY_FORCE },\n\t{ \"auto\",\t\t\tREQUEST_TTY_AUTO },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_canonicalizehostname[] = {\n\t{ \"true\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"false\",\t\t\tSSH_CANONICALISE_NO },\n\t{ \"yes\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"no\",\t\t\t\tSSH_CANONICALISE_NO },\n\t{ \"always\",\t\t\tSSH_CANONICALISE_ALWAYS },\n\t{ NULL, -1 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct multistate multistate_yesnoask[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_strict_hostkey[] = {\n\t{ \"true\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"false\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"yes\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"no\",\t\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"ask\",\t\t\tSSH_STRICT_HOSTKEY_ASK },\n\t{ \"off\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"accept-new\",\t\t\tSSH_STRICT_HOSTKEY_NEW },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_yesnoaskconfirm[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ \"confirm\",\t\t\t3 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_controlmaster[] = {\n\t{ \"true\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"yes\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"false\",\t\t\tSSHCTL_MASTER_NO },\n\t{ \"no\",\t\t\t\tSSHCTL_MASTER_NO },\n\t{ \"auto\",\t\t\tSSHCTL_MASTER_AUTO },\n\t{ \"ask\",\t\t\tSSHCTL_MASTER_ASK },\n\t{ \"autoask\",\t\t\tSSHCTL_MASTER_AUTO_ASK },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_tunnel[] = {\n\t{ \"ethernet\",\t\t\tSSH_TUNMODE_ETHERNET },\n\t{ \"point-to-point\",\t\tSSH_TUNMODE_POINTOPOINT },\n\t{ \"true\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"yes\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"false\",\t\t\tSSH_TUNMODE_NO },\n\t{ \"no\",\t\t\t\tSSH_TUNMODE_NO },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_requesttty[] = {\n\t{ \"true\",\t\t\tREQUEST_TTY_YES },\n\t{ \"yes\",\t\t\tREQUEST_TTY_YES },\n\t{ \"false\",\t\t\tREQUEST_TTY_NO },\n\t{ \"no\",\t\t\t\tREQUEST_TTY_NO },\n\t{ \"force\",\t\t\tREQUEST_TTY_FORCE },\n\t{ \"auto\",\t\t\tREQUEST_TTY_AUTO },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_canonicalizehostname[] = {\n\t{ \"true\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"false\",\t\t\tSSH_CANONICALISE_NO },\n\t{ \"yes\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"no\",\t\t\t\tSSH_CANONICALISE_NO },\n\t{ \"always\",\t\t\tSSH_CANONICALISE_ALWAYS },\n\t{ NULL, -1 }\n};\n\nstatic const char *\nfmt_intarg(OpCodes code, int val)\n{\n\tif (val == -1)\n\t\treturn \"unset\";\n\tswitch (code) {\n\tcase oAddressFamily:\n\t\treturn fmt_multistate_int(val, multistate_addressfamily);\n\tcase oVerifyHostKeyDNS:\n\tcase oUpdateHostkeys:\n\t\treturn fmt_multistate_int(val, multistate_yesnoask);\n\tcase oStrictHostKeyChecking:\n\t\treturn fmt_multistate_int(val, multistate_strict_hostkey);\n\tcase oControlMaster:\n\t\treturn fmt_multistate_int(val, multistate_controlmaster);\n\tcase oTunnel:\n\t\treturn fmt_multistate_int(val, multistate_tunnel);\n\tcase oRequestTTY:\n\t\treturn fmt_multistate_int(val, multistate_requesttty);\n\tcase oCanonicalizeHostname:\n\t\treturn fmt_multistate_int(val, multistate_canonicalizehostname);\n\tcase oAddKeysToAgent:\n\t\treturn fmt_multistate_int(val, multistate_yesnoaskconfirm);\n\tcase oFingerprintHash:\n\t\treturn ssh_digest_alg_name(val);\n\tdefault:\n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\treturn \"no\";\n\t\tcase 1:\n\t\t\treturn \"yes\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_opcode_name",
          "args": [
            "code"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_opcode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2479-2488",
          "snippet": "static const char *\nlookup_opcode_name(OpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t/* Deprecated options */\n\t{ \"protocol\", oIgnore }, /* NB. silently ignored */\n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t/* Unsupported options */\n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\n\t/* Sometimes-unsupported options */\n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"smartcarddevice\", oPKCS11Provider },\n\t{ \"pkcs11provider\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t    /* alias */\n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"challengeresponseauthentication\", oChallengeResponseAuthentication },\n\t{ \"skeyauthentication\", oUnsupported },\n\t{ \"tisauthentication\", oChallengeResponseAuthentication },  /* alias */\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t/* obsolete */\n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostName },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t/* obsolete */\n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedkeytypes\", oHostbasedKeyTypes },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedKeyTypes },\n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\n\t{ NULL, oBadOption }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t/* Deprecated options */\n\t{ \"protocol\", oIgnore }, /* NB. silently ignored */\n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t/* Unsupported options */\n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\n\t/* Sometimes-unsupported options */\n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"smartcarddevice\", oPKCS11Provider },\n\t{ \"pkcs11provider\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t    /* alias */\n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"challengeresponseauthentication\", oChallengeResponseAuthentication },\n\t{ \"skeyauthentication\", oUnsupported },\n\t{ \"tisauthentication\", oChallengeResponseAuthentication },  /* alias */\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t/* obsolete */\n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostName },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t/* obsolete */\n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedkeytypes\", oHostbasedKeyTypes },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedKeyTypes },\n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\n\t{ NULL, oBadOption }\n};\n\nstatic const char *\nlookup_opcode_name(OpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_fmtint(OpCodes code, int val)\n{\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code), fmt_intarg(code, val));\n}"
  },
  {
    "function_name": "dump_cfg_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "2490-2494",
    "snippet": "static void\ndump_cfg_int(OpCodes code, int val)\n{\n\tprintf(\"%s %d\\n\", lookup_opcode_name(code), val);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %d\\n\"",
            "lookup_opcode_name(code)",
            "val"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_opcode_name",
          "args": [
            "code"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_opcode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2479-2488",
          "snippet": "static const char *\nlookup_opcode_name(OpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t/* Deprecated options */\n\t{ \"protocol\", oIgnore }, /* NB. silently ignored */\n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t/* Unsupported options */\n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\n\t/* Sometimes-unsupported options */\n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"smartcarddevice\", oPKCS11Provider },\n\t{ \"pkcs11provider\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t    /* alias */\n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"challengeresponseauthentication\", oChallengeResponseAuthentication },\n\t{ \"skeyauthentication\", oUnsupported },\n\t{ \"tisauthentication\", oChallengeResponseAuthentication },  /* alias */\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t/* obsolete */\n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostName },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t/* obsolete */\n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedkeytypes\", oHostbasedKeyTypes },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedKeyTypes },\n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\n\t{ NULL, oBadOption }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t/* Deprecated options */\n\t{ \"protocol\", oIgnore }, /* NB. silently ignored */\n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t/* Unsupported options */\n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\n\t/* Sometimes-unsupported options */\n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"smartcarddevice\", oPKCS11Provider },\n\t{ \"pkcs11provider\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t    /* alias */\n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"challengeresponseauthentication\", oChallengeResponseAuthentication },\n\t{ \"skeyauthentication\", oUnsupported },\n\t{ \"tisauthentication\", oChallengeResponseAuthentication },  /* alias */\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t/* obsolete */\n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostName },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t/* obsolete */\n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedkeytypes\", oHostbasedKeyTypes },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedKeyTypes },\n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\n\t{ NULL, oBadOption }\n};\n\nstatic const char *\nlookup_opcode_name(OpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump_cfg_int(OpCodes code, int val)\n{\n\tprintf(\"%s %d\\n\", lookup_opcode_name(code), val);\n}"
  },
  {
    "function_name": "lookup_opcode_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "2479-2488",
    "snippet": "static const char *\nlookup_opcode_name(OpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t/* Deprecated options */\n\t{ \"protocol\", oIgnore }, /* NB. silently ignored */\n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t/* Unsupported options */\n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\n\t/* Sometimes-unsupported options */\n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"smartcarddevice\", oPKCS11Provider },\n\t{ \"pkcs11provider\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t    /* alias */\n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"challengeresponseauthentication\", oChallengeResponseAuthentication },\n\t{ \"skeyauthentication\", oUnsupported },\n\t{ \"tisauthentication\", oChallengeResponseAuthentication },  /* alias */\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t/* obsolete */\n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostName },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t/* obsolete */\n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedkeytypes\", oHostbasedKeyTypes },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedKeyTypes },\n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\n\t{ NULL, oBadOption }\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t/* Deprecated options */\n\t{ \"protocol\", oIgnore }, /* NB. silently ignored */\n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t/* Unsupported options */\n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\n\t/* Sometimes-unsupported options */\n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"smartcarddevice\", oPKCS11Provider },\n\t{ \"pkcs11provider\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t    /* alias */\n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"challengeresponseauthentication\", oChallengeResponseAuthentication },\n\t{ \"skeyauthentication\", oUnsupported },\n\t{ \"tisauthentication\", oChallengeResponseAuthentication },  /* alias */\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t/* obsolete */\n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostName },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t/* obsolete */\n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedkeytypes\", oHostbasedKeyTypes },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedKeyTypes },\n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\n\t{ NULL, oBadOption }\n};\n\nstatic const char *\nlookup_opcode_name(OpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}"
  },
  {
    "function_name": "fmt_intarg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "2442-2477",
    "snippet": "static const char *\nfmt_intarg(OpCodes code, int val)\n{\n\tif (val == -1)\n\t\treturn \"unset\";\n\tswitch (code) {\n\tcase oAddressFamily:\n\t\treturn fmt_multistate_int(val, multistate_addressfamily);\n\tcase oVerifyHostKeyDNS:\n\tcase oUpdateHostkeys:\n\t\treturn fmt_multistate_int(val, multistate_yesnoask);\n\tcase oStrictHostKeyChecking:\n\t\treturn fmt_multistate_int(val, multistate_strict_hostkey);\n\tcase oControlMaster:\n\t\treturn fmt_multistate_int(val, multistate_controlmaster);\n\tcase oTunnel:\n\t\treturn fmt_multistate_int(val, multistate_tunnel);\n\tcase oRequestTTY:\n\t\treturn fmt_multistate_int(val, multistate_requesttty);\n\tcase oCanonicalizeHostname:\n\t\treturn fmt_multistate_int(val, multistate_canonicalizehostname);\n\tcase oAddKeysToAgent:\n\t\treturn fmt_multistate_int(val, multistate_yesnoaskconfirm);\n\tcase oFingerprintHash:\n\t\treturn ssh_digest_alg_name(val);\n\tdefault:\n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\treturn \"no\";\n\t\tcase 1:\n\t\t\treturn \"yes\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct multistate multistate_yesnoask[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_strict_hostkey[] = {\n\t{ \"true\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"false\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"yes\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"no\",\t\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"ask\",\t\t\tSSH_STRICT_HOSTKEY_ASK },\n\t{ \"off\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"accept-new\",\t\t\tSSH_STRICT_HOSTKEY_NEW },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_yesnoaskconfirm[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ \"confirm\",\t\t\t3 },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_controlmaster[] = {\n\t{ \"true\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"yes\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"false\",\t\t\tSSHCTL_MASTER_NO },\n\t{ \"no\",\t\t\t\tSSHCTL_MASTER_NO },\n\t{ \"auto\",\t\t\tSSHCTL_MASTER_AUTO },\n\t{ \"ask\",\t\t\tSSHCTL_MASTER_ASK },\n\t{ \"autoask\",\t\t\tSSHCTL_MASTER_AUTO_ASK },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_tunnel[] = {\n\t{ \"ethernet\",\t\t\tSSH_TUNMODE_ETHERNET },\n\t{ \"point-to-point\",\t\tSSH_TUNMODE_POINTOPOINT },\n\t{ \"true\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"yes\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"false\",\t\t\tSSH_TUNMODE_NO },\n\t{ \"no\",\t\t\t\tSSH_TUNMODE_NO },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_requesttty[] = {\n\t{ \"true\",\t\t\tREQUEST_TTY_YES },\n\t{ \"yes\",\t\t\tREQUEST_TTY_YES },\n\t{ \"false\",\t\t\tREQUEST_TTY_NO },\n\t{ \"no\",\t\t\t\tREQUEST_TTY_NO },\n\t{ \"force\",\t\t\tREQUEST_TTY_FORCE },\n\t{ \"auto\",\t\t\tREQUEST_TTY_AUTO },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_canonicalizehostname[] = {\n\t{ \"true\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"false\",\t\t\tSSH_CANONICALISE_NO },\n\t{ \"yes\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"no\",\t\t\t\tSSH_CANONICALISE_NO },\n\t{ \"always\",\t\t\tSSH_CANONICALISE_ALWAYS },\n\t{ NULL, -1 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_digest_alg_name",
          "args": [
            "val"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_alg_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "135-141",
          "snippet": "const char *\nssh_digest_alg_name(int alg)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(alg);\n\n\treturn digest == NULL ? NULL : digest->name;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_digest_alg_name(int alg)\n{\n\tconst struct ssh_digest *digest = ssh_digest_by_alg(alg);\n\n\treturn digest == NULL ? NULL : digest->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmt_multistate_int",
          "args": [
            "val",
            "multistate_yesnoaskconfirm"
          ],
          "line": 2464
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2430-2440",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct multistate multistate_yesnoask[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_strict_hostkey[] = {\n\t{ \"true\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"false\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"yes\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"no\",\t\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"ask\",\t\t\tSSH_STRICT_HOSTKEY_ASK },\n\t{ \"off\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"accept-new\",\t\t\tSSH_STRICT_HOSTKEY_NEW },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_yesnoaskconfirm[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ \"confirm\",\t\t\t3 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_controlmaster[] = {\n\t{ \"true\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"yes\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"false\",\t\t\tSSHCTL_MASTER_NO },\n\t{ \"no\",\t\t\t\tSSHCTL_MASTER_NO },\n\t{ \"auto\",\t\t\tSSHCTL_MASTER_AUTO },\n\t{ \"ask\",\t\t\tSSHCTL_MASTER_ASK },\n\t{ \"autoask\",\t\t\tSSHCTL_MASTER_AUTO_ASK },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_tunnel[] = {\n\t{ \"ethernet\",\t\t\tSSH_TUNMODE_ETHERNET },\n\t{ \"point-to-point\",\t\tSSH_TUNMODE_POINTOPOINT },\n\t{ \"true\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"yes\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"false\",\t\t\tSSH_TUNMODE_NO },\n\t{ \"no\",\t\t\t\tSSH_TUNMODE_NO },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_requesttty[] = {\n\t{ \"true\",\t\t\tREQUEST_TTY_YES },\n\t{ \"yes\",\t\t\tREQUEST_TTY_YES },\n\t{ \"false\",\t\t\tREQUEST_TTY_NO },\n\t{ \"no\",\t\t\t\tREQUEST_TTY_NO },\n\t{ \"force\",\t\t\tREQUEST_TTY_FORCE },\n\t{ \"auto\",\t\t\tREQUEST_TTY_AUTO },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_canonicalizehostname[] = {\n\t{ \"true\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"false\",\t\t\tSSH_CANONICALISE_NO },\n\t{ \"yes\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"no\",\t\t\t\tSSH_CANONICALISE_NO },\n\t{ \"always\",\t\t\tSSH_CANONICALISE_ALWAYS },\n\t{ NULL, -1 }\n};\n\nstatic const char *\nfmt_intarg(OpCodes code, int val)\n{\n\tif (val == -1)\n\t\treturn \"unset\";\n\tswitch (code) {\n\tcase oAddressFamily:\n\t\treturn fmt_multistate_int(val, multistate_addressfamily);\n\tcase oVerifyHostKeyDNS:\n\tcase oUpdateHostkeys:\n\t\treturn fmt_multistate_int(val, multistate_yesnoask);\n\tcase oStrictHostKeyChecking:\n\t\treturn fmt_multistate_int(val, multistate_strict_hostkey);\n\tcase oControlMaster:\n\t\treturn fmt_multistate_int(val, multistate_controlmaster);\n\tcase oTunnel:\n\t\treturn fmt_multistate_int(val, multistate_tunnel);\n\tcase oRequestTTY:\n\t\treturn fmt_multistate_int(val, multistate_requesttty);\n\tcase oCanonicalizeHostname:\n\t\treturn fmt_multistate_int(val, multistate_canonicalizehostname);\n\tcase oAddKeysToAgent:\n\t\treturn fmt_multistate_int(val, multistate_yesnoaskconfirm);\n\tcase oFingerprintHash:\n\t\treturn ssh_digest_alg_name(val);\n\tdefault:\n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\treturn \"no\";\n\t\tcase 1:\n\t\t\treturn \"yes\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "fmt_multistate_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "2430-2440",
    "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
  },
  {
    "function_name": "parse_ssh_uri",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "2417-2427",
    "snippet": "int\nparse_ssh_uri(const char *uri, char **userp, char **hostp, int *portp)\n{\n\tchar *path;\n\tint r;\n\n\tr = parse_uri(\"ssh\", uri, userp, hostp, portp, &path);\n\tif (r == 0 && path != NULL)\n\t\tr = -1;\t\t/* path not allowed */\n\treturn r;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_uri",
          "args": [
            "\"ssh\"",
            "uri",
            "userp",
            "hostp",
            "portp",
            "&path"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "parse_uri",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "769-858",
          "snippet": "int\nparse_uri(const char *scheme, const char *uri, char **userp, char **hostp,\n    int *portp, char **pathp)\n{\n\tchar *uridup, *cp, *tmp, ch;\n\tchar *user = NULL, *host = NULL, *path = NULL;\n\tint port = -1, ret = -1;\n\tsize_t len;\n\n\tlen = strlen(scheme);\n\tif (strncmp(uri, scheme, len) != 0 || strncmp(uri + len, \"://\", 3) != 0)\n\t\treturn 1;\n\turi += len + 3;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (hostp != NULL)\n\t\t*hostp = NULL;\n\tif (portp != NULL)\n\t\t*portp = -1;\n\tif (pathp != NULL)\n\t\t*pathp = NULL;\n\n\turidup = tmp = xstrdup(uri);\n\n\t/* Extract optional ssh-info (username + connection params) */\n\tif ((cp = strchr(tmp, '@')) != NULL) {\n\t\tchar *delim;\n\n\t\t*cp = '\\0';\n\t\t/* Extract username and connection params */\n\t\tif ((delim = strchr(tmp, ';')) != NULL) {\n\t\t\t/* Just ignore connection params for now */\n\t\t\t*delim = '\\0';\n\t\t}\n\t\tif (*tmp == '\\0') {\n\t\t\t/* Empty username */\n\t\t\tgoto out;\n\t\t}\n\t\tif ((user = urldecode(tmp)) == NULL)\n\t\t\tgoto out;\n\t\ttmp = cp + 1;\n\t}\n\n\t/* Extract mandatory hostname */\n\tif ((cp = hpdelim2(&tmp, &ch)) == NULL || *cp == '\\0')\n\t\tgoto out;\n\thost = xstrdup(cleanhostname(cp));\n\tif (!valid_domain(host, 0, NULL))\n\t\tgoto out;\n\n\tif (tmp != NULL && *tmp != '\\0') {\n\t\tif (ch == ':') {\n\t\t\t/* Convert and verify port. */\n\t\t\tif ((cp = strchr(tmp, '/')) != NULL)\n\t\t\t\t*cp = '\\0';\n\t\t\tif ((port = a2port(tmp)) <= 0)\n\t\t\t\tgoto out;\n\t\t\ttmp = cp ? cp + 1 : NULL;\n\t\t}\n\t\tif (tmp != NULL && *tmp != '\\0') {\n\t\t\t/* Extract optional path */\n\t\t\tif ((path = urldecode(tmp)) == NULL)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Success */\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (hostp != NULL) {\n\t\t*hostp = host;\n\t\thost = NULL;\n\t}\n\tif (portp != NULL)\n\t\t*portp = port;\n\tif (pathp != NULL) {\n\t\t*pathp = path;\n\t\tpath = NULL;\n\t}\n\tret = 0;\n out:\n\tfree(uridup);\n\tfree(user);\n\tfree(host);\n\tfree(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_uri(const char *scheme, const char *uri, char **userp, char **hostp,\n    int *portp, char **pathp)\n{\n\tchar *uridup, *cp, *tmp, ch;\n\tchar *user = NULL, *host = NULL, *path = NULL;\n\tint port = -1, ret = -1;\n\tsize_t len;\n\n\tlen = strlen(scheme);\n\tif (strncmp(uri, scheme, len) != 0 || strncmp(uri + len, \"://\", 3) != 0)\n\t\treturn 1;\n\turi += len + 3;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (hostp != NULL)\n\t\t*hostp = NULL;\n\tif (portp != NULL)\n\t\t*portp = -1;\n\tif (pathp != NULL)\n\t\t*pathp = NULL;\n\n\turidup = tmp = xstrdup(uri);\n\n\t/* Extract optional ssh-info (username + connection params) */\n\tif ((cp = strchr(tmp, '@')) != NULL) {\n\t\tchar *delim;\n\n\t\t*cp = '\\0';\n\t\t/* Extract username and connection params */\n\t\tif ((delim = strchr(tmp, ';')) != NULL) {\n\t\t\t/* Just ignore connection params for now */\n\t\t\t*delim = '\\0';\n\t\t}\n\t\tif (*tmp == '\\0') {\n\t\t\t/* Empty username */\n\t\t\tgoto out;\n\t\t}\n\t\tif ((user = urldecode(tmp)) == NULL)\n\t\t\tgoto out;\n\t\ttmp = cp + 1;\n\t}\n\n\t/* Extract mandatory hostname */\n\tif ((cp = hpdelim2(&tmp, &ch)) == NULL || *cp == '\\0')\n\t\tgoto out;\n\thost = xstrdup(cleanhostname(cp));\n\tif (!valid_domain(host, 0, NULL))\n\t\tgoto out;\n\n\tif (tmp != NULL && *tmp != '\\0') {\n\t\tif (ch == ':') {\n\t\t\t/* Convert and verify port. */\n\t\t\tif ((cp = strchr(tmp, '/')) != NULL)\n\t\t\t\t*cp = '\\0';\n\t\t\tif ((port = a2port(tmp)) <= 0)\n\t\t\t\tgoto out;\n\t\t\ttmp = cp ? cp + 1 : NULL;\n\t\t}\n\t\tif (tmp != NULL && *tmp != '\\0') {\n\t\t\t/* Extract optional path */\n\t\t\tif ((path = urldecode(tmp)) == NULL)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Success */\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (hostp != NULL) {\n\t\t*hostp = host;\n\t\thost = NULL;\n\t}\n\tif (portp != NULL)\n\t\t*portp = port;\n\tif (pathp != NULL) {\n\t\t*pathp = path;\n\t\tpath = NULL;\n\t}\n\tret = 0;\n out:\n\tfree(uridup);\n\tfree(user);\n\tfree(host);\n\tfree(path);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_ssh_uri(const char *uri, char **userp, char **hostp, int *portp)\n{\n\tchar *path;\n\tint r;\n\n\tr = parse_uri(\"ssh\", uri, userp, hostp, portp, &path);\n\tif (r == 0 && path != NULL)\n\t\tr = -1;\t\t/* path not allowed */\n\treturn r;\n}"
  },
  {
    "function_name": "parse_jump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "2360-2415",
    "snippet": "int\nparse_jump(const char *s, Options *o, int active)\n{\n\tchar *orig, *sdup, *cp;\n\tchar *host = NULL, *user = NULL;\n\tint ret = -1, port = -1, first;\n\n\tactive &= o->proxy_command == NULL && o->jump_host == NULL;\n\n\torig = sdup = xstrdup(s);\n\tfirst = active;\n\tdo {\n\t\tif (strcasecmp(s, \"none\") == 0)\n\t\t\tbreak;\n\t\tif ((cp = strrchr(sdup, ',')) == NULL)\n\t\t\tcp = sdup; /* last */\n\t\telse\n\t\t\t*cp++ = '\\0';\n\n\t\tif (first) {\n\t\t\t/* First argument and configuration is active */\n\t\t\tif (parse_ssh_uri(cp, &user, &host, &port) == -1 ||\n\t\t\t    parse_user_host_port(cp, &user, &host, &port) != 0)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\t/* Subsequent argument or inactive configuration */\n\t\t\tif (parse_ssh_uri(cp, NULL, NULL, NULL) == -1 ||\n\t\t\t    parse_user_host_port(cp, NULL, NULL, NULL) != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tfirst = 0; /* only check syntax for subsequent hosts */\n\t} while (cp != sdup);\n\t/* success */\n\tif (active) {\n\t\tif (strcasecmp(s, \"none\") == 0) {\n\t\t\to->jump_host = xstrdup(\"none\");\n\t\t\to->jump_port = 0;\n\t\t} else {\n\t\t\to->jump_user = user;\n\t\t\to->jump_host = host;\n\t\t\to->jump_port = port;\n\t\t\to->proxy_command = xstrdup(\"none\");\n\t\t\tuser = host = NULL;\n\t\t\tif ((cp = strrchr(s, ',')) != NULL && cp != s) {\n\t\t\t\to->jump_extra = xstrdup(s);\n\t\t\t\to->jump_extra[cp - s] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\n out:\n\tfree(orig);\n\tfree(user);\n\tfree(host);\n\treturn ret;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "host"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "s"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "s",
            "','"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "s",
            "\"none\""
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_user_host_port",
          "args": [
            "cp",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "parse_user_host_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "645-696",
          "snippet": "int\nparse_user_host_port(const char *s, char **userp, char **hostp, int *portp)\n{\n\tchar *sdup, *cp, *tmp;\n\tchar *user = NULL, *host = NULL;\n\tint port = -1, ret = -1;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (hostp != NULL)\n\t\t*hostp = NULL;\n\tif (portp != NULL)\n\t\t*portp = -1;\n\n\tif ((sdup = tmp = strdup(s)) == NULL)\n\t\treturn -1;\n\t/* Extract optional username */\n\tif ((cp = strrchr(tmp, '@')) != NULL) {\n\t\t*cp = '\\0';\n\t\tif (*tmp == '\\0')\n\t\t\tgoto out;\n\t\tif ((user = strdup(tmp)) == NULL)\n\t\t\tgoto out;\n\t\ttmp = cp + 1;\n\t}\n\t/* Extract mandatory hostname */\n\tif ((cp = hpdelim(&tmp)) == NULL || *cp == '\\0')\n\t\tgoto out;\n\thost = xstrdup(cleanhostname(cp));\n\t/* Convert and verify optional port */\n\tif (tmp != NULL && *tmp != '\\0') {\n\t\tif ((port = a2port(tmp)) <= 0)\n\t\t\tgoto out;\n\t}\n\t/* Success */\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (hostp != NULL) {\n\t\t*hostp = host;\n\t\thost = NULL;\n\t}\n\tif (portp != NULL)\n\t\t*portp = port;\n\tret = 0;\n out:\n\tfree(sdup);\n\tfree(user);\n\tfree(host);\n\treturn ret;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_user_host_port(const char *s, char **userp, char **hostp, int *portp)\n{\n\tchar *sdup, *cp, *tmp;\n\tchar *user = NULL, *host = NULL;\n\tint port = -1, ret = -1;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (hostp != NULL)\n\t\t*hostp = NULL;\n\tif (portp != NULL)\n\t\t*portp = -1;\n\n\tif ((sdup = tmp = strdup(s)) == NULL)\n\t\treturn -1;\n\t/* Extract optional username */\n\tif ((cp = strrchr(tmp, '@')) != NULL) {\n\t\t*cp = '\\0';\n\t\tif (*tmp == '\\0')\n\t\t\tgoto out;\n\t\tif ((user = strdup(tmp)) == NULL)\n\t\t\tgoto out;\n\t\ttmp = cp + 1;\n\t}\n\t/* Extract mandatory hostname */\n\tif ((cp = hpdelim(&tmp)) == NULL || *cp == '\\0')\n\t\tgoto out;\n\thost = xstrdup(cleanhostname(cp));\n\t/* Convert and verify optional port */\n\tif (tmp != NULL && *tmp != '\\0') {\n\t\tif ((port = a2port(tmp)) <= 0)\n\t\t\tgoto out;\n\t}\n\t/* Success */\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (hostp != NULL) {\n\t\t*hostp = host;\n\t\thost = NULL;\n\t}\n\tif (portp != NULL)\n\t\t*portp = port;\n\tret = 0;\n out:\n\tfree(sdup);\n\tfree(user);\n\tfree(host);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_ssh_uri",
          "args": [
            "cp",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 2386
        },
        "resolved": true,
        "details": {
          "function_name": "parse_ssh_uri",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2417-2427",
          "snippet": "int\nparse_ssh_uri(const char *uri, char **userp, char **hostp, int *portp)\n{\n\tchar *path;\n\tint r;\n\n\tr = parse_uri(\"ssh\", uri, userp, hostp, portp, &path);\n\tif (r == 0 && path != NULL)\n\t\tr = -1;\t\t/* path not allowed */\n\treturn r;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_ssh_uri(const char *uri, char **userp, char **hostp, int *portp)\n{\n\tchar *path;\n\tint r;\n\n\tr = parse_uri(\"ssh\", uri, userp, hostp, portp, &path);\n\tif (r == 0 && path != NULL)\n\t\tr = -1;\t\t/* path not allowed */\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "sdup",
            "','"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "s",
            "\"none\""
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_jump(const char *s, Options *o, int active)\n{\n\tchar *orig, *sdup, *cp;\n\tchar *host = NULL, *user = NULL;\n\tint ret = -1, port = -1, first;\n\n\tactive &= o->proxy_command == NULL && o->jump_host == NULL;\n\n\torig = sdup = xstrdup(s);\n\tfirst = active;\n\tdo {\n\t\tif (strcasecmp(s, \"none\") == 0)\n\t\t\tbreak;\n\t\tif ((cp = strrchr(sdup, ',')) == NULL)\n\t\t\tcp = sdup; /* last */\n\t\telse\n\t\t\t*cp++ = '\\0';\n\n\t\tif (first) {\n\t\t\t/* First argument and configuration is active */\n\t\t\tif (parse_ssh_uri(cp, &user, &host, &port) == -1 ||\n\t\t\t    parse_user_host_port(cp, &user, &host, &port) != 0)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\t/* Subsequent argument or inactive configuration */\n\t\t\tif (parse_ssh_uri(cp, NULL, NULL, NULL) == -1 ||\n\t\t\t    parse_user_host_port(cp, NULL, NULL, NULL) != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tfirst = 0; /* only check syntax for subsequent hosts */\n\t} while (cp != sdup);\n\t/* success */\n\tif (active) {\n\t\tif (strcasecmp(s, \"none\") == 0) {\n\t\t\to->jump_host = xstrdup(\"none\");\n\t\t\to->jump_port = 0;\n\t\t} else {\n\t\t\to->jump_user = user;\n\t\t\to->jump_host = host;\n\t\t\to->jump_port = port;\n\t\t\to->proxy_command = xstrdup(\"none\");\n\t\t\tuser = host = NULL;\n\t\t\tif ((cp = strrchr(s, ',')) != NULL && cp != s) {\n\t\t\t\to->jump_extra = xstrdup(s);\n\t\t\t\to->jump_extra[cp - s] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\n out:\n\tfree(orig);\n\tfree(user);\n\tfree(host);\n\treturn ret;\n}"
  },
  {
    "function_name": "parse_forward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "2229-2358",
    "snippet": "int\nparse_forward(struct Forward *fwd, const char *fwdspec, int dynamicfwd, int remotefwd)\n{\n\tstruct fwdarg fwdargs[4];\n\tchar *p, *cp;\n\tint i;\n\n\tmemset(fwd, 0, sizeof(*fwd));\n\tmemset(fwdargs, 0, sizeof(fwdargs));\n\n\tcp = p = xstrdup(fwdspec);\n\n\t/* skip leading spaces */\n\twhile (isspace((u_char)*cp))\n\t\tcp++;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (parse_fwd_field(&cp, &fwdargs[i]) != 0)\n\t\t\tbreak;\n\t}\n\n\t/* Check for trailing garbage */\n\tif (cp != NULL && *cp != '\\0') {\n\t\ti = 0;\t/* failure */\n\t}\n\n\tswitch (i) {\n\tcase 1:\n\t\tif (fwdargs[0].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t}\n\t\tfwd->connect_host = xstrdup(\"socks\");\n\t\tbreak;\n\n\tcase 2:\n\t\tif (fwdargs[0].ispath && fwdargs[1].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t\tfwd->connect_path = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else if (fwdargs[1].ispath) {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t\tfwd->connect_path = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\t\tfwd->connect_host = xstrdup(\"socks\");\n\t\t}\n\t\tbreak;\n\n\tcase 3:\n\t\tif (fwdargs[0].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t\tfwd->connect_host = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = a2port(fwdargs[2].arg);\n\t\t} else if (fwdargs[2].ispath) {\n\t\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\t\tfwd->connect_path = xstrdup(fwdargs[2].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t\tfwd->connect_host = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = a2port(fwdargs[2].arg);\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\tfwd->connect_host = xstrdup(fwdargs[2].arg);\n\t\tfwd->connect_port = a2port(fwdargs[3].arg);\n\t\tbreak;\n\tdefault:\n\t\ti = 0; /* failure */\n\t}\n\n\tfree(p);\n\n\tif (dynamicfwd) {\n\t\tif (!(i == 1 || i == 2))\n\t\t\tgoto fail_free;\n\t} else {\n\t\tif (!(i == 3 || i == 4)) {\n\t\t\tif (fwd->connect_path == NULL &&\n\t\t\t    fwd->listen_path == NULL)\n\t\t\t\tgoto fail_free;\n\t\t}\n\t\tif (fwd->connect_port <= 0 && fwd->connect_path == NULL)\n\t\t\tgoto fail_free;\n\t}\n\n\tif ((fwd->listen_port < 0 && fwd->listen_path == NULL) ||\n\t    (!remotefwd && fwd->listen_port == 0))\n\t\tgoto fail_free;\n\tif (fwd->connect_host != NULL &&\n\t    strlen(fwd->connect_host) >= NI_MAXHOST)\n\t\tgoto fail_free;\n\t/* XXX - if connecting to a remote socket, max sun len may not match this host */\n\tif (fwd->connect_path != NULL &&\n\t    strlen(fwd->connect_path) >= PATH_MAX_SUN)\n\t\tgoto fail_free;\n\tif (fwd->listen_host != NULL &&\n\t    strlen(fwd->listen_host) >= NI_MAXHOST)\n\t\tgoto fail_free;\n\tif (fwd->listen_path != NULL &&\n\t    strlen(fwd->listen_path) >= PATH_MAX_SUN)\n\t\tgoto fail_free;\n\n\treturn (i);\n\n fail_free:\n\tfree(fwd->connect_host);\n\tfwd->connect_host = NULL;\n\tfree(fwd->connect_path);\n\tfwd->connect_path = NULL;\n\tfree(fwd->listen_host);\n\tfwd->listen_host = NULL;\n\tfree(fwd->listen_path);\n\tfwd->listen_path = NULL;\n\treturn (0);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fwd->listen_path"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fwd->listen_path"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fwd->listen_host"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fwd->connect_path"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fwd->connect_host"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a2port",
          "args": [
            "fwdargs[3].arg"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "a2port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "333-346",
          "snippet": "int\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "fwdargs[2].arg"
          ],
          "line": 2307
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_fwd_field",
          "args": [
            "&cp",
            "&fwdargs[i]"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "parse_fwd_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2163-2217",
          "snippet": "static int\nparse_fwd_field(char **p, struct fwdarg *fwd)\n{\n\tchar *ep, *cp = *p;\n\tint ispath = 0;\n\n\tif (*cp == '\\0') {\n\t\t*p = NULL;\n\t\treturn -1;\t/* end of string */\n\t}\n\n\t/*\n\t * A field escaped with square brackets is used literally.\n\t * XXX - allow ']' to be escaped via backslash?\n\t */\n\tif (*cp == '[') {\n\t\t/* find matching ']' */\n\t\tfor (ep = cp + 1; *ep != ']' && *ep != '\\0'; ep++) {\n\t\t\tif (*ep == '/')\n\t\t\t\tispath = 1;\n\t\t}\n\t\t/* no matching ']' or not at end of field. */\n\t\tif (ep[0] != ']' || (ep[1] != ':' && ep[1] != '\\0'))\n\t\t\treturn -1;\n\t\t/* NUL terminate the field and advance p past the colon */\n\t\t*ep++ = '\\0';\n\t\tif (*ep != '\\0')\n\t\t\t*ep++ = '\\0';\n\t\tfwd->arg = cp + 1;\n\t\tfwd->ispath = ispath;\n\t\t*p = ep;\n\t\treturn 0;\n\t}\n\n\tfor (cp = *p; *cp != '\\0'; cp++) {\n\t\tswitch (*cp) {\n\t\tcase '\\\\':\n\t\t\tmemmove(cp, cp + 1, strlen(cp + 1) + 1);\n\t\t\tif (*cp == '\\0')\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tispath = 1;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t*cp++ = '\\0';\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tfwd->arg = *p;\n\tfwd->ispath = ispath;\n\t*p = cp;\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nparse_fwd_field(char **p, struct fwdarg *fwd)\n{\n\tchar *ep, *cp = *p;\n\tint ispath = 0;\n\n\tif (*cp == '\\0') {\n\t\t*p = NULL;\n\t\treturn -1;\t/* end of string */\n\t}\n\n\t/*\n\t * A field escaped with square brackets is used literally.\n\t * XXX - allow ']' to be escaped via backslash?\n\t */\n\tif (*cp == '[') {\n\t\t/* find matching ']' */\n\t\tfor (ep = cp + 1; *ep != ']' && *ep != '\\0'; ep++) {\n\t\t\tif (*ep == '/')\n\t\t\t\tispath = 1;\n\t\t}\n\t\t/* no matching ']' or not at end of field. */\n\t\tif (ep[0] != ']' || (ep[1] != ':' && ep[1] != '\\0'))\n\t\t\treturn -1;\n\t\t/* NUL terminate the field and advance p past the colon */\n\t\t*ep++ = '\\0';\n\t\tif (*ep != '\\0')\n\t\t\t*ep++ = '\\0';\n\t\tfwd->arg = cp + 1;\n\t\tfwd->ispath = ispath;\n\t\t*p = ep;\n\t\treturn 0;\n\t}\n\n\tfor (cp = *p; *cp != '\\0'; cp++) {\n\t\tswitch (*cp) {\n\t\tcase '\\\\':\n\t\t\tmemmove(cp, cp + 1, strlen(cp + 1) + 1);\n\t\t\tif (*cp == '\\0')\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tispath = 1;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t*cp++ = '\\0';\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tfwd->arg = *p;\n\tfwd->ispath = ispath;\n\t*p = cp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(u_char)*cp"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fwdargs",
            "0",
            "sizeof(fwdargs)"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fwd",
            "0",
            "sizeof(*fwd)"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_forward(struct Forward *fwd, const char *fwdspec, int dynamicfwd, int remotefwd)\n{\n\tstruct fwdarg fwdargs[4];\n\tchar *p, *cp;\n\tint i;\n\n\tmemset(fwd, 0, sizeof(*fwd));\n\tmemset(fwdargs, 0, sizeof(fwdargs));\n\n\tcp = p = xstrdup(fwdspec);\n\n\t/* skip leading spaces */\n\twhile (isspace((u_char)*cp))\n\t\tcp++;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (parse_fwd_field(&cp, &fwdargs[i]) != 0)\n\t\t\tbreak;\n\t}\n\n\t/* Check for trailing garbage */\n\tif (cp != NULL && *cp != '\\0') {\n\t\ti = 0;\t/* failure */\n\t}\n\n\tswitch (i) {\n\tcase 1:\n\t\tif (fwdargs[0].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t}\n\t\tfwd->connect_host = xstrdup(\"socks\");\n\t\tbreak;\n\n\tcase 2:\n\t\tif (fwdargs[0].ispath && fwdargs[1].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t\tfwd->connect_path = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else if (fwdargs[1].ispath) {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t\tfwd->connect_path = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\t\tfwd->connect_host = xstrdup(\"socks\");\n\t\t}\n\t\tbreak;\n\n\tcase 3:\n\t\tif (fwdargs[0].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t\tfwd->connect_host = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = a2port(fwdargs[2].arg);\n\t\t} else if (fwdargs[2].ispath) {\n\t\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\t\tfwd->connect_path = xstrdup(fwdargs[2].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t\tfwd->connect_host = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = a2port(fwdargs[2].arg);\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\tfwd->connect_host = xstrdup(fwdargs[2].arg);\n\t\tfwd->connect_port = a2port(fwdargs[3].arg);\n\t\tbreak;\n\tdefault:\n\t\ti = 0; /* failure */\n\t}\n\n\tfree(p);\n\n\tif (dynamicfwd) {\n\t\tif (!(i == 1 || i == 2))\n\t\t\tgoto fail_free;\n\t} else {\n\t\tif (!(i == 3 || i == 4)) {\n\t\t\tif (fwd->connect_path == NULL &&\n\t\t\t    fwd->listen_path == NULL)\n\t\t\t\tgoto fail_free;\n\t\t}\n\t\tif (fwd->connect_port <= 0 && fwd->connect_path == NULL)\n\t\t\tgoto fail_free;\n\t}\n\n\tif ((fwd->listen_port < 0 && fwd->listen_path == NULL) ||\n\t    (!remotefwd && fwd->listen_port == 0))\n\t\tgoto fail_free;\n\tif (fwd->connect_host != NULL &&\n\t    strlen(fwd->connect_host) >= NI_MAXHOST)\n\t\tgoto fail_free;\n\t/* XXX - if connecting to a remote socket, max sun len may not match this host */\n\tif (fwd->connect_path != NULL &&\n\t    strlen(fwd->connect_path) >= PATH_MAX_SUN)\n\t\tgoto fail_free;\n\tif (fwd->listen_host != NULL &&\n\t    strlen(fwd->listen_host) >= NI_MAXHOST)\n\t\tgoto fail_free;\n\tif (fwd->listen_path != NULL &&\n\t    strlen(fwd->listen_path) >= PATH_MAX_SUN)\n\t\tgoto fail_free;\n\n\treturn (i);\n\n fail_free:\n\tfree(fwd->connect_host);\n\tfwd->connect_host = NULL;\n\tfree(fwd->connect_path);\n\tfwd->connect_path = NULL;\n\tfree(fwd->listen_host);\n\tfwd->listen_host = NULL;\n\tfree(fwd->listen_path);\n\tfwd->listen_path = NULL;\n\treturn (0);\n}"
  },
  {
    "function_name": "parse_fwd_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "2163-2217",
    "snippet": "static int\nparse_fwd_field(char **p, struct fwdarg *fwd)\n{\n\tchar *ep, *cp = *p;\n\tint ispath = 0;\n\n\tif (*cp == '\\0') {\n\t\t*p = NULL;\n\t\treturn -1;\t/* end of string */\n\t}\n\n\t/*\n\t * A field escaped with square brackets is used literally.\n\t * XXX - allow ']' to be escaped via backslash?\n\t */\n\tif (*cp == '[') {\n\t\t/* find matching ']' */\n\t\tfor (ep = cp + 1; *ep != ']' && *ep != '\\0'; ep++) {\n\t\t\tif (*ep == '/')\n\t\t\t\tispath = 1;\n\t\t}\n\t\t/* no matching ']' or not at end of field. */\n\t\tif (ep[0] != ']' || (ep[1] != ':' && ep[1] != '\\0'))\n\t\t\treturn -1;\n\t\t/* NUL terminate the field and advance p past the colon */\n\t\t*ep++ = '\\0';\n\t\tif (*ep != '\\0')\n\t\t\t*ep++ = '\\0';\n\t\tfwd->arg = cp + 1;\n\t\tfwd->ispath = ispath;\n\t\t*p = ep;\n\t\treturn 0;\n\t}\n\n\tfor (cp = *p; *cp != '\\0'; cp++) {\n\t\tswitch (*cp) {\n\t\tcase '\\\\':\n\t\t\tmemmove(cp, cp + 1, strlen(cp + 1) + 1);\n\t\t\tif (*cp == '\\0')\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tispath = 1;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t*cp++ = '\\0';\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tfwd->arg = *p;\n\tfwd->ispath = ispath;\n\t*p = cp;\n\treturn 0;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "cp",
            "cp + 1",
            "strlen(cp + 1) + 1"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp + 1"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nparse_fwd_field(char **p, struct fwdarg *fwd)\n{\n\tchar *ep, *cp = *p;\n\tint ispath = 0;\n\n\tif (*cp == '\\0') {\n\t\t*p = NULL;\n\t\treturn -1;\t/* end of string */\n\t}\n\n\t/*\n\t * A field escaped with square brackets is used literally.\n\t * XXX - allow ']' to be escaped via backslash?\n\t */\n\tif (*cp == '[') {\n\t\t/* find matching ']' */\n\t\tfor (ep = cp + 1; *ep != ']' && *ep != '\\0'; ep++) {\n\t\t\tif (*ep == '/')\n\t\t\t\tispath = 1;\n\t\t}\n\t\t/* no matching ']' or not at end of field. */\n\t\tif (ep[0] != ']' || (ep[1] != ':' && ep[1] != '\\0'))\n\t\t\treturn -1;\n\t\t/* NUL terminate the field and advance p past the colon */\n\t\t*ep++ = '\\0';\n\t\tif (*ep != '\\0')\n\t\t\t*ep++ = '\\0';\n\t\tfwd->arg = cp + 1;\n\t\tfwd->ispath = ispath;\n\t\t*p = ep;\n\t\treturn 0;\n\t}\n\n\tfor (cp = *p; *cp != '\\0'; cp++) {\n\t\tswitch (*cp) {\n\t\tcase '\\\\':\n\t\t\tmemmove(cp, cp + 1, strlen(cp + 1) + 1);\n\t\t\tif (*cp == '\\0')\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tispath = 1;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t*cp++ = '\\0';\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tfwd->arg = *p;\n\tfwd->ispath = ispath;\n\t*p = cp;\n\treturn 0;\n}"
  },
  {
    "function_name": "fill_default_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "1950-2149",
    "snippet": "void\nfill_default_options(Options * options)\n{\n\tchar *all_cipher, *all_mac, *all_kex, *all_key, *all_sig;\n\tint r;\n\n\tif (options->forward_agent == -1)\n\t\toptions->forward_agent = 0;\n\tif (options->forward_x11 == -1)\n\t\toptions->forward_x11 = 0;\n\tif (options->forward_x11_trusted == -1)\n\t\toptions->forward_x11_trusted = 0;\n\tif (options->forward_x11_timeout == -1)\n\t\toptions->forward_x11_timeout = 1200;\n\t/*\n\t * stdio forwarding (-W) changes the default for these but we defer\n\t * setting the values so they can be overridden.\n\t */\n\tif (options->exit_on_forward_failure == -1)\n\t\toptions->exit_on_forward_failure =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == -1)\n\t\toptions->clear_forwardings =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == 1)\n\t\tclear_forwardings(options);\n\n\tif (options->xauth_location == NULL)\n\t\toptions->xauth_location = _PATH_XAUTH;\n\tif (options->fwd_opts.gateway_ports == -1)\n\t\toptions->fwd_opts.gateway_ports = 0;\n\tif (options->fwd_opts.streamlocal_bind_mask == (mode_t)-1)\n\t\toptions->fwd_opts.streamlocal_bind_mask = 0177;\n\tif (options->fwd_opts.streamlocal_bind_unlink == -1)\n\t\toptions->fwd_opts.streamlocal_bind_unlink = 0;\n\tif (options->pubkey_authentication == -1)\n\t\toptions->pubkey_authentication = 1;\n\tif (options->challenge_response_authentication == -1)\n\t\toptions->challenge_response_authentication = 1;\n\tif (options->gss_authentication == -1)\n\t\toptions->gss_authentication = 0;\n\tif (options->gss_deleg_creds == -1)\n\t\toptions->gss_deleg_creds = 0;\n\tif (options->password_authentication == -1)\n\t\toptions->password_authentication = 1;\n\tif (options->kbd_interactive_authentication == -1)\n\t\toptions->kbd_interactive_authentication = 1;\n\tif (options->hostbased_authentication == -1)\n\t\toptions->hostbased_authentication = 0;\n\tif (options->batch_mode == -1)\n\t\toptions->batch_mode = 0;\n\tif (options->check_host_ip == -1)\n\t\toptions->check_host_ip = 1;\n\tif (options->strict_host_key_checking == -1)\n\t\toptions->strict_host_key_checking = SSH_STRICT_HOSTKEY_ASK;\n\tif (options->compression == -1)\n\t\toptions->compression = 0;\n\tif (options->tcp_keep_alive == -1)\n\t\toptions->tcp_keep_alive = 1;\n\tif (options->port == -1)\n\t\toptions->port = 0;\t/* Filled in ssh_connect. */\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\tif (options->connection_attempts == -1)\n\t\toptions->connection_attempts = 1;\n\tif (options->number_of_password_prompts == -1)\n\t\toptions->number_of_password_prompts = 3;\n\t/* options->hostkeyalgorithms, default set in myproposals.h */\n\tif (options->add_keys_to_agent == -1)\n\t\toptions->add_keys_to_agent = 0;\n\tif (options->num_identity_files == 0) {\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_RSA, 0);\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_DSA, 0);\n#ifdef OPENSSL_HAS_ECC\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_ECDSA, 0);\n#endif\n\t\tadd_identity_file(options, \"~/\",\n\t\t    _PATH_SSH_CLIENT_ID_ED25519, 0);\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_XMSS, 0);\n\t}\n\tif (options->escape_char == -1)\n\t\toptions->escape_char = '~';\n\tif (options->num_system_hostfiles == 0) {\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE);\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE2);\n\t}\n\tif (options->num_user_hostfiles == 0) {\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE);\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE2);\n\t}\n\tif (options->log_level == SYSLOG_LEVEL_NOT_SET)\n\t\toptions->log_level = SYSLOG_LEVEL_INFO;\n\tif (options->log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\toptions->log_facility = SYSLOG_FACILITY_USER;\n\tif (options->no_host_authentication_for_localhost == - 1)\n\t\toptions->no_host_authentication_for_localhost = 0;\n\tif (options->identities_only == -1)\n\t\toptions->identities_only = 0;\n\tif (options->enable_ssh_keysign == -1)\n\t\toptions->enable_ssh_keysign = 0;\n\tif (options->rekey_limit == -1)\n\t\toptions->rekey_limit = 0;\n\tif (options->rekey_interval == -1)\n\t\toptions->rekey_interval = 0;\n\tif (options->verify_host_key_dns == -1)\n\t\toptions->verify_host_key_dns = 0;\n\tif (options->server_alive_interval == -1)\n\t\toptions->server_alive_interval = 0;\n\tif (options->server_alive_count_max == -1)\n\t\toptions->server_alive_count_max = 3;\n\tif (options->control_master == -1)\n\t\toptions->control_master = 0;\n\tif (options->control_persist == -1) {\n\t\toptions->control_persist = 0;\n\t\toptions->control_persist_timeout = 0;\n\t}\n\tif (options->hash_known_hosts == -1)\n\t\toptions->hash_known_hosts = 0;\n\tif (options->tun_open == -1)\n\t\toptions->tun_open = SSH_TUNMODE_NO;\n\tif (options->tun_local == -1)\n\t\toptions->tun_local = SSH_TUNID_ANY;\n\tif (options->tun_remote == -1)\n\t\toptions->tun_remote = SSH_TUNID_ANY;\n\tif (options->permit_local_command == -1)\n\t\toptions->permit_local_command = 0;\n\tif (options->visual_host_key == -1)\n\t\toptions->visual_host_key = 0;\n\tif (options->ip_qos_interactive == -1)\n\t\toptions->ip_qos_interactive = IPTOS_DSCP_AF21;\n\tif (options->ip_qos_bulk == -1)\n\t\toptions->ip_qos_bulk = IPTOS_DSCP_CS1;\n\tif (options->request_tty == -1)\n\t\toptions->request_tty = REQUEST_TTY_AUTO;\n\tif (options->proxy_use_fdpass == -1)\n\t\toptions->proxy_use_fdpass = 0;\n\tif (options->canonicalize_max_dots == -1)\n\t\toptions->canonicalize_max_dots = 1;\n\tif (options->canonicalize_fallback_local == -1)\n\t\toptions->canonicalize_fallback_local = 1;\n\tif (options->canonicalize_hostname == -1)\n\t\toptions->canonicalize_hostname = SSH_CANONICALISE_NO;\n\tif (options->fingerprint_hash == -1)\n\t\toptions->fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\tif (options->update_hostkeys == -1)\n\t\toptions->update_hostkeys = 0;\n\n\t/* Expand KEX name lists */\n\tall_cipher = cipher_alg_list(',', 0);\n\tall_mac = mac_alg_list(',');\n\tall_kex = kex_alg_list(',');\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tall_sig = sshkey_alg_list(0, 1, 1, ',');\n#define ASSEMBLE(what, defaults, all) \\\n\tdo { \\\n\t\tif ((r = kex_assemble_names(&options->what, \\\n\t\t    defaults, all)) != 0) \\\n\t\t\tfatal(\"%s: %s: %s\", __func__, #what, ssh_err(r)); \\\n\t} while (0)\n\tASSEMBLE(ciphers, KEX_SERVER_ENCRYPT, all_cipher);\n\tASSEMBLE(macs, KEX_SERVER_MAC, all_mac);\n\tASSEMBLE(kex_algorithms, KEX_SERVER_KEX, all_kex);\n\tASSEMBLE(hostbased_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(pubkey_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(ca_sign_algorithms, SSH_ALLOWED_CA_SIGALGS, all_sig);\n#undef ASSEMBLE\n\tfree(all_cipher);\n\tfree(all_mac);\n\tfree(all_kex);\n\tfree(all_key);\n\tfree(all_sig);\n\n#define CLEAR_ON_NONE(v) \\\n\tdo { \\\n\t\tif (option_clear_or_none(v)) { \\\n\t\t\tfree(v); \\\n\t\t\tv = NULL; \\\n\t\t} \\\n\t} while(0)\n\tCLEAR_ON_NONE(options->local_command);\n\tCLEAR_ON_NONE(options->remote_command);\n\tCLEAR_ON_NONE(options->proxy_command);\n\tCLEAR_ON_NONE(options->control_path);\n\tCLEAR_ON_NONE(options->revoked_host_keys);\n\tif (options->jump_host != NULL &&\n\t    strcmp(options->jump_host, \"none\") == 0 &&\n\t    options->jump_port == 0 && options->jump_user == NULL) {\n\t\tfree(options->jump_host);\n\t\toptions->jump_host = NULL;\n\t}\n\t/* options->identity_agent distinguishes NULL from 'none' */\n\t/* options->user will be set in the main program if appropriate */\n\t/* options->hostname will be set in the main program if appropriate */\n\t/* options->host_key_alias should not be set by default */\n\t/* options->preferred_authentications will be set in ssh */\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "options->jump_host"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "options->jump_host",
            "\"none\""
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CLEAR_ON_NONE",
          "args": [
            "options->revoked_host_keys"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_ON_NONE",
          "args": [
            "options->control_path"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_ON_NONE",
          "args": [
            "options->proxy_command"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_ON_NONE",
          "args": [
            "options->remote_command"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_ON_NONE",
          "args": [
            "options->local_command"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSEMBLE",
          "args": [
            "ca_sign_algorithms",
            "SSH_ALLOWED_CA_SIGALGS",
            "all_sig"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSEMBLE",
          "args": [
            "pubkey_key_types",
            "KEX_DEFAULT_PK_ALG",
            "all_key"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSEMBLE",
          "args": [
            "hostbased_key_types",
            "KEX_DEFAULT_PK_ALG",
            "all_key"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSEMBLE",
          "args": [
            "kex_algorithms",
            "KEX_SERVER_KEX",
            "all_kex"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSEMBLE",
          "args": [
            "macs",
            "KEX_SERVER_MAC",
            "all_mac"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSEMBLE",
          "args": [
            "ciphers",
            "KEX_SERVER_ENCRYPT",
            "all_cipher"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_alg_list",
          "args": [
            "0",
            "1",
            "1",
            "','"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_alg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "218-244",
          "snippet": "char *\nsshkey_alg_list(int certs_only, int plain_only, int include_sigonly, char sep)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->name == NULL)\n\t\t\tcontinue;\n\t\tif (!include_sigonly && kt->sigonly)\n\t\t\tcontinue;\n\t\tif ((certs_only && !kt->cert) || (plain_only && kt->cert))\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(kt->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, kt->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nchar *\nsshkey_alg_list(int certs_only, int plain_only, int include_sigonly, char sep)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->name == NULL)\n\t\t\tcontinue;\n\t\tif (!include_sigonly && kt->sigonly)\n\t\t\tcontinue;\n\t\tif ((certs_only && !kt->cert) || (plain_only && kt->cert))\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(kt->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, kt->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kex_alg_list",
          "args": [
            "','"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "kex_alg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "109-129",
          "snippet": "char *\nkex_alg_list(char sep)\n{\n\tchar *ret = NULL, *tmp;\n\tsize_t nlen, rlen = 0;\n\tconst struct kexalg *k;\n\n\tfor (k = kexalgs; k->name != NULL; k++) {\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(k->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, k->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kexalg kexalgs[] = {\n#ifdef WITH_OPENSSL\n\t{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA1, KEX_DH_GRP14_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA256, KEX_DH_GRP14_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_DH16_SHA512, KEX_DH_GRP16_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DH18_SHA512, KEX_DH_GRP18_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DHGEX_SHA1, KEX_DH_GEX_SHA1, 0, SSH_DIGEST_SHA1 },\n#ifdef HAVE_EVP_SHA256\n\t{ KEX_DHGEX_SHA256, KEX_DH_GEX_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 */\n#ifdef OPENSSL_HAS_ECC\n\t{ KEX_ECDH_SHA2_NISTP256, KEX_ECDH_SHA2,\n\t    NID_X9_62_prime256v1, SSH_DIGEST_SHA256 },\n\t{ KEX_ECDH_SHA2_NISTP384, KEX_ECDH_SHA2, NID_secp384r1,\n\t    SSH_DIGEST_SHA384 },\n# ifdef OPENSSL_HAS_NISTP521\n\t{ KEX_ECDH_SHA2_NISTP521, KEX_ECDH_SHA2, NID_secp521r1,\n\t    SSH_DIGEST_SHA512 },\n# endif /* OPENSSL_HAS_NISTP521 */\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n#if defined(HAVE_EVP_SHA256) || !defined(WITH_OPENSSL)\n\t{ KEX_CURVE25519_SHA256, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_CURVE25519_SHA256_OLD, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 || !WITH_OPENSSL */\n\t{ NULL, -1, -1, -1},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nstatic const struct kexalg kexalgs[] = {\n#ifdef WITH_OPENSSL\n\t{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA1, KEX_DH_GRP14_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA256, KEX_DH_GRP14_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_DH16_SHA512, KEX_DH_GRP16_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DH18_SHA512, KEX_DH_GRP18_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DHGEX_SHA1, KEX_DH_GEX_SHA1, 0, SSH_DIGEST_SHA1 },\n#ifdef HAVE_EVP_SHA256\n\t{ KEX_DHGEX_SHA256, KEX_DH_GEX_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 */\n#ifdef OPENSSL_HAS_ECC\n\t{ KEX_ECDH_SHA2_NISTP256, KEX_ECDH_SHA2,\n\t    NID_X9_62_prime256v1, SSH_DIGEST_SHA256 },\n\t{ KEX_ECDH_SHA2_NISTP384, KEX_ECDH_SHA2, NID_secp384r1,\n\t    SSH_DIGEST_SHA384 },\n# ifdef OPENSSL_HAS_NISTP521\n\t{ KEX_ECDH_SHA2_NISTP521, KEX_ECDH_SHA2, NID_secp521r1,\n\t    SSH_DIGEST_SHA512 },\n# endif /* OPENSSL_HAS_NISTP521 */\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n#if defined(HAVE_EVP_SHA256) || !defined(WITH_OPENSSL)\n\t{ KEX_CURVE25519_SHA256, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_CURVE25519_SHA256_OLD, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 || !WITH_OPENSSL */\n\t{ NULL, -1, -1, -1},\n};\n\nchar *\nkex_alg_list(char sep)\n{\n\tchar *ret = NULL, *tmp;\n\tsize_t nlen, rlen = 0;\n\tconst struct kexalg *k;\n\n\tfor (k = kexalgs; k->name != NULL; k++) {\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(k->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, k->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mac_alg_list",
          "args": [
            "','"
          ],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "mac_alg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mac.c",
          "lines": "86-106",
          "snippet": "char *\nmac_alg_list(char sep)\n{\n\tchar *ret = NULL, *tmp;\n\tsize_t nlen, rlen = 0;\n\tconst struct macalg *m;\n\n\tfor (m = macs; m->name != NULL; m++) {\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(m->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, m->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"mac.h\"",
            "#include \"umac.h\"",
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct macalg macs[] = {\n\t/* Encrypt-and-MAC (encrypt-and-authenticate) variants */\n\t{ \"hmac-sha1\",\t\t\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 0 },\n\t{ \"hmac-sha1-96\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 0 },\n#ifdef HAVE_EVP_SHA256\n\t{ \"hmac-sha2-256\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 0 },\n\t{ \"hmac-sha2-512\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 0 },\n#endif\n\t{ \"hmac-md5\",\t\t\t\tSSH_DIGEST, SSH_DIGEST_MD5, 0, 0, 0, 0 },\n\t{ \"hmac-md5-96\",\t\t\tSSH_DIGEST, SSH_DIGEST_MD5, 96, 0, 0, 0 },\n\t{ \"umac-64@openssh.com\",\t\tSSH_UMAC, 0, 0, 128, 64, 0 },\n\t{ \"umac-128@openssh.com\",\t\tSSH_UMAC128, 0, 0, 128, 128, 0 },\n\n\t/* Encrypt-then-MAC variants */\n\t{ \"hmac-sha1-etm@openssh.com\",\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 1 },\n\t{ \"hmac-sha1-96-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 1 },\n#ifdef HAVE_EVP_SHA256\n\t{ \"hmac-sha2-256-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 1 },\n\t{ \"hmac-sha2-512-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 1 },\n#endif\n\t{ \"hmac-md5-etm@openssh.com\",\t\tSSH_DIGEST, SSH_DIGEST_MD5, 0, 0, 0, 1 },\n\t{ \"hmac-md5-96-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_MD5, 96, 0, 0, 1 },\n\t{ \"umac-64-etm@openssh.com\",\t\tSSH_UMAC, 0, 0, 128, 64, 1 },\n\t{ \"umac-128-etm@openssh.com\",\t\tSSH_UMAC128, 0, 0, 128, 128, 1 },\n\n\t{ NULL,\t\t\t\t\t0, 0, 0, 0, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"mac.h\"\n#include \"umac.h\"\n#include \"hmac.h\"\n#include \"digest.h\"\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct macalg macs[] = {\n\t/* Encrypt-and-MAC (encrypt-and-authenticate) variants */\n\t{ \"hmac-sha1\",\t\t\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 0 },\n\t{ \"hmac-sha1-96\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 0 },\n#ifdef HAVE_EVP_SHA256\n\t{ \"hmac-sha2-256\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 0 },\n\t{ \"hmac-sha2-512\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 0 },\n#endif\n\t{ \"hmac-md5\",\t\t\t\tSSH_DIGEST, SSH_DIGEST_MD5, 0, 0, 0, 0 },\n\t{ \"hmac-md5-96\",\t\t\tSSH_DIGEST, SSH_DIGEST_MD5, 96, 0, 0, 0 },\n\t{ \"umac-64@openssh.com\",\t\tSSH_UMAC, 0, 0, 128, 64, 0 },\n\t{ \"umac-128@openssh.com\",\t\tSSH_UMAC128, 0, 0, 128, 128, 0 },\n\n\t/* Encrypt-then-MAC variants */\n\t{ \"hmac-sha1-etm@openssh.com\",\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 1 },\n\t{ \"hmac-sha1-96-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 1 },\n#ifdef HAVE_EVP_SHA256\n\t{ \"hmac-sha2-256-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 1 },\n\t{ \"hmac-sha2-512-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 1 },\n#endif\n\t{ \"hmac-md5-etm@openssh.com\",\t\tSSH_DIGEST, SSH_DIGEST_MD5, 0, 0, 0, 1 },\n\t{ \"hmac-md5-96-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_MD5, 96, 0, 0, 1 },\n\t{ \"umac-64-etm@openssh.com\",\t\tSSH_UMAC, 0, 0, 128, 64, 1 },\n\t{ \"umac-128-etm@openssh.com\",\t\tSSH_UMAC128, 0, 0, 128, 128, 1 },\n\n\t{ NULL,\t\t\t\t\t0, 0, 0, 0, 0, 0 }\n};\n\nchar *\nmac_alg_list(char sep)\n{\n\tchar *ret = NULL, *tmp;\n\tsize_t nlen, rlen = 0;\n\tconst struct macalg *m;\n\n\tfor (m = macs; m->name != NULL; m++) {\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(m->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, m->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_alg_list",
          "args": [
            "','",
            "0"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_alg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "117-141",
          "snippet": "char *\ncipher_alg_list(char sep, int auth_only)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct sshcipher *c;\n\n\tfor (c = ciphers; c->name != NULL; c++) {\n\t\tif ((c->flags & CFLAG_INTERNAL) != 0)\n\t\t\tcontinue;\n\t\tif (auth_only && c->auth_len == 0)\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(c->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, c->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_INTERNAL\t\tCFLAG_NONE /* Don't use \"none\" for packets */"
          ],
          "globals_used": [
            "static const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_INTERNAL\t\tCFLAG_NONE /* Don't use \"none\" for packets */\n\nstatic const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};\n\nchar *\ncipher_alg_list(char sep, int auth_only)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct sshcipher *c;\n\n\tfor (c = ciphers; c->name != NULL; c++) {\n\t\tif ((c->flags & CFLAG_INTERNAL) != 0)\n\t\t\tcontinue;\n\t\tif (auth_only && c->auth_len == 0)\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(c->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, c->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "_PATH_SSH_USER_HOSTFILE2"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_identity_file",
          "args": [
            "options",
            "\"~/\"",
            "_PATH_SSH_CLIENT_ID_XMSS",
            "0"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "add_identity_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "430-459",
          "snippet": "void\nadd_identity_file(Options *options, const char *dir, const char *filename,\n    int userprovided)\n{\n\tchar *path;\n\tint i;\n\n\tif (options->num_identity_files >= SSH_MAX_IDENTITY_FILES)\n\t\tfatal(\"Too many identity files specified (max %d)\",\n\t\t    SSH_MAX_IDENTITY_FILES);\n\n\tif (dir == NULL) /* no dir, filename is absolute */\n\t\tpath = xstrdup(filename);\n\telse if (xasprintf(&path, \"%s%s\", dir, filename) >= PATH_MAX)\n\t\tfatal(\"Identity file path %s too long\", path);\n\n\t/* Avoid registering duplicates */\n\tfor (i = 0; i < options->num_identity_files; i++) {\n\t\tif (options->identity_file_userprovided[i] == userprovided &&\n\t\t    strcmp(options->identity_files[i], path) == 0) {\n\t\t\tdebug2(\"%s: ignoring duplicate key %s\", __func__, path);\n\t\t\tfree(path);\n\t\t\treturn;\n\t\t}\n\t}\n\n\toptions->identity_file_userprovided[options->num_identity_files] =\n\t    userprovided;\n\toptions->identity_files[options->num_identity_files++] = path;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nadd_identity_file(Options *options, const char *dir, const char *filename,\n    int userprovided)\n{\n\tchar *path;\n\tint i;\n\n\tif (options->num_identity_files >= SSH_MAX_IDENTITY_FILES)\n\t\tfatal(\"Too many identity files specified (max %d)\",\n\t\t    SSH_MAX_IDENTITY_FILES);\n\n\tif (dir == NULL) /* no dir, filename is absolute */\n\t\tpath = xstrdup(filename);\n\telse if (xasprintf(&path, \"%s%s\", dir, filename) >= PATH_MAX)\n\t\tfatal(\"Identity file path %s too long\", path);\n\n\t/* Avoid registering duplicates */\n\tfor (i = 0; i < options->num_identity_files; i++) {\n\t\tif (options->identity_file_userprovided[i] == userprovided &&\n\t\t    strcmp(options->identity_files[i], path) == 0) {\n\t\t\tdebug2(\"%s: ignoring duplicate key %s\", __func__, path);\n\t\t\tfree(path);\n\t\t\treturn;\n\t\t}\n\t}\n\n\toptions->identity_file_userprovided[options->num_identity_files] =\n\t    userprovided;\n\toptions->identity_files[options->num_identity_files++] = path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_forwardings",
          "args": [
            "options"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "clear_forwardings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "376-404",
          "snippet": "static void\nclear_forwardings(Options *options)\n{\n\tint i;\n\n\tfor (i = 0; i < options->num_local_forwards; i++) {\n\t\tfree(options->local_forwards[i].listen_host);\n\t\tfree(options->local_forwards[i].listen_path);\n\t\tfree(options->local_forwards[i].connect_host);\n\t\tfree(options->local_forwards[i].connect_path);\n\t}\n\tif (options->num_local_forwards > 0) {\n\t\tfree(options->local_forwards);\n\t\toptions->local_forwards = NULL;\n\t}\n\toptions->num_local_forwards = 0;\n\tfor (i = 0; i < options->num_remote_forwards; i++) {\n\t\tfree(options->remote_forwards[i].listen_host);\n\t\tfree(options->remote_forwards[i].listen_path);\n\t\tfree(options->remote_forwards[i].connect_host);\n\t\tfree(options->remote_forwards[i].connect_path);\n\t}\n\tif (options->num_remote_forwards > 0) {\n\t\tfree(options->remote_forwards);\n\t\toptions->remote_forwards = NULL;\n\t}\n\toptions->num_remote_forwards = 0;\n\toptions->tun_open = SSH_TUNMODE_NO;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nclear_forwardings(Options *options)\n{\n\tint i;\n\n\tfor (i = 0; i < options->num_local_forwards; i++) {\n\t\tfree(options->local_forwards[i].listen_host);\n\t\tfree(options->local_forwards[i].listen_path);\n\t\tfree(options->local_forwards[i].connect_host);\n\t\tfree(options->local_forwards[i].connect_path);\n\t}\n\tif (options->num_local_forwards > 0) {\n\t\tfree(options->local_forwards);\n\t\toptions->local_forwards = NULL;\n\t}\n\toptions->num_local_forwards = 0;\n\tfor (i = 0; i < options->num_remote_forwards; i++) {\n\t\tfree(options->remote_forwards[i].listen_host);\n\t\tfree(options->remote_forwards[i].listen_path);\n\t\tfree(options->remote_forwards[i].connect_host);\n\t\tfree(options->remote_forwards[i].connect_path);\n\t}\n\tif (options->num_remote_forwards > 0) {\n\t\tfree(options->remote_forwards);\n\t\toptions->remote_forwards = NULL;\n\t}\n\toptions->num_remote_forwards = 0;\n\toptions->tun_open = SSH_TUNMODE_NO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfill_default_options(Options * options)\n{\n\tchar *all_cipher, *all_mac, *all_kex, *all_key, *all_sig;\n\tint r;\n\n\tif (options->forward_agent == -1)\n\t\toptions->forward_agent = 0;\n\tif (options->forward_x11 == -1)\n\t\toptions->forward_x11 = 0;\n\tif (options->forward_x11_trusted == -1)\n\t\toptions->forward_x11_trusted = 0;\n\tif (options->forward_x11_timeout == -1)\n\t\toptions->forward_x11_timeout = 1200;\n\t/*\n\t * stdio forwarding (-W) changes the default for these but we defer\n\t * setting the values so they can be overridden.\n\t */\n\tif (options->exit_on_forward_failure == -1)\n\t\toptions->exit_on_forward_failure =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == -1)\n\t\toptions->clear_forwardings =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == 1)\n\t\tclear_forwardings(options);\n\n\tif (options->xauth_location == NULL)\n\t\toptions->xauth_location = _PATH_XAUTH;\n\tif (options->fwd_opts.gateway_ports == -1)\n\t\toptions->fwd_opts.gateway_ports = 0;\n\tif (options->fwd_opts.streamlocal_bind_mask == (mode_t)-1)\n\t\toptions->fwd_opts.streamlocal_bind_mask = 0177;\n\tif (options->fwd_opts.streamlocal_bind_unlink == -1)\n\t\toptions->fwd_opts.streamlocal_bind_unlink = 0;\n\tif (options->pubkey_authentication == -1)\n\t\toptions->pubkey_authentication = 1;\n\tif (options->challenge_response_authentication == -1)\n\t\toptions->challenge_response_authentication = 1;\n\tif (options->gss_authentication == -1)\n\t\toptions->gss_authentication = 0;\n\tif (options->gss_deleg_creds == -1)\n\t\toptions->gss_deleg_creds = 0;\n\tif (options->password_authentication == -1)\n\t\toptions->password_authentication = 1;\n\tif (options->kbd_interactive_authentication == -1)\n\t\toptions->kbd_interactive_authentication = 1;\n\tif (options->hostbased_authentication == -1)\n\t\toptions->hostbased_authentication = 0;\n\tif (options->batch_mode == -1)\n\t\toptions->batch_mode = 0;\n\tif (options->check_host_ip == -1)\n\t\toptions->check_host_ip = 1;\n\tif (options->strict_host_key_checking == -1)\n\t\toptions->strict_host_key_checking = SSH_STRICT_HOSTKEY_ASK;\n\tif (options->compression == -1)\n\t\toptions->compression = 0;\n\tif (options->tcp_keep_alive == -1)\n\t\toptions->tcp_keep_alive = 1;\n\tif (options->port == -1)\n\t\toptions->port = 0;\t/* Filled in ssh_connect. */\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\tif (options->connection_attempts == -1)\n\t\toptions->connection_attempts = 1;\n\tif (options->number_of_password_prompts == -1)\n\t\toptions->number_of_password_prompts = 3;\n\t/* options->hostkeyalgorithms, default set in myproposals.h */\n\tif (options->add_keys_to_agent == -1)\n\t\toptions->add_keys_to_agent = 0;\n\tif (options->num_identity_files == 0) {\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_RSA, 0);\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_DSA, 0);\n#ifdef OPENSSL_HAS_ECC\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_ECDSA, 0);\n#endif\n\t\tadd_identity_file(options, \"~/\",\n\t\t    _PATH_SSH_CLIENT_ID_ED25519, 0);\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_XMSS, 0);\n\t}\n\tif (options->escape_char == -1)\n\t\toptions->escape_char = '~';\n\tif (options->num_system_hostfiles == 0) {\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE);\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE2);\n\t}\n\tif (options->num_user_hostfiles == 0) {\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE);\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE2);\n\t}\n\tif (options->log_level == SYSLOG_LEVEL_NOT_SET)\n\t\toptions->log_level = SYSLOG_LEVEL_INFO;\n\tif (options->log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\toptions->log_facility = SYSLOG_FACILITY_USER;\n\tif (options->no_host_authentication_for_localhost == - 1)\n\t\toptions->no_host_authentication_for_localhost = 0;\n\tif (options->identities_only == -1)\n\t\toptions->identities_only = 0;\n\tif (options->enable_ssh_keysign == -1)\n\t\toptions->enable_ssh_keysign = 0;\n\tif (options->rekey_limit == -1)\n\t\toptions->rekey_limit = 0;\n\tif (options->rekey_interval == -1)\n\t\toptions->rekey_interval = 0;\n\tif (options->verify_host_key_dns == -1)\n\t\toptions->verify_host_key_dns = 0;\n\tif (options->server_alive_interval == -1)\n\t\toptions->server_alive_interval = 0;\n\tif (options->server_alive_count_max == -1)\n\t\toptions->server_alive_count_max = 3;\n\tif (options->control_master == -1)\n\t\toptions->control_master = 0;\n\tif (options->control_persist == -1) {\n\t\toptions->control_persist = 0;\n\t\toptions->control_persist_timeout = 0;\n\t}\n\tif (options->hash_known_hosts == -1)\n\t\toptions->hash_known_hosts = 0;\n\tif (options->tun_open == -1)\n\t\toptions->tun_open = SSH_TUNMODE_NO;\n\tif (options->tun_local == -1)\n\t\toptions->tun_local = SSH_TUNID_ANY;\n\tif (options->tun_remote == -1)\n\t\toptions->tun_remote = SSH_TUNID_ANY;\n\tif (options->permit_local_command == -1)\n\t\toptions->permit_local_command = 0;\n\tif (options->visual_host_key == -1)\n\t\toptions->visual_host_key = 0;\n\tif (options->ip_qos_interactive == -1)\n\t\toptions->ip_qos_interactive = IPTOS_DSCP_AF21;\n\tif (options->ip_qos_bulk == -1)\n\t\toptions->ip_qos_bulk = IPTOS_DSCP_CS1;\n\tif (options->request_tty == -1)\n\t\toptions->request_tty = REQUEST_TTY_AUTO;\n\tif (options->proxy_use_fdpass == -1)\n\t\toptions->proxy_use_fdpass = 0;\n\tif (options->canonicalize_max_dots == -1)\n\t\toptions->canonicalize_max_dots = 1;\n\tif (options->canonicalize_fallback_local == -1)\n\t\toptions->canonicalize_fallback_local = 1;\n\tif (options->canonicalize_hostname == -1)\n\t\toptions->canonicalize_hostname = SSH_CANONICALISE_NO;\n\tif (options->fingerprint_hash == -1)\n\t\toptions->fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\tif (options->update_hostkeys == -1)\n\t\toptions->update_hostkeys = 0;\n\n\t/* Expand KEX name lists */\n\tall_cipher = cipher_alg_list(',', 0);\n\tall_mac = mac_alg_list(',');\n\tall_kex = kex_alg_list(',');\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tall_sig = sshkey_alg_list(0, 1, 1, ',');\n#define ASSEMBLE(what, defaults, all) \\\n\tdo { \\\n\t\tif ((r = kex_assemble_names(&options->what, \\\n\t\t    defaults, all)) != 0) \\\n\t\t\tfatal(\"%s: %s: %s\", __func__, #what, ssh_err(r)); \\\n\t} while (0)\n\tASSEMBLE(ciphers, KEX_SERVER_ENCRYPT, all_cipher);\n\tASSEMBLE(macs, KEX_SERVER_MAC, all_mac);\n\tASSEMBLE(kex_algorithms, KEX_SERVER_KEX, all_kex);\n\tASSEMBLE(hostbased_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(pubkey_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(ca_sign_algorithms, SSH_ALLOWED_CA_SIGALGS, all_sig);\n#undef ASSEMBLE\n\tfree(all_cipher);\n\tfree(all_mac);\n\tfree(all_kex);\n\tfree(all_key);\n\tfree(all_sig);\n\n#define CLEAR_ON_NONE(v) \\\n\tdo { \\\n\t\tif (option_clear_or_none(v)) { \\\n\t\t\tfree(v); \\\n\t\t\tv = NULL; \\\n\t\t} \\\n\t} while(0)\n\tCLEAR_ON_NONE(options->local_command);\n\tCLEAR_ON_NONE(options->remote_command);\n\tCLEAR_ON_NONE(options->proxy_command);\n\tCLEAR_ON_NONE(options->control_path);\n\tCLEAR_ON_NONE(options->revoked_host_keys);\n\tif (options->jump_host != NULL &&\n\t    strcmp(options->jump_host, \"none\") == 0 &&\n\t    options->jump_port == 0 && options->jump_user == NULL) {\n\t\tfree(options->jump_host);\n\t\toptions->jump_host = NULL;\n\t}\n\t/* options->identity_agent distinguishes NULL from 'none' */\n\t/* options->user will be set in the main program if appropriate */\n\t/* options->hostname will be set in the main program if appropriate */\n\t/* options->host_key_alias should not be set by default */\n\t/* options->preferred_authentications will be set in ssh */\n}"
  },
  {
    "function_name": "fill_default_options_for_canonicalization",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "1935-1944",
    "snippet": "void\nfill_default_options_for_canonicalization(Options *options)\n{\n\tif (options->canonicalize_max_dots == -1)\n\t\toptions->canonicalize_max_dots = 1;\n\tif (options->canonicalize_fallback_local == -1)\n\t\toptions->canonicalize_fallback_local = 1;\n\tif (options->canonicalize_hostname == -1)\n\t\toptions->canonicalize_hostname = SSH_CANONICALISE_NO;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfill_default_options_for_canonicalization(Options *options)\n{\n\tif (options->canonicalize_max_dots == -1)\n\t\toptions->canonicalize_max_dots = 1;\n\tif (options->canonicalize_fallback_local == -1)\n\t\toptions->canonicalize_fallback_local = 1;\n\tif (options->canonicalize_hostname == -1)\n\t\toptions->canonicalize_hostname = SSH_CANONICALISE_NO;\n}"
  },
  {
    "function_name": "initialize_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "1826-1929",
    "snippet": "void\ninitialize_options(Options * options)\n{\n\tmemset(options, 'X', sizeof(*options));\n\toptions->forward_agent = -1;\n\toptions->forward_x11 = -1;\n\toptions->forward_x11_trusted = -1;\n\toptions->forward_x11_timeout = -1;\n\toptions->stdio_forward_host = NULL;\n\toptions->stdio_forward_port = 0;\n\toptions->clear_forwardings = -1;\n\toptions->exit_on_forward_failure = -1;\n\toptions->xauth_location = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->pubkey_authentication = -1;\n\toptions->challenge_response_authentication = -1;\n\toptions->gss_authentication = -1;\n\toptions->gss_deleg_creds = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->kbd_interactive_devices = NULL;\n\toptions->hostbased_authentication = -1;\n\toptions->batch_mode = -1;\n\toptions->check_host_ip = -1;\n\toptions->strict_host_key_checking = -1;\n\toptions->compression = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->port = -1;\n\toptions->address_family = -1;\n\toptions->connection_attempts = -1;\n\toptions->connection_timeout = -1;\n\toptions->number_of_password_prompts = -1;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->ca_sign_algorithms = NULL;\n\toptions->num_identity_files = 0;\n\toptions->num_certificate_files = 0;\n\toptions->hostname = NULL;\n\toptions->host_key_alias = NULL;\n\toptions->proxy_command = NULL;\n\toptions->jump_user = NULL;\n\toptions->jump_host = NULL;\n\toptions->jump_port = -1;\n\toptions->jump_extra = NULL;\n\toptions->user = NULL;\n\toptions->escape_char = -1;\n\toptions->num_system_hostfiles = 0;\n\toptions->num_user_hostfiles = 0;\n\toptions->local_forwards = NULL;\n\toptions->num_local_forwards = 0;\n\toptions->remote_forwards = NULL;\n\toptions->num_remote_forwards = 0;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->preferred_authentications = NULL;\n\toptions->bind_address = NULL;\n\toptions->bind_interface = NULL;\n\toptions->pkcs11_provider = NULL;\n\toptions->enable_ssh_keysign = - 1;\n\toptions->no_host_authentication_for_localhost = - 1;\n\toptions->identities_only = - 1;\n\toptions->rekey_limit = - 1;\n\toptions->rekey_interval = -1;\n\toptions->verify_host_key_dns = -1;\n\toptions->server_alive_interval = -1;\n\toptions->server_alive_count_max = -1;\n\toptions->send_env = NULL;\n\toptions->num_send_env = 0;\n\toptions->setenv = NULL;\n\toptions->num_setenv = 0;\n\toptions->control_path = NULL;\n\toptions->control_master = -1;\n\toptions->control_persist = -1;\n\toptions->control_persist_timeout = 0;\n\toptions->hash_known_hosts = -1;\n\toptions->tun_open = -1;\n\toptions->tun_local = -1;\n\toptions->tun_remote = -1;\n\toptions->local_command = NULL;\n\toptions->permit_local_command = -1;\n\toptions->remote_command = NULL;\n\toptions->add_keys_to_agent = -1;\n\toptions->identity_agent = NULL;\n\toptions->visual_host_key = -1;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->request_tty = -1;\n\toptions->proxy_use_fdpass = -1;\n\toptions->ignored_unknown = NULL;\n\toptions->num_canonical_domains = 0;\n\toptions->num_permitted_cnames = 0;\n\toptions->canonicalize_max_dots = -1;\n\toptions->canonicalize_fallback_local = -1;\n\toptions->canonicalize_hostname = -1;\n\toptions->revoked_host_keys = NULL;\n\toptions->fingerprint_hash = -1;\n\toptions->update_hostkeys = -1;\n\toptions->hostbased_key_types = NULL;\n\toptions->pubkey_key_types = NULL;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "options",
            "'X'",
            "sizeof(*options)"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ninitialize_options(Options * options)\n{\n\tmemset(options, 'X', sizeof(*options));\n\toptions->forward_agent = -1;\n\toptions->forward_x11 = -1;\n\toptions->forward_x11_trusted = -1;\n\toptions->forward_x11_timeout = -1;\n\toptions->stdio_forward_host = NULL;\n\toptions->stdio_forward_port = 0;\n\toptions->clear_forwardings = -1;\n\toptions->exit_on_forward_failure = -1;\n\toptions->xauth_location = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->pubkey_authentication = -1;\n\toptions->challenge_response_authentication = -1;\n\toptions->gss_authentication = -1;\n\toptions->gss_deleg_creds = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->kbd_interactive_devices = NULL;\n\toptions->hostbased_authentication = -1;\n\toptions->batch_mode = -1;\n\toptions->check_host_ip = -1;\n\toptions->strict_host_key_checking = -1;\n\toptions->compression = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->port = -1;\n\toptions->address_family = -1;\n\toptions->connection_attempts = -1;\n\toptions->connection_timeout = -1;\n\toptions->number_of_password_prompts = -1;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->ca_sign_algorithms = NULL;\n\toptions->num_identity_files = 0;\n\toptions->num_certificate_files = 0;\n\toptions->hostname = NULL;\n\toptions->host_key_alias = NULL;\n\toptions->proxy_command = NULL;\n\toptions->jump_user = NULL;\n\toptions->jump_host = NULL;\n\toptions->jump_port = -1;\n\toptions->jump_extra = NULL;\n\toptions->user = NULL;\n\toptions->escape_char = -1;\n\toptions->num_system_hostfiles = 0;\n\toptions->num_user_hostfiles = 0;\n\toptions->local_forwards = NULL;\n\toptions->num_local_forwards = 0;\n\toptions->remote_forwards = NULL;\n\toptions->num_remote_forwards = 0;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->preferred_authentications = NULL;\n\toptions->bind_address = NULL;\n\toptions->bind_interface = NULL;\n\toptions->pkcs11_provider = NULL;\n\toptions->enable_ssh_keysign = - 1;\n\toptions->no_host_authentication_for_localhost = - 1;\n\toptions->identities_only = - 1;\n\toptions->rekey_limit = - 1;\n\toptions->rekey_interval = -1;\n\toptions->verify_host_key_dns = -1;\n\toptions->server_alive_interval = -1;\n\toptions->server_alive_count_max = -1;\n\toptions->send_env = NULL;\n\toptions->num_send_env = 0;\n\toptions->setenv = NULL;\n\toptions->num_setenv = 0;\n\toptions->control_path = NULL;\n\toptions->control_master = -1;\n\toptions->control_persist = -1;\n\toptions->control_persist_timeout = 0;\n\toptions->hash_known_hosts = -1;\n\toptions->tun_open = -1;\n\toptions->tun_local = -1;\n\toptions->tun_remote = -1;\n\toptions->local_command = NULL;\n\toptions->permit_local_command = -1;\n\toptions->remote_command = NULL;\n\toptions->add_keys_to_agent = -1;\n\toptions->identity_agent = NULL;\n\toptions->visual_host_key = -1;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->request_tty = -1;\n\toptions->proxy_use_fdpass = -1;\n\toptions->ignored_unknown = NULL;\n\toptions->num_canonical_domains = 0;\n\toptions->num_permitted_cnames = 0;\n\toptions->canonicalize_max_dots = -1;\n\toptions->canonicalize_fallback_local = -1;\n\toptions->canonicalize_hostname = -1;\n\toptions->revoked_host_keys = NULL;\n\toptions->fingerprint_hash = -1;\n\toptions->update_hostkeys = -1;\n\toptions->hostbased_key_types = NULL;\n\toptions->pubkey_key_types = NULL;\n}"
  },
  {
    "function_name": "option_clear_or_none",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "1813-1817",
    "snippet": "int\noption_clear_or_none(const char *o)\n{\n\treturn o == NULL || strcasecmp(o, \"none\") == 0;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "o",
            "\"none\""
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\noption_clear_or_none(const char *o)\n{\n\treturn o == NULL || strcasecmp(o, \"none\") == 0;\n}"
  },
  {
    "function_name": "read_config_file_depth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "1763-1810",
    "snippet": "static int\nread_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int depth)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t linesize = 0;\n\tint linenum;\n\tint bad_options = 0;\n\n\tif (depth < 0 || depth > READCONF_MAX_DEPTH)\n\t\tfatal(\"Too many recursive configuration includes\");\n\n\tif ((f = fopen(filename, \"r\")) == NULL)\n\t\treturn 0;\n\n\tif (flags & SSHCONF_CHECKPERM) {\n\t\tstruct stat sb;\n\n\t\tif (fstat(fileno(f), &sb) == -1)\n\t\t\tfatal(\"fstat %s: %s\", filename, strerror(errno));\n\t\tif (((sb.st_uid != 0 && sb.st_uid != getuid()) ||\n\t\t    (sb.st_mode & 022) != 0))\n\t\t\tfatal(\"Bad owner or permissions on %s\", filename);\n\t}\n\n\tdebug(\"Reading configuration data %.200s\", filename);\n\n\t/*\n\t * Mark that we are now processing the options.  This flag is turned\n\t * on/off by Host specifications.\n\t */\n\tlinenum = 0;\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\t/* Update line number counter. */\n\t\tlinenum++;\n\t\tif (process_config_line_depth(options, pw, host, original_host,\n\t\t    line, filename, linenum, activep, flags, depth) != 0)\n\t\t\tbad_options++;\n\t}\n\tfree(line);\n\tfclose(f);\n\tif (bad_options > 0)\n\t\tfatal(\"%s: terminating, %d bad configuration options\",\n\t\t    filename, bad_options);\n\treturn 1;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define READCONF_MAX_DEPTH\t16"
    ],
    "globals_used": [
      "static int read_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int depth);",
      "static int process_config_line_depth(Options *options, struct passwd *pw,\n    const char *host, const char *original_host, char *line,\n    const char *filename, int linenum, int *activep, int flags, int depth);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: terminating, %d bad configuration options\"",
            "filename",
            "bad_options"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_config_line_depth",
          "args": [
            "options",
            "pw",
            "host",
            "original_host",
            "line",
            "filename",
            "linenum",
            "activep",
            "flags",
            "depth"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "process_config_line_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "831-1745",
          "snippet": "static int\nprocess_config_line_depth(Options *options, struct passwd *pw, const char *host,\n    const char *original_host, char *line, const char *filename,\n    int linenum, int *activep, int flags, int depth)\n{\n\tchar *s, **charptr, *endofnumber, *keyword, *arg, *arg2;\n\tchar **cpptr, fwdarg[256];\n\tu_int i, *uintptr, max_entries = 0;\n\tint r, oactive, negated, opcode, *intptr, value, value2, cmdline = 0;\n\tint remotefwd, dynamicfwd;\n\tLogLevel *log_level_ptr;\n\tSyslogFacility *log_facility_ptr;\n\tlong long val64;\n\tsize_t len;\n\tstruct Forward fwd;\n\tconst struct multistate *multistate_ptr;\n\tstruct allowed_cname *cname;\n\tglob_t gl;\n\tconst char *errstr;\n\n\tif (activep == NULL) { /* We are processing a command line directive */\n\t\tcmdline = 1;\n\t\tactivep = &cmdline;\n\t}\n\n\t/* Strip trailing whitespace. Allow \\f (form feed) at EOL only */\n\tif ((len = strlen(line)) == 0)\n\t\treturn 0;\n\tfor (len--; len > 0; len--) {\n\t\tif (strchr(WHITESPACE \"\\f\", line[len]) == NULL)\n\t\t\tbreak;\n\t\tline[len] = '\\0';\n\t}\n\n\ts = line;\n\t/* Get the keyword. (Each line is supposed to begin with a keyword). */\n\tif ((keyword = strdelim(&s)) == NULL)\n\t\treturn 0;\n\t/* Ignore leading whitespace. */\n\tif (*keyword == '\\0')\n\t\tkeyword = strdelim(&s);\n\tif (keyword == NULL || !*keyword || *keyword == '\\n' || *keyword == '#')\n\t\treturn 0;\n\t/* Match lowercase keyword */\n\tlowercase(keyword);\n\n\topcode = parse_token(keyword, filename, linenum,\n\t    options->ignored_unknown);\n\n\tswitch (opcode) {\n\tcase oBadOption:\n\t\t/* don't panic, but count bad options */\n\t\treturn -1;\n\tcase oIgnore:\n\t\treturn 0;\n\tcase oIgnoredUnknownOption:\n\t\tdebug(\"%s line %d: Ignored unknown option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn 0;\n\tcase oConnectTimeout:\n\t\tintptr = &options->connection_timeout;\nparse_time:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing time value.\",\n\t\t\t    filename, linenum);\n\t\tif (strcmp(arg, \"none\") == 0)\n\t\t\tvalue = -1;\n\t\telse if ((value = convtime(arg)) == -1)\n\t\t\tfatal(\"%s line %d: invalid time value.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oForwardAgent:\n\t\tintptr = &options->forward_agent;\n parse_flag:\n\t\tmultistate_ptr = multistate_flag;\n parse_multistate:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; multistate_ptr[i].key != NULL; i++) {\n\t\t\tif (strcasecmp(arg, multistate_ptr[i].key) == 0) {\n\t\t\t\tvalue = multistate_ptr[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: unsupported option \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oForwardX11:\n\t\tintptr = &options->forward_x11;\n\t\tgoto parse_flag;\n\n\tcase oForwardX11Trusted:\n\t\tintptr = &options->forward_x11_trusted;\n\t\tgoto parse_flag;\n\n\tcase oForwardX11Timeout:\n\t\tintptr = &options->forward_x11_timeout;\n\t\tgoto parse_time;\n\n\tcase oGatewayPorts:\n\t\tintptr = &options->fwd_opts.gateway_ports;\n\t\tgoto parse_flag;\n\n\tcase oExitOnForwardFailure:\n\t\tintptr = &options->exit_on_forward_failure;\n\t\tgoto parse_flag;\n\n\tcase oPasswordAuthentication:\n\t\tintptr = &options->password_authentication;\n\t\tgoto parse_flag;\n\n\tcase oKbdInteractiveAuthentication:\n\t\tintptr = &options->kbd_interactive_authentication;\n\t\tgoto parse_flag;\n\n\tcase oKbdInteractiveDevices:\n\t\tcharptr = &options->kbd_interactive_devices;\n\t\tgoto parse_string;\n\n\tcase oPubkeyAuthentication:\n\t\tintptr = &options->pubkey_authentication;\n\t\tgoto parse_flag;\n\n\tcase oHostbasedAuthentication:\n\t\tintptr = &options->hostbased_authentication;\n\t\tgoto parse_flag;\n\n\tcase oChallengeResponseAuthentication:\n\t\tintptr = &options->challenge_response_authentication;\n\t\tgoto parse_flag;\n\n\tcase oGssAuthentication:\n\t\tintptr = &options->gss_authentication;\n\t\tgoto parse_flag;\n\n\tcase oGssDelegateCreds:\n\t\tintptr = &options->gss_deleg_creds;\n\t\tgoto parse_flag;\n\n\tcase oBatchMode:\n\t\tintptr = &options->batch_mode;\n\t\tgoto parse_flag;\n\n\tcase oCheckHostIP:\n\t\tintptr = &options->check_host_ip;\n\t\tgoto parse_flag;\n\n\tcase oVerifyHostKeyDNS:\n\t\tintptr = &options->verify_host_key_dns;\n\t\tmultistate_ptr = multistate_yesnoask;\n\t\tgoto parse_multistate;\n\n\tcase oStrictHostKeyChecking:\n\t\tintptr = &options->strict_host_key_checking;\n\t\tmultistate_ptr = multistate_strict_hostkey;\n\t\tgoto parse_multistate;\n\n\tcase oCompression:\n\t\tintptr = &options->compression;\n\t\tgoto parse_flag;\n\n\tcase oTCPKeepAlive:\n\t\tintptr = &options->tcp_keep_alive;\n\t\tgoto parse_flag;\n\n\tcase oNoHostAuthenticationForLocalhost:\n\t\tintptr = &options->no_host_authentication_for_localhost;\n\t\tgoto parse_flag;\n\n\tcase oNumberOfPasswordPrompts:\n\t\tintptr = &options->number_of_password_prompts;\n\t\tgoto parse_int;\n\n\tcase oRekeyLimit:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tif (strcmp(arg, \"default\") == 0) {\n\t\t\tval64 = 0;\n\t\t} else {\n\t\t\tif (scan_scaled(arg, &val64) == -1)\n\t\t\t\tfatal(\"%.200s line %d: Bad number '%s': %s\",\n\t\t\t\t    filename, linenum, arg, strerror(errno));\n\t\t\tif (val64 != 0 && val64 < 16)\n\t\t\t\tfatal(\"%.200s line %d: RekeyLimit too small\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\tif (*activep && options->rekey_limit == -1)\n\t\t\toptions->rekey_limit = val64;\n\t\tif (s != NULL) { /* optional rekey interval present */\n\t\t\tif (strcmp(s, \"none\") == 0) {\n\t\t\t\t(void)strdelim(&s);\t/* discard */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tintptr = &options->rekey_interval;\n\t\t\tgoto parse_time;\n\t\t}\n\t\tbreak;\n\n\tcase oIdentityFile:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (*activep) {\n\t\t\tintptr = &options->num_identity_files;\n\t\t\tif (*intptr >= SSH_MAX_IDENTITY_FILES)\n\t\t\t\tfatal(\"%.200s line %d: Too many identity files specified (max %d).\",\n\t\t\t\t    filename, linenum, SSH_MAX_IDENTITY_FILES);\n\t\t\tadd_identity_file(options, NULL,\n\t\t\t    arg, flags & SSHCONF_USERCONF);\n\t\t}\n\t\tbreak;\n\n\tcase oCertificateFile:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep) {\n\t\t\tintptr = &options->num_certificate_files;\n\t\t\tif (*intptr >= SSH_MAX_CERTIFICATE_FILES) {\n\t\t\t\tfatal(\"%.200s line %d: Too many certificate \"\n\t\t\t\t    \"files specified (max %d).\",\n\t\t\t\t    filename, linenum,\n\t\t\t\t    SSH_MAX_CERTIFICATE_FILES);\n\t\t\t}\n\t\t\tadd_certificate_file(options, arg,\n\t\t\t    flags & SSHCONF_USERCONF);\n\t\t}\n\t\tbreak;\n\n\tcase oXAuthLocation:\n\t\tcharptr=&options->xauth_location;\n\t\tgoto parse_string;\n\n\tcase oUser:\n\t\tcharptr = &options->user;\nparse_string:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oGlobalKnownHostsFile:\n\t\tcpptr = (char **)&options->system_hostfiles;\n\t\tuintptr = &options->num_system_hostfiles;\n\t\tmax_entries = SSH_MAX_HOSTS_FILES;\nparse_char_array:\n\t\tif (*activep && *uintptr == 0) {\n\t\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\t\tif ((*uintptr) >= max_entries)\n\t\t\t\t\tfatal(\"%s line %d: \"\n\t\t\t\t\t    \"too many authorized keys files.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\tcpptr[(*uintptr)++] = xstrdup(arg);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase oUserKnownHostsFile:\n\t\tcpptr = (char **)&options->user_hostfiles;\n\t\tuintptr = &options->num_user_hostfiles;\n\t\tmax_entries = SSH_MAX_HOSTS_FILES;\n\t\tgoto parse_char_array;\n\n\tcase oHostName:\n\t\tcharptr = &options->hostname;\n\t\tgoto parse_string;\n\n\tcase oHostKeyAlias:\n\t\tcharptr = &options->host_key_alias;\n\t\tgoto parse_string;\n\n\tcase oPreferredAuthentications:\n\t\tcharptr = &options->preferred_authentications;\n\t\tgoto parse_string;\n\n\tcase oBindAddress:\n\t\tcharptr = &options->bind_address;\n\t\tgoto parse_string;\n\n\tcase oBindInterface:\n\t\tcharptr = &options->bind_interface;\n\t\tgoto parse_string;\n\n\tcase oPKCS11Provider:\n\t\tcharptr = &options->pkcs11_provider;\n\t\tgoto parse_string;\n\n\tcase oProxyCommand:\n\t\tcharptr = &options->proxy_command;\n\t\t/* Ignore ProxyCommand if ProxyJump already specified */\n\t\tif (options->jump_host != NULL)\n\t\t\tcharptr = &options->jump_host; /* Skip below */\nparse_command:\n\t\tif (s == NULL)\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tlen = strspn(s, WHITESPACE \"=\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(s + len);\n\t\treturn 0;\n\n\tcase oProxyJump:\n\t\tif (s == NULL) {\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t}\n\t\tlen = strspn(s, WHITESPACE \"=\");\n\t\tif (parse_jump(s + len, options, *activep) == -1) {\n\t\t\tfatal(\"%.200s line %d: Invalid ProxyJump \\\"%s\\\"\",\n\t\t\t    filename, linenum, s + len);\n\t\t}\n\t\treturn 0;\n\n\tcase oPort:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = a2port(arg);\n\t\tif (value <= 0)\n\t\t\tfatal(\"%.200s line %d: Bad port '%s'.\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && options->port == -1)\n\t\t\toptions->port = value;\n\t\tbreak;\n\n\tcase oConnectionAttempts:\n\t\tintptr = &options->connection_attempts;\nparse_int:\n\t\targ = strdelim(&s);\n\t\tif ((errstr = atoi_err(arg, &value)) != NULL)\n\t\t\tfatal(\"%s line %d: integer value %s.\",\n\t\t\t    filename, linenum, errstr);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oCiphers:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !ciphers_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%.200s line %d: Bad SSH2 cipher spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && options->ciphers == NULL)\n\t\t\toptions->ciphers = xstrdup(arg);\n\t\tbreak;\n\n\tcase oMacs:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !mac_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%.200s line %d: Bad SSH2 Mac spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && options->macs == NULL)\n\t\t\toptions->macs = xstrdup(arg);\n\t\tbreak;\n\n\tcase oKexAlgorithms:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !kex_names_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%.200s line %d: Bad SSH2 KexAlgorithms '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && options->kex_algorithms == NULL)\n\t\t\toptions->kex_algorithms = xstrdup(arg);\n\t\tbreak;\n\n\tcase oHostKeyAlgorithms:\n\t\tcharptr = &options->hostkeyalgorithms;\nparse_keytypes:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !sshkey_names_valid2(*arg == '+' ? arg + 1 : arg, 1))\n\t\t\tfatal(\"%s line %d: Bad key types '%s'.\",\n\t\t\t\tfilename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oCASignatureAlgorithms:\n\t\tcharptr = &options->ca_sign_algorithms;\n\t\tgoto parse_keytypes;\n\n\tcase oLogLevel:\n\t\tlog_level_ptr = &options->log_level;\n\t\targ = strdelim(&s);\n\t\tvalue = log_level_number(arg);\n\t\tif (value == SYSLOG_LEVEL_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log level '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *log_level_ptr == SYSLOG_LEVEL_NOT_SET)\n\t\t\t*log_level_ptr = (LogLevel) value;\n\t\tbreak;\n\n\tcase oLogFacility:\n\t\tlog_facility_ptr = &options->log_facility;\n\t\targ = strdelim(&s);\n\t\tvalue = log_facility_number(arg);\n\t\tif (value == SYSLOG_FACILITY_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log facility '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*log_facility_ptr == -1)\n\t\t\t*log_facility_ptr = (SyslogFacility) value;\n\t\tbreak;\n\n\tcase oLocalForward:\n\tcase oRemoteForward:\n\tcase oDynamicForward:\n\t\targ = strdelim(&s);\n\t\tif (arg == NULL || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing port argument.\",\n\t\t\t    filename, linenum);\n\n\t\tremotefwd = (opcode == oRemoteForward);\n\t\tdynamicfwd = (opcode == oDynamicForward);\n\n\t\tif (!dynamicfwd) {\n\t\t\targ2 = strdelim(&s);\n\t\t\tif (arg2 == NULL || *arg2 == '\\0') {\n\t\t\t\tif (remotefwd)\n\t\t\t\t\tdynamicfwd = 1;\n\t\t\t\telse\n\t\t\t\t\tfatal(\"%.200s line %d: Missing target \"\n\t\t\t\t\t    \"argument.\", filename, linenum);\n\t\t\t} else {\n\t\t\t\t/* construct a string for parse_forward */\n\t\t\t\tsnprintf(fwdarg, sizeof(fwdarg), \"%s:%s\", arg,\n\t\t\t\t    arg2);\n\t\t\t}\n\t\t}\n\t\tif (dynamicfwd)\n\t\t\tstrlcpy(fwdarg, arg, sizeof(fwdarg));\n\n\t\tif (parse_forward(&fwd, fwdarg, dynamicfwd, remotefwd) == 0)\n\t\t\tfatal(\"%.200s line %d: Bad forwarding specification.\",\n\t\t\t    filename, linenum);\n\n\t\tif (*activep) {\n\t\t\tif (remotefwd) {\n\t\t\t\tadd_remote_forward(options, &fwd);\n\t\t\t} else {\n\t\t\t\tadd_local_forward(options, &fwd);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase oClearAllForwardings:\n\t\tintptr = &options->clear_forwardings;\n\t\tgoto parse_flag;\n\n\tcase oHost:\n\t\tif (cmdline)\n\t\t\tfatal(\"Host directive not supported as a command-line \"\n\t\t\t    \"option\");\n\t\t*activep = 0;\n\t\targ2 = NULL;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\tif ((flags & SSHCONF_NEVERMATCH) != 0)\n\t\t\t\tbreak;\n\t\t\tnegated = *arg == '!';\n\t\t\tif (negated)\n\t\t\t\targ++;\n\t\t\tif (match_pattern(host, arg)) {\n\t\t\t\tif (negated) {\n\t\t\t\t\tdebug(\"%.200s line %d: Skipping Host \"\n\t\t\t\t\t    \"block because of negated match \"\n\t\t\t\t\t    \"for %.100s\", filename, linenum,\n\t\t\t\t\t    arg);\n\t\t\t\t\t*activep = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!*activep)\n\t\t\t\t\targ2 = arg; /* logged below */\n\t\t\t\t*activep = 1;\n\t\t\t}\n\t\t}\n\t\tif (*activep)\n\t\t\tdebug(\"%.200s line %d: Applying options for %.100s\",\n\t\t\t    filename, linenum, arg2);\n\t\t/* Avoid garbage check below, as strdelim is done. */\n\t\treturn 0;\n\n\tcase oMatch:\n\t\tif (cmdline)\n\t\t\tfatal(\"Host directive not supported as a command-line \"\n\t\t\t    \"option\");\n\t\tvalue = match_cfg_line(options, &s, pw, host, original_host,\n\t\t    flags & SSHCONF_POSTCANON, filename, linenum);\n\t\tif (value < 0)\n\t\t\tfatal(\"%.200s line %d: Bad Match condition\", filename,\n\t\t\t    linenum);\n\t\t*activep = (flags & SSHCONF_NEVERMATCH) ? 0 : value;\n\t\tbreak;\n\n\tcase oEscapeChar:\n\t\tintptr = &options->escape_char;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (strcmp(arg, \"none\") == 0)\n\t\t\tvalue = SSH_ESCAPECHAR_NONE;\n\t\telse if (arg[1] == '\\0')\n\t\t\tvalue = (u_char) arg[0];\n\t\telse if (arg[0] == '^' && arg[2] == 0 &&\n\t\t    (u_char) arg[1] >= 64 && (u_char) arg[1] < 128)\n\t\t\tvalue = (u_char) arg[1] & 31;\n\t\telse {\n\t\t\tfatal(\"%.200s line %d: Bad escape character.\",\n\t\t\t    filename, linenum);\n\t\t\t/* NOTREACHED */\n\t\t\tvalue = 0;\t/* Avoid compiler warning. */\n\t\t}\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oAddressFamily:\n\t\tintptr = &options->address_family;\n\t\tmultistate_ptr = multistate_addressfamily;\n\t\tgoto parse_multistate;\n\n\tcase oEnableSSHKeysign:\n\t\tintptr = &options->enable_ssh_keysign;\n\t\tgoto parse_flag;\n\n\tcase oIdentitiesOnly:\n\t\tintptr = &options->identities_only;\n\t\tgoto parse_flag;\n\n\tcase oServerAliveInterval:\n\t\tintptr = &options->server_alive_interval;\n\t\tgoto parse_time;\n\n\tcase oServerAliveCountMax:\n\t\tintptr = &options->server_alive_count_max;\n\t\tgoto parse_int;\n\n\tcase oSendEnv:\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') != NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment name.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tif (*arg == '-') {\n\t\t\t\t/* Removing an env var */\n\t\t\t\trm_env(options, arg, filename, linenum);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/* Adding an env var */\n\t\t\t\tif (options->num_send_env >= INT_MAX)\n\t\t\t\t\tfatal(\"%s line %d: too many send env.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\toptions->send_env = xrecallocarray(\n\t\t\t\t    options->send_env, options->num_send_env,\n\t\t\t\t    options->num_send_env + 1,\n\t\t\t\t    sizeof(*options->send_env));\n\t\t\t\toptions->send_env[options->num_send_env++] =\n\t\t\t\t    xstrdup(arg);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase oSetEnv:\n\t\tvalue = options->num_setenv;\n\t\twhile ((arg = strdelimw(&s)) != NULL && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') == NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid SetEnv.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep || value != 0)\n\t\t\t\tcontinue;\n\t\t\t/* Adding a setenv var */\n\t\t\tif (options->num_setenv >= INT_MAX)\n\t\t\t\tfatal(\"%s line %d: too many SetEnv.\",\n\t\t\t\t    filename, linenum);\n\t\t\toptions->setenv = xrecallocarray(\n\t\t\t    options->setenv, options->num_setenv,\n\t\t\t    options->num_setenv + 1, sizeof(*options->setenv));\n\t\t\toptions->setenv[options->num_setenv++] = xstrdup(arg);\n\t\t}\n\t\tbreak;\n\n\tcase oControlPath:\n\t\tcharptr = &options->control_path;\n\t\tgoto parse_string;\n\n\tcase oControlMaster:\n\t\tintptr = &options->control_master;\n\t\tmultistate_ptr = multistate_controlmaster;\n\t\tgoto parse_multistate;\n\n\tcase oControlPersist:\n\t\t/* no/false/yes/true, or a time spec */\n\t\tintptr = &options->control_persist;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing ControlPersist\"\n\t\t\t    \" argument.\", filename, linenum);\n\t\tvalue = 0;\n\t\tvalue2 = 0;\t/* timeout */\n\t\tif (strcmp(arg, \"no\") == 0 || strcmp(arg, \"false\") == 0)\n\t\t\tvalue = 0;\n\t\telse if (strcmp(arg, \"yes\") == 0 || strcmp(arg, \"true\") == 0)\n\t\t\tvalue = 1;\n\t\telse if ((value2 = convtime(arg)) >= 0)\n\t\t\tvalue = 1;\n\t\telse\n\t\t\tfatal(\"%.200s line %d: Bad ControlPersist argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1) {\n\t\t\t*intptr = value;\n\t\t\toptions->control_persist_timeout = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oHashKnownHosts:\n\t\tintptr = &options->hash_known_hosts;\n\t\tgoto parse_flag;\n\n\tcase oTunnel:\n\t\tintptr = &options->tun_open;\n\t\tmultistate_ptr = multistate_tunnel;\n\t\tgoto parse_multistate;\n\n\tcase oTunnelDevice:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tvalue = a2tun(arg, &value2);\n\t\tif (value == SSH_TUNID_ERR)\n\t\t\tfatal(\"%.200s line %d: Bad tun device.\", filename, linenum);\n\t\tif (*activep) {\n\t\t\toptions->tun_local = value;\n\t\t\toptions->tun_remote = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oLocalCommand:\n\t\tcharptr = &options->local_command;\n\t\tgoto parse_command;\n\n\tcase oPermitLocalCommand:\n\t\tintptr = &options->permit_local_command;\n\t\tgoto parse_flag;\n\n\tcase oRemoteCommand:\n\t\tcharptr = &options->remote_command;\n\t\tgoto parse_command;\n\n\tcase oVisualHostKey:\n\t\tintptr = &options->visual_host_key;\n\t\tgoto parse_flag;\n\n\tcase oInclude:\n\t\tif (cmdline)\n\t\t\tfatal(\"Include directive not supported as a \"\n\t\t\t    \"command-line option\");\n\t\tvalue = 0;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\t/*\n\t\t\t * Ensure all paths are anchored. User configuration\n\t\t\t * files may begin with '~/' but system configurations\n\t\t\t * must not. If the path is relative, then treat it\n\t\t\t * as living in ~/.ssh for user configurations or\n\t\t\t * /etc/ssh for system ones.\n\t\t\t */\n\t\t\tif (*arg == '~' && (flags & SSHCONF_USERCONF) == 0)\n\t\t\t\tfatal(\"%.200s line %d: bad include path %s.\",\n\t\t\t\t    filename, linenum, arg);\n\t\t\tif (*arg != '/' && *arg != '~') {\n\t\t\t\txasprintf(&arg2, \"%s/%s\",\n\t\t\t\t    (flags & SSHCONF_USERCONF) ?\n\t\t\t\t    \"~/\" _PATH_SSH_USER_DIR : SSHDIR, arg);\n\t\t\t} else\n\t\t\t\targ2 = xstrdup(arg);\n\t\t\tmemset(&gl, 0, sizeof(gl));\n\t\t\tr = glob(arg2, GLOB_TILDE, NULL, &gl);\n\t\t\tif (r == GLOB_NOMATCH) {\n\t\t\t\tdebug(\"%.200s line %d: include %s matched no \"\n\t\t\t\t    \"files\",filename, linenum, arg2);\n\t\t\t\tfree(arg2);\n\t\t\t\tcontinue;\n\t\t\t} else if (r != 0 || gl.gl_pathc < 0)\n\t\t\t\tfatal(\"%.200s line %d: glob failed for %s.\",\n\t\t\t\t    filename, linenum, arg2);\n\t\t\tfree(arg2);\n\t\t\toactive = *activep;\n\t\t\tfor (i = 0; i < (u_int)gl.gl_pathc; i++) {\n\t\t\t\tdebug3(\"%.200s line %d: Including file %s \"\n\t\t\t\t    \"depth %d%s\", filename, linenum,\n\t\t\t\t    gl.gl_pathv[i], depth,\n\t\t\t\t    oactive ? \"\" : \" (parse only)\");\n\t\t\t\tr = read_config_file_depth(gl.gl_pathv[i],\n\t\t\t\t    pw, host, original_host, options,\n\t\t\t\t    flags | SSHCONF_CHECKPERM |\n\t\t\t\t    (oactive ? 0 : SSHCONF_NEVERMATCH),\n\t\t\t\t    activep, depth + 1);\n\t\t\t\tif (r != 1 && errno != ENOENT) {\n\t\t\t\t\tfatal(\"Can't open user config file \"\n\t\t\t\t\t    \"%.100s: %.100s\", gl.gl_pathv[i],\n\t\t\t\t\t    strerror(errno));\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * don't let Match in includes clobber the\n\t\t\t\t * containing file's Match state.\n\t\t\t\t */\n\t\t\t\t*activep = oactive;\n\t\t\t\tif (r != 1)\n\t\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\tglobfree(&gl);\n\t\t}\n\t\tif (value != 0)\n\t\t\treturn value;\n\t\tbreak;\n\n\tcase oIPQoS:\n\t\targ = strdelim(&s);\n\t\tif ((value = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\targ = strdelim(&s);\n\t\tif (arg == NULL)\n\t\t\tvalue2 = value;\n\t\telse if ((value2 = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep) {\n\t\t\toptions->ip_qos_interactive = value;\n\t\t\toptions->ip_qos_bulk = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oRequestTTY:\n\t\tintptr = &options->request_tty;\n\t\tmultistate_ptr = multistate_requesttty;\n\t\tgoto parse_multistate;\n\n\tcase oIgnoreUnknown:\n\t\tcharptr = &options->ignored_unknown;\n\t\tgoto parse_string;\n\n\tcase oProxyUseFdpass:\n\t\tintptr = &options->proxy_use_fdpass;\n\t\tgoto parse_flag;\n\n\tcase oCanonicalDomains:\n\t\tvalue = options->num_canonical_domains != 0;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\tif (!valid_domain(arg, 1, &errstr)) {\n\t\t\t\tfatal(\"%s line %d: %s\", filename, linenum,\n\t\t\t\t    errstr);\n\t\t\t}\n\t\t\tif (!*activep || value)\n\t\t\t\tcontinue;\n\t\t\tif (options->num_canonical_domains >= MAX_CANON_DOMAINS)\n\t\t\t\tfatal(\"%s line %d: too many hostname suffixes.\",\n\t\t\t\t    filename, linenum);\n\t\t\toptions->canonical_domains[\n\t\t\t    options->num_canonical_domains++] = xstrdup(arg);\n\t\t}\n\t\tbreak;\n\n\tcase oCanonicalizePermittedCNAMEs:\n\t\tvalue = options->num_permitted_cnames != 0;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\t/* Either '*' for everything or 'list:list' */\n\t\t\tif (strcmp(arg, \"*\") == 0)\n\t\t\t\targ2 = arg;\n\t\t\telse {\n\t\t\t\tlowercase(arg);\n\t\t\t\tif ((arg2 = strchr(arg, ':')) == NULL ||\n\t\t\t\t    arg2[1] == '\\0') {\n\t\t\t\t\tfatal(\"%s line %d: \"\n\t\t\t\t\t    \"Invalid permitted CNAME \\\"%s\\\"\",\n\t\t\t\t\t    filename, linenum, arg);\n\t\t\t\t}\n\t\t\t\t*arg2 = '\\0';\n\t\t\t\targ2++;\n\t\t\t}\n\t\t\tif (!*activep || value)\n\t\t\t\tcontinue;\n\t\t\tif (options->num_permitted_cnames >= MAX_CANON_DOMAINS)\n\t\t\t\tfatal(\"%s line %d: too many permitted CNAMEs.\",\n\t\t\t\t    filename, linenum);\n\t\t\tcname = options->permitted_cnames +\n\t\t\t    options->num_permitted_cnames++;\n\t\t\tcname->source_list = xstrdup(arg);\n\t\t\tcname->target_list = xstrdup(arg2);\n\t\t}\n\t\tbreak;\n\n\tcase oCanonicalizeHostname:\n\t\tintptr = &options->canonicalize_hostname;\n\t\tmultistate_ptr = multistate_canonicalizehostname;\n\t\tgoto parse_multistate;\n\n\tcase oCanonicalizeMaxDots:\n\t\tintptr = &options->canonicalize_max_dots;\n\t\tgoto parse_int;\n\n\tcase oCanonicalizeFallbackLocal:\n\t\tintptr = &options->canonicalize_fallback_local;\n\t\tgoto parse_flag;\n\n\tcase oStreamLocalBindMask:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing StreamLocalBindMask argument.\", filename, linenum);\n\t\t/* Parse mode in octal format */\n\t\tvalue = strtol(arg, &endofnumber, 8);\n\t\tif (arg == endofnumber || value < 0 || value > 0777)\n\t\t\tfatal(\"%.200s line %d: Bad mask.\", filename, linenum);\n\t\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)value;\n\t\tbreak;\n\n\tcase oStreamLocalBindUnlink:\n\t\tintptr = &options->fwd_opts.streamlocal_bind_unlink;\n\t\tgoto parse_flag;\n\n\tcase oRevokedHostKeys:\n\t\tcharptr = &options->revoked_host_keys;\n\t\tgoto parse_string;\n\n\tcase oFingerprintHash:\n\t\tintptr = &options->fingerprint_hash;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = ssh_digest_alg_by_name(arg)) == -1)\n\t\t\tfatal(\"%.200s line %d: Invalid hash algorithm \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oUpdateHostkeys:\n\t\tintptr = &options->update_hostkeys;\n\t\tmultistate_ptr = multistate_yesnoask;\n\t\tgoto parse_multistate;\n\n\tcase oHostbasedKeyTypes:\n\t\tcharptr = &options->hostbased_key_types;\n\t\tgoto parse_keytypes;\n\n\tcase oPubkeyAcceptedKeyTypes:\n\t\tcharptr = &options->pubkey_key_types;\n\t\tgoto parse_keytypes;\n\n\tcase oAddKeysToAgent:\n\t\tintptr = &options->add_keys_to_agent;\n\t\tmultistate_ptr = multistate_yesnoaskconfirm;\n\t\tgoto parse_multistate;\n\n\tcase oIdentityAgent:\n\t\tcharptr = &options->identity_agent;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t/* Extra validation if the string represents an env var. */\n\t\tif (arg[0] == '$' && !valid_env_name(arg + 1)) {\n\t\t\tfatal(\"%.200s line %d: Invalid environment name %s.\",\n\t\t\t    filename, linenum, arg);\n\t\t}\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oDeprecated:\n\t\tdebug(\"%s line %d: Deprecated option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn 0;\n\n\tcase oUnsupported:\n\t\terror(\"%s line %d: Unsupported option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn 0;\n\n\tdefault:\n\t\tfatal(\"%s: Unimplemented opcode %d\", __func__, opcode);\n\t}\n\n\t/* Check that there is no garbage at end of line. */\n\tif ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\tfatal(\"%.200s line %d: garbage at end of line; \\\"%.200s\\\".\",\n\t\t    filename, linenum, arg);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define WHITESPACE \" \\t\\r\\n\""
          ],
          "globals_used": [
            "static int read_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int depth);",
            "static int process_config_line_depth(Options *options, struct passwd *pw,\n    const char *host, const char *original_host, char *line,\n    const char *filename, int linenum, int *activep, int flags, int depth);",
            "static const struct multistate multistate_flag[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_yesnoask[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_strict_hostkey[] = {\n\t{ \"true\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"false\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"yes\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"no\",\t\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"ask\",\t\t\tSSH_STRICT_HOSTKEY_ASK },\n\t{ \"off\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"accept-new\",\t\t\tSSH_STRICT_HOSTKEY_NEW },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_yesnoaskconfirm[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ \"confirm\",\t\t\t3 },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_controlmaster[] = {\n\t{ \"true\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"yes\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"false\",\t\t\tSSHCTL_MASTER_NO },\n\t{ \"no\",\t\t\t\tSSHCTL_MASTER_NO },\n\t{ \"auto\",\t\t\tSSHCTL_MASTER_AUTO },\n\t{ \"ask\",\t\t\tSSHCTL_MASTER_ASK },\n\t{ \"autoask\",\t\t\tSSHCTL_MASTER_AUTO_ASK },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_tunnel[] = {\n\t{ \"ethernet\",\t\t\tSSH_TUNMODE_ETHERNET },\n\t{ \"point-to-point\",\t\tSSH_TUNMODE_POINTOPOINT },\n\t{ \"true\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"yes\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"false\",\t\t\tSSH_TUNMODE_NO },\n\t{ \"no\",\t\t\t\tSSH_TUNMODE_NO },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_requesttty[] = {\n\t{ \"true\",\t\t\tREQUEST_TTY_YES },\n\t{ \"yes\",\t\t\tREQUEST_TTY_YES },\n\t{ \"false\",\t\t\tREQUEST_TTY_NO },\n\t{ \"no\",\t\t\t\tREQUEST_TTY_NO },\n\t{ \"force\",\t\t\tREQUEST_TTY_FORCE },\n\t{ \"auto\",\t\t\tREQUEST_TTY_AUTO },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_canonicalizehostname[] = {\n\t{ \"true\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"false\",\t\t\tSSH_CANONICALISE_NO },\n\t{ \"yes\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"no\",\t\t\t\tSSH_CANONICALISE_NO },\n\t{ \"always\",\t\t\tSSH_CANONICALISE_ALWAYS },\n\t{ NULL, -1 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define WHITESPACE \" \\t\\r\\n\"\n\nstatic int read_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int depth);\nstatic int process_config_line_depth(Options *options, struct passwd *pw,\n    const char *host, const char *original_host, char *line,\n    const char *filename, int linenum, int *activep, int flags, int depth);\nstatic const struct multistate multistate_flag[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_yesnoask[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_strict_hostkey[] = {\n\t{ \"true\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"false\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"yes\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"no\",\t\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"ask\",\t\t\tSSH_STRICT_HOSTKEY_ASK },\n\t{ \"off\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"accept-new\",\t\t\tSSH_STRICT_HOSTKEY_NEW },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_yesnoaskconfirm[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ \"confirm\",\t\t\t3 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_controlmaster[] = {\n\t{ \"true\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"yes\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"false\",\t\t\tSSHCTL_MASTER_NO },\n\t{ \"no\",\t\t\t\tSSHCTL_MASTER_NO },\n\t{ \"auto\",\t\t\tSSHCTL_MASTER_AUTO },\n\t{ \"ask\",\t\t\tSSHCTL_MASTER_ASK },\n\t{ \"autoask\",\t\t\tSSHCTL_MASTER_AUTO_ASK },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_tunnel[] = {\n\t{ \"ethernet\",\t\t\tSSH_TUNMODE_ETHERNET },\n\t{ \"point-to-point\",\t\tSSH_TUNMODE_POINTOPOINT },\n\t{ \"true\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"yes\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"false\",\t\t\tSSH_TUNMODE_NO },\n\t{ \"no\",\t\t\t\tSSH_TUNMODE_NO },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_requesttty[] = {\n\t{ \"true\",\t\t\tREQUEST_TTY_YES },\n\t{ \"yes\",\t\t\tREQUEST_TTY_YES },\n\t{ \"false\",\t\t\tREQUEST_TTY_NO },\n\t{ \"no\",\t\t\t\tREQUEST_TTY_NO },\n\t{ \"force\",\t\t\tREQUEST_TTY_FORCE },\n\t{ \"auto\",\t\t\tREQUEST_TTY_AUTO },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_canonicalizehostname[] = {\n\t{ \"true\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"false\",\t\t\tSSH_CANONICALISE_NO },\n\t{ \"yes\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"no\",\t\t\t\tSSH_CANONICALISE_NO },\n\t{ \"always\",\t\t\tSSH_CANONICALISE_ALWAYS },\n\t{ NULL, -1 }\n};\n\nstatic int\nprocess_config_line_depth(Options *options, struct passwd *pw, const char *host,\n    const char *original_host, char *line, const char *filename,\n    int linenum, int *activep, int flags, int depth)\n{\n\tchar *s, **charptr, *endofnumber, *keyword, *arg, *arg2;\n\tchar **cpptr, fwdarg[256];\n\tu_int i, *uintptr, max_entries = 0;\n\tint r, oactive, negated, opcode, *intptr, value, value2, cmdline = 0;\n\tint remotefwd, dynamicfwd;\n\tLogLevel *log_level_ptr;\n\tSyslogFacility *log_facility_ptr;\n\tlong long val64;\n\tsize_t len;\n\tstruct Forward fwd;\n\tconst struct multistate *multistate_ptr;\n\tstruct allowed_cname *cname;\n\tglob_t gl;\n\tconst char *errstr;\n\n\tif (activep == NULL) { /* We are processing a command line directive */\n\t\tcmdline = 1;\n\t\tactivep = &cmdline;\n\t}\n\n\t/* Strip trailing whitespace. Allow \\f (form feed) at EOL only */\n\tif ((len = strlen(line)) == 0)\n\t\treturn 0;\n\tfor (len--; len > 0; len--) {\n\t\tif (strchr(WHITESPACE \"\\f\", line[len]) == NULL)\n\t\t\tbreak;\n\t\tline[len] = '\\0';\n\t}\n\n\ts = line;\n\t/* Get the keyword. (Each line is supposed to begin with a keyword). */\n\tif ((keyword = strdelim(&s)) == NULL)\n\t\treturn 0;\n\t/* Ignore leading whitespace. */\n\tif (*keyword == '\\0')\n\t\tkeyword = strdelim(&s);\n\tif (keyword == NULL || !*keyword || *keyword == '\\n' || *keyword == '#')\n\t\treturn 0;\n\t/* Match lowercase keyword */\n\tlowercase(keyword);\n\n\topcode = parse_token(keyword, filename, linenum,\n\t    options->ignored_unknown);\n\n\tswitch (opcode) {\n\tcase oBadOption:\n\t\t/* don't panic, but count bad options */\n\t\treturn -1;\n\tcase oIgnore:\n\t\treturn 0;\n\tcase oIgnoredUnknownOption:\n\t\tdebug(\"%s line %d: Ignored unknown option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn 0;\n\tcase oConnectTimeout:\n\t\tintptr = &options->connection_timeout;\nparse_time:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing time value.\",\n\t\t\t    filename, linenum);\n\t\tif (strcmp(arg, \"none\") == 0)\n\t\t\tvalue = -1;\n\t\telse if ((value = convtime(arg)) == -1)\n\t\t\tfatal(\"%s line %d: invalid time value.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oForwardAgent:\n\t\tintptr = &options->forward_agent;\n parse_flag:\n\t\tmultistate_ptr = multistate_flag;\n parse_multistate:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; multistate_ptr[i].key != NULL; i++) {\n\t\t\tif (strcasecmp(arg, multistate_ptr[i].key) == 0) {\n\t\t\t\tvalue = multistate_ptr[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: unsupported option \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oForwardX11:\n\t\tintptr = &options->forward_x11;\n\t\tgoto parse_flag;\n\n\tcase oForwardX11Trusted:\n\t\tintptr = &options->forward_x11_trusted;\n\t\tgoto parse_flag;\n\n\tcase oForwardX11Timeout:\n\t\tintptr = &options->forward_x11_timeout;\n\t\tgoto parse_time;\n\n\tcase oGatewayPorts:\n\t\tintptr = &options->fwd_opts.gateway_ports;\n\t\tgoto parse_flag;\n\n\tcase oExitOnForwardFailure:\n\t\tintptr = &options->exit_on_forward_failure;\n\t\tgoto parse_flag;\n\n\tcase oPasswordAuthentication:\n\t\tintptr = &options->password_authentication;\n\t\tgoto parse_flag;\n\n\tcase oKbdInteractiveAuthentication:\n\t\tintptr = &options->kbd_interactive_authentication;\n\t\tgoto parse_flag;\n\n\tcase oKbdInteractiveDevices:\n\t\tcharptr = &options->kbd_interactive_devices;\n\t\tgoto parse_string;\n\n\tcase oPubkeyAuthentication:\n\t\tintptr = &options->pubkey_authentication;\n\t\tgoto parse_flag;\n\n\tcase oHostbasedAuthentication:\n\t\tintptr = &options->hostbased_authentication;\n\t\tgoto parse_flag;\n\n\tcase oChallengeResponseAuthentication:\n\t\tintptr = &options->challenge_response_authentication;\n\t\tgoto parse_flag;\n\n\tcase oGssAuthentication:\n\t\tintptr = &options->gss_authentication;\n\t\tgoto parse_flag;\n\n\tcase oGssDelegateCreds:\n\t\tintptr = &options->gss_deleg_creds;\n\t\tgoto parse_flag;\n\n\tcase oBatchMode:\n\t\tintptr = &options->batch_mode;\n\t\tgoto parse_flag;\n\n\tcase oCheckHostIP:\n\t\tintptr = &options->check_host_ip;\n\t\tgoto parse_flag;\n\n\tcase oVerifyHostKeyDNS:\n\t\tintptr = &options->verify_host_key_dns;\n\t\tmultistate_ptr = multistate_yesnoask;\n\t\tgoto parse_multistate;\n\n\tcase oStrictHostKeyChecking:\n\t\tintptr = &options->strict_host_key_checking;\n\t\tmultistate_ptr = multistate_strict_hostkey;\n\t\tgoto parse_multistate;\n\n\tcase oCompression:\n\t\tintptr = &options->compression;\n\t\tgoto parse_flag;\n\n\tcase oTCPKeepAlive:\n\t\tintptr = &options->tcp_keep_alive;\n\t\tgoto parse_flag;\n\n\tcase oNoHostAuthenticationForLocalhost:\n\t\tintptr = &options->no_host_authentication_for_localhost;\n\t\tgoto parse_flag;\n\n\tcase oNumberOfPasswordPrompts:\n\t\tintptr = &options->number_of_password_prompts;\n\t\tgoto parse_int;\n\n\tcase oRekeyLimit:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tif (strcmp(arg, \"default\") == 0) {\n\t\t\tval64 = 0;\n\t\t} else {\n\t\t\tif (scan_scaled(arg, &val64) == -1)\n\t\t\t\tfatal(\"%.200s line %d: Bad number '%s': %s\",\n\t\t\t\t    filename, linenum, arg, strerror(errno));\n\t\t\tif (val64 != 0 && val64 < 16)\n\t\t\t\tfatal(\"%.200s line %d: RekeyLimit too small\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\tif (*activep && options->rekey_limit == -1)\n\t\t\toptions->rekey_limit = val64;\n\t\tif (s != NULL) { /* optional rekey interval present */\n\t\t\tif (strcmp(s, \"none\") == 0) {\n\t\t\t\t(void)strdelim(&s);\t/* discard */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tintptr = &options->rekey_interval;\n\t\t\tgoto parse_time;\n\t\t}\n\t\tbreak;\n\n\tcase oIdentityFile:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (*activep) {\n\t\t\tintptr = &options->num_identity_files;\n\t\t\tif (*intptr >= SSH_MAX_IDENTITY_FILES)\n\t\t\t\tfatal(\"%.200s line %d: Too many identity files specified (max %d).\",\n\t\t\t\t    filename, linenum, SSH_MAX_IDENTITY_FILES);\n\t\t\tadd_identity_file(options, NULL,\n\t\t\t    arg, flags & SSHCONF_USERCONF);\n\t\t}\n\t\tbreak;\n\n\tcase oCertificateFile:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep) {\n\t\t\tintptr = &options->num_certificate_files;\n\t\t\tif (*intptr >= SSH_MAX_CERTIFICATE_FILES) {\n\t\t\t\tfatal(\"%.200s line %d: Too many certificate \"\n\t\t\t\t    \"files specified (max %d).\",\n\t\t\t\t    filename, linenum,\n\t\t\t\t    SSH_MAX_CERTIFICATE_FILES);\n\t\t\t}\n\t\t\tadd_certificate_file(options, arg,\n\t\t\t    flags & SSHCONF_USERCONF);\n\t\t}\n\t\tbreak;\n\n\tcase oXAuthLocation:\n\t\tcharptr=&options->xauth_location;\n\t\tgoto parse_string;\n\n\tcase oUser:\n\t\tcharptr = &options->user;\nparse_string:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oGlobalKnownHostsFile:\n\t\tcpptr = (char **)&options->system_hostfiles;\n\t\tuintptr = &options->num_system_hostfiles;\n\t\tmax_entries = SSH_MAX_HOSTS_FILES;\nparse_char_array:\n\t\tif (*activep && *uintptr == 0) {\n\t\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\t\tif ((*uintptr) >= max_entries)\n\t\t\t\t\tfatal(\"%s line %d: \"\n\t\t\t\t\t    \"too many authorized keys files.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\tcpptr[(*uintptr)++] = xstrdup(arg);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase oUserKnownHostsFile:\n\t\tcpptr = (char **)&options->user_hostfiles;\n\t\tuintptr = &options->num_user_hostfiles;\n\t\tmax_entries = SSH_MAX_HOSTS_FILES;\n\t\tgoto parse_char_array;\n\n\tcase oHostName:\n\t\tcharptr = &options->hostname;\n\t\tgoto parse_string;\n\n\tcase oHostKeyAlias:\n\t\tcharptr = &options->host_key_alias;\n\t\tgoto parse_string;\n\n\tcase oPreferredAuthentications:\n\t\tcharptr = &options->preferred_authentications;\n\t\tgoto parse_string;\n\n\tcase oBindAddress:\n\t\tcharptr = &options->bind_address;\n\t\tgoto parse_string;\n\n\tcase oBindInterface:\n\t\tcharptr = &options->bind_interface;\n\t\tgoto parse_string;\n\n\tcase oPKCS11Provider:\n\t\tcharptr = &options->pkcs11_provider;\n\t\tgoto parse_string;\n\n\tcase oProxyCommand:\n\t\tcharptr = &options->proxy_command;\n\t\t/* Ignore ProxyCommand if ProxyJump already specified */\n\t\tif (options->jump_host != NULL)\n\t\t\tcharptr = &options->jump_host; /* Skip below */\nparse_command:\n\t\tif (s == NULL)\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tlen = strspn(s, WHITESPACE \"=\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(s + len);\n\t\treturn 0;\n\n\tcase oProxyJump:\n\t\tif (s == NULL) {\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t}\n\t\tlen = strspn(s, WHITESPACE \"=\");\n\t\tif (parse_jump(s + len, options, *activep) == -1) {\n\t\t\tfatal(\"%.200s line %d: Invalid ProxyJump \\\"%s\\\"\",\n\t\t\t    filename, linenum, s + len);\n\t\t}\n\t\treturn 0;\n\n\tcase oPort:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = a2port(arg);\n\t\tif (value <= 0)\n\t\t\tfatal(\"%.200s line %d: Bad port '%s'.\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && options->port == -1)\n\t\t\toptions->port = value;\n\t\tbreak;\n\n\tcase oConnectionAttempts:\n\t\tintptr = &options->connection_attempts;\nparse_int:\n\t\targ = strdelim(&s);\n\t\tif ((errstr = atoi_err(arg, &value)) != NULL)\n\t\t\tfatal(\"%s line %d: integer value %s.\",\n\t\t\t    filename, linenum, errstr);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oCiphers:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !ciphers_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%.200s line %d: Bad SSH2 cipher spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && options->ciphers == NULL)\n\t\t\toptions->ciphers = xstrdup(arg);\n\t\tbreak;\n\n\tcase oMacs:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !mac_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%.200s line %d: Bad SSH2 Mac spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && options->macs == NULL)\n\t\t\toptions->macs = xstrdup(arg);\n\t\tbreak;\n\n\tcase oKexAlgorithms:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !kex_names_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%.200s line %d: Bad SSH2 KexAlgorithms '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && options->kex_algorithms == NULL)\n\t\t\toptions->kex_algorithms = xstrdup(arg);\n\t\tbreak;\n\n\tcase oHostKeyAlgorithms:\n\t\tcharptr = &options->hostkeyalgorithms;\nparse_keytypes:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !sshkey_names_valid2(*arg == '+' ? arg + 1 : arg, 1))\n\t\t\tfatal(\"%s line %d: Bad key types '%s'.\",\n\t\t\t\tfilename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oCASignatureAlgorithms:\n\t\tcharptr = &options->ca_sign_algorithms;\n\t\tgoto parse_keytypes;\n\n\tcase oLogLevel:\n\t\tlog_level_ptr = &options->log_level;\n\t\targ = strdelim(&s);\n\t\tvalue = log_level_number(arg);\n\t\tif (value == SYSLOG_LEVEL_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log level '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *log_level_ptr == SYSLOG_LEVEL_NOT_SET)\n\t\t\t*log_level_ptr = (LogLevel) value;\n\t\tbreak;\n\n\tcase oLogFacility:\n\t\tlog_facility_ptr = &options->log_facility;\n\t\targ = strdelim(&s);\n\t\tvalue = log_facility_number(arg);\n\t\tif (value == SYSLOG_FACILITY_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log facility '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*log_facility_ptr == -1)\n\t\t\t*log_facility_ptr = (SyslogFacility) value;\n\t\tbreak;\n\n\tcase oLocalForward:\n\tcase oRemoteForward:\n\tcase oDynamicForward:\n\t\targ = strdelim(&s);\n\t\tif (arg == NULL || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing port argument.\",\n\t\t\t    filename, linenum);\n\n\t\tremotefwd = (opcode == oRemoteForward);\n\t\tdynamicfwd = (opcode == oDynamicForward);\n\n\t\tif (!dynamicfwd) {\n\t\t\targ2 = strdelim(&s);\n\t\t\tif (arg2 == NULL || *arg2 == '\\0') {\n\t\t\t\tif (remotefwd)\n\t\t\t\t\tdynamicfwd = 1;\n\t\t\t\telse\n\t\t\t\t\tfatal(\"%.200s line %d: Missing target \"\n\t\t\t\t\t    \"argument.\", filename, linenum);\n\t\t\t} else {\n\t\t\t\t/* construct a string for parse_forward */\n\t\t\t\tsnprintf(fwdarg, sizeof(fwdarg), \"%s:%s\", arg,\n\t\t\t\t    arg2);\n\t\t\t}\n\t\t}\n\t\tif (dynamicfwd)\n\t\t\tstrlcpy(fwdarg, arg, sizeof(fwdarg));\n\n\t\tif (parse_forward(&fwd, fwdarg, dynamicfwd, remotefwd) == 0)\n\t\t\tfatal(\"%.200s line %d: Bad forwarding specification.\",\n\t\t\t    filename, linenum);\n\n\t\tif (*activep) {\n\t\t\tif (remotefwd) {\n\t\t\t\tadd_remote_forward(options, &fwd);\n\t\t\t} else {\n\t\t\t\tadd_local_forward(options, &fwd);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase oClearAllForwardings:\n\t\tintptr = &options->clear_forwardings;\n\t\tgoto parse_flag;\n\n\tcase oHost:\n\t\tif (cmdline)\n\t\t\tfatal(\"Host directive not supported as a command-line \"\n\t\t\t    \"option\");\n\t\t*activep = 0;\n\t\targ2 = NULL;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\tif ((flags & SSHCONF_NEVERMATCH) != 0)\n\t\t\t\tbreak;\n\t\t\tnegated = *arg == '!';\n\t\t\tif (negated)\n\t\t\t\targ++;\n\t\t\tif (match_pattern(host, arg)) {\n\t\t\t\tif (negated) {\n\t\t\t\t\tdebug(\"%.200s line %d: Skipping Host \"\n\t\t\t\t\t    \"block because of negated match \"\n\t\t\t\t\t    \"for %.100s\", filename, linenum,\n\t\t\t\t\t    arg);\n\t\t\t\t\t*activep = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!*activep)\n\t\t\t\t\targ2 = arg; /* logged below */\n\t\t\t\t*activep = 1;\n\t\t\t}\n\t\t}\n\t\tif (*activep)\n\t\t\tdebug(\"%.200s line %d: Applying options for %.100s\",\n\t\t\t    filename, linenum, arg2);\n\t\t/* Avoid garbage check below, as strdelim is done. */\n\t\treturn 0;\n\n\tcase oMatch:\n\t\tif (cmdline)\n\t\t\tfatal(\"Host directive not supported as a command-line \"\n\t\t\t    \"option\");\n\t\tvalue = match_cfg_line(options, &s, pw, host, original_host,\n\t\t    flags & SSHCONF_POSTCANON, filename, linenum);\n\t\tif (value < 0)\n\t\t\tfatal(\"%.200s line %d: Bad Match condition\", filename,\n\t\t\t    linenum);\n\t\t*activep = (flags & SSHCONF_NEVERMATCH) ? 0 : value;\n\t\tbreak;\n\n\tcase oEscapeChar:\n\t\tintptr = &options->escape_char;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (strcmp(arg, \"none\") == 0)\n\t\t\tvalue = SSH_ESCAPECHAR_NONE;\n\t\telse if (arg[1] == '\\0')\n\t\t\tvalue = (u_char) arg[0];\n\t\telse if (arg[0] == '^' && arg[2] == 0 &&\n\t\t    (u_char) arg[1] >= 64 && (u_char) arg[1] < 128)\n\t\t\tvalue = (u_char) arg[1] & 31;\n\t\telse {\n\t\t\tfatal(\"%.200s line %d: Bad escape character.\",\n\t\t\t    filename, linenum);\n\t\t\t/* NOTREACHED */\n\t\t\tvalue = 0;\t/* Avoid compiler warning. */\n\t\t}\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oAddressFamily:\n\t\tintptr = &options->address_family;\n\t\tmultistate_ptr = multistate_addressfamily;\n\t\tgoto parse_multistate;\n\n\tcase oEnableSSHKeysign:\n\t\tintptr = &options->enable_ssh_keysign;\n\t\tgoto parse_flag;\n\n\tcase oIdentitiesOnly:\n\t\tintptr = &options->identities_only;\n\t\tgoto parse_flag;\n\n\tcase oServerAliveInterval:\n\t\tintptr = &options->server_alive_interval;\n\t\tgoto parse_time;\n\n\tcase oServerAliveCountMax:\n\t\tintptr = &options->server_alive_count_max;\n\t\tgoto parse_int;\n\n\tcase oSendEnv:\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') != NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment name.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tif (*arg == '-') {\n\t\t\t\t/* Removing an env var */\n\t\t\t\trm_env(options, arg, filename, linenum);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/* Adding an env var */\n\t\t\t\tif (options->num_send_env >= INT_MAX)\n\t\t\t\t\tfatal(\"%s line %d: too many send env.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\toptions->send_env = xrecallocarray(\n\t\t\t\t    options->send_env, options->num_send_env,\n\t\t\t\t    options->num_send_env + 1,\n\t\t\t\t    sizeof(*options->send_env));\n\t\t\t\toptions->send_env[options->num_send_env++] =\n\t\t\t\t    xstrdup(arg);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase oSetEnv:\n\t\tvalue = options->num_setenv;\n\t\twhile ((arg = strdelimw(&s)) != NULL && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') == NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid SetEnv.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep || value != 0)\n\t\t\t\tcontinue;\n\t\t\t/* Adding a setenv var */\n\t\t\tif (options->num_setenv >= INT_MAX)\n\t\t\t\tfatal(\"%s line %d: too many SetEnv.\",\n\t\t\t\t    filename, linenum);\n\t\t\toptions->setenv = xrecallocarray(\n\t\t\t    options->setenv, options->num_setenv,\n\t\t\t    options->num_setenv + 1, sizeof(*options->setenv));\n\t\t\toptions->setenv[options->num_setenv++] = xstrdup(arg);\n\t\t}\n\t\tbreak;\n\n\tcase oControlPath:\n\t\tcharptr = &options->control_path;\n\t\tgoto parse_string;\n\n\tcase oControlMaster:\n\t\tintptr = &options->control_master;\n\t\tmultistate_ptr = multistate_controlmaster;\n\t\tgoto parse_multistate;\n\n\tcase oControlPersist:\n\t\t/* no/false/yes/true, or a time spec */\n\t\tintptr = &options->control_persist;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing ControlPersist\"\n\t\t\t    \" argument.\", filename, linenum);\n\t\tvalue = 0;\n\t\tvalue2 = 0;\t/* timeout */\n\t\tif (strcmp(arg, \"no\") == 0 || strcmp(arg, \"false\") == 0)\n\t\t\tvalue = 0;\n\t\telse if (strcmp(arg, \"yes\") == 0 || strcmp(arg, \"true\") == 0)\n\t\t\tvalue = 1;\n\t\telse if ((value2 = convtime(arg)) >= 0)\n\t\t\tvalue = 1;\n\t\telse\n\t\t\tfatal(\"%.200s line %d: Bad ControlPersist argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1) {\n\t\t\t*intptr = value;\n\t\t\toptions->control_persist_timeout = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oHashKnownHosts:\n\t\tintptr = &options->hash_known_hosts;\n\t\tgoto parse_flag;\n\n\tcase oTunnel:\n\t\tintptr = &options->tun_open;\n\t\tmultistate_ptr = multistate_tunnel;\n\t\tgoto parse_multistate;\n\n\tcase oTunnelDevice:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tvalue = a2tun(arg, &value2);\n\t\tif (value == SSH_TUNID_ERR)\n\t\t\tfatal(\"%.200s line %d: Bad tun device.\", filename, linenum);\n\t\tif (*activep) {\n\t\t\toptions->tun_local = value;\n\t\t\toptions->tun_remote = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oLocalCommand:\n\t\tcharptr = &options->local_command;\n\t\tgoto parse_command;\n\n\tcase oPermitLocalCommand:\n\t\tintptr = &options->permit_local_command;\n\t\tgoto parse_flag;\n\n\tcase oRemoteCommand:\n\t\tcharptr = &options->remote_command;\n\t\tgoto parse_command;\n\n\tcase oVisualHostKey:\n\t\tintptr = &options->visual_host_key;\n\t\tgoto parse_flag;\n\n\tcase oInclude:\n\t\tif (cmdline)\n\t\t\tfatal(\"Include directive not supported as a \"\n\t\t\t    \"command-line option\");\n\t\tvalue = 0;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\t/*\n\t\t\t * Ensure all paths are anchored. User configuration\n\t\t\t * files may begin with '~/' but system configurations\n\t\t\t * must not. If the path is relative, then treat it\n\t\t\t * as living in ~/.ssh for user configurations or\n\t\t\t * /etc/ssh for system ones.\n\t\t\t */\n\t\t\tif (*arg == '~' && (flags & SSHCONF_USERCONF) == 0)\n\t\t\t\tfatal(\"%.200s line %d: bad include path %s.\",\n\t\t\t\t    filename, linenum, arg);\n\t\t\tif (*arg != '/' && *arg != '~') {\n\t\t\t\txasprintf(&arg2, \"%s/%s\",\n\t\t\t\t    (flags & SSHCONF_USERCONF) ?\n\t\t\t\t    \"~/\" _PATH_SSH_USER_DIR : SSHDIR, arg);\n\t\t\t} else\n\t\t\t\targ2 = xstrdup(arg);\n\t\t\tmemset(&gl, 0, sizeof(gl));\n\t\t\tr = glob(arg2, GLOB_TILDE, NULL, &gl);\n\t\t\tif (r == GLOB_NOMATCH) {\n\t\t\t\tdebug(\"%.200s line %d: include %s matched no \"\n\t\t\t\t    \"files\",filename, linenum, arg2);\n\t\t\t\tfree(arg2);\n\t\t\t\tcontinue;\n\t\t\t} else if (r != 0 || gl.gl_pathc < 0)\n\t\t\t\tfatal(\"%.200s line %d: glob failed for %s.\",\n\t\t\t\t    filename, linenum, arg2);\n\t\t\tfree(arg2);\n\t\t\toactive = *activep;\n\t\t\tfor (i = 0; i < (u_int)gl.gl_pathc; i++) {\n\t\t\t\tdebug3(\"%.200s line %d: Including file %s \"\n\t\t\t\t    \"depth %d%s\", filename, linenum,\n\t\t\t\t    gl.gl_pathv[i], depth,\n\t\t\t\t    oactive ? \"\" : \" (parse only)\");\n\t\t\t\tr = read_config_file_depth(gl.gl_pathv[i],\n\t\t\t\t    pw, host, original_host, options,\n\t\t\t\t    flags | SSHCONF_CHECKPERM |\n\t\t\t\t    (oactive ? 0 : SSHCONF_NEVERMATCH),\n\t\t\t\t    activep, depth + 1);\n\t\t\t\tif (r != 1 && errno != ENOENT) {\n\t\t\t\t\tfatal(\"Can't open user config file \"\n\t\t\t\t\t    \"%.100s: %.100s\", gl.gl_pathv[i],\n\t\t\t\t\t    strerror(errno));\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * don't let Match in includes clobber the\n\t\t\t\t * containing file's Match state.\n\t\t\t\t */\n\t\t\t\t*activep = oactive;\n\t\t\t\tif (r != 1)\n\t\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\tglobfree(&gl);\n\t\t}\n\t\tif (value != 0)\n\t\t\treturn value;\n\t\tbreak;\n\n\tcase oIPQoS:\n\t\targ = strdelim(&s);\n\t\tif ((value = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\targ = strdelim(&s);\n\t\tif (arg == NULL)\n\t\t\tvalue2 = value;\n\t\telse if ((value2 = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep) {\n\t\t\toptions->ip_qos_interactive = value;\n\t\t\toptions->ip_qos_bulk = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oRequestTTY:\n\t\tintptr = &options->request_tty;\n\t\tmultistate_ptr = multistate_requesttty;\n\t\tgoto parse_multistate;\n\n\tcase oIgnoreUnknown:\n\t\tcharptr = &options->ignored_unknown;\n\t\tgoto parse_string;\n\n\tcase oProxyUseFdpass:\n\t\tintptr = &options->proxy_use_fdpass;\n\t\tgoto parse_flag;\n\n\tcase oCanonicalDomains:\n\t\tvalue = options->num_canonical_domains != 0;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\tif (!valid_domain(arg, 1, &errstr)) {\n\t\t\t\tfatal(\"%s line %d: %s\", filename, linenum,\n\t\t\t\t    errstr);\n\t\t\t}\n\t\t\tif (!*activep || value)\n\t\t\t\tcontinue;\n\t\t\tif (options->num_canonical_domains >= MAX_CANON_DOMAINS)\n\t\t\t\tfatal(\"%s line %d: too many hostname suffixes.\",\n\t\t\t\t    filename, linenum);\n\t\t\toptions->canonical_domains[\n\t\t\t    options->num_canonical_domains++] = xstrdup(arg);\n\t\t}\n\t\tbreak;\n\n\tcase oCanonicalizePermittedCNAMEs:\n\t\tvalue = options->num_permitted_cnames != 0;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\t/* Either '*' for everything or 'list:list' */\n\t\t\tif (strcmp(arg, \"*\") == 0)\n\t\t\t\targ2 = arg;\n\t\t\telse {\n\t\t\t\tlowercase(arg);\n\t\t\t\tif ((arg2 = strchr(arg, ':')) == NULL ||\n\t\t\t\t    arg2[1] == '\\0') {\n\t\t\t\t\tfatal(\"%s line %d: \"\n\t\t\t\t\t    \"Invalid permitted CNAME \\\"%s\\\"\",\n\t\t\t\t\t    filename, linenum, arg);\n\t\t\t\t}\n\t\t\t\t*arg2 = '\\0';\n\t\t\t\targ2++;\n\t\t\t}\n\t\t\tif (!*activep || value)\n\t\t\t\tcontinue;\n\t\t\tif (options->num_permitted_cnames >= MAX_CANON_DOMAINS)\n\t\t\t\tfatal(\"%s line %d: too many permitted CNAMEs.\",\n\t\t\t\t    filename, linenum);\n\t\t\tcname = options->permitted_cnames +\n\t\t\t    options->num_permitted_cnames++;\n\t\t\tcname->source_list = xstrdup(arg);\n\t\t\tcname->target_list = xstrdup(arg2);\n\t\t}\n\t\tbreak;\n\n\tcase oCanonicalizeHostname:\n\t\tintptr = &options->canonicalize_hostname;\n\t\tmultistate_ptr = multistate_canonicalizehostname;\n\t\tgoto parse_multistate;\n\n\tcase oCanonicalizeMaxDots:\n\t\tintptr = &options->canonicalize_max_dots;\n\t\tgoto parse_int;\n\n\tcase oCanonicalizeFallbackLocal:\n\t\tintptr = &options->canonicalize_fallback_local;\n\t\tgoto parse_flag;\n\n\tcase oStreamLocalBindMask:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing StreamLocalBindMask argument.\", filename, linenum);\n\t\t/* Parse mode in octal format */\n\t\tvalue = strtol(arg, &endofnumber, 8);\n\t\tif (arg == endofnumber || value < 0 || value > 0777)\n\t\t\tfatal(\"%.200s line %d: Bad mask.\", filename, linenum);\n\t\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)value;\n\t\tbreak;\n\n\tcase oStreamLocalBindUnlink:\n\t\tintptr = &options->fwd_opts.streamlocal_bind_unlink;\n\t\tgoto parse_flag;\n\n\tcase oRevokedHostKeys:\n\t\tcharptr = &options->revoked_host_keys;\n\t\tgoto parse_string;\n\n\tcase oFingerprintHash:\n\t\tintptr = &options->fingerprint_hash;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = ssh_digest_alg_by_name(arg)) == -1)\n\t\t\tfatal(\"%.200s line %d: Invalid hash algorithm \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oUpdateHostkeys:\n\t\tintptr = &options->update_hostkeys;\n\t\tmultistate_ptr = multistate_yesnoask;\n\t\tgoto parse_multistate;\n\n\tcase oHostbasedKeyTypes:\n\t\tcharptr = &options->hostbased_key_types;\n\t\tgoto parse_keytypes;\n\n\tcase oPubkeyAcceptedKeyTypes:\n\t\tcharptr = &options->pubkey_key_types;\n\t\tgoto parse_keytypes;\n\n\tcase oAddKeysToAgent:\n\t\tintptr = &options->add_keys_to_agent;\n\t\tmultistate_ptr = multistate_yesnoaskconfirm;\n\t\tgoto parse_multistate;\n\n\tcase oIdentityAgent:\n\t\tcharptr = &options->identity_agent;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t/* Extra validation if the string represents an env var. */\n\t\tif (arg[0] == '$' && !valid_env_name(arg + 1)) {\n\t\t\tfatal(\"%.200s line %d: Invalid environment name %s.\",\n\t\t\t    filename, linenum, arg);\n\t\t}\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oDeprecated:\n\t\tdebug(\"%s line %d: Deprecated option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn 0;\n\n\tcase oUnsupported:\n\t\terror(\"%s line %d: Unsupported option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn 0;\n\n\tdefault:\n\t\tfatal(\"%s: Unimplemented opcode %d\", __func__, opcode);\n\t}\n\n\t/* Check that there is no garbage at end of line. */\n\tif ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\tfatal(\"%.200s line %d: garbage at end of line; \\\"%.200s\\\".\",\n\t\t    filename, linenum, arg);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&linesize",
            "f"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-getline.c",
          "lines": "92-96",
          "snippet": "ssize_t\ngetline(char **buf, size_t *bufsiz, FILE *fp)\n{\n\treturn getdelim(buf, bufsiz, '\\n', fp);\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"file.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"file.h\"\n#include \"includes.h\"\n\nssize_t\ngetline(char **buf, size_t *bufsiz, FILE *fp)\n{\n\treturn getdelim(buf, bufsiz, '\\n', fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Reading configuration data %.200s\"",
            "filename"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Bad owner or permissions on %s\"",
            "filename"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fileno(f)",
            "&sb"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "fstatvfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-statvfs.c",
          "lines": "71-85",
          "snippet": "int fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}",
          "includes": [
            "#include <errno.h>",
            "# include <sys/mount.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n# include <sys/mount.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nint fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "f"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "filename",
            "\"r\""
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define READCONF_MAX_DEPTH\t16\n\nstatic int read_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int depth);\nstatic int process_config_line_depth(Options *options, struct passwd *pw,\n    const char *host, const char *original_host, char *line,\n    const char *filename, int linenum, int *activep, int flags, int depth);\n\nstatic int\nread_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int depth)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t linesize = 0;\n\tint linenum;\n\tint bad_options = 0;\n\n\tif (depth < 0 || depth > READCONF_MAX_DEPTH)\n\t\tfatal(\"Too many recursive configuration includes\");\n\n\tif ((f = fopen(filename, \"r\")) == NULL)\n\t\treturn 0;\n\n\tif (flags & SSHCONF_CHECKPERM) {\n\t\tstruct stat sb;\n\n\t\tif (fstat(fileno(f), &sb) == -1)\n\t\t\tfatal(\"fstat %s: %s\", filename, strerror(errno));\n\t\tif (((sb.st_uid != 0 && sb.st_uid != getuid()) ||\n\t\t    (sb.st_mode & 022) != 0))\n\t\t\tfatal(\"Bad owner or permissions on %s\", filename);\n\t}\n\n\tdebug(\"Reading configuration data %.200s\", filename);\n\n\t/*\n\t * Mark that we are now processing the options.  This flag is turned\n\t * on/off by Host specifications.\n\t */\n\tlinenum = 0;\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\t/* Update line number counter. */\n\t\tlinenum++;\n\t\tif (process_config_line_depth(options, pw, host, original_host,\n\t\t    line, filename, linenum, activep, flags, depth) != 0)\n\t\t\tbad_options++;\n\t}\n\tfree(line);\n\tfclose(f);\n\tif (bad_options > 0)\n\t\tfatal(\"%s: terminating, %d bad configuration options\",\n\t\t    filename, bad_options);\n\treturn 1;\n}"
  },
  {
    "function_name": "read_config_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "1752-1760",
    "snippet": "int\nread_config_file(const char *filename, struct passwd *pw, const char *host,\n    const char *original_host, Options *options, int flags)\n{\n\tint active = 1;\n\n\treturn read_config_file_depth(filename, pw, host, original_host,\n\t    options, flags, &active, 0);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_config_file_depth",
          "args": [
            "filename",
            "pw",
            "host",
            "original_host",
            "options",
            "flags",
            "&active",
            "0"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "read_config_file_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "1763-1810",
          "snippet": "static int\nread_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int depth)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t linesize = 0;\n\tint linenum;\n\tint bad_options = 0;\n\n\tif (depth < 0 || depth > READCONF_MAX_DEPTH)\n\t\tfatal(\"Too many recursive configuration includes\");\n\n\tif ((f = fopen(filename, \"r\")) == NULL)\n\t\treturn 0;\n\n\tif (flags & SSHCONF_CHECKPERM) {\n\t\tstruct stat sb;\n\n\t\tif (fstat(fileno(f), &sb) == -1)\n\t\t\tfatal(\"fstat %s: %s\", filename, strerror(errno));\n\t\tif (((sb.st_uid != 0 && sb.st_uid != getuid()) ||\n\t\t    (sb.st_mode & 022) != 0))\n\t\t\tfatal(\"Bad owner or permissions on %s\", filename);\n\t}\n\n\tdebug(\"Reading configuration data %.200s\", filename);\n\n\t/*\n\t * Mark that we are now processing the options.  This flag is turned\n\t * on/off by Host specifications.\n\t */\n\tlinenum = 0;\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\t/* Update line number counter. */\n\t\tlinenum++;\n\t\tif (process_config_line_depth(options, pw, host, original_host,\n\t\t    line, filename, linenum, activep, flags, depth) != 0)\n\t\t\tbad_options++;\n\t}\n\tfree(line);\n\tfclose(f);\n\tif (bad_options > 0)\n\t\tfatal(\"%s: terminating, %d bad configuration options\",\n\t\t    filename, bad_options);\n\treturn 1;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define READCONF_MAX_DEPTH\t16"
          ],
          "globals_used": [
            "static int read_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int depth);",
            "static int process_config_line_depth(Options *options, struct passwd *pw,\n    const char *host, const char *original_host, char *line,\n    const char *filename, int linenum, int *activep, int flags, int depth);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define READCONF_MAX_DEPTH\t16\n\nstatic int read_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int depth);\nstatic int process_config_line_depth(Options *options, struct passwd *pw,\n    const char *host, const char *original_host, char *line,\n    const char *filename, int linenum, int *activep, int flags, int depth);\n\nstatic int\nread_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int depth)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t linesize = 0;\n\tint linenum;\n\tint bad_options = 0;\n\n\tif (depth < 0 || depth > READCONF_MAX_DEPTH)\n\t\tfatal(\"Too many recursive configuration includes\");\n\n\tif ((f = fopen(filename, \"r\")) == NULL)\n\t\treturn 0;\n\n\tif (flags & SSHCONF_CHECKPERM) {\n\t\tstruct stat sb;\n\n\t\tif (fstat(fileno(f), &sb) == -1)\n\t\t\tfatal(\"fstat %s: %s\", filename, strerror(errno));\n\t\tif (((sb.st_uid != 0 && sb.st_uid != getuid()) ||\n\t\t    (sb.st_mode & 022) != 0))\n\t\t\tfatal(\"Bad owner or permissions on %s\", filename);\n\t}\n\n\tdebug(\"Reading configuration data %.200s\", filename);\n\n\t/*\n\t * Mark that we are now processing the options.  This flag is turned\n\t * on/off by Host specifications.\n\t */\n\tlinenum = 0;\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\t/* Update line number counter. */\n\t\tlinenum++;\n\t\tif (process_config_line_depth(options, pw, host, original_host,\n\t\t    line, filename, linenum, activep, flags, depth) != 0)\n\t\t\tbad_options++;\n\t}\n\tfree(line);\n\tfclose(f);\n\tif (bad_options > 0)\n\t\tfatal(\"%s: terminating, %d bad configuration options\",\n\t\t    filename, bad_options);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nread_config_file(const char *filename, struct passwd *pw, const char *host,\n    const char *original_host, Options *options, int flags)\n{\n\tint active = 1;\n\n\treturn read_config_file_depth(filename, pw, host, original_host,\n\t    options, flags, &active, 0);\n}"
  },
  {
    "function_name": "process_config_line_depth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "831-1745",
    "snippet": "static int\nprocess_config_line_depth(Options *options, struct passwd *pw, const char *host,\n    const char *original_host, char *line, const char *filename,\n    int linenum, int *activep, int flags, int depth)\n{\n\tchar *s, **charptr, *endofnumber, *keyword, *arg, *arg2;\n\tchar **cpptr, fwdarg[256];\n\tu_int i, *uintptr, max_entries = 0;\n\tint r, oactive, negated, opcode, *intptr, value, value2, cmdline = 0;\n\tint remotefwd, dynamicfwd;\n\tLogLevel *log_level_ptr;\n\tSyslogFacility *log_facility_ptr;\n\tlong long val64;\n\tsize_t len;\n\tstruct Forward fwd;\n\tconst struct multistate *multistate_ptr;\n\tstruct allowed_cname *cname;\n\tglob_t gl;\n\tconst char *errstr;\n\n\tif (activep == NULL) { /* We are processing a command line directive */\n\t\tcmdline = 1;\n\t\tactivep = &cmdline;\n\t}\n\n\t/* Strip trailing whitespace. Allow \\f (form feed) at EOL only */\n\tif ((len = strlen(line)) == 0)\n\t\treturn 0;\n\tfor (len--; len > 0; len--) {\n\t\tif (strchr(WHITESPACE \"\\f\", line[len]) == NULL)\n\t\t\tbreak;\n\t\tline[len] = '\\0';\n\t}\n\n\ts = line;\n\t/* Get the keyword. (Each line is supposed to begin with a keyword). */\n\tif ((keyword = strdelim(&s)) == NULL)\n\t\treturn 0;\n\t/* Ignore leading whitespace. */\n\tif (*keyword == '\\0')\n\t\tkeyword = strdelim(&s);\n\tif (keyword == NULL || !*keyword || *keyword == '\\n' || *keyword == '#')\n\t\treturn 0;\n\t/* Match lowercase keyword */\n\tlowercase(keyword);\n\n\topcode = parse_token(keyword, filename, linenum,\n\t    options->ignored_unknown);\n\n\tswitch (opcode) {\n\tcase oBadOption:\n\t\t/* don't panic, but count bad options */\n\t\treturn -1;\n\tcase oIgnore:\n\t\treturn 0;\n\tcase oIgnoredUnknownOption:\n\t\tdebug(\"%s line %d: Ignored unknown option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn 0;\n\tcase oConnectTimeout:\n\t\tintptr = &options->connection_timeout;\nparse_time:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing time value.\",\n\t\t\t    filename, linenum);\n\t\tif (strcmp(arg, \"none\") == 0)\n\t\t\tvalue = -1;\n\t\telse if ((value = convtime(arg)) == -1)\n\t\t\tfatal(\"%s line %d: invalid time value.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oForwardAgent:\n\t\tintptr = &options->forward_agent;\n parse_flag:\n\t\tmultistate_ptr = multistate_flag;\n parse_multistate:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; multistate_ptr[i].key != NULL; i++) {\n\t\t\tif (strcasecmp(arg, multistate_ptr[i].key) == 0) {\n\t\t\t\tvalue = multistate_ptr[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: unsupported option \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oForwardX11:\n\t\tintptr = &options->forward_x11;\n\t\tgoto parse_flag;\n\n\tcase oForwardX11Trusted:\n\t\tintptr = &options->forward_x11_trusted;\n\t\tgoto parse_flag;\n\n\tcase oForwardX11Timeout:\n\t\tintptr = &options->forward_x11_timeout;\n\t\tgoto parse_time;\n\n\tcase oGatewayPorts:\n\t\tintptr = &options->fwd_opts.gateway_ports;\n\t\tgoto parse_flag;\n\n\tcase oExitOnForwardFailure:\n\t\tintptr = &options->exit_on_forward_failure;\n\t\tgoto parse_flag;\n\n\tcase oPasswordAuthentication:\n\t\tintptr = &options->password_authentication;\n\t\tgoto parse_flag;\n\n\tcase oKbdInteractiveAuthentication:\n\t\tintptr = &options->kbd_interactive_authentication;\n\t\tgoto parse_flag;\n\n\tcase oKbdInteractiveDevices:\n\t\tcharptr = &options->kbd_interactive_devices;\n\t\tgoto parse_string;\n\n\tcase oPubkeyAuthentication:\n\t\tintptr = &options->pubkey_authentication;\n\t\tgoto parse_flag;\n\n\tcase oHostbasedAuthentication:\n\t\tintptr = &options->hostbased_authentication;\n\t\tgoto parse_flag;\n\n\tcase oChallengeResponseAuthentication:\n\t\tintptr = &options->challenge_response_authentication;\n\t\tgoto parse_flag;\n\n\tcase oGssAuthentication:\n\t\tintptr = &options->gss_authentication;\n\t\tgoto parse_flag;\n\n\tcase oGssDelegateCreds:\n\t\tintptr = &options->gss_deleg_creds;\n\t\tgoto parse_flag;\n\n\tcase oBatchMode:\n\t\tintptr = &options->batch_mode;\n\t\tgoto parse_flag;\n\n\tcase oCheckHostIP:\n\t\tintptr = &options->check_host_ip;\n\t\tgoto parse_flag;\n\n\tcase oVerifyHostKeyDNS:\n\t\tintptr = &options->verify_host_key_dns;\n\t\tmultistate_ptr = multistate_yesnoask;\n\t\tgoto parse_multistate;\n\n\tcase oStrictHostKeyChecking:\n\t\tintptr = &options->strict_host_key_checking;\n\t\tmultistate_ptr = multistate_strict_hostkey;\n\t\tgoto parse_multistate;\n\n\tcase oCompression:\n\t\tintptr = &options->compression;\n\t\tgoto parse_flag;\n\n\tcase oTCPKeepAlive:\n\t\tintptr = &options->tcp_keep_alive;\n\t\tgoto parse_flag;\n\n\tcase oNoHostAuthenticationForLocalhost:\n\t\tintptr = &options->no_host_authentication_for_localhost;\n\t\tgoto parse_flag;\n\n\tcase oNumberOfPasswordPrompts:\n\t\tintptr = &options->number_of_password_prompts;\n\t\tgoto parse_int;\n\n\tcase oRekeyLimit:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tif (strcmp(arg, \"default\") == 0) {\n\t\t\tval64 = 0;\n\t\t} else {\n\t\t\tif (scan_scaled(arg, &val64) == -1)\n\t\t\t\tfatal(\"%.200s line %d: Bad number '%s': %s\",\n\t\t\t\t    filename, linenum, arg, strerror(errno));\n\t\t\tif (val64 != 0 && val64 < 16)\n\t\t\t\tfatal(\"%.200s line %d: RekeyLimit too small\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\tif (*activep && options->rekey_limit == -1)\n\t\t\toptions->rekey_limit = val64;\n\t\tif (s != NULL) { /* optional rekey interval present */\n\t\t\tif (strcmp(s, \"none\") == 0) {\n\t\t\t\t(void)strdelim(&s);\t/* discard */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tintptr = &options->rekey_interval;\n\t\t\tgoto parse_time;\n\t\t}\n\t\tbreak;\n\n\tcase oIdentityFile:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (*activep) {\n\t\t\tintptr = &options->num_identity_files;\n\t\t\tif (*intptr >= SSH_MAX_IDENTITY_FILES)\n\t\t\t\tfatal(\"%.200s line %d: Too many identity files specified (max %d).\",\n\t\t\t\t    filename, linenum, SSH_MAX_IDENTITY_FILES);\n\t\t\tadd_identity_file(options, NULL,\n\t\t\t    arg, flags & SSHCONF_USERCONF);\n\t\t}\n\t\tbreak;\n\n\tcase oCertificateFile:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep) {\n\t\t\tintptr = &options->num_certificate_files;\n\t\t\tif (*intptr >= SSH_MAX_CERTIFICATE_FILES) {\n\t\t\t\tfatal(\"%.200s line %d: Too many certificate \"\n\t\t\t\t    \"files specified (max %d).\",\n\t\t\t\t    filename, linenum,\n\t\t\t\t    SSH_MAX_CERTIFICATE_FILES);\n\t\t\t}\n\t\t\tadd_certificate_file(options, arg,\n\t\t\t    flags & SSHCONF_USERCONF);\n\t\t}\n\t\tbreak;\n\n\tcase oXAuthLocation:\n\t\tcharptr=&options->xauth_location;\n\t\tgoto parse_string;\n\n\tcase oUser:\n\t\tcharptr = &options->user;\nparse_string:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oGlobalKnownHostsFile:\n\t\tcpptr = (char **)&options->system_hostfiles;\n\t\tuintptr = &options->num_system_hostfiles;\n\t\tmax_entries = SSH_MAX_HOSTS_FILES;\nparse_char_array:\n\t\tif (*activep && *uintptr == 0) {\n\t\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\t\tif ((*uintptr) >= max_entries)\n\t\t\t\t\tfatal(\"%s line %d: \"\n\t\t\t\t\t    \"too many authorized keys files.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\tcpptr[(*uintptr)++] = xstrdup(arg);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase oUserKnownHostsFile:\n\t\tcpptr = (char **)&options->user_hostfiles;\n\t\tuintptr = &options->num_user_hostfiles;\n\t\tmax_entries = SSH_MAX_HOSTS_FILES;\n\t\tgoto parse_char_array;\n\n\tcase oHostName:\n\t\tcharptr = &options->hostname;\n\t\tgoto parse_string;\n\n\tcase oHostKeyAlias:\n\t\tcharptr = &options->host_key_alias;\n\t\tgoto parse_string;\n\n\tcase oPreferredAuthentications:\n\t\tcharptr = &options->preferred_authentications;\n\t\tgoto parse_string;\n\n\tcase oBindAddress:\n\t\tcharptr = &options->bind_address;\n\t\tgoto parse_string;\n\n\tcase oBindInterface:\n\t\tcharptr = &options->bind_interface;\n\t\tgoto parse_string;\n\n\tcase oPKCS11Provider:\n\t\tcharptr = &options->pkcs11_provider;\n\t\tgoto parse_string;\n\n\tcase oProxyCommand:\n\t\tcharptr = &options->proxy_command;\n\t\t/* Ignore ProxyCommand if ProxyJump already specified */\n\t\tif (options->jump_host != NULL)\n\t\t\tcharptr = &options->jump_host; /* Skip below */\nparse_command:\n\t\tif (s == NULL)\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tlen = strspn(s, WHITESPACE \"=\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(s + len);\n\t\treturn 0;\n\n\tcase oProxyJump:\n\t\tif (s == NULL) {\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t}\n\t\tlen = strspn(s, WHITESPACE \"=\");\n\t\tif (parse_jump(s + len, options, *activep) == -1) {\n\t\t\tfatal(\"%.200s line %d: Invalid ProxyJump \\\"%s\\\"\",\n\t\t\t    filename, linenum, s + len);\n\t\t}\n\t\treturn 0;\n\n\tcase oPort:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = a2port(arg);\n\t\tif (value <= 0)\n\t\t\tfatal(\"%.200s line %d: Bad port '%s'.\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && options->port == -1)\n\t\t\toptions->port = value;\n\t\tbreak;\n\n\tcase oConnectionAttempts:\n\t\tintptr = &options->connection_attempts;\nparse_int:\n\t\targ = strdelim(&s);\n\t\tif ((errstr = atoi_err(arg, &value)) != NULL)\n\t\t\tfatal(\"%s line %d: integer value %s.\",\n\t\t\t    filename, linenum, errstr);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oCiphers:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !ciphers_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%.200s line %d: Bad SSH2 cipher spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && options->ciphers == NULL)\n\t\t\toptions->ciphers = xstrdup(arg);\n\t\tbreak;\n\n\tcase oMacs:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !mac_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%.200s line %d: Bad SSH2 Mac spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && options->macs == NULL)\n\t\t\toptions->macs = xstrdup(arg);\n\t\tbreak;\n\n\tcase oKexAlgorithms:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !kex_names_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%.200s line %d: Bad SSH2 KexAlgorithms '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && options->kex_algorithms == NULL)\n\t\t\toptions->kex_algorithms = xstrdup(arg);\n\t\tbreak;\n\n\tcase oHostKeyAlgorithms:\n\t\tcharptr = &options->hostkeyalgorithms;\nparse_keytypes:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !sshkey_names_valid2(*arg == '+' ? arg + 1 : arg, 1))\n\t\t\tfatal(\"%s line %d: Bad key types '%s'.\",\n\t\t\t\tfilename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oCASignatureAlgorithms:\n\t\tcharptr = &options->ca_sign_algorithms;\n\t\tgoto parse_keytypes;\n\n\tcase oLogLevel:\n\t\tlog_level_ptr = &options->log_level;\n\t\targ = strdelim(&s);\n\t\tvalue = log_level_number(arg);\n\t\tif (value == SYSLOG_LEVEL_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log level '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *log_level_ptr == SYSLOG_LEVEL_NOT_SET)\n\t\t\t*log_level_ptr = (LogLevel) value;\n\t\tbreak;\n\n\tcase oLogFacility:\n\t\tlog_facility_ptr = &options->log_facility;\n\t\targ = strdelim(&s);\n\t\tvalue = log_facility_number(arg);\n\t\tif (value == SYSLOG_FACILITY_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log facility '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*log_facility_ptr == -1)\n\t\t\t*log_facility_ptr = (SyslogFacility) value;\n\t\tbreak;\n\n\tcase oLocalForward:\n\tcase oRemoteForward:\n\tcase oDynamicForward:\n\t\targ = strdelim(&s);\n\t\tif (arg == NULL || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing port argument.\",\n\t\t\t    filename, linenum);\n\n\t\tremotefwd = (opcode == oRemoteForward);\n\t\tdynamicfwd = (opcode == oDynamicForward);\n\n\t\tif (!dynamicfwd) {\n\t\t\targ2 = strdelim(&s);\n\t\t\tif (arg2 == NULL || *arg2 == '\\0') {\n\t\t\t\tif (remotefwd)\n\t\t\t\t\tdynamicfwd = 1;\n\t\t\t\telse\n\t\t\t\t\tfatal(\"%.200s line %d: Missing target \"\n\t\t\t\t\t    \"argument.\", filename, linenum);\n\t\t\t} else {\n\t\t\t\t/* construct a string for parse_forward */\n\t\t\t\tsnprintf(fwdarg, sizeof(fwdarg), \"%s:%s\", arg,\n\t\t\t\t    arg2);\n\t\t\t}\n\t\t}\n\t\tif (dynamicfwd)\n\t\t\tstrlcpy(fwdarg, arg, sizeof(fwdarg));\n\n\t\tif (parse_forward(&fwd, fwdarg, dynamicfwd, remotefwd) == 0)\n\t\t\tfatal(\"%.200s line %d: Bad forwarding specification.\",\n\t\t\t    filename, linenum);\n\n\t\tif (*activep) {\n\t\t\tif (remotefwd) {\n\t\t\t\tadd_remote_forward(options, &fwd);\n\t\t\t} else {\n\t\t\t\tadd_local_forward(options, &fwd);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase oClearAllForwardings:\n\t\tintptr = &options->clear_forwardings;\n\t\tgoto parse_flag;\n\n\tcase oHost:\n\t\tif (cmdline)\n\t\t\tfatal(\"Host directive not supported as a command-line \"\n\t\t\t    \"option\");\n\t\t*activep = 0;\n\t\targ2 = NULL;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\tif ((flags & SSHCONF_NEVERMATCH) != 0)\n\t\t\t\tbreak;\n\t\t\tnegated = *arg == '!';\n\t\t\tif (negated)\n\t\t\t\targ++;\n\t\t\tif (match_pattern(host, arg)) {\n\t\t\t\tif (negated) {\n\t\t\t\t\tdebug(\"%.200s line %d: Skipping Host \"\n\t\t\t\t\t    \"block because of negated match \"\n\t\t\t\t\t    \"for %.100s\", filename, linenum,\n\t\t\t\t\t    arg);\n\t\t\t\t\t*activep = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!*activep)\n\t\t\t\t\targ2 = arg; /* logged below */\n\t\t\t\t*activep = 1;\n\t\t\t}\n\t\t}\n\t\tif (*activep)\n\t\t\tdebug(\"%.200s line %d: Applying options for %.100s\",\n\t\t\t    filename, linenum, arg2);\n\t\t/* Avoid garbage check below, as strdelim is done. */\n\t\treturn 0;\n\n\tcase oMatch:\n\t\tif (cmdline)\n\t\t\tfatal(\"Host directive not supported as a command-line \"\n\t\t\t    \"option\");\n\t\tvalue = match_cfg_line(options, &s, pw, host, original_host,\n\t\t    flags & SSHCONF_POSTCANON, filename, linenum);\n\t\tif (value < 0)\n\t\t\tfatal(\"%.200s line %d: Bad Match condition\", filename,\n\t\t\t    linenum);\n\t\t*activep = (flags & SSHCONF_NEVERMATCH) ? 0 : value;\n\t\tbreak;\n\n\tcase oEscapeChar:\n\t\tintptr = &options->escape_char;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (strcmp(arg, \"none\") == 0)\n\t\t\tvalue = SSH_ESCAPECHAR_NONE;\n\t\telse if (arg[1] == '\\0')\n\t\t\tvalue = (u_char) arg[0];\n\t\telse if (arg[0] == '^' && arg[2] == 0 &&\n\t\t    (u_char) arg[1] >= 64 && (u_char) arg[1] < 128)\n\t\t\tvalue = (u_char) arg[1] & 31;\n\t\telse {\n\t\t\tfatal(\"%.200s line %d: Bad escape character.\",\n\t\t\t    filename, linenum);\n\t\t\t/* NOTREACHED */\n\t\t\tvalue = 0;\t/* Avoid compiler warning. */\n\t\t}\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oAddressFamily:\n\t\tintptr = &options->address_family;\n\t\tmultistate_ptr = multistate_addressfamily;\n\t\tgoto parse_multistate;\n\n\tcase oEnableSSHKeysign:\n\t\tintptr = &options->enable_ssh_keysign;\n\t\tgoto parse_flag;\n\n\tcase oIdentitiesOnly:\n\t\tintptr = &options->identities_only;\n\t\tgoto parse_flag;\n\n\tcase oServerAliveInterval:\n\t\tintptr = &options->server_alive_interval;\n\t\tgoto parse_time;\n\n\tcase oServerAliveCountMax:\n\t\tintptr = &options->server_alive_count_max;\n\t\tgoto parse_int;\n\n\tcase oSendEnv:\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') != NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment name.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tif (*arg == '-') {\n\t\t\t\t/* Removing an env var */\n\t\t\t\trm_env(options, arg, filename, linenum);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/* Adding an env var */\n\t\t\t\tif (options->num_send_env >= INT_MAX)\n\t\t\t\t\tfatal(\"%s line %d: too many send env.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\toptions->send_env = xrecallocarray(\n\t\t\t\t    options->send_env, options->num_send_env,\n\t\t\t\t    options->num_send_env + 1,\n\t\t\t\t    sizeof(*options->send_env));\n\t\t\t\toptions->send_env[options->num_send_env++] =\n\t\t\t\t    xstrdup(arg);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase oSetEnv:\n\t\tvalue = options->num_setenv;\n\t\twhile ((arg = strdelimw(&s)) != NULL && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') == NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid SetEnv.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep || value != 0)\n\t\t\t\tcontinue;\n\t\t\t/* Adding a setenv var */\n\t\t\tif (options->num_setenv >= INT_MAX)\n\t\t\t\tfatal(\"%s line %d: too many SetEnv.\",\n\t\t\t\t    filename, linenum);\n\t\t\toptions->setenv = xrecallocarray(\n\t\t\t    options->setenv, options->num_setenv,\n\t\t\t    options->num_setenv + 1, sizeof(*options->setenv));\n\t\t\toptions->setenv[options->num_setenv++] = xstrdup(arg);\n\t\t}\n\t\tbreak;\n\n\tcase oControlPath:\n\t\tcharptr = &options->control_path;\n\t\tgoto parse_string;\n\n\tcase oControlMaster:\n\t\tintptr = &options->control_master;\n\t\tmultistate_ptr = multistate_controlmaster;\n\t\tgoto parse_multistate;\n\n\tcase oControlPersist:\n\t\t/* no/false/yes/true, or a time spec */\n\t\tintptr = &options->control_persist;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing ControlPersist\"\n\t\t\t    \" argument.\", filename, linenum);\n\t\tvalue = 0;\n\t\tvalue2 = 0;\t/* timeout */\n\t\tif (strcmp(arg, \"no\") == 0 || strcmp(arg, \"false\") == 0)\n\t\t\tvalue = 0;\n\t\telse if (strcmp(arg, \"yes\") == 0 || strcmp(arg, \"true\") == 0)\n\t\t\tvalue = 1;\n\t\telse if ((value2 = convtime(arg)) >= 0)\n\t\t\tvalue = 1;\n\t\telse\n\t\t\tfatal(\"%.200s line %d: Bad ControlPersist argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1) {\n\t\t\t*intptr = value;\n\t\t\toptions->control_persist_timeout = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oHashKnownHosts:\n\t\tintptr = &options->hash_known_hosts;\n\t\tgoto parse_flag;\n\n\tcase oTunnel:\n\t\tintptr = &options->tun_open;\n\t\tmultistate_ptr = multistate_tunnel;\n\t\tgoto parse_multistate;\n\n\tcase oTunnelDevice:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tvalue = a2tun(arg, &value2);\n\t\tif (value == SSH_TUNID_ERR)\n\t\t\tfatal(\"%.200s line %d: Bad tun device.\", filename, linenum);\n\t\tif (*activep) {\n\t\t\toptions->tun_local = value;\n\t\t\toptions->tun_remote = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oLocalCommand:\n\t\tcharptr = &options->local_command;\n\t\tgoto parse_command;\n\n\tcase oPermitLocalCommand:\n\t\tintptr = &options->permit_local_command;\n\t\tgoto parse_flag;\n\n\tcase oRemoteCommand:\n\t\tcharptr = &options->remote_command;\n\t\tgoto parse_command;\n\n\tcase oVisualHostKey:\n\t\tintptr = &options->visual_host_key;\n\t\tgoto parse_flag;\n\n\tcase oInclude:\n\t\tif (cmdline)\n\t\t\tfatal(\"Include directive not supported as a \"\n\t\t\t    \"command-line option\");\n\t\tvalue = 0;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\t/*\n\t\t\t * Ensure all paths are anchored. User configuration\n\t\t\t * files may begin with '~/' but system configurations\n\t\t\t * must not. If the path is relative, then treat it\n\t\t\t * as living in ~/.ssh for user configurations or\n\t\t\t * /etc/ssh for system ones.\n\t\t\t */\n\t\t\tif (*arg == '~' && (flags & SSHCONF_USERCONF) == 0)\n\t\t\t\tfatal(\"%.200s line %d: bad include path %s.\",\n\t\t\t\t    filename, linenum, arg);\n\t\t\tif (*arg != '/' && *arg != '~') {\n\t\t\t\txasprintf(&arg2, \"%s/%s\",\n\t\t\t\t    (flags & SSHCONF_USERCONF) ?\n\t\t\t\t    \"~/\" _PATH_SSH_USER_DIR : SSHDIR, arg);\n\t\t\t} else\n\t\t\t\targ2 = xstrdup(arg);\n\t\t\tmemset(&gl, 0, sizeof(gl));\n\t\t\tr = glob(arg2, GLOB_TILDE, NULL, &gl);\n\t\t\tif (r == GLOB_NOMATCH) {\n\t\t\t\tdebug(\"%.200s line %d: include %s matched no \"\n\t\t\t\t    \"files\",filename, linenum, arg2);\n\t\t\t\tfree(arg2);\n\t\t\t\tcontinue;\n\t\t\t} else if (r != 0 || gl.gl_pathc < 0)\n\t\t\t\tfatal(\"%.200s line %d: glob failed for %s.\",\n\t\t\t\t    filename, linenum, arg2);\n\t\t\tfree(arg2);\n\t\t\toactive = *activep;\n\t\t\tfor (i = 0; i < (u_int)gl.gl_pathc; i++) {\n\t\t\t\tdebug3(\"%.200s line %d: Including file %s \"\n\t\t\t\t    \"depth %d%s\", filename, linenum,\n\t\t\t\t    gl.gl_pathv[i], depth,\n\t\t\t\t    oactive ? \"\" : \" (parse only)\");\n\t\t\t\tr = read_config_file_depth(gl.gl_pathv[i],\n\t\t\t\t    pw, host, original_host, options,\n\t\t\t\t    flags | SSHCONF_CHECKPERM |\n\t\t\t\t    (oactive ? 0 : SSHCONF_NEVERMATCH),\n\t\t\t\t    activep, depth + 1);\n\t\t\t\tif (r != 1 && errno != ENOENT) {\n\t\t\t\t\tfatal(\"Can't open user config file \"\n\t\t\t\t\t    \"%.100s: %.100s\", gl.gl_pathv[i],\n\t\t\t\t\t    strerror(errno));\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * don't let Match in includes clobber the\n\t\t\t\t * containing file's Match state.\n\t\t\t\t */\n\t\t\t\t*activep = oactive;\n\t\t\t\tif (r != 1)\n\t\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\tglobfree(&gl);\n\t\t}\n\t\tif (value != 0)\n\t\t\treturn value;\n\t\tbreak;\n\n\tcase oIPQoS:\n\t\targ = strdelim(&s);\n\t\tif ((value = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\targ = strdelim(&s);\n\t\tif (arg == NULL)\n\t\t\tvalue2 = value;\n\t\telse if ((value2 = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep) {\n\t\t\toptions->ip_qos_interactive = value;\n\t\t\toptions->ip_qos_bulk = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oRequestTTY:\n\t\tintptr = &options->request_tty;\n\t\tmultistate_ptr = multistate_requesttty;\n\t\tgoto parse_multistate;\n\n\tcase oIgnoreUnknown:\n\t\tcharptr = &options->ignored_unknown;\n\t\tgoto parse_string;\n\n\tcase oProxyUseFdpass:\n\t\tintptr = &options->proxy_use_fdpass;\n\t\tgoto parse_flag;\n\n\tcase oCanonicalDomains:\n\t\tvalue = options->num_canonical_domains != 0;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\tif (!valid_domain(arg, 1, &errstr)) {\n\t\t\t\tfatal(\"%s line %d: %s\", filename, linenum,\n\t\t\t\t    errstr);\n\t\t\t}\n\t\t\tif (!*activep || value)\n\t\t\t\tcontinue;\n\t\t\tif (options->num_canonical_domains >= MAX_CANON_DOMAINS)\n\t\t\t\tfatal(\"%s line %d: too many hostname suffixes.\",\n\t\t\t\t    filename, linenum);\n\t\t\toptions->canonical_domains[\n\t\t\t    options->num_canonical_domains++] = xstrdup(arg);\n\t\t}\n\t\tbreak;\n\n\tcase oCanonicalizePermittedCNAMEs:\n\t\tvalue = options->num_permitted_cnames != 0;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\t/* Either '*' for everything or 'list:list' */\n\t\t\tif (strcmp(arg, \"*\") == 0)\n\t\t\t\targ2 = arg;\n\t\t\telse {\n\t\t\t\tlowercase(arg);\n\t\t\t\tif ((arg2 = strchr(arg, ':')) == NULL ||\n\t\t\t\t    arg2[1] == '\\0') {\n\t\t\t\t\tfatal(\"%s line %d: \"\n\t\t\t\t\t    \"Invalid permitted CNAME \\\"%s\\\"\",\n\t\t\t\t\t    filename, linenum, arg);\n\t\t\t\t}\n\t\t\t\t*arg2 = '\\0';\n\t\t\t\targ2++;\n\t\t\t}\n\t\t\tif (!*activep || value)\n\t\t\t\tcontinue;\n\t\t\tif (options->num_permitted_cnames >= MAX_CANON_DOMAINS)\n\t\t\t\tfatal(\"%s line %d: too many permitted CNAMEs.\",\n\t\t\t\t    filename, linenum);\n\t\t\tcname = options->permitted_cnames +\n\t\t\t    options->num_permitted_cnames++;\n\t\t\tcname->source_list = xstrdup(arg);\n\t\t\tcname->target_list = xstrdup(arg2);\n\t\t}\n\t\tbreak;\n\n\tcase oCanonicalizeHostname:\n\t\tintptr = &options->canonicalize_hostname;\n\t\tmultistate_ptr = multistate_canonicalizehostname;\n\t\tgoto parse_multistate;\n\n\tcase oCanonicalizeMaxDots:\n\t\tintptr = &options->canonicalize_max_dots;\n\t\tgoto parse_int;\n\n\tcase oCanonicalizeFallbackLocal:\n\t\tintptr = &options->canonicalize_fallback_local;\n\t\tgoto parse_flag;\n\n\tcase oStreamLocalBindMask:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing StreamLocalBindMask argument.\", filename, linenum);\n\t\t/* Parse mode in octal format */\n\t\tvalue = strtol(arg, &endofnumber, 8);\n\t\tif (arg == endofnumber || value < 0 || value > 0777)\n\t\t\tfatal(\"%.200s line %d: Bad mask.\", filename, linenum);\n\t\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)value;\n\t\tbreak;\n\n\tcase oStreamLocalBindUnlink:\n\t\tintptr = &options->fwd_opts.streamlocal_bind_unlink;\n\t\tgoto parse_flag;\n\n\tcase oRevokedHostKeys:\n\t\tcharptr = &options->revoked_host_keys;\n\t\tgoto parse_string;\n\n\tcase oFingerprintHash:\n\t\tintptr = &options->fingerprint_hash;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = ssh_digest_alg_by_name(arg)) == -1)\n\t\t\tfatal(\"%.200s line %d: Invalid hash algorithm \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oUpdateHostkeys:\n\t\tintptr = &options->update_hostkeys;\n\t\tmultistate_ptr = multistate_yesnoask;\n\t\tgoto parse_multistate;\n\n\tcase oHostbasedKeyTypes:\n\t\tcharptr = &options->hostbased_key_types;\n\t\tgoto parse_keytypes;\n\n\tcase oPubkeyAcceptedKeyTypes:\n\t\tcharptr = &options->pubkey_key_types;\n\t\tgoto parse_keytypes;\n\n\tcase oAddKeysToAgent:\n\t\tintptr = &options->add_keys_to_agent;\n\t\tmultistate_ptr = multistate_yesnoaskconfirm;\n\t\tgoto parse_multistate;\n\n\tcase oIdentityAgent:\n\t\tcharptr = &options->identity_agent;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t/* Extra validation if the string represents an env var. */\n\t\tif (arg[0] == '$' && !valid_env_name(arg + 1)) {\n\t\t\tfatal(\"%.200s line %d: Invalid environment name %s.\",\n\t\t\t    filename, linenum, arg);\n\t\t}\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oDeprecated:\n\t\tdebug(\"%s line %d: Deprecated option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn 0;\n\n\tcase oUnsupported:\n\t\terror(\"%s line %d: Unsupported option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn 0;\n\n\tdefault:\n\t\tfatal(\"%s: Unimplemented opcode %d\", __func__, opcode);\n\t}\n\n\t/* Check that there is no garbage at end of line. */\n\tif ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\tfatal(\"%.200s line %d: garbage at end of line; \\\"%.200s\\\".\",\n\t\t    filename, linenum, arg);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define WHITESPACE \" \\t\\r\\n\""
    ],
    "globals_used": [
      "static int read_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int depth);",
      "static int process_config_line_depth(Options *options, struct passwd *pw,\n    const char *host, const char *original_host, char *line,\n    const char *filename, int linenum, int *activep, int flags, int depth);",
      "static const struct multistate multistate_flag[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_yesnoask[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_strict_hostkey[] = {\n\t{ \"true\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"false\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"yes\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"no\",\t\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"ask\",\t\t\tSSH_STRICT_HOSTKEY_ASK },\n\t{ \"off\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"accept-new\",\t\t\tSSH_STRICT_HOSTKEY_NEW },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_yesnoaskconfirm[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ \"confirm\",\t\t\t3 },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_controlmaster[] = {\n\t{ \"true\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"yes\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"false\",\t\t\tSSHCTL_MASTER_NO },\n\t{ \"no\",\t\t\t\tSSHCTL_MASTER_NO },\n\t{ \"auto\",\t\t\tSSHCTL_MASTER_AUTO },\n\t{ \"ask\",\t\t\tSSHCTL_MASTER_ASK },\n\t{ \"autoask\",\t\t\tSSHCTL_MASTER_AUTO_ASK },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_tunnel[] = {\n\t{ \"ethernet\",\t\t\tSSH_TUNMODE_ETHERNET },\n\t{ \"point-to-point\",\t\tSSH_TUNMODE_POINTOPOINT },\n\t{ \"true\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"yes\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"false\",\t\t\tSSH_TUNMODE_NO },\n\t{ \"no\",\t\t\t\tSSH_TUNMODE_NO },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_requesttty[] = {\n\t{ \"true\",\t\t\tREQUEST_TTY_YES },\n\t{ \"yes\",\t\t\tREQUEST_TTY_YES },\n\t{ \"false\",\t\t\tREQUEST_TTY_NO },\n\t{ \"no\",\t\t\t\tREQUEST_TTY_NO },\n\t{ \"force\",\t\t\tREQUEST_TTY_FORCE },\n\t{ \"auto\",\t\t\tREQUEST_TTY_AUTO },\n\t{ NULL, -1 }\n};",
      "static const struct multistate multistate_canonicalizehostname[] = {\n\t{ \"true\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"false\",\t\t\tSSH_CANONICALISE_NO },\n\t{ \"yes\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"no\",\t\t\t\tSSH_CANONICALISE_NO },\n\t{ \"always\",\t\t\tSSH_CANONICALISE_ALWAYS },\n\t{ NULL, -1 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%.200s line %d: garbage at end of line; \\\"%.200s\\\".\"",
            "filename",
            "linenum",
            "arg"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdelim",
          "args": [
            "&s"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "strdelimw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "296-300",
          "snippet": "char *\nstrdelimw(char **s)\n{\n\treturn strdelim_internal(s, 0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nstrdelimw(char **s)\n{\n\treturn strdelim_internal(s, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s line %d: Unsupported option \\\"%s\\\"\"",
            "filename",
            "linenum",
            "keyword"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s line %d: Deprecated option \\\"%s\\\"\"",
            "filename",
            "linenum",
            "keyword"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "arg"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_env_name",
          "args": [
            "arg + 1"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "valid_env_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1960-1972",
          "snippet": "int\nvalid_env_name(const char *name)\n{\n\tconst char *cp;\n\n\tif (name[0] == '\\0')\n\t\treturn 0;\n\tfor (cp = name; *cp != '\\0'; cp++) {\n\t\tif (!isalnum((u_char)*cp) && *cp != '_')\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nvalid_env_name(const char *name)\n{\n\tconst char *cp;\n\n\tif (name[0] == '\\0')\n\t\treturn 0;\n\tfor (cp = name; *cp != '\\0'; cp++) {\n\t\tif (!isalnum((u_char)*cp) && *cp != '_')\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_digest_alg_by_name",
          "args": [
            "arg"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_alg_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "123-133",
          "snippet": "int\nssh_digest_alg_by_name(const char *name)\n{\n\tint alg;\n\n\tfor (alg = 0; alg < SSH_DIGEST_MAX; alg++) {\n\t\tif (strcasecmp(name, digests[alg].name) == 0)\n\t\t\treturn digests[alg].id;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_digest_alg_by_name(const char *name)\n{\n\tint alg;\n\n\tfor (alg = 0; alg < SSH_DIGEST_MAX; alg++) {\n\t\tif (strcasecmp(name, digests[alg].name) == 0)\n\t\t\treturn digests[alg].id;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "arg",
            "&endofnumber",
            "8"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "strtoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtoll.c",
          "lines": "49-147",
          "snippet": "long long\nstrtoll(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tlong long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\t/*\n\t * Compute the cutoff value between legal numbers and illegal\n\t * numbers.  That is the largest legal value, divided by the\n\t * base.  An input number that is greater than this value, if\n\t * followed by a legal input character, is too big.  One that\n\t * is equal to this value may be valid or not; the limit\n\t * between valid and invalid numbers is then based on the last\n\t * digit.  For instance, if the range for long longs is\n\t * [-9223372036854775808..9223372036854775807] and the input base\n\t * is 10, cutoff will be set to 922337203685477580 and cutlim to\n\t * either 7 (neg==0) or 8 (neg==1), meaning that if we have\n\t * accumulated a value > 922337203685477580, or equal but the\n\t * next digit is > 7 (or 8), the number is too big, and we will\n\t * return a range error.\n\t *\n\t * Set any if any `digits' consumed; make it negative to indicate\n\t * overflow.\n\t */\n\tcutoff = neg ? LLONG_MIN : LLONG_MAX;\n\tcutlim = cutoff % base;\n\tcutoff /= base;\n\tif (neg) {\n\t\tif (cutlim > 0) {\n\t\t\tcutlim -= base;\n\t\t\tcutoff += 1;\n\t\t}\n\t\tcutlim = -cutlim;\n\t}\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (neg) {\n\t\t\tif (acc < cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MIN;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc -= c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MAX;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc += c;\n\t\t\t}\n\t\t}\n\t}\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nlong long\nstrtoll(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tlong long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\t/*\n\t * Compute the cutoff value between legal numbers and illegal\n\t * numbers.  That is the largest legal value, divided by the\n\t * base.  An input number that is greater than this value, if\n\t * followed by a legal input character, is too big.  One that\n\t * is equal to this value may be valid or not; the limit\n\t * between valid and invalid numbers is then based on the last\n\t * digit.  For instance, if the range for long longs is\n\t * [-9223372036854775808..9223372036854775807] and the input base\n\t * is 10, cutoff will be set to 922337203685477580 and cutlim to\n\t * either 7 (neg==0) or 8 (neg==1), meaning that if we have\n\t * accumulated a value > 922337203685477580, or equal but the\n\t * next digit is > 7 (or 8), the number is too big, and we will\n\t * return a range error.\n\t *\n\t * Set any if any `digits' consumed; make it negative to indicate\n\t * overflow.\n\t */\n\tcutoff = neg ? LLONG_MIN : LLONG_MAX;\n\tcutlim = cutoff % base;\n\tcutoff /= base;\n\tif (neg) {\n\t\tif (cutlim > 0) {\n\t\t\tcutlim -= base;\n\t\t\tcutoff += 1;\n\t\t}\n\t\tcutlim = -cutlim;\n\t}\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (neg) {\n\t\t\tif (acc < cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MIN;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc -= c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MAX;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc += c;\n\t\t\t}\n\t\t}\n\t}\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "arg",
            "':'"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lowercase",
          "args": [
            "arg"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "lowercase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1480-1485",
          "snippet": "void\nlowercase(char *s)\n{\n\tfor (; *s; s++)\n\t\t*s = tolower((u_char)*s);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlowercase(char *s)\n{\n\tfor (; *s; s++)\n\t\t*s = tolower((u_char)*s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"*\""
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_domain",
          "args": [
            "arg",
            "1",
            "&errstr"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "valid_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1911-1953",
          "snippet": "int\nvalid_domain(char *name, int makelower, const char **errstr)\n{\n\tsize_t i, l = strlen(name);\n\tu_char c, last = '\\0';\n\tstatic char errbuf[256];\n\n\tif (l == 0) {\n\t\tstrlcpy(errbuf, \"empty domain name\", sizeof(errbuf));\n\t\tgoto bad;\n\t}\n\tif (!isalpha((u_char)name[0]) && !isdigit((u_char)name[0])) {\n\t\tsnprintf(errbuf, sizeof(errbuf), \"domain name \\\"%.100s\\\" \"\n\t\t    \"starts with invalid character\", name);\n\t\tgoto bad;\n\t}\n\tfor (i = 0; i < l; i++) {\n\t\tc = tolower((u_char)name[i]);\n\t\tif (makelower)\n\t\t\tname[i] = (char)c;\n\t\tif (last == '.' && c == '.') {\n\t\t\tsnprintf(errbuf, sizeof(errbuf), \"domain name \"\n\t\t\t    \"\\\"%.100s\\\" contains consecutive separators\", name);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (c != '.' && c != '-' && !isalnum(c) &&\n\t\t    c != '_') /* technically invalid, but common */ {\n\t\t\tsnprintf(errbuf, sizeof(errbuf), \"domain name \"\n\t\t\t    \"\\\"%.100s\\\" contains invalid characters\", name);\n\t\t\tgoto bad;\n\t\t}\n\t\tlast = c;\n\t}\n\tif (name[l - 1] == '.')\n\t\tname[l - 1] = '\\0';\n\tif (errstr != NULL)\n\t\t*errstr = NULL;\n\treturn 1;\nbad:\n\tif (errstr != NULL)\n\t\t*errstr = errbuf;\n\treturn 0;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nvalid_domain(char *name, int makelower, const char **errstr)\n{\n\tsize_t i, l = strlen(name);\n\tu_char c, last = '\\0';\n\tstatic char errbuf[256];\n\n\tif (l == 0) {\n\t\tstrlcpy(errbuf, \"empty domain name\", sizeof(errbuf));\n\t\tgoto bad;\n\t}\n\tif (!isalpha((u_char)name[0]) && !isdigit((u_char)name[0])) {\n\t\tsnprintf(errbuf, sizeof(errbuf), \"domain name \\\"%.100s\\\" \"\n\t\t    \"starts with invalid character\", name);\n\t\tgoto bad;\n\t}\n\tfor (i = 0; i < l; i++) {\n\t\tc = tolower((u_char)name[i]);\n\t\tif (makelower)\n\t\t\tname[i] = (char)c;\n\t\tif (last == '.' && c == '.') {\n\t\t\tsnprintf(errbuf, sizeof(errbuf), \"domain name \"\n\t\t\t    \"\\\"%.100s\\\" contains consecutive separators\", name);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (c != '.' && c != '-' && !isalnum(c) &&\n\t\t    c != '_') /* technically invalid, but common */ {\n\t\t\tsnprintf(errbuf, sizeof(errbuf), \"domain name \"\n\t\t\t    \"\\\"%.100s\\\" contains invalid characters\", name);\n\t\t\tgoto bad;\n\t\t}\n\t\tlast = c;\n\t}\n\tif (name[l - 1] == '.')\n\t\tname[l - 1] = '\\0';\n\tif (errstr != NULL)\n\t\t*errstr = NULL;\n\treturn 1;\nbad:\n\tif (errstr != NULL)\n\t\t*errstr = errbuf;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_ipqos",
          "args": [
            "arg"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "parse_ipqos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1446-1464",
          "snippet": "int\nparse_ipqos(const char *cp)\n{\n\tu_int i;\n\tchar *ep;\n\tlong val;\n\n\tif (cp == NULL)\n\t\treturn -1;\n\tfor (i = 0; ipqos[i].name != NULL; i++) {\n\t\tif (strcasecmp(cp, ipqos[i].name) == 0)\n\t\t\treturn ipqos[i].value;\n\t}\n\t/* Try parsing as an integer */\n\tval = strtol(cp, &ep, 0);\n\tif (*cp == '\\0' || *ep != '\\0' || val < 0 || val > 255)\n\t\treturn -1;\n\treturn val;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct {\n\tconst char *name;\n\tint value;\n} ipqos[] = {\n\t{ \"none\", INT_MAX },\t\t/* can't use 0 here; that's CS0 */\n\t{ \"af11\", IPTOS_DSCP_AF11 },\n\t{ \"af12\", IPTOS_DSCP_AF12 },\n\t{ \"af13\", IPTOS_DSCP_AF13 },\n\t{ \"af21\", IPTOS_DSCP_AF21 },\n\t{ \"af22\", IPTOS_DSCP_AF22 },\n\t{ \"af23\", IPTOS_DSCP_AF23 },\n\t{ \"af31\", IPTOS_DSCP_AF31 },\n\t{ \"af32\", IPTOS_DSCP_AF32 },\n\t{ \"af33\", IPTOS_DSCP_AF33 },\n\t{ \"af41\", IPTOS_DSCP_AF41 },\n\t{ \"af42\", IPTOS_DSCP_AF42 },\n\t{ \"af43\", IPTOS_DSCP_AF43 },\n\t{ \"cs0\", IPTOS_DSCP_CS0 },\n\t{ \"cs1\", IPTOS_DSCP_CS1 },\n\t{ \"cs2\", IPTOS_DSCP_CS2 },\n\t{ \"cs3\", IPTOS_DSCP_CS3 },\n\t{ \"cs4\", IPTOS_DSCP_CS4 },\n\t{ \"cs5\", IPTOS_DSCP_CS5 },\n\t{ \"cs6\", IPTOS_DSCP_CS6 },\n\t{ \"cs7\", IPTOS_DSCP_CS7 },\n\t{ \"ef\", IPTOS_DSCP_EF },\n\t{ \"lowdelay\", IPTOS_LOWDELAY },\n\t{ \"throughput\", IPTOS_THROUGHPUT },\n\t{ \"reliability\", IPTOS_RELIABILITY },\n\t{ NULL, -1 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct {\n\tconst char *name;\n\tint value;\n} ipqos[] = {\n\t{ \"none\", INT_MAX },\t\t/* can't use 0 here; that's CS0 */\n\t{ \"af11\", IPTOS_DSCP_AF11 },\n\t{ \"af12\", IPTOS_DSCP_AF12 },\n\t{ \"af13\", IPTOS_DSCP_AF13 },\n\t{ \"af21\", IPTOS_DSCP_AF21 },\n\t{ \"af22\", IPTOS_DSCP_AF22 },\n\t{ \"af23\", IPTOS_DSCP_AF23 },\n\t{ \"af31\", IPTOS_DSCP_AF31 },\n\t{ \"af32\", IPTOS_DSCP_AF32 },\n\t{ \"af33\", IPTOS_DSCP_AF33 },\n\t{ \"af41\", IPTOS_DSCP_AF41 },\n\t{ \"af42\", IPTOS_DSCP_AF42 },\n\t{ \"af43\", IPTOS_DSCP_AF43 },\n\t{ \"cs0\", IPTOS_DSCP_CS0 },\n\t{ \"cs1\", IPTOS_DSCP_CS1 },\n\t{ \"cs2\", IPTOS_DSCP_CS2 },\n\t{ \"cs3\", IPTOS_DSCP_CS3 },\n\t{ \"cs4\", IPTOS_DSCP_CS4 },\n\t{ \"cs5\", IPTOS_DSCP_CS5 },\n\t{ \"cs6\", IPTOS_DSCP_CS6 },\n\t{ \"cs7\", IPTOS_DSCP_CS7 },\n\t{ \"ef\", IPTOS_DSCP_EF },\n\t{ \"lowdelay\", IPTOS_LOWDELAY },\n\t{ \"throughput\", IPTOS_THROUGHPUT },\n\t{ \"reliability\", IPTOS_RELIABILITY },\n\t{ NULL, -1 }\n};\n\nint\nparse_ipqos(const char *cp)\n{\n\tu_int i;\n\tchar *ep;\n\tlong val;\n\n\tif (cp == NULL)\n\t\treturn -1;\n\tfor (i = 0; ipqos[i].name != NULL; i++) {\n\t\tif (strcasecmp(cp, ipqos[i].name) == 0)\n\t\t\treturn ipqos[i].value;\n\t}\n\t/* Try parsing as an integer */\n\tval = strtol(cp, &ep, 0);\n\tif (*cp == '\\0' || *ep != '\\0' || val < 0 || val > 255)\n\t\treturn -1;\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "globfree",
          "args": [
            "&gl"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "globfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "959-981",
          "snippet": "void\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nvoid\nglobfree(glob_t *pglob)\n{\n\tint i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tif (*pp)\n\t\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tif (pglob->gl_statv[i] != NULL)\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_config_file_depth",
          "args": [
            "gl.gl_pathv[i]",
            "pw",
            "host",
            "original_host",
            "options",
            "flags | SSHCONF_CHECKPERM |\n\t\t\t\t    (oactive ? 0 : SSHCONF_NEVERMATCH)",
            "activep",
            "depth + 1"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "read_config_file_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "1763-1810",
          "snippet": "static int\nread_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int depth)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t linesize = 0;\n\tint linenum;\n\tint bad_options = 0;\n\n\tif (depth < 0 || depth > READCONF_MAX_DEPTH)\n\t\tfatal(\"Too many recursive configuration includes\");\n\n\tif ((f = fopen(filename, \"r\")) == NULL)\n\t\treturn 0;\n\n\tif (flags & SSHCONF_CHECKPERM) {\n\t\tstruct stat sb;\n\n\t\tif (fstat(fileno(f), &sb) == -1)\n\t\t\tfatal(\"fstat %s: %s\", filename, strerror(errno));\n\t\tif (((sb.st_uid != 0 && sb.st_uid != getuid()) ||\n\t\t    (sb.st_mode & 022) != 0))\n\t\t\tfatal(\"Bad owner or permissions on %s\", filename);\n\t}\n\n\tdebug(\"Reading configuration data %.200s\", filename);\n\n\t/*\n\t * Mark that we are now processing the options.  This flag is turned\n\t * on/off by Host specifications.\n\t */\n\tlinenum = 0;\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\t/* Update line number counter. */\n\t\tlinenum++;\n\t\tif (process_config_line_depth(options, pw, host, original_host,\n\t\t    line, filename, linenum, activep, flags, depth) != 0)\n\t\t\tbad_options++;\n\t}\n\tfree(line);\n\tfclose(f);\n\tif (bad_options > 0)\n\t\tfatal(\"%s: terminating, %d bad configuration options\",\n\t\t    filename, bad_options);\n\treturn 1;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define READCONF_MAX_DEPTH\t16"
          ],
          "globals_used": [
            "static int read_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int depth);",
            "static int process_config_line_depth(Options *options, struct passwd *pw,\n    const char *host, const char *original_host, char *line,\n    const char *filename, int linenum, int *activep, int flags, int depth);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define READCONF_MAX_DEPTH\t16\n\nstatic int read_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int depth);\nstatic int process_config_line_depth(Options *options, struct passwd *pw,\n    const char *host, const char *original_host, char *line,\n    const char *filename, int linenum, int *activep, int flags, int depth);\n\nstatic int\nread_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int depth)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t linesize = 0;\n\tint linenum;\n\tint bad_options = 0;\n\n\tif (depth < 0 || depth > READCONF_MAX_DEPTH)\n\t\tfatal(\"Too many recursive configuration includes\");\n\n\tif ((f = fopen(filename, \"r\")) == NULL)\n\t\treturn 0;\n\n\tif (flags & SSHCONF_CHECKPERM) {\n\t\tstruct stat sb;\n\n\t\tif (fstat(fileno(f), &sb) == -1)\n\t\t\tfatal(\"fstat %s: %s\", filename, strerror(errno));\n\t\tif (((sb.st_uid != 0 && sb.st_uid != getuid()) ||\n\t\t    (sb.st_mode & 022) != 0))\n\t\t\tfatal(\"Bad owner or permissions on %s\", filename);\n\t}\n\n\tdebug(\"Reading configuration data %.200s\", filename);\n\n\t/*\n\t * Mark that we are now processing the options.  This flag is turned\n\t * on/off by Host specifications.\n\t */\n\tlinenum = 0;\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\t/* Update line number counter. */\n\t\tlinenum++;\n\t\tif (process_config_line_depth(options, pw, host, original_host,\n\t\t    line, filename, linenum, activep, flags, depth) != 0)\n\t\t\tbad_options++;\n\t}\n\tfree(line);\n\tfclose(f);\n\tif (bad_options > 0)\n\t\tfatal(\"%s: terminating, %d bad configuration options\",\n\t\t    filename, bad_options);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "arg2"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "glob",
          "args": [
            "arg2",
            "GLOB_TILDE",
            "NULL",
            "&gl"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "do_globbed_ls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp.c",
          "lines": "929-1033",
          "snippet": "static int\ndo_globbed_ls(struct sftp_conn *conn, const char *path,\n    const char *strip_path, int lflag)\n{\n\tchar *fname, *lname;\n\tglob_t g;\n\tint err, r;\n\tstruct winsize ws;\n\tu_int i, j, nentries, *indices = NULL, c = 1;\n\tu_int colspace = 0, columns = 1, m = 0, width = 80;\n\n\tmemset(&g, 0, sizeof(g));\n\n\tif ((r = remote_glob(conn, path,\n\t    GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE|GLOB_KEEPSTAT|GLOB_NOSORT,\n\t    NULL, &g)) != 0 ||\n\t    (g.gl_pathc && !g.gl_matchc)) {\n\t\tif (g.gl_pathc)\n\t\t\tglobfree(&g);\n\t\tif (r == GLOB_NOSPACE) {\n\t\t\terror(\"Can't ls: Too many matches for \\\"%s\\\"\", path);\n\t\t} else {\n\t\t\terror(\"Can't ls: \\\"%s\\\" not found\", path);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (interrupted)\n\t\tgoto out;\n\n\t/*\n\t * If the glob returns a single match and it is a directory,\n\t * then just list its contents.\n\t */\n\tif (g.gl_matchc == 1 && g.gl_statv[0] != NULL &&\n\t    S_ISDIR(g.gl_statv[0]->st_mode)) {\n\t\terr = do_ls_dir(conn, g.gl_pathv[0], strip_path, lflag);\n\t\tglobfree(&g);\n\t\treturn err;\n\t}\n\n\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\twidth = ws.ws_col;\n\n\tif (!(lflag & LS_SHORT_VIEW)) {\n\t\t/* Count entries for sort and find longest filename */\n\t\tfor (i = 0; g.gl_pathv[i]; i++)\n\t\t\tm = MAXIMUM(m, strlen(g.gl_pathv[i]));\n\n\t\tcolumns = width / (m + 2);\n\t\tcolumns = MAXIMUM(columns, 1);\n\t\tcolspace = width / columns;\n\t}\n\n\t/*\n\t * Sorting: rather than mess with the contents of glob_t, prepare\n\t * an array of indices into it and sort that. For the usual\n\t * unsorted case, the indices are just the identity 1=1, 2=2, etc.\n\t */\n\tfor (nentries = 0; g.gl_pathv[nentries] != NULL; nentries++)\n\t\t;\t/* count entries */\n\tindices = calloc(nentries, sizeof(*indices));\n\tfor (i = 0; i < nentries; i++)\n\t\tindices[i] = i;\n\n\tif (lflag & SORT_FLAGS) {\n\t\tsort_glob = &g;\n\t\tsort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);\n\t\tqsort(indices, nentries, sizeof(*indices), sglob_comp);\n\t\tsort_glob = NULL;\n\t}\n\n\tfor (j = 0; j < nentries && !interrupted; j++) {\n\t\ti = indices[j];\n\t\tfname = path_strip(g.gl_pathv[i], strip_path);\n\t\tif (lflag & LS_LONG_VIEW) {\n\t\t\tif (g.gl_statv[i] == NULL) {\n\t\t\t\terror(\"no stat information for %s\", fname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlname = ls_file(fname, g.gl_statv[i], 1,\n\t\t\t    (lflag & LS_SI_UNITS));\n\t\t\tmprintf(\"%s\\n\", lname);\n\t\t\tfree(lname);\n\t\t} else {\n\t\t\tmprintf(\"%-*s\", colspace, fname);\n\t\t\tif (c >= columns) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tc = 1;\n\t\t\t} else\n\t\t\t\tc++;\n\t\t}\n\t\tfree(fname);\n\t}\n\n\tif (!(lflag & LS_LONG_VIEW) && (c != 1))\n\t\tprintf(\"\\n\");\n\n out:\n\tif (g.gl_pathc)\n\t\tglobfree(&g);\n\tfree(indices);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <histedit.h>",
            "# include <locale.h>",
            "#include <libgen.h>",
            "# include <paths.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "# include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)",
            "#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */",
            "#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */",
            "#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */",
            "#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */"
          ],
          "globals_used": [
            "volatile sig_atomic_t interrupted = 0;",
            "int sort_flag;",
            "glob_t *sort_glob;",
            "int remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n#include <histedit.h>\n# include <locale.h>\n#include <libgen.h>\n# include <paths.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/statvfs.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n# include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)\n#define LS_SI_UNITS\t0x0100\t/* Display sizes as K, M, G, etc. */\n#define LS_REVERSE_SORT\t0x0040\t/* Reverse sort order */\n#define LS_SHORT_VIEW\t0x0002\t/* Single row view ala ls -1 */\n#define LS_LONG_VIEW\t0x0001\t/* Full view ala ls -l */\n\nvolatile sig_atomic_t interrupted = 0;\nint sort_flag;\nglob_t *sort_glob;\nint remote_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);\n\nstatic int\ndo_globbed_ls(struct sftp_conn *conn, const char *path,\n    const char *strip_path, int lflag)\n{\n\tchar *fname, *lname;\n\tglob_t g;\n\tint err, r;\n\tstruct winsize ws;\n\tu_int i, j, nentries, *indices = NULL, c = 1;\n\tu_int colspace = 0, columns = 1, m = 0, width = 80;\n\n\tmemset(&g, 0, sizeof(g));\n\n\tif ((r = remote_glob(conn, path,\n\t    GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE|GLOB_KEEPSTAT|GLOB_NOSORT,\n\t    NULL, &g)) != 0 ||\n\t    (g.gl_pathc && !g.gl_matchc)) {\n\t\tif (g.gl_pathc)\n\t\t\tglobfree(&g);\n\t\tif (r == GLOB_NOSPACE) {\n\t\t\terror(\"Can't ls: Too many matches for \\\"%s\\\"\", path);\n\t\t} else {\n\t\t\terror(\"Can't ls: \\\"%s\\\" not found\", path);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (interrupted)\n\t\tgoto out;\n\n\t/*\n\t * If the glob returns a single match and it is a directory,\n\t * then just list its contents.\n\t */\n\tif (g.gl_matchc == 1 && g.gl_statv[0] != NULL &&\n\t    S_ISDIR(g.gl_statv[0]->st_mode)) {\n\t\terr = do_ls_dir(conn, g.gl_pathv[0], strip_path, lflag);\n\t\tglobfree(&g);\n\t\treturn err;\n\t}\n\n\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\twidth = ws.ws_col;\n\n\tif (!(lflag & LS_SHORT_VIEW)) {\n\t\t/* Count entries for sort and find longest filename */\n\t\tfor (i = 0; g.gl_pathv[i]; i++)\n\t\t\tm = MAXIMUM(m, strlen(g.gl_pathv[i]));\n\n\t\tcolumns = width / (m + 2);\n\t\tcolumns = MAXIMUM(columns, 1);\n\t\tcolspace = width / columns;\n\t}\n\n\t/*\n\t * Sorting: rather than mess with the contents of glob_t, prepare\n\t * an array of indices into it and sort that. For the usual\n\t * unsorted case, the indices are just the identity 1=1, 2=2, etc.\n\t */\n\tfor (nentries = 0; g.gl_pathv[nentries] != NULL; nentries++)\n\t\t;\t/* count entries */\n\tindices = calloc(nentries, sizeof(*indices));\n\tfor (i = 0; i < nentries; i++)\n\t\tindices[i] = i;\n\n\tif (lflag & SORT_FLAGS) {\n\t\tsort_glob = &g;\n\t\tsort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);\n\t\tqsort(indices, nentries, sizeof(*indices), sglob_comp);\n\t\tsort_glob = NULL;\n\t}\n\n\tfor (j = 0; j < nentries && !interrupted; j++) {\n\t\ti = indices[j];\n\t\tfname = path_strip(g.gl_pathv[i], strip_path);\n\t\tif (lflag & LS_LONG_VIEW) {\n\t\t\tif (g.gl_statv[i] == NULL) {\n\t\t\t\terror(\"no stat information for %s\", fname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlname = ls_file(fname, g.gl_statv[i], 1,\n\t\t\t    (lflag & LS_SI_UNITS));\n\t\t\tmprintf(\"%s\\n\", lname);\n\t\t\tfree(lname);\n\t\t} else {\n\t\t\tmprintf(\"%-*s\", colspace, fname);\n\t\t\tif (c >= columns) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tc = 1;\n\t\t\t} else\n\t\t\t\tc++;\n\t\t}\n\t\tfree(fname);\n\t}\n\n\tif (!(lflag & LS_LONG_VIEW) && (c != 1))\n\t\tprintf(\"\\n\");\n\n out:\n\tif (g.gl_pathc)\n\t\tglobfree(&g);\n\tfree(indices);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&gl",
            "0",
            "sizeof(gl)"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&arg2",
            "\"%s/%s\"",
            "(flags & SSHCONF_USERCONF) ?\n\t\t\t\t    \"~/\" _PATH_SSH_USER_DIR : SSHDIR",
            "arg"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "a2tun",
          "args": [
            "arg",
            "&value2"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "a2tun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "348-377",
          "snippet": "int\na2tun(const char *s, int *remote)\n{\n\tconst char *errstr = NULL;\n\tchar *sp, *ep;\n\tint tun;\n\n\tif (remote != NULL) {\n\t\t*remote = SSH_TUNID_ANY;\n\t\tsp = xstrdup(s);\n\t\tif ((ep = strchr(sp, ':')) == NULL) {\n\t\t\tfree(sp);\n\t\t\treturn (a2tun(s, NULL));\n\t\t}\n\t\tep[0] = '\\0'; ep++;\n\t\t*remote = a2tun(ep, NULL);\n\t\ttun = a2tun(sp, NULL);\n\t\tfree(sp);\n\t\treturn (*remote == SSH_TUNID_ERR ? *remote : tun);\n\t}\n\n\tif (strcasecmp(s, \"any\") == 0)\n\t\treturn (SSH_TUNID_ANY);\n\n\ttun = strtonum(s, 0, SSH_TUNID_MAX, &errstr);\n\tif (errstr != NULL)\n\t\treturn (SSH_TUNID_ERR);\n\n\treturn (tun);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\na2tun(const char *s, int *remote)\n{\n\tconst char *errstr = NULL;\n\tchar *sp, *ep;\n\tint tun;\n\n\tif (remote != NULL) {\n\t\t*remote = SSH_TUNID_ANY;\n\t\tsp = xstrdup(s);\n\t\tif ((ep = strchr(sp, ':')) == NULL) {\n\t\t\tfree(sp);\n\t\t\treturn (a2tun(s, NULL));\n\t\t}\n\t\tep[0] = '\\0'; ep++;\n\t\t*remote = a2tun(ep, NULL);\n\t\ttun = a2tun(sp, NULL);\n\t\tfree(sp);\n\t\treturn (*remote == SSH_TUNID_ERR ? *remote : tun);\n\t}\n\n\tif (strcasecmp(s, \"any\") == 0)\n\t\treturn (SSH_TUNID_ANY);\n\n\ttun = strtonum(s, 0, SSH_TUNID_MAX, &errstr);\n\tif (errstr != NULL)\n\t\treturn (SSH_TUNID_ERR);\n\n\treturn (tun);\n}"
        }
      },
      {
        "call_info": {
          "callee": "convtime",
          "args": [
            "arg"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "convtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "406-465",
          "snippet": "long\nconvtime(const char *s)\n{\n\tlong total, secs, multiplier = 1;\n\tconst char *p;\n\tchar *endp;\n\n\terrno = 0;\n\ttotal = 0;\n\tp = s;\n\n\tif (p == NULL || *p == '\\0')\n\t\treturn -1;\n\n\twhile (*p) {\n\t\tsecs = strtol(p, &endp, 10);\n\t\tif (p == endp ||\n\t\t    (errno == ERANGE && (secs == LONG_MIN || secs == LONG_MAX)) ||\n\t\t    secs < 0)\n\t\t\treturn -1;\n\n\t\tswitch (*endp++) {\n\t\tcase '\\0':\n\t\t\tendp--;\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tbreak;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tmultiplier = MINUTES;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\tmultiplier = HOURS;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tmultiplier = DAYS;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\tcase 'W':\n\t\t\tmultiplier = WEEKS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (secs >= LONG_MAX / multiplier)\n\t\t\treturn -1;\n\t\tsecs *= multiplier;\n\t\tif  (total >= LONG_MAX - secs)\n\t\t\treturn -1;\n\t\ttotal += secs;\n\t\tif (total < 0)\n\t\t\treturn -1;\n\t\tp = endp;\n\t}\n\n\treturn total;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define WEEKS\t\t(DAYS * 7)",
            "#define DAYS\t\t(HOURS * 24)",
            "#define HOURS\t\t(MINUTES * 60)",
            "#define MINUTES\t\t(SECONDS * 60)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define WEEKS\t\t(DAYS * 7)\n#define DAYS\t\t(HOURS * 24)\n#define HOURS\t\t(MINUTES * 60)\n#define MINUTES\t\t(SECONDS * 60)\n\nlong\nconvtime(const char *s)\n{\n\tlong total, secs, multiplier = 1;\n\tconst char *p;\n\tchar *endp;\n\n\terrno = 0;\n\ttotal = 0;\n\tp = s;\n\n\tif (p == NULL || *p == '\\0')\n\t\treturn -1;\n\n\twhile (*p) {\n\t\tsecs = strtol(p, &endp, 10);\n\t\tif (p == endp ||\n\t\t    (errno == ERANGE && (secs == LONG_MIN || secs == LONG_MAX)) ||\n\t\t    secs < 0)\n\t\t\treturn -1;\n\n\t\tswitch (*endp++) {\n\t\tcase '\\0':\n\t\t\tendp--;\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tbreak;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tmultiplier = MINUTES;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\tmultiplier = HOURS;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tmultiplier = DAYS;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\tcase 'W':\n\t\t\tmultiplier = WEEKS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (secs >= LONG_MAX / multiplier)\n\t\t\treturn -1;\n\t\tsecs *= multiplier;\n\t\tif  (total >= LONG_MAX - secs)\n\t\t\treturn -1;\n\t\ttotal += secs;\n\t\tif (total < 0)\n\t\t\treturn -1;\n\t\tp = endp;\n\t}\n\n\treturn total;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xrecallocarray",
          "args": [
            "options->setenv",
            "options->num_setenv",
            "options->num_setenv + 1",
            "sizeof(*options->setenv)"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rm_env",
          "args": [
            "options",
            "arg",
            "filename",
            "linenum"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "rm_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "687-713",
          "snippet": "static void\nrm_env(Options *options, const char *arg, const char *filename, int linenum)\n{\n\tint i, j;\n\tchar *cp;\n\n\t/* Remove an environment variable */\n\tfor (i = 0; i < options->num_send_env; ) {\n\t\tcp = xstrdup(options->send_env[i]);\n\t\tif (!match_pattern(cp, arg + 1)) {\n\t\t\tfree(cp);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tdebug3(\"%s line %d: removing environment %s\",\n\t\t    filename, linenum, cp);\n\t\tfree(cp);\n\t\tfree(options->send_env[i]);\n\t\toptions->send_env[i] = NULL;\n\t\tfor (j = i; j < options->num_send_env - 1; j++) {\n\t\t\toptions->send_env[j] = options->send_env[j + 1];\n\t\t\toptions->send_env[j + 1] = NULL;\n\t\t}\n\t\toptions->num_send_env--;\n\t\t/* NB. don't increment i */\n\t}\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nrm_env(Options *options, const char *arg, const char *filename, int linenum)\n{\n\tint i, j;\n\tchar *cp;\n\n\t/* Remove an environment variable */\n\tfor (i = 0; i < options->num_send_env; ) {\n\t\tcp = xstrdup(options->send_env[i]);\n\t\tif (!match_pattern(cp, arg + 1)) {\n\t\t\tfree(cp);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tdebug3(\"%s line %d: removing environment %s\",\n\t\t    filename, linenum, cp);\n\t\tfree(cp);\n\t\tfree(options->send_env[i]);\n\t\toptions->send_env[i] = NULL;\n\t\tfor (j = i; j < options->num_send_env - 1; j++) {\n\t\t\toptions->send_env[j] = options->send_env[j + 1];\n\t\t\toptions->send_env[j + 1] = NULL;\n\t\t}\n\t\toptions->num_send_env--;\n\t\t/* NB. don't increment i */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_cfg_line",
          "args": [
            "options",
            "&s",
            "pw",
            "host",
            "original_host",
            "flags & SSHCONF_POSTCANON",
            "filename",
            "linenum"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "match_cfg_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "540-684",
          "snippet": "static int\nmatch_cfg_line(Options *options, char **condition, struct passwd *pw,\n    const char *host_arg, const char *original_host, int post_canon,\n    const char *filename, int linenum)\n{\n\tchar *arg, *oattrib, *attrib, *cmd, *cp = *condition, *host, *criteria;\n\tconst char *ruser;\n\tint r, port, this_result, result = 1, attributes = 0, negate;\n\tchar thishost[NI_MAXHOST], shorthost[NI_MAXHOST], portstr[NI_MAXSERV];\n\tchar uidstr[32];\n\n\t/*\n\t * Configuration is likely to be incomplete at this point so we\n\t * must be prepared to use default values.\n\t */\n\tport = options->port <= 0 ? default_ssh_port() : options->port;\n\truser = options->user == NULL ? pw->pw_name : options->user;\n\tif (post_canon) {\n\t\thost = xstrdup(options->hostname);\n\t} else if (options->hostname != NULL) {\n\t\t/* NB. Please keep in sync with ssh.c:main() */\n\t\thost = percent_expand(options->hostname,\n\t\t    \"h\", host_arg, (char *)NULL);\n\t} else {\n\t\thost = xstrdup(host_arg);\n\t}\n\n\tdebug2(\"checking match for '%s' host %s originally %s\",\n\t    cp, host, original_host);\n\twhile ((oattrib = attrib = strdelim(&cp)) && *attrib != '\\0') {\n\t\tcriteria = NULL;\n\t\tthis_result = 1;\n\t\tif ((negate = attrib[0] == '!'))\n\t\t\tattrib++;\n\t\t/* criteria \"all\" and \"canonical\" have no argument */\n\t\tif (strcasecmp(attrib, \"all\") == 0) {\n\t\t\tif (attributes > 1 ||\n\t\t\t    ((arg = strdelim(&cp)) != NULL && *arg != '\\0')) {\n\t\t\t\terror(\"%.200s line %d: '%s' cannot be combined \"\n\t\t\t\t    \"with other Match attributes\",\n\t\t\t\t    filename, linenum, oattrib);\n\t\t\t\tresult = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (result)\n\t\t\t\tresult = negate ? 0 : 1;\n\t\t\tgoto out;\n\t\t}\n\t\tattributes++;\n\t\tif (strcasecmp(attrib, \"canonical\") == 0) {\n\t\t\tr = !!post_canon;  /* force bitmask member to boolean */\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t\tdebug3(\"%.200s line %d: %smatched '%s'\",\n\t\t\t    filename, linenum,\n\t\t\t    this_result ? \"\" : \"not \", oattrib);\n\t\t\tcontinue;\n\t\t}\n\t\t/* All other criteria require an argument */\n\t\tif ((arg = strdelim(&cp)) == NULL || *arg == '\\0') {\n\t\t\terror(\"Missing Match criteria for %s\", attrib);\n\t\t\tresult = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcasecmp(attrib, \"host\") == 0) {\n\t\t\tcriteria = xstrdup(host);\n\t\t\tr = match_hostname(host, arg) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"originalhost\") == 0) {\n\t\t\tcriteria = xstrdup(original_host);\n\t\t\tr = match_hostname(original_host, arg) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"user\") == 0) {\n\t\t\tcriteria = xstrdup(ruser);\n\t\t\tr = match_pattern_list(ruser, arg, 0) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"localuser\") == 0) {\n\t\t\tcriteria = xstrdup(pw->pw_name);\n\t\t\tr = match_pattern_list(pw->pw_name, arg, 0) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"exec\") == 0) {\n\t\t\tif (gethostname(thishost, sizeof(thishost)) == -1)\n\t\t\t\tfatal(\"gethostname: %s\", strerror(errno));\n\t\t\tstrlcpy(shorthost, thishost, sizeof(shorthost));\n\t\t\tshorthost[strcspn(thishost, \".\")] = '\\0';\n\t\t\tsnprintf(portstr, sizeof(portstr), \"%d\", port);\n\t\t\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t\t\t    (unsigned long long)pw->pw_uid);\n\n\t\t\tcmd = percent_expand(arg,\n\t\t\t    \"L\", shorthost,\n\t\t\t    \"d\", pw->pw_dir,\n\t\t\t    \"h\", host,\n\t\t\t    \"l\", thishost,\n\t\t\t    \"n\", original_host,\n\t\t\t    \"p\", portstr,\n\t\t\t    \"r\", ruser,\n\t\t\t    \"u\", pw->pw_name,\n\t\t\t    \"i\", uidstr,\n\t\t\t    (char *)NULL);\n\t\t\tif (result != 1) {\n\t\t\t\t/* skip execution if prior predicate failed */\n\t\t\t\tdebug3(\"%.200s line %d: skipped exec \"\n\t\t\t\t    \"\\\"%.100s\\\"\", filename, linenum, cmd);\n\t\t\t\tfree(cmd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr = execute_in_shell(cmd);\n\t\t\tif (r == -1) {\n\t\t\t\tfatal(\"%.200s line %d: match exec \"\n\t\t\t\t    \"'%.100s' error\", filename,\n\t\t\t\t    linenum, cmd);\n\t\t\t}\n\t\t\tcriteria = xstrdup(cmd);\n\t\t\tfree(cmd);\n\t\t\t/* Force exit status to boolean */\n\t\t\tr = r == 0;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else {\n\t\t\terror(\"Unsupported Match attribute %s\", attrib);\n\t\t\tresult = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tdebug3(\"%.200s line %d: %smatched '%s \\\"%.100s\\\"' \",\n\t\t    filename, linenum, this_result ? \"\": \"not \",\n\t\t    oattrib, criteria);\n\t\tfree(criteria);\n\t}\n\tif (attributes == 0) {\n\t\terror(\"One or more attributes required for Match\");\n\t\tresult = -1;\n\t\tgoto out;\n\t}\n out:\n\tif (result != -1)\n\t\tdebug2(\"match %sfound\", result ? \"\" : \"not \");\n\t*condition = cp;\n\tfree(host);\n\treturn result;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nmatch_cfg_line(Options *options, char **condition, struct passwd *pw,\n    const char *host_arg, const char *original_host, int post_canon,\n    const char *filename, int linenum)\n{\n\tchar *arg, *oattrib, *attrib, *cmd, *cp = *condition, *host, *criteria;\n\tconst char *ruser;\n\tint r, port, this_result, result = 1, attributes = 0, negate;\n\tchar thishost[NI_MAXHOST], shorthost[NI_MAXHOST], portstr[NI_MAXSERV];\n\tchar uidstr[32];\n\n\t/*\n\t * Configuration is likely to be incomplete at this point so we\n\t * must be prepared to use default values.\n\t */\n\tport = options->port <= 0 ? default_ssh_port() : options->port;\n\truser = options->user == NULL ? pw->pw_name : options->user;\n\tif (post_canon) {\n\t\thost = xstrdup(options->hostname);\n\t} else if (options->hostname != NULL) {\n\t\t/* NB. Please keep in sync with ssh.c:main() */\n\t\thost = percent_expand(options->hostname,\n\t\t    \"h\", host_arg, (char *)NULL);\n\t} else {\n\t\thost = xstrdup(host_arg);\n\t}\n\n\tdebug2(\"checking match for '%s' host %s originally %s\",\n\t    cp, host, original_host);\n\twhile ((oattrib = attrib = strdelim(&cp)) && *attrib != '\\0') {\n\t\tcriteria = NULL;\n\t\tthis_result = 1;\n\t\tif ((negate = attrib[0] == '!'))\n\t\t\tattrib++;\n\t\t/* criteria \"all\" and \"canonical\" have no argument */\n\t\tif (strcasecmp(attrib, \"all\") == 0) {\n\t\t\tif (attributes > 1 ||\n\t\t\t    ((arg = strdelim(&cp)) != NULL && *arg != '\\0')) {\n\t\t\t\terror(\"%.200s line %d: '%s' cannot be combined \"\n\t\t\t\t    \"with other Match attributes\",\n\t\t\t\t    filename, linenum, oattrib);\n\t\t\t\tresult = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (result)\n\t\t\t\tresult = negate ? 0 : 1;\n\t\t\tgoto out;\n\t\t}\n\t\tattributes++;\n\t\tif (strcasecmp(attrib, \"canonical\") == 0) {\n\t\t\tr = !!post_canon;  /* force bitmask member to boolean */\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t\tdebug3(\"%.200s line %d: %smatched '%s'\",\n\t\t\t    filename, linenum,\n\t\t\t    this_result ? \"\" : \"not \", oattrib);\n\t\t\tcontinue;\n\t\t}\n\t\t/* All other criteria require an argument */\n\t\tif ((arg = strdelim(&cp)) == NULL || *arg == '\\0') {\n\t\t\terror(\"Missing Match criteria for %s\", attrib);\n\t\t\tresult = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcasecmp(attrib, \"host\") == 0) {\n\t\t\tcriteria = xstrdup(host);\n\t\t\tr = match_hostname(host, arg) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"originalhost\") == 0) {\n\t\t\tcriteria = xstrdup(original_host);\n\t\t\tr = match_hostname(original_host, arg) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"user\") == 0) {\n\t\t\tcriteria = xstrdup(ruser);\n\t\t\tr = match_pattern_list(ruser, arg, 0) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"localuser\") == 0) {\n\t\t\tcriteria = xstrdup(pw->pw_name);\n\t\t\tr = match_pattern_list(pw->pw_name, arg, 0) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"exec\") == 0) {\n\t\t\tif (gethostname(thishost, sizeof(thishost)) == -1)\n\t\t\t\tfatal(\"gethostname: %s\", strerror(errno));\n\t\t\tstrlcpy(shorthost, thishost, sizeof(shorthost));\n\t\t\tshorthost[strcspn(thishost, \".\")] = '\\0';\n\t\t\tsnprintf(portstr, sizeof(portstr), \"%d\", port);\n\t\t\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t\t\t    (unsigned long long)pw->pw_uid);\n\n\t\t\tcmd = percent_expand(arg,\n\t\t\t    \"L\", shorthost,\n\t\t\t    \"d\", pw->pw_dir,\n\t\t\t    \"h\", host,\n\t\t\t    \"l\", thishost,\n\t\t\t    \"n\", original_host,\n\t\t\t    \"p\", portstr,\n\t\t\t    \"r\", ruser,\n\t\t\t    \"u\", pw->pw_name,\n\t\t\t    \"i\", uidstr,\n\t\t\t    (char *)NULL);\n\t\t\tif (result != 1) {\n\t\t\t\t/* skip execution if prior predicate failed */\n\t\t\t\tdebug3(\"%.200s line %d: skipped exec \"\n\t\t\t\t    \"\\\"%.100s\\\"\", filename, linenum, cmd);\n\t\t\t\tfree(cmd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr = execute_in_shell(cmd);\n\t\t\tif (r == -1) {\n\t\t\t\tfatal(\"%.200s line %d: match exec \"\n\t\t\t\t    \"'%.100s' error\", filename,\n\t\t\t\t    linenum, cmd);\n\t\t\t}\n\t\t\tcriteria = xstrdup(cmd);\n\t\t\tfree(cmd);\n\t\t\t/* Force exit status to boolean */\n\t\t\tr = r == 0;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else {\n\t\t\terror(\"Unsupported Match attribute %s\", attrib);\n\t\t\tresult = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tdebug3(\"%.200s line %d: %smatched '%s \\\"%.100s\\\"' \",\n\t\t    filename, linenum, this_result ? \"\": \"not \",\n\t\t    oattrib, criteria);\n\t\tfree(criteria);\n\t}\n\tif (attributes == 0) {\n\t\terror(\"One or more attributes required for Match\");\n\t\tresult = -1;\n\t\tgoto out;\n\t}\n out:\n\tif (result != -1)\n\t\tdebug2(\"match %sfound\", result ? \"\" : \"not \");\n\t*condition = cp;\n\tfree(host);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_pattern",
          "args": [
            "host",
            "arg"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "56-112",
          "snippet": "int\nmatch_pattern(const char *s, const char *pattern)\n{\n\tfor (;;) {\n\t\t/* If at end of pattern, accept if also at end of string. */\n\t\tif (!*pattern)\n\t\t\treturn !*s;\n\n\t\tif (*pattern == '*') {\n\t\t\t/* Skip the asterisk. */\n\t\t\tpattern++;\n\n\t\t\t/* If at end of pattern, accept immediately. */\n\t\t\tif (!*pattern)\n\t\t\t\treturn 1;\n\n\t\t\t/* If next character in pattern is known, optimize. */\n\t\t\tif (*pattern != '?' && *pattern != '*') {\n\t\t\t\t/*\n\t\t\t\t * Look instances of the next character in\n\t\t\t\t * pattern, and try to match starting from\n\t\t\t\t * those.\n\t\t\t\t */\n\t\t\t\tfor (; *s; s++)\n\t\t\t\t\tif (*s == *pattern &&\n\t\t\t\t\t    match_pattern(s + 1, pattern + 1))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t/* Failed. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Move ahead one character at a time and try to\n\t\t\t * match at each position.\n\t\t\t */\n\t\t\tfor (; *s; s++)\n\t\t\t\tif (match_pattern(s, pattern))\n\t\t\t\t\treturn 1;\n\t\t\t/* Failed. */\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * There must be at least one more character in the string.\n\t\t * If we are at the end, fail.\n\t\t */\n\t\tif (!*s)\n\t\t\treturn 0;\n\n\t\t/* Check if the next character of the string is acceptable. */\n\t\tif (*pattern != '?' && *pattern != *s)\n\t\t\treturn 0;\n\n\t\t/* Move to the next character, both in string and in pattern. */\n\t\ts++;\n\t\tpattern++;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern(const char *s, const char *pattern)\n{\n\tfor (;;) {\n\t\t/* If at end of pattern, accept if also at end of string. */\n\t\tif (!*pattern)\n\t\t\treturn !*s;\n\n\t\tif (*pattern == '*') {\n\t\t\t/* Skip the asterisk. */\n\t\t\tpattern++;\n\n\t\t\t/* If at end of pattern, accept immediately. */\n\t\t\tif (!*pattern)\n\t\t\t\treturn 1;\n\n\t\t\t/* If next character in pattern is known, optimize. */\n\t\t\tif (*pattern != '?' && *pattern != '*') {\n\t\t\t\t/*\n\t\t\t\t * Look instances of the next character in\n\t\t\t\t * pattern, and try to match starting from\n\t\t\t\t * those.\n\t\t\t\t */\n\t\t\t\tfor (; *s; s++)\n\t\t\t\t\tif (*s == *pattern &&\n\t\t\t\t\t    match_pattern(s + 1, pattern + 1))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t/* Failed. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Move ahead one character at a time and try to\n\t\t\t * match at each position.\n\t\t\t */\n\t\t\tfor (; *s; s++)\n\t\t\t\tif (match_pattern(s, pattern))\n\t\t\t\t\treturn 1;\n\t\t\t/* Failed. */\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * There must be at least one more character in the string.\n\t\t * If we are at the end, fail.\n\t\t */\n\t\tif (!*s)\n\t\t\treturn 0;\n\n\t\t/* Check if the next character of the string is acceptable. */\n\t\tif (*pattern != '?' && *pattern != *s)\n\t\t\treturn 0;\n\n\t\t/* Move to the next character, both in string and in pattern. */\n\t\ts++;\n\t\tpattern++;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_local_forward",
          "args": [
            "options",
            "&fwd"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "add_local_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "321-343",
          "snippet": "void\nadd_local_forward(Options *options, const struct Forward *newfwd)\n{\n\tstruct Forward *fwd;\n\tint i;\n\n\t/* Don't add duplicates */\n\tfor (i = 0; i < options->num_local_forwards; i++) {\n\t\tif (forward_equals(newfwd, options->local_forwards + i))\n\t\t\treturn;\n\t}\n\toptions->local_forwards = xreallocarray(options->local_forwards,\n\t    options->num_local_forwards + 1,\n\t    sizeof(*options->local_forwards));\n\tfwd = &options->local_forwards[options->num_local_forwards++];\n\n\tfwd->listen_host = newfwd->listen_host;\n\tfwd->listen_port = newfwd->listen_port;\n\tfwd->listen_path = newfwd->listen_path;\n\tfwd->connect_host = newfwd->connect_host;\n\tfwd->connect_port = newfwd->connect_port;\n\tfwd->connect_path = newfwd->connect_path;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nadd_local_forward(Options *options, const struct Forward *newfwd)\n{\n\tstruct Forward *fwd;\n\tint i;\n\n\t/* Don't add duplicates */\n\tfor (i = 0; i < options->num_local_forwards; i++) {\n\t\tif (forward_equals(newfwd, options->local_forwards + i))\n\t\t\treturn;\n\t}\n\toptions->local_forwards = xreallocarray(options->local_forwards,\n\t    options->num_local_forwards + 1,\n\t    sizeof(*options->local_forwards));\n\tfwd = &options->local_forwards[options->num_local_forwards++];\n\n\tfwd->listen_host = newfwd->listen_host;\n\tfwd->listen_port = newfwd->listen_port;\n\tfwd->listen_path = newfwd->listen_path;\n\tfwd->connect_host = newfwd->connect_host;\n\tfwd->connect_port = newfwd->connect_port;\n\tfwd->connect_path = newfwd->connect_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_remote_forward",
          "args": [
            "options",
            "&fwd"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "add_remote_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "350-374",
          "snippet": "void\nadd_remote_forward(Options *options, const struct Forward *newfwd)\n{\n\tstruct Forward *fwd;\n\tint i;\n\n\t/* Don't add duplicates */\n\tfor (i = 0; i < options->num_remote_forwards; i++) {\n\t\tif (forward_equals(newfwd, options->remote_forwards + i))\n\t\t\treturn;\n\t}\n\toptions->remote_forwards = xreallocarray(options->remote_forwards,\n\t    options->num_remote_forwards + 1,\n\t    sizeof(*options->remote_forwards));\n\tfwd = &options->remote_forwards[options->num_remote_forwards++];\n\n\tfwd->listen_host = newfwd->listen_host;\n\tfwd->listen_port = newfwd->listen_port;\n\tfwd->listen_path = newfwd->listen_path;\n\tfwd->connect_host = newfwd->connect_host;\n\tfwd->connect_port = newfwd->connect_port;\n\tfwd->connect_path = newfwd->connect_path;\n\tfwd->handle = newfwd->handle;\n\tfwd->allocated_port = 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nadd_remote_forward(Options *options, const struct Forward *newfwd)\n{\n\tstruct Forward *fwd;\n\tint i;\n\n\t/* Don't add duplicates */\n\tfor (i = 0; i < options->num_remote_forwards; i++) {\n\t\tif (forward_equals(newfwd, options->remote_forwards + i))\n\t\t\treturn;\n\t}\n\toptions->remote_forwards = xreallocarray(options->remote_forwards,\n\t    options->num_remote_forwards + 1,\n\t    sizeof(*options->remote_forwards));\n\tfwd = &options->remote_forwards[options->num_remote_forwards++];\n\n\tfwd->listen_host = newfwd->listen_host;\n\tfwd->listen_port = newfwd->listen_port;\n\tfwd->listen_path = newfwd->listen_path;\n\tfwd->connect_host = newfwd->connect_host;\n\tfwd->connect_port = newfwd->connect_port;\n\tfwd->connect_path = newfwd->connect_path;\n\tfwd->handle = newfwd->handle;\n\tfwd->allocated_port = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_forward",
          "args": [
            "&fwd",
            "fwdarg",
            "dynamicfwd",
            "remotefwd"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "parse_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2229-2358",
          "snippet": "int\nparse_forward(struct Forward *fwd, const char *fwdspec, int dynamicfwd, int remotefwd)\n{\n\tstruct fwdarg fwdargs[4];\n\tchar *p, *cp;\n\tint i;\n\n\tmemset(fwd, 0, sizeof(*fwd));\n\tmemset(fwdargs, 0, sizeof(fwdargs));\n\n\tcp = p = xstrdup(fwdspec);\n\n\t/* skip leading spaces */\n\twhile (isspace((u_char)*cp))\n\t\tcp++;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (parse_fwd_field(&cp, &fwdargs[i]) != 0)\n\t\t\tbreak;\n\t}\n\n\t/* Check for trailing garbage */\n\tif (cp != NULL && *cp != '\\0') {\n\t\ti = 0;\t/* failure */\n\t}\n\n\tswitch (i) {\n\tcase 1:\n\t\tif (fwdargs[0].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t}\n\t\tfwd->connect_host = xstrdup(\"socks\");\n\t\tbreak;\n\n\tcase 2:\n\t\tif (fwdargs[0].ispath && fwdargs[1].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t\tfwd->connect_path = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else if (fwdargs[1].ispath) {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t\tfwd->connect_path = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\t\tfwd->connect_host = xstrdup(\"socks\");\n\t\t}\n\t\tbreak;\n\n\tcase 3:\n\t\tif (fwdargs[0].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t\tfwd->connect_host = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = a2port(fwdargs[2].arg);\n\t\t} else if (fwdargs[2].ispath) {\n\t\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\t\tfwd->connect_path = xstrdup(fwdargs[2].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t\tfwd->connect_host = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = a2port(fwdargs[2].arg);\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\tfwd->connect_host = xstrdup(fwdargs[2].arg);\n\t\tfwd->connect_port = a2port(fwdargs[3].arg);\n\t\tbreak;\n\tdefault:\n\t\ti = 0; /* failure */\n\t}\n\n\tfree(p);\n\n\tif (dynamicfwd) {\n\t\tif (!(i == 1 || i == 2))\n\t\t\tgoto fail_free;\n\t} else {\n\t\tif (!(i == 3 || i == 4)) {\n\t\t\tif (fwd->connect_path == NULL &&\n\t\t\t    fwd->listen_path == NULL)\n\t\t\t\tgoto fail_free;\n\t\t}\n\t\tif (fwd->connect_port <= 0 && fwd->connect_path == NULL)\n\t\t\tgoto fail_free;\n\t}\n\n\tif ((fwd->listen_port < 0 && fwd->listen_path == NULL) ||\n\t    (!remotefwd && fwd->listen_port == 0))\n\t\tgoto fail_free;\n\tif (fwd->connect_host != NULL &&\n\t    strlen(fwd->connect_host) >= NI_MAXHOST)\n\t\tgoto fail_free;\n\t/* XXX - if connecting to a remote socket, max sun len may not match this host */\n\tif (fwd->connect_path != NULL &&\n\t    strlen(fwd->connect_path) >= PATH_MAX_SUN)\n\t\tgoto fail_free;\n\tif (fwd->listen_host != NULL &&\n\t    strlen(fwd->listen_host) >= NI_MAXHOST)\n\t\tgoto fail_free;\n\tif (fwd->listen_path != NULL &&\n\t    strlen(fwd->listen_path) >= PATH_MAX_SUN)\n\t\tgoto fail_free;\n\n\treturn (i);\n\n fail_free:\n\tfree(fwd->connect_host);\n\tfwd->connect_host = NULL;\n\tfree(fwd->connect_path);\n\tfwd->connect_path = NULL;\n\tfree(fwd->listen_host);\n\tfwd->listen_host = NULL;\n\tfree(fwd->listen_path);\n\tfwd->listen_path = NULL;\n\treturn (0);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_forward(struct Forward *fwd, const char *fwdspec, int dynamicfwd, int remotefwd)\n{\n\tstruct fwdarg fwdargs[4];\n\tchar *p, *cp;\n\tint i;\n\n\tmemset(fwd, 0, sizeof(*fwd));\n\tmemset(fwdargs, 0, sizeof(fwdargs));\n\n\tcp = p = xstrdup(fwdspec);\n\n\t/* skip leading spaces */\n\twhile (isspace((u_char)*cp))\n\t\tcp++;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (parse_fwd_field(&cp, &fwdargs[i]) != 0)\n\t\t\tbreak;\n\t}\n\n\t/* Check for trailing garbage */\n\tif (cp != NULL && *cp != '\\0') {\n\t\ti = 0;\t/* failure */\n\t}\n\n\tswitch (i) {\n\tcase 1:\n\t\tif (fwdargs[0].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t}\n\t\tfwd->connect_host = xstrdup(\"socks\");\n\t\tbreak;\n\n\tcase 2:\n\t\tif (fwdargs[0].ispath && fwdargs[1].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t\tfwd->connect_path = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else if (fwdargs[1].ispath) {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t\tfwd->connect_path = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\t\tfwd->connect_host = xstrdup(\"socks\");\n\t\t}\n\t\tbreak;\n\n\tcase 3:\n\t\tif (fwdargs[0].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t\tfwd->connect_host = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = a2port(fwdargs[2].arg);\n\t\t} else if (fwdargs[2].ispath) {\n\t\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\t\tfwd->connect_path = xstrdup(fwdargs[2].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t\tfwd->connect_host = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = a2port(fwdargs[2].arg);\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\tfwd->connect_host = xstrdup(fwdargs[2].arg);\n\t\tfwd->connect_port = a2port(fwdargs[3].arg);\n\t\tbreak;\n\tdefault:\n\t\ti = 0; /* failure */\n\t}\n\n\tfree(p);\n\n\tif (dynamicfwd) {\n\t\tif (!(i == 1 || i == 2))\n\t\t\tgoto fail_free;\n\t} else {\n\t\tif (!(i == 3 || i == 4)) {\n\t\t\tif (fwd->connect_path == NULL &&\n\t\t\t    fwd->listen_path == NULL)\n\t\t\t\tgoto fail_free;\n\t\t}\n\t\tif (fwd->connect_port <= 0 && fwd->connect_path == NULL)\n\t\t\tgoto fail_free;\n\t}\n\n\tif ((fwd->listen_port < 0 && fwd->listen_path == NULL) ||\n\t    (!remotefwd && fwd->listen_port == 0))\n\t\tgoto fail_free;\n\tif (fwd->connect_host != NULL &&\n\t    strlen(fwd->connect_host) >= NI_MAXHOST)\n\t\tgoto fail_free;\n\t/* XXX - if connecting to a remote socket, max sun len may not match this host */\n\tif (fwd->connect_path != NULL &&\n\t    strlen(fwd->connect_path) >= PATH_MAX_SUN)\n\t\tgoto fail_free;\n\tif (fwd->listen_host != NULL &&\n\t    strlen(fwd->listen_host) >= NI_MAXHOST)\n\t\tgoto fail_free;\n\tif (fwd->listen_path != NULL &&\n\t    strlen(fwd->listen_path) >= PATH_MAX_SUN)\n\t\tgoto fail_free;\n\n\treturn (i);\n\n fail_free:\n\tfree(fwd->connect_host);\n\tfwd->connect_host = NULL;\n\tfree(fwd->connect_path);\n\tfwd->connect_path = NULL;\n\tfree(fwd->listen_host);\n\tfwd->listen_host = NULL;\n\tfree(fwd->listen_path);\n\tfwd->listen_path = NULL;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "fwdarg",
            "arg",
            "sizeof(fwdarg)"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fwdarg",
            "sizeof(fwdarg)",
            "\"%s:%s\"",
            "arg",
            "arg2"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_facility_number",
          "args": [
            "arg"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "log_facility_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "114-124",
          "snippet": "SyslogFacility\nlog_facility_number(char *name)\n{\n\tint i;\n\n\tif (name != NULL)\n\t\tfor (i = 0; log_facilities[i].name; i++)\n\t\t\tif (strcasecmp(log_facilities[i].name, name) == 0)\n\t\t\t\treturn log_facilities[i].val;\n\treturn SYSLOG_FACILITY_NOT_SET;\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tSyslogFacility val;\n} log_facilities[] = {\n\t{ \"DAEMON\",\tSYSLOG_FACILITY_DAEMON },\n\t{ \"USER\",\tSYSLOG_FACILITY_USER },\n\t{ \"AUTH\",\tSYSLOG_FACILITY_AUTH },\n#ifdef LOG_AUTHPRIV\n\t{ \"AUTHPRIV\",\tSYSLOG_FACILITY_AUTHPRIV },\n#endif\n\t{ \"LOCAL0\",\tSYSLOG_FACILITY_LOCAL0 },\n\t{ \"LOCAL1\",\tSYSLOG_FACILITY_LOCAL1 },\n\t{ \"LOCAL2\",\tSYSLOG_FACILITY_LOCAL2 },\n\t{ \"LOCAL3\",\tSYSLOG_FACILITY_LOCAL3 },\n\t{ \"LOCAL4\",\tSYSLOG_FACILITY_LOCAL4 },\n\t{ \"LOCAL5\",\tSYSLOG_FACILITY_LOCAL5 },\n\t{ \"LOCAL6\",\tSYSLOG_FACILITY_LOCAL6 },\n\t{ \"LOCAL7\",\tSYSLOG_FACILITY_LOCAL7 },\n\t{ NULL,\t\tSYSLOG_FACILITY_NOT_SET }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tSyslogFacility val;\n} log_facilities[] = {\n\t{ \"DAEMON\",\tSYSLOG_FACILITY_DAEMON },\n\t{ \"USER\",\tSYSLOG_FACILITY_USER },\n\t{ \"AUTH\",\tSYSLOG_FACILITY_AUTH },\n#ifdef LOG_AUTHPRIV\n\t{ \"AUTHPRIV\",\tSYSLOG_FACILITY_AUTHPRIV },\n#endif\n\t{ \"LOCAL0\",\tSYSLOG_FACILITY_LOCAL0 },\n\t{ \"LOCAL1\",\tSYSLOG_FACILITY_LOCAL1 },\n\t{ \"LOCAL2\",\tSYSLOG_FACILITY_LOCAL2 },\n\t{ \"LOCAL3\",\tSYSLOG_FACILITY_LOCAL3 },\n\t{ \"LOCAL4\",\tSYSLOG_FACILITY_LOCAL4 },\n\t{ \"LOCAL5\",\tSYSLOG_FACILITY_LOCAL5 },\n\t{ \"LOCAL6\",\tSYSLOG_FACILITY_LOCAL6 },\n\t{ \"LOCAL7\",\tSYSLOG_FACILITY_LOCAL7 },\n\t{ NULL,\t\tSYSLOG_FACILITY_NOT_SET }\n};\n\nSyslogFacility\nlog_facility_number(char *name)\n{\n\tint i;\n\n\tif (name != NULL)\n\t\tfor (i = 0; log_facilities[i].name; i++)\n\t\t\tif (strcasecmp(log_facilities[i].name, name) == 0)\n\t\t\t\treturn log_facilities[i].val;\n\treturn SYSLOG_FACILITY_NOT_SET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_level_number",
          "args": [
            "arg"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "log_level_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "137-147",
          "snippet": "LogLevel\nlog_level_number(char *name)\n{\n\tint i;\n\n\tif (name != NULL)\n\t\tfor (i = 0; log_levels[i].name; i++)\n\t\t\tif (strcasecmp(log_levels[i].name, name) == 0)\n\t\t\t\treturn log_levels[i].val;\n\treturn SYSLOG_LEVEL_NOT_SET;\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tLogLevel val;\n} log_levels[] =\n{\n\t{ \"QUIET\",\tSYSLOG_LEVEL_QUIET },\n\t{ \"FATAL\",\tSYSLOG_LEVEL_FATAL },\n\t{ \"ERROR\",\tSYSLOG_LEVEL_ERROR },\n\t{ \"INFO\",\tSYSLOG_LEVEL_INFO },\n\t{ \"VERBOSE\",\tSYSLOG_LEVEL_VERBOSE },\n\t{ \"DEBUG\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG1\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG2\",\tSYSLOG_LEVEL_DEBUG2 },\n\t{ \"DEBUG3\",\tSYSLOG_LEVEL_DEBUG3 },\n\t{ NULL,\t\tSYSLOG_LEVEL_NOT_SET }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tLogLevel val;\n} log_levels[] =\n{\n\t{ \"QUIET\",\tSYSLOG_LEVEL_QUIET },\n\t{ \"FATAL\",\tSYSLOG_LEVEL_FATAL },\n\t{ \"ERROR\",\tSYSLOG_LEVEL_ERROR },\n\t{ \"INFO\",\tSYSLOG_LEVEL_INFO },\n\t{ \"VERBOSE\",\tSYSLOG_LEVEL_VERBOSE },\n\t{ \"DEBUG\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG1\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG2\",\tSYSLOG_LEVEL_DEBUG2 },\n\t{ \"DEBUG3\",\tSYSLOG_LEVEL_DEBUG3 },\n\t{ NULL,\t\tSYSLOG_LEVEL_NOT_SET }\n};\n\nLogLevel\nlog_level_number(char *name)\n{\n\tint i;\n\n\tif (name != NULL)\n\t\tfor (i = 0; log_levels[i].name; i++)\n\t\t\tif (strcasecmp(log_levels[i].name, name) == 0)\n\t\t\t\treturn log_levels[i].val;\n\treturn SYSLOG_LEVEL_NOT_SET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_names_valid2",
          "args": [
            "*arg == '+' ? arg + 1 : arg",
            "1"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_names_valid2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "246-281",
          "snippet": "int\nsshkey_names_valid2(const char *names, int allow_wildcard)\n{\n\tchar *s, *cp, *p;\n\tconst struct keytype *kt;\n\tint type;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((s = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0';\n\t    (p = strsep(&cp, \",\"))) {\n\t\ttype = sshkey_type_from_name(p);\n\t\tif (type == KEY_UNSPEC) {\n\t\t\tif (allow_wildcard) {\n\t\t\t\t/*\n\t\t\t\t * Try matching key types against the string.\n\t\t\t\t * If any has a positive or negative match then\n\t\t\t\t * the component is accepted.\n\t\t\t\t */\n\t\t\t\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t\t\t\tif (match_pattern_list(kt->name,\n\t\t\t\t\t    p, 0) != 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (kt->type != -1)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(s);\n\treturn 1;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_names_valid2(const char *names, int allow_wildcard)\n{\n\tchar *s, *cp, *p;\n\tconst struct keytype *kt;\n\tint type;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((s = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0';\n\t    (p = strsep(&cp, \",\"))) {\n\t\ttype = sshkey_type_from_name(p);\n\t\tif (type == KEY_UNSPEC) {\n\t\t\tif (allow_wildcard) {\n\t\t\t\t/*\n\t\t\t\t * Try matching key types against the string.\n\t\t\t\t * If any has a positive or negative match then\n\t\t\t\t * the component is accepted.\n\t\t\t\t */\n\t\t\t\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t\t\t\tif (match_pattern_list(kt->name,\n\t\t\t\t\t    p, 0) != 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (kt->type != -1)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(s);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kex_names_valid",
          "args": [
            "*arg == '+' ? arg + 1 : arg"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "kex_names_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "144-164",
          "snippet": "int\nkex_names_valid(const char *names)\n{\n\tchar *s, *cp, *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((s = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0';\n\t    (p = strsep(&cp, \",\"))) {\n\t\tif (kex_alg_by_name(p) == NULL) {\n\t\t\terror(\"Unsupported KEX algorithm \\\"%.100s\\\"\", p);\n\t\t\tfree(s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdebug3(\"kex names ok: [%s]\", names);\n\tfree(s);\n\treturn 1;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nint\nkex_names_valid(const char *names)\n{\n\tchar *s, *cp, *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((s = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0';\n\t    (p = strsep(&cp, \",\"))) {\n\t\tif (kex_alg_by_name(p) == NULL) {\n\t\t\terror(\"Unsupported KEX algorithm \\\"%.100s\\\"\", p);\n\t\t\tfree(s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdebug3(\"kex names ok: [%s]\", names);\n\tfree(s);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mac_valid",
          "args": [
            "*arg == '+' ? arg + 1 : arg"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "mac_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mac.c",
          "lines": "247-265",
          "snippet": "int\nmac_valid(const char *names)\n{\n\tchar *maclist, *cp, *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((maclist = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, MAC_SEP)); p && *p != '\\0';\n\t    (p = strsep(&cp, MAC_SEP))) {\n\t\tif (mac_setup(NULL, p) < 0) {\n\t\t\tfree(maclist);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(maclist);\n\treturn 1;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"mac.h\"",
            "#include \"umac.h\"",
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tMAC_SEP\t\",\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"mac.h\"\n#include \"umac.h\"\n#include \"hmac.h\"\n#include \"digest.h\"\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tMAC_SEP\t\",\"\n\nint\nmac_valid(const char *names)\n{\n\tchar *maclist, *cp, *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((maclist = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, MAC_SEP)); p && *p != '\\0';\n\t    (p = strsep(&cp, MAC_SEP))) {\n\t\tif (mac_setup(NULL, p) < 0) {\n\t\t\tfree(maclist);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(maclist);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ciphers_valid",
          "args": [
            "*arg == '+' ? arg + 1 : arg"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "ciphers_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "203-224",
          "snippet": "int\nciphers_valid(const char *names)\n{\n\tconst struct sshcipher *c;\n\tchar *cipher_list, *cp;\n\tchar *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((cipher_list = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, CIPHER_SEP)); p && *p != '\\0';\n\t    (p = strsep(&cp, CIPHER_SEP))) {\n\t\tc = cipher_by_name(p);\n\t\tif (c == NULL || (c->flags & CFLAG_INTERNAL) != 0) {\n\t\t\tfree(cipher_list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(cipher_list);\n\treturn 1;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tCIPHER_SEP\t\",\"",
            "#define CFLAG_INTERNAL\t\tCFLAG_NONE /* Don't use \"none\" for packets */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tCIPHER_SEP\t\",\"\n#define CFLAG_INTERNAL\t\tCFLAG_NONE /* Don't use \"none\" for packets */\n\nint\nciphers_valid(const char *names)\n{\n\tconst struct sshcipher *c;\n\tchar *cipher_list, *cp;\n\tchar *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((cipher_list = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, CIPHER_SEP)); p && *p != '\\0';\n\t    (p = strsep(&cp, CIPHER_SEP))) {\n\t\tc = cipher_by_name(p);\n\t\tif (c == NULL || (c->flags & CFLAG_INTERNAL) != 0) {\n\t\t\tfree(cipher_list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(cipher_list);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi_err",
          "args": [
            "arg",
            "&value"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "atoi_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1974-1986",
          "snippet": "const char *\natoi_err(const char *nptr, int *val)\n{\n\tconst char *errstr = NULL;\n\tlong long num;\n\n\tif (nptr == NULL || *nptr == '\\0')\n\t\treturn \"missing\";\n\tnum = strtonum(nptr, 0, INT_MAX, &errstr);\n\tif (errstr == NULL)\n\t\t*val = (int)num;\n\treturn errstr;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\natoi_err(const char *nptr, int *val)\n{\n\tconst char *errstr = NULL;\n\tlong long num;\n\n\tif (nptr == NULL || *nptr == '\\0')\n\t\treturn \"missing\";\n\tnum = strtonum(nptr, 0, INT_MAX, &errstr);\n\tif (errstr == NULL)\n\t\t*val = (int)num;\n\treturn errstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "a2port",
          "args": [
            "arg"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "a2port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "333-346",
          "snippet": "int\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_jump",
          "args": [
            "s + len",
            "options",
            "*activep"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "parse_jump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "2360-2415",
          "snippet": "int\nparse_jump(const char *s, Options *o, int active)\n{\n\tchar *orig, *sdup, *cp;\n\tchar *host = NULL, *user = NULL;\n\tint ret = -1, port = -1, first;\n\n\tactive &= o->proxy_command == NULL && o->jump_host == NULL;\n\n\torig = sdup = xstrdup(s);\n\tfirst = active;\n\tdo {\n\t\tif (strcasecmp(s, \"none\") == 0)\n\t\t\tbreak;\n\t\tif ((cp = strrchr(sdup, ',')) == NULL)\n\t\t\tcp = sdup; /* last */\n\t\telse\n\t\t\t*cp++ = '\\0';\n\n\t\tif (first) {\n\t\t\t/* First argument and configuration is active */\n\t\t\tif (parse_ssh_uri(cp, &user, &host, &port) == -1 ||\n\t\t\t    parse_user_host_port(cp, &user, &host, &port) != 0)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\t/* Subsequent argument or inactive configuration */\n\t\t\tif (parse_ssh_uri(cp, NULL, NULL, NULL) == -1 ||\n\t\t\t    parse_user_host_port(cp, NULL, NULL, NULL) != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tfirst = 0; /* only check syntax for subsequent hosts */\n\t} while (cp != sdup);\n\t/* success */\n\tif (active) {\n\t\tif (strcasecmp(s, \"none\") == 0) {\n\t\t\to->jump_host = xstrdup(\"none\");\n\t\t\to->jump_port = 0;\n\t\t} else {\n\t\t\to->jump_user = user;\n\t\t\to->jump_host = host;\n\t\t\to->jump_port = port;\n\t\t\to->proxy_command = xstrdup(\"none\");\n\t\t\tuser = host = NULL;\n\t\t\tif ((cp = strrchr(s, ',')) != NULL && cp != s) {\n\t\t\t\to->jump_extra = xstrdup(s);\n\t\t\t\to->jump_extra[cp - s] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\n out:\n\tfree(orig);\n\tfree(user);\n\tfree(host);\n\treturn ret;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_jump(const char *s, Options *o, int active)\n{\n\tchar *orig, *sdup, *cp;\n\tchar *host = NULL, *user = NULL;\n\tint ret = -1, port = -1, first;\n\n\tactive &= o->proxy_command == NULL && o->jump_host == NULL;\n\n\torig = sdup = xstrdup(s);\n\tfirst = active;\n\tdo {\n\t\tif (strcasecmp(s, \"none\") == 0)\n\t\t\tbreak;\n\t\tif ((cp = strrchr(sdup, ',')) == NULL)\n\t\t\tcp = sdup; /* last */\n\t\telse\n\t\t\t*cp++ = '\\0';\n\n\t\tif (first) {\n\t\t\t/* First argument and configuration is active */\n\t\t\tif (parse_ssh_uri(cp, &user, &host, &port) == -1 ||\n\t\t\t    parse_user_host_port(cp, &user, &host, &port) != 0)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\t/* Subsequent argument or inactive configuration */\n\t\t\tif (parse_ssh_uri(cp, NULL, NULL, NULL) == -1 ||\n\t\t\t    parse_user_host_port(cp, NULL, NULL, NULL) != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tfirst = 0; /* only check syntax for subsequent hosts */\n\t} while (cp != sdup);\n\t/* success */\n\tif (active) {\n\t\tif (strcasecmp(s, \"none\") == 0) {\n\t\t\to->jump_host = xstrdup(\"none\");\n\t\t\to->jump_port = 0;\n\t\t} else {\n\t\t\to->jump_user = user;\n\t\t\to->jump_host = host;\n\t\t\to->jump_port = port;\n\t\t\to->proxy_command = xstrdup(\"none\");\n\t\t\tuser = host = NULL;\n\t\t\tif ((cp = strrchr(s, ',')) != NULL && cp != s) {\n\t\t\t\to->jump_extra = xstrdup(s);\n\t\t\t\to->jump_extra[cp - s] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\n out:\n\tfree(orig);\n\tfree(user);\n\tfree(host);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "s",
            "WHITESPACE \"=\""
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "s",
            "WHITESPACE \"=\""
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_certificate_file",
          "args": [
            "options",
            "arg",
            "flags & SSHCONF_USERCONF"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "add_certificate_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "406-428",
          "snippet": "void\nadd_certificate_file(Options *options, const char *path, int userprovided)\n{\n\tint i;\n\n\tif (options->num_certificate_files >= SSH_MAX_CERTIFICATE_FILES)\n\t\tfatal(\"Too many certificate files specified (max %d)\",\n\t\t    SSH_MAX_CERTIFICATE_FILES);\n\n\t/* Avoid registering duplicates */\n\tfor (i = 0; i < options->num_certificate_files; i++) {\n\t\tif (options->certificate_file_userprovided[i] == userprovided &&\n\t\t    strcmp(options->certificate_files[i], path) == 0) {\n\t\t\tdebug2(\"%s: ignoring duplicate key %s\", __func__, path);\n\t\t\treturn;\n\t\t}\n\t}\n\n\toptions->certificate_file_userprovided[options->num_certificate_files] =\n\t    userprovided;\n\toptions->certificate_files[options->num_certificate_files++] =\n\t    xstrdup(path);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nadd_certificate_file(Options *options, const char *path, int userprovided)\n{\n\tint i;\n\n\tif (options->num_certificate_files >= SSH_MAX_CERTIFICATE_FILES)\n\t\tfatal(\"Too many certificate files specified (max %d)\",\n\t\t    SSH_MAX_CERTIFICATE_FILES);\n\n\t/* Avoid registering duplicates */\n\tfor (i = 0; i < options->num_certificate_files; i++) {\n\t\tif (options->certificate_file_userprovided[i] == userprovided &&\n\t\t    strcmp(options->certificate_files[i], path) == 0) {\n\t\t\tdebug2(\"%s: ignoring duplicate key %s\", __func__, path);\n\t\t\treturn;\n\t\t}\n\t}\n\n\toptions->certificate_file_userprovided[options->num_certificate_files] =\n\t    userprovided;\n\toptions->certificate_files[options->num_certificate_files++] =\n\t    xstrdup(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_identity_file",
          "args": [
            "options",
            "NULL",
            "arg",
            "flags & SSHCONF_USERCONF"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "add_identity_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "430-459",
          "snippet": "void\nadd_identity_file(Options *options, const char *dir, const char *filename,\n    int userprovided)\n{\n\tchar *path;\n\tint i;\n\n\tif (options->num_identity_files >= SSH_MAX_IDENTITY_FILES)\n\t\tfatal(\"Too many identity files specified (max %d)\",\n\t\t    SSH_MAX_IDENTITY_FILES);\n\n\tif (dir == NULL) /* no dir, filename is absolute */\n\t\tpath = xstrdup(filename);\n\telse if (xasprintf(&path, \"%s%s\", dir, filename) >= PATH_MAX)\n\t\tfatal(\"Identity file path %s too long\", path);\n\n\t/* Avoid registering duplicates */\n\tfor (i = 0; i < options->num_identity_files; i++) {\n\t\tif (options->identity_file_userprovided[i] == userprovided &&\n\t\t    strcmp(options->identity_files[i], path) == 0) {\n\t\t\tdebug2(\"%s: ignoring duplicate key %s\", __func__, path);\n\t\t\tfree(path);\n\t\t\treturn;\n\t\t}\n\t}\n\n\toptions->identity_file_userprovided[options->num_identity_files] =\n\t    userprovided;\n\toptions->identity_files[options->num_identity_files++] = path;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nadd_identity_file(Options *options, const char *dir, const char *filename,\n    int userprovided)\n{\n\tchar *path;\n\tint i;\n\n\tif (options->num_identity_files >= SSH_MAX_IDENTITY_FILES)\n\t\tfatal(\"Too many identity files specified (max %d)\",\n\t\t    SSH_MAX_IDENTITY_FILES);\n\n\tif (dir == NULL) /* no dir, filename is absolute */\n\t\tpath = xstrdup(filename);\n\telse if (xasprintf(&path, \"%s%s\", dir, filename) >= PATH_MAX)\n\t\tfatal(\"Identity file path %s too long\", path);\n\n\t/* Avoid registering duplicates */\n\tfor (i = 0; i < options->num_identity_files; i++) {\n\t\tif (options->identity_file_userprovided[i] == userprovided &&\n\t\t    strcmp(options->identity_files[i], path) == 0) {\n\t\t\tdebug2(\"%s: ignoring duplicate key %s\", __func__, path);\n\t\t\tfree(path);\n\t\t\treturn;\n\t\t}\n\t}\n\n\toptions->identity_file_userprovided[options->num_identity_files] =\n\t    userprovided;\n\toptions->identity_files[options->num_identity_files++] = path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scan_scaled",
          "args": [
            "arg",
            "&val64"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "scan_scaled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fmt_scaled.c",
          "lines": "75-212",
          "snippet": "int\nscan_scaled(char *scaled, long long *result)\n{\n\tchar *p = scaled;\n\tint sign = 0;\n\tunsigned int i, ndigits = 0, fract_digits = 0;\n\tlong long scale_fact = 1, whole = 0, fpart = 0;\n\n\t/* Skip leading whitespace */\n\twhile (isascii((unsigned char)*p) && isspace((unsigned char)*p))\n\t\t++p;\n\n\t/* Then at most one leading + or - */\n\twhile (*p == '-' || *p == '+') {\n\t\tif (*p == '-') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = -1;\n\t\t\t++p;\n\t\t} else if (*p == '+') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = +1;\n\t\t\t++p;\n\t\t}\n\t}\n\n\t/* Main loop: Scan digits, find decimal point, if present.\n\t * We don't allow exponentials, so no scientific notation\n\t * (but note that E for Exa might look like e to some!).\n\t * Advance 'p' to end, to get scale factor.\n\t */\n\tfor (; isascii((unsigned char)*p) &&\n\t    (isdigit((unsigned char)*p) || *p=='.'); ++p) {\n\t\tif (*p == '.') {\n\t\t\tif (fract_digits > 0) {\t/* oops, more than one '.' */\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfract_digits = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\ti = (*p) - '0';\t\t\t/* whew! finally a digit we can use */\n\t\tif (fract_digits > 0) {\n\t\t\tif (fract_digits >= MAX_DIGITS-1)\n\t\t\t\t/* ignore extra fractional digits */\n\t\t\t\tcontinue;\n\t\t\tfract_digits++;\t\t/* for later scaling */\n\t\t\tif (fpart > LLONG_MAX / 10) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfpart *= 10;\n\t\t\tif (i > LLONG_MAX - fpart) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfpart += i;\n\t\t} else {\t\t\t\t/* normal digit */\n\t\t\tif (++ndigits >= MAX_DIGITS) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (whole > LLONG_MAX / 10) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole *= 10;\n\t\t\tif (i > LLONG_MAX - whole) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole += i;\n\t\t}\n\t}\n\n\tif (sign) {\n\t\twhole *= sign;\n\t\tfpart *= sign;\n\t}\n\n\t/* If no scale factor given, we're done. fraction is discarded. */\n\tif (!*p) {\n\t\t*result = whole;\n\t\treturn 0;\n\t}\n\n\t/* Validate scale factor, and scale whole and fraction by it. */\n\tfor (i = 0; i < SCALE_LENGTH; i++) {\n\n\t\t/* Are we there yet? */\n\t\tif (*p == scale_chars[i] ||\n\t\t\t*p == tolower((unsigned char)scale_chars[i])) {\n\n\t\t\t/* If it ends with alphanumerics after the scale char, bad. */\n\t\t\tif (isalnum((unsigned char)*(p+1))) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tscale_fact = scale_factors[i];\n\n\t\t\t/* check for overflow and underflow after scaling */\n\t\t\tif (whole > LLONG_MAX / scale_fact ||\n\t\t\t    whole < LLONG_MIN / scale_fact) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* scale whole part */\n\t\t\twhole *= scale_fact;\n\n\t\t\t/* truncate fpart so it doesn't overflow.\n\t\t\t * then scale fractional part.\n\t\t\t */\n\t\t\twhile (fpart >= LLONG_MAX / scale_fact) {\n\t\t\t\tfpart /= 10;\n\t\t\t\tfract_digits--;\n\t\t\t}\n\t\t\tfpart *= scale_fact;\n\t\t\tif (fract_digits > 0) {\n\t\t\t\tfor (i = 0; i < fract_digits -1; i++)\n\t\t\t\t\tfpart /= 10;\n\t\t\t}\n\t\t\twhole += fpart;\n\t\t\t*result = whole;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Invalid unit or character */\n\terrno = EINVAL;\n\treturn -1;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_DIGITS (SCALE_LENGTH * 3)\t/* XXX strlen(sprintf(\"%lld\", -1)? */",
            "#define\tSCALE_LENGTH (sizeof(units)/sizeof(units[0]))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"includes.h\"\n\n#define MAX_DIGITS (SCALE_LENGTH * 3)\t/* XXX strlen(sprintf(\"%lld\", -1)? */\n#define\tSCALE_LENGTH (sizeof(units)/sizeof(units[0]))\n\nint\nscan_scaled(char *scaled, long long *result)\n{\n\tchar *p = scaled;\n\tint sign = 0;\n\tunsigned int i, ndigits = 0, fract_digits = 0;\n\tlong long scale_fact = 1, whole = 0, fpart = 0;\n\n\t/* Skip leading whitespace */\n\twhile (isascii((unsigned char)*p) && isspace((unsigned char)*p))\n\t\t++p;\n\n\t/* Then at most one leading + or - */\n\twhile (*p == '-' || *p == '+') {\n\t\tif (*p == '-') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = -1;\n\t\t\t++p;\n\t\t} else if (*p == '+') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = +1;\n\t\t\t++p;\n\t\t}\n\t}\n\n\t/* Main loop: Scan digits, find decimal point, if present.\n\t * We don't allow exponentials, so no scientific notation\n\t * (but note that E for Exa might look like e to some!).\n\t * Advance 'p' to end, to get scale factor.\n\t */\n\tfor (; isascii((unsigned char)*p) &&\n\t    (isdigit((unsigned char)*p) || *p=='.'); ++p) {\n\t\tif (*p == '.') {\n\t\t\tif (fract_digits > 0) {\t/* oops, more than one '.' */\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfract_digits = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\ti = (*p) - '0';\t\t\t/* whew! finally a digit we can use */\n\t\tif (fract_digits > 0) {\n\t\t\tif (fract_digits >= MAX_DIGITS-1)\n\t\t\t\t/* ignore extra fractional digits */\n\t\t\t\tcontinue;\n\t\t\tfract_digits++;\t\t/* for later scaling */\n\t\t\tif (fpart > LLONG_MAX / 10) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfpart *= 10;\n\t\t\tif (i > LLONG_MAX - fpart) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfpart += i;\n\t\t} else {\t\t\t\t/* normal digit */\n\t\t\tif (++ndigits >= MAX_DIGITS) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (whole > LLONG_MAX / 10) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole *= 10;\n\t\t\tif (i > LLONG_MAX - whole) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole += i;\n\t\t}\n\t}\n\n\tif (sign) {\n\t\twhole *= sign;\n\t\tfpart *= sign;\n\t}\n\n\t/* If no scale factor given, we're done. fraction is discarded. */\n\tif (!*p) {\n\t\t*result = whole;\n\t\treturn 0;\n\t}\n\n\t/* Validate scale factor, and scale whole and fraction by it. */\n\tfor (i = 0; i < SCALE_LENGTH; i++) {\n\n\t\t/* Are we there yet? */\n\t\tif (*p == scale_chars[i] ||\n\t\t\t*p == tolower((unsigned char)scale_chars[i])) {\n\n\t\t\t/* If it ends with alphanumerics after the scale char, bad. */\n\t\t\tif (isalnum((unsigned char)*(p+1))) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tscale_fact = scale_factors[i];\n\n\t\t\t/* check for overflow and underflow after scaling */\n\t\t\tif (whole > LLONG_MAX / scale_fact ||\n\t\t\t    whole < LLONG_MIN / scale_fact) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* scale whole part */\n\t\t\twhole *= scale_fact;\n\n\t\t\t/* truncate fpart so it doesn't overflow.\n\t\t\t * then scale fractional part.\n\t\t\t */\n\t\t\twhile (fpart >= LLONG_MAX / scale_fact) {\n\t\t\t\tfpart /= 10;\n\t\t\t\tfract_digits--;\n\t\t\t}\n\t\t\tfpart *= scale_fact;\n\t\t\tif (fract_digits > 0) {\n\t\t\t\tfor (i = 0; i < fract_digits -1; i++)\n\t\t\t\t\tfpart /= 10;\n\t\t\t}\n\t\t\twhole += fpart;\n\t\t\t*result = whole;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Invalid unit or character */\n\terrno = EINVAL;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "arg",
            "multistate_ptr[i].key"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_token",
          "args": [
            "keyword",
            "filename",
            "linenum",
            "options->ignored_unknown"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "parse_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "718-733",
          "snippet": "static OpCodes\nparse_token(const char *cp, const char *filename, int linenum,\n    const char *ignored_unknown)\n{\n\tint i;\n\n\tfor (i = 0; keywords[i].name; i++)\n\t\tif (strcmp(cp, keywords[i].name) == 0)\n\t\t\treturn keywords[i].opcode;\n\tif (ignored_unknown != NULL &&\n\t    match_pattern_list(cp, ignored_unknown, 1) == 1)\n\t\treturn oIgnoredUnknownOption;\n\terror(\"%s: line %d: Bad configuration option: %s\",\n\t    filename, linenum, cp);\n\treturn oBadOption;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t/* Deprecated options */\n\t{ \"protocol\", oIgnore }, /* NB. silently ignored */\n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t/* Unsupported options */\n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\n\t/* Sometimes-unsupported options */\n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"smartcarddevice\", oPKCS11Provider },\n\t{ \"pkcs11provider\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t    /* alias */\n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"challengeresponseauthentication\", oChallengeResponseAuthentication },\n\t{ \"skeyauthentication\", oUnsupported },\n\t{ \"tisauthentication\", oChallengeResponseAuthentication },  /* alias */\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t/* obsolete */\n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostName },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t/* obsolete */\n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedkeytypes\", oHostbasedKeyTypes },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedKeyTypes },\n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\n\t{ NULL, oBadOption }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t/* Deprecated options */\n\t{ \"protocol\", oIgnore }, /* NB. silently ignored */\n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t/* Unsupported options */\n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\n\t/* Sometimes-unsupported options */\n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"smartcarddevice\", oPKCS11Provider },\n\t{ \"pkcs11provider\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t    /* alias */\n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"challengeresponseauthentication\", oChallengeResponseAuthentication },\n\t{ \"skeyauthentication\", oUnsupported },\n\t{ \"tisauthentication\", oChallengeResponseAuthentication },  /* alias */\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t/* obsolete */\n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostName },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t/* obsolete */\n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedkeytypes\", oHostbasedKeyTypes },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedKeyTypes },\n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\n\t{ NULL, oBadOption }\n};\n\nstatic OpCodes\nparse_token(const char *cp, const char *filename, int linenum,\n    const char *ignored_unknown)\n{\n\tint i;\n\n\tfor (i = 0; keywords[i].name; i++)\n\t\tif (strcmp(cp, keywords[i].name) == 0)\n\t\t\treturn keywords[i].opcode;\n\tif (ignored_unknown != NULL &&\n\t    match_pattern_list(cp, ignored_unknown, 1) == 1)\n\t\treturn oIgnoredUnknownOption;\n\terror(\"%s: line %d: Bad configuration option: %s\",\n\t    filename, linenum, cp);\n\treturn oBadOption;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define WHITESPACE \" \\t\\r\\n\"\n\nstatic int read_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int depth);\nstatic int process_config_line_depth(Options *options, struct passwd *pw,\n    const char *host, const char *original_host, char *line,\n    const char *filename, int linenum, int *activep, int flags, int depth);\nstatic const struct multistate multistate_flag[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_yesnoask[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_strict_hostkey[] = {\n\t{ \"true\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"false\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"yes\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"no\",\t\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"ask\",\t\t\tSSH_STRICT_HOSTKEY_ASK },\n\t{ \"off\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"accept-new\",\t\t\tSSH_STRICT_HOSTKEY_NEW },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_yesnoaskconfirm[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ \"confirm\",\t\t\t3 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_controlmaster[] = {\n\t{ \"true\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"yes\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"false\",\t\t\tSSHCTL_MASTER_NO },\n\t{ \"no\",\t\t\t\tSSHCTL_MASTER_NO },\n\t{ \"auto\",\t\t\tSSHCTL_MASTER_AUTO },\n\t{ \"ask\",\t\t\tSSHCTL_MASTER_ASK },\n\t{ \"autoask\",\t\t\tSSHCTL_MASTER_AUTO_ASK },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_tunnel[] = {\n\t{ \"ethernet\",\t\t\tSSH_TUNMODE_ETHERNET },\n\t{ \"point-to-point\",\t\tSSH_TUNMODE_POINTOPOINT },\n\t{ \"true\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"yes\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"false\",\t\t\tSSH_TUNMODE_NO },\n\t{ \"no\",\t\t\t\tSSH_TUNMODE_NO },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_requesttty[] = {\n\t{ \"true\",\t\t\tREQUEST_TTY_YES },\n\t{ \"yes\",\t\t\tREQUEST_TTY_YES },\n\t{ \"false\",\t\t\tREQUEST_TTY_NO },\n\t{ \"no\",\t\t\t\tREQUEST_TTY_NO },\n\t{ \"force\",\t\t\tREQUEST_TTY_FORCE },\n\t{ \"auto\",\t\t\tREQUEST_TTY_AUTO },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_canonicalizehostname[] = {\n\t{ \"true\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"false\",\t\t\tSSH_CANONICALISE_NO },\n\t{ \"yes\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"no\",\t\t\t\tSSH_CANONICALISE_NO },\n\t{ \"always\",\t\t\tSSH_CANONICALISE_ALWAYS },\n\t{ NULL, -1 }\n};\n\nstatic int\nprocess_config_line_depth(Options *options, struct passwd *pw, const char *host,\n    const char *original_host, char *line, const char *filename,\n    int linenum, int *activep, int flags, int depth)\n{\n\tchar *s, **charptr, *endofnumber, *keyword, *arg, *arg2;\n\tchar **cpptr, fwdarg[256];\n\tu_int i, *uintptr, max_entries = 0;\n\tint r, oactive, negated, opcode, *intptr, value, value2, cmdline = 0;\n\tint remotefwd, dynamicfwd;\n\tLogLevel *log_level_ptr;\n\tSyslogFacility *log_facility_ptr;\n\tlong long val64;\n\tsize_t len;\n\tstruct Forward fwd;\n\tconst struct multistate *multistate_ptr;\n\tstruct allowed_cname *cname;\n\tglob_t gl;\n\tconst char *errstr;\n\n\tif (activep == NULL) { /* We are processing a command line directive */\n\t\tcmdline = 1;\n\t\tactivep = &cmdline;\n\t}\n\n\t/* Strip trailing whitespace. Allow \\f (form feed) at EOL only */\n\tif ((len = strlen(line)) == 0)\n\t\treturn 0;\n\tfor (len--; len > 0; len--) {\n\t\tif (strchr(WHITESPACE \"\\f\", line[len]) == NULL)\n\t\t\tbreak;\n\t\tline[len] = '\\0';\n\t}\n\n\ts = line;\n\t/* Get the keyword. (Each line is supposed to begin with a keyword). */\n\tif ((keyword = strdelim(&s)) == NULL)\n\t\treturn 0;\n\t/* Ignore leading whitespace. */\n\tif (*keyword == '\\0')\n\t\tkeyword = strdelim(&s);\n\tif (keyword == NULL || !*keyword || *keyword == '\\n' || *keyword == '#')\n\t\treturn 0;\n\t/* Match lowercase keyword */\n\tlowercase(keyword);\n\n\topcode = parse_token(keyword, filename, linenum,\n\t    options->ignored_unknown);\n\n\tswitch (opcode) {\n\tcase oBadOption:\n\t\t/* don't panic, but count bad options */\n\t\treturn -1;\n\tcase oIgnore:\n\t\treturn 0;\n\tcase oIgnoredUnknownOption:\n\t\tdebug(\"%s line %d: Ignored unknown option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn 0;\n\tcase oConnectTimeout:\n\t\tintptr = &options->connection_timeout;\nparse_time:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing time value.\",\n\t\t\t    filename, linenum);\n\t\tif (strcmp(arg, \"none\") == 0)\n\t\t\tvalue = -1;\n\t\telse if ((value = convtime(arg)) == -1)\n\t\t\tfatal(\"%s line %d: invalid time value.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oForwardAgent:\n\t\tintptr = &options->forward_agent;\n parse_flag:\n\t\tmultistate_ptr = multistate_flag;\n parse_multistate:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; multistate_ptr[i].key != NULL; i++) {\n\t\t\tif (strcasecmp(arg, multistate_ptr[i].key) == 0) {\n\t\t\t\tvalue = multistate_ptr[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: unsupported option \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oForwardX11:\n\t\tintptr = &options->forward_x11;\n\t\tgoto parse_flag;\n\n\tcase oForwardX11Trusted:\n\t\tintptr = &options->forward_x11_trusted;\n\t\tgoto parse_flag;\n\n\tcase oForwardX11Timeout:\n\t\tintptr = &options->forward_x11_timeout;\n\t\tgoto parse_time;\n\n\tcase oGatewayPorts:\n\t\tintptr = &options->fwd_opts.gateway_ports;\n\t\tgoto parse_flag;\n\n\tcase oExitOnForwardFailure:\n\t\tintptr = &options->exit_on_forward_failure;\n\t\tgoto parse_flag;\n\n\tcase oPasswordAuthentication:\n\t\tintptr = &options->password_authentication;\n\t\tgoto parse_flag;\n\n\tcase oKbdInteractiveAuthentication:\n\t\tintptr = &options->kbd_interactive_authentication;\n\t\tgoto parse_flag;\n\n\tcase oKbdInteractiveDevices:\n\t\tcharptr = &options->kbd_interactive_devices;\n\t\tgoto parse_string;\n\n\tcase oPubkeyAuthentication:\n\t\tintptr = &options->pubkey_authentication;\n\t\tgoto parse_flag;\n\n\tcase oHostbasedAuthentication:\n\t\tintptr = &options->hostbased_authentication;\n\t\tgoto parse_flag;\n\n\tcase oChallengeResponseAuthentication:\n\t\tintptr = &options->challenge_response_authentication;\n\t\tgoto parse_flag;\n\n\tcase oGssAuthentication:\n\t\tintptr = &options->gss_authentication;\n\t\tgoto parse_flag;\n\n\tcase oGssDelegateCreds:\n\t\tintptr = &options->gss_deleg_creds;\n\t\tgoto parse_flag;\n\n\tcase oBatchMode:\n\t\tintptr = &options->batch_mode;\n\t\tgoto parse_flag;\n\n\tcase oCheckHostIP:\n\t\tintptr = &options->check_host_ip;\n\t\tgoto parse_flag;\n\n\tcase oVerifyHostKeyDNS:\n\t\tintptr = &options->verify_host_key_dns;\n\t\tmultistate_ptr = multistate_yesnoask;\n\t\tgoto parse_multistate;\n\n\tcase oStrictHostKeyChecking:\n\t\tintptr = &options->strict_host_key_checking;\n\t\tmultistate_ptr = multistate_strict_hostkey;\n\t\tgoto parse_multistate;\n\n\tcase oCompression:\n\t\tintptr = &options->compression;\n\t\tgoto parse_flag;\n\n\tcase oTCPKeepAlive:\n\t\tintptr = &options->tcp_keep_alive;\n\t\tgoto parse_flag;\n\n\tcase oNoHostAuthenticationForLocalhost:\n\t\tintptr = &options->no_host_authentication_for_localhost;\n\t\tgoto parse_flag;\n\n\tcase oNumberOfPasswordPrompts:\n\t\tintptr = &options->number_of_password_prompts;\n\t\tgoto parse_int;\n\n\tcase oRekeyLimit:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tif (strcmp(arg, \"default\") == 0) {\n\t\t\tval64 = 0;\n\t\t} else {\n\t\t\tif (scan_scaled(arg, &val64) == -1)\n\t\t\t\tfatal(\"%.200s line %d: Bad number '%s': %s\",\n\t\t\t\t    filename, linenum, arg, strerror(errno));\n\t\t\tif (val64 != 0 && val64 < 16)\n\t\t\t\tfatal(\"%.200s line %d: RekeyLimit too small\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\tif (*activep && options->rekey_limit == -1)\n\t\t\toptions->rekey_limit = val64;\n\t\tif (s != NULL) { /* optional rekey interval present */\n\t\t\tif (strcmp(s, \"none\") == 0) {\n\t\t\t\t(void)strdelim(&s);\t/* discard */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tintptr = &options->rekey_interval;\n\t\t\tgoto parse_time;\n\t\t}\n\t\tbreak;\n\n\tcase oIdentityFile:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (*activep) {\n\t\t\tintptr = &options->num_identity_files;\n\t\t\tif (*intptr >= SSH_MAX_IDENTITY_FILES)\n\t\t\t\tfatal(\"%.200s line %d: Too many identity files specified (max %d).\",\n\t\t\t\t    filename, linenum, SSH_MAX_IDENTITY_FILES);\n\t\t\tadd_identity_file(options, NULL,\n\t\t\t    arg, flags & SSHCONF_USERCONF);\n\t\t}\n\t\tbreak;\n\n\tcase oCertificateFile:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep) {\n\t\t\tintptr = &options->num_certificate_files;\n\t\t\tif (*intptr >= SSH_MAX_CERTIFICATE_FILES) {\n\t\t\t\tfatal(\"%.200s line %d: Too many certificate \"\n\t\t\t\t    \"files specified (max %d).\",\n\t\t\t\t    filename, linenum,\n\t\t\t\t    SSH_MAX_CERTIFICATE_FILES);\n\t\t\t}\n\t\t\tadd_certificate_file(options, arg,\n\t\t\t    flags & SSHCONF_USERCONF);\n\t\t}\n\t\tbreak;\n\n\tcase oXAuthLocation:\n\t\tcharptr=&options->xauth_location;\n\t\tgoto parse_string;\n\n\tcase oUser:\n\t\tcharptr = &options->user;\nparse_string:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oGlobalKnownHostsFile:\n\t\tcpptr = (char **)&options->system_hostfiles;\n\t\tuintptr = &options->num_system_hostfiles;\n\t\tmax_entries = SSH_MAX_HOSTS_FILES;\nparse_char_array:\n\t\tif (*activep && *uintptr == 0) {\n\t\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\t\tif ((*uintptr) >= max_entries)\n\t\t\t\t\tfatal(\"%s line %d: \"\n\t\t\t\t\t    \"too many authorized keys files.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\tcpptr[(*uintptr)++] = xstrdup(arg);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase oUserKnownHostsFile:\n\t\tcpptr = (char **)&options->user_hostfiles;\n\t\tuintptr = &options->num_user_hostfiles;\n\t\tmax_entries = SSH_MAX_HOSTS_FILES;\n\t\tgoto parse_char_array;\n\n\tcase oHostName:\n\t\tcharptr = &options->hostname;\n\t\tgoto parse_string;\n\n\tcase oHostKeyAlias:\n\t\tcharptr = &options->host_key_alias;\n\t\tgoto parse_string;\n\n\tcase oPreferredAuthentications:\n\t\tcharptr = &options->preferred_authentications;\n\t\tgoto parse_string;\n\n\tcase oBindAddress:\n\t\tcharptr = &options->bind_address;\n\t\tgoto parse_string;\n\n\tcase oBindInterface:\n\t\tcharptr = &options->bind_interface;\n\t\tgoto parse_string;\n\n\tcase oPKCS11Provider:\n\t\tcharptr = &options->pkcs11_provider;\n\t\tgoto parse_string;\n\n\tcase oProxyCommand:\n\t\tcharptr = &options->proxy_command;\n\t\t/* Ignore ProxyCommand if ProxyJump already specified */\n\t\tif (options->jump_host != NULL)\n\t\t\tcharptr = &options->jump_host; /* Skip below */\nparse_command:\n\t\tif (s == NULL)\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tlen = strspn(s, WHITESPACE \"=\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(s + len);\n\t\treturn 0;\n\n\tcase oProxyJump:\n\t\tif (s == NULL) {\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t}\n\t\tlen = strspn(s, WHITESPACE \"=\");\n\t\tif (parse_jump(s + len, options, *activep) == -1) {\n\t\t\tfatal(\"%.200s line %d: Invalid ProxyJump \\\"%s\\\"\",\n\t\t\t    filename, linenum, s + len);\n\t\t}\n\t\treturn 0;\n\n\tcase oPort:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = a2port(arg);\n\t\tif (value <= 0)\n\t\t\tfatal(\"%.200s line %d: Bad port '%s'.\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && options->port == -1)\n\t\t\toptions->port = value;\n\t\tbreak;\n\n\tcase oConnectionAttempts:\n\t\tintptr = &options->connection_attempts;\nparse_int:\n\t\targ = strdelim(&s);\n\t\tif ((errstr = atoi_err(arg, &value)) != NULL)\n\t\t\tfatal(\"%s line %d: integer value %s.\",\n\t\t\t    filename, linenum, errstr);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oCiphers:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !ciphers_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%.200s line %d: Bad SSH2 cipher spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && options->ciphers == NULL)\n\t\t\toptions->ciphers = xstrdup(arg);\n\t\tbreak;\n\n\tcase oMacs:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !mac_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%.200s line %d: Bad SSH2 Mac spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && options->macs == NULL)\n\t\t\toptions->macs = xstrdup(arg);\n\t\tbreak;\n\n\tcase oKexAlgorithms:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !kex_names_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%.200s line %d: Bad SSH2 KexAlgorithms '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && options->kex_algorithms == NULL)\n\t\t\toptions->kex_algorithms = xstrdup(arg);\n\t\tbreak;\n\n\tcase oHostKeyAlgorithms:\n\t\tcharptr = &options->hostkeyalgorithms;\nparse_keytypes:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !sshkey_names_valid2(*arg == '+' ? arg + 1 : arg, 1))\n\t\t\tfatal(\"%s line %d: Bad key types '%s'.\",\n\t\t\t\tfilename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oCASignatureAlgorithms:\n\t\tcharptr = &options->ca_sign_algorithms;\n\t\tgoto parse_keytypes;\n\n\tcase oLogLevel:\n\t\tlog_level_ptr = &options->log_level;\n\t\targ = strdelim(&s);\n\t\tvalue = log_level_number(arg);\n\t\tif (value == SYSLOG_LEVEL_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log level '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *log_level_ptr == SYSLOG_LEVEL_NOT_SET)\n\t\t\t*log_level_ptr = (LogLevel) value;\n\t\tbreak;\n\n\tcase oLogFacility:\n\t\tlog_facility_ptr = &options->log_facility;\n\t\targ = strdelim(&s);\n\t\tvalue = log_facility_number(arg);\n\t\tif (value == SYSLOG_FACILITY_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log facility '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*log_facility_ptr == -1)\n\t\t\t*log_facility_ptr = (SyslogFacility) value;\n\t\tbreak;\n\n\tcase oLocalForward:\n\tcase oRemoteForward:\n\tcase oDynamicForward:\n\t\targ = strdelim(&s);\n\t\tif (arg == NULL || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing port argument.\",\n\t\t\t    filename, linenum);\n\n\t\tremotefwd = (opcode == oRemoteForward);\n\t\tdynamicfwd = (opcode == oDynamicForward);\n\n\t\tif (!dynamicfwd) {\n\t\t\targ2 = strdelim(&s);\n\t\t\tif (arg2 == NULL || *arg2 == '\\0') {\n\t\t\t\tif (remotefwd)\n\t\t\t\t\tdynamicfwd = 1;\n\t\t\t\telse\n\t\t\t\t\tfatal(\"%.200s line %d: Missing target \"\n\t\t\t\t\t    \"argument.\", filename, linenum);\n\t\t\t} else {\n\t\t\t\t/* construct a string for parse_forward */\n\t\t\t\tsnprintf(fwdarg, sizeof(fwdarg), \"%s:%s\", arg,\n\t\t\t\t    arg2);\n\t\t\t}\n\t\t}\n\t\tif (dynamicfwd)\n\t\t\tstrlcpy(fwdarg, arg, sizeof(fwdarg));\n\n\t\tif (parse_forward(&fwd, fwdarg, dynamicfwd, remotefwd) == 0)\n\t\t\tfatal(\"%.200s line %d: Bad forwarding specification.\",\n\t\t\t    filename, linenum);\n\n\t\tif (*activep) {\n\t\t\tif (remotefwd) {\n\t\t\t\tadd_remote_forward(options, &fwd);\n\t\t\t} else {\n\t\t\t\tadd_local_forward(options, &fwd);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase oClearAllForwardings:\n\t\tintptr = &options->clear_forwardings;\n\t\tgoto parse_flag;\n\n\tcase oHost:\n\t\tif (cmdline)\n\t\t\tfatal(\"Host directive not supported as a command-line \"\n\t\t\t    \"option\");\n\t\t*activep = 0;\n\t\targ2 = NULL;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\tif ((flags & SSHCONF_NEVERMATCH) != 0)\n\t\t\t\tbreak;\n\t\t\tnegated = *arg == '!';\n\t\t\tif (negated)\n\t\t\t\targ++;\n\t\t\tif (match_pattern(host, arg)) {\n\t\t\t\tif (negated) {\n\t\t\t\t\tdebug(\"%.200s line %d: Skipping Host \"\n\t\t\t\t\t    \"block because of negated match \"\n\t\t\t\t\t    \"for %.100s\", filename, linenum,\n\t\t\t\t\t    arg);\n\t\t\t\t\t*activep = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!*activep)\n\t\t\t\t\targ2 = arg; /* logged below */\n\t\t\t\t*activep = 1;\n\t\t\t}\n\t\t}\n\t\tif (*activep)\n\t\t\tdebug(\"%.200s line %d: Applying options for %.100s\",\n\t\t\t    filename, linenum, arg2);\n\t\t/* Avoid garbage check below, as strdelim is done. */\n\t\treturn 0;\n\n\tcase oMatch:\n\t\tif (cmdline)\n\t\t\tfatal(\"Host directive not supported as a command-line \"\n\t\t\t    \"option\");\n\t\tvalue = match_cfg_line(options, &s, pw, host, original_host,\n\t\t    flags & SSHCONF_POSTCANON, filename, linenum);\n\t\tif (value < 0)\n\t\t\tfatal(\"%.200s line %d: Bad Match condition\", filename,\n\t\t\t    linenum);\n\t\t*activep = (flags & SSHCONF_NEVERMATCH) ? 0 : value;\n\t\tbreak;\n\n\tcase oEscapeChar:\n\t\tintptr = &options->escape_char;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (strcmp(arg, \"none\") == 0)\n\t\t\tvalue = SSH_ESCAPECHAR_NONE;\n\t\telse if (arg[1] == '\\0')\n\t\t\tvalue = (u_char) arg[0];\n\t\telse if (arg[0] == '^' && arg[2] == 0 &&\n\t\t    (u_char) arg[1] >= 64 && (u_char) arg[1] < 128)\n\t\t\tvalue = (u_char) arg[1] & 31;\n\t\telse {\n\t\t\tfatal(\"%.200s line %d: Bad escape character.\",\n\t\t\t    filename, linenum);\n\t\t\t/* NOTREACHED */\n\t\t\tvalue = 0;\t/* Avoid compiler warning. */\n\t\t}\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oAddressFamily:\n\t\tintptr = &options->address_family;\n\t\tmultistate_ptr = multistate_addressfamily;\n\t\tgoto parse_multistate;\n\n\tcase oEnableSSHKeysign:\n\t\tintptr = &options->enable_ssh_keysign;\n\t\tgoto parse_flag;\n\n\tcase oIdentitiesOnly:\n\t\tintptr = &options->identities_only;\n\t\tgoto parse_flag;\n\n\tcase oServerAliveInterval:\n\t\tintptr = &options->server_alive_interval;\n\t\tgoto parse_time;\n\n\tcase oServerAliveCountMax:\n\t\tintptr = &options->server_alive_count_max;\n\t\tgoto parse_int;\n\n\tcase oSendEnv:\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') != NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment name.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tif (*arg == '-') {\n\t\t\t\t/* Removing an env var */\n\t\t\t\trm_env(options, arg, filename, linenum);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/* Adding an env var */\n\t\t\t\tif (options->num_send_env >= INT_MAX)\n\t\t\t\t\tfatal(\"%s line %d: too many send env.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\toptions->send_env = xrecallocarray(\n\t\t\t\t    options->send_env, options->num_send_env,\n\t\t\t\t    options->num_send_env + 1,\n\t\t\t\t    sizeof(*options->send_env));\n\t\t\t\toptions->send_env[options->num_send_env++] =\n\t\t\t\t    xstrdup(arg);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase oSetEnv:\n\t\tvalue = options->num_setenv;\n\t\twhile ((arg = strdelimw(&s)) != NULL && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') == NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid SetEnv.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep || value != 0)\n\t\t\t\tcontinue;\n\t\t\t/* Adding a setenv var */\n\t\t\tif (options->num_setenv >= INT_MAX)\n\t\t\t\tfatal(\"%s line %d: too many SetEnv.\",\n\t\t\t\t    filename, linenum);\n\t\t\toptions->setenv = xrecallocarray(\n\t\t\t    options->setenv, options->num_setenv,\n\t\t\t    options->num_setenv + 1, sizeof(*options->setenv));\n\t\t\toptions->setenv[options->num_setenv++] = xstrdup(arg);\n\t\t}\n\t\tbreak;\n\n\tcase oControlPath:\n\t\tcharptr = &options->control_path;\n\t\tgoto parse_string;\n\n\tcase oControlMaster:\n\t\tintptr = &options->control_master;\n\t\tmultistate_ptr = multistate_controlmaster;\n\t\tgoto parse_multistate;\n\n\tcase oControlPersist:\n\t\t/* no/false/yes/true, or a time spec */\n\t\tintptr = &options->control_persist;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing ControlPersist\"\n\t\t\t    \" argument.\", filename, linenum);\n\t\tvalue = 0;\n\t\tvalue2 = 0;\t/* timeout */\n\t\tif (strcmp(arg, \"no\") == 0 || strcmp(arg, \"false\") == 0)\n\t\t\tvalue = 0;\n\t\telse if (strcmp(arg, \"yes\") == 0 || strcmp(arg, \"true\") == 0)\n\t\t\tvalue = 1;\n\t\telse if ((value2 = convtime(arg)) >= 0)\n\t\t\tvalue = 1;\n\t\telse\n\t\t\tfatal(\"%.200s line %d: Bad ControlPersist argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1) {\n\t\t\t*intptr = value;\n\t\t\toptions->control_persist_timeout = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oHashKnownHosts:\n\t\tintptr = &options->hash_known_hosts;\n\t\tgoto parse_flag;\n\n\tcase oTunnel:\n\t\tintptr = &options->tun_open;\n\t\tmultistate_ptr = multistate_tunnel;\n\t\tgoto parse_multistate;\n\n\tcase oTunnelDevice:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tvalue = a2tun(arg, &value2);\n\t\tif (value == SSH_TUNID_ERR)\n\t\t\tfatal(\"%.200s line %d: Bad tun device.\", filename, linenum);\n\t\tif (*activep) {\n\t\t\toptions->tun_local = value;\n\t\t\toptions->tun_remote = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oLocalCommand:\n\t\tcharptr = &options->local_command;\n\t\tgoto parse_command;\n\n\tcase oPermitLocalCommand:\n\t\tintptr = &options->permit_local_command;\n\t\tgoto parse_flag;\n\n\tcase oRemoteCommand:\n\t\tcharptr = &options->remote_command;\n\t\tgoto parse_command;\n\n\tcase oVisualHostKey:\n\t\tintptr = &options->visual_host_key;\n\t\tgoto parse_flag;\n\n\tcase oInclude:\n\t\tif (cmdline)\n\t\t\tfatal(\"Include directive not supported as a \"\n\t\t\t    \"command-line option\");\n\t\tvalue = 0;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\t/*\n\t\t\t * Ensure all paths are anchored. User configuration\n\t\t\t * files may begin with '~/' but system configurations\n\t\t\t * must not. If the path is relative, then treat it\n\t\t\t * as living in ~/.ssh for user configurations or\n\t\t\t * /etc/ssh for system ones.\n\t\t\t */\n\t\t\tif (*arg == '~' && (flags & SSHCONF_USERCONF) == 0)\n\t\t\t\tfatal(\"%.200s line %d: bad include path %s.\",\n\t\t\t\t    filename, linenum, arg);\n\t\t\tif (*arg != '/' && *arg != '~') {\n\t\t\t\txasprintf(&arg2, \"%s/%s\",\n\t\t\t\t    (flags & SSHCONF_USERCONF) ?\n\t\t\t\t    \"~/\" _PATH_SSH_USER_DIR : SSHDIR, arg);\n\t\t\t} else\n\t\t\t\targ2 = xstrdup(arg);\n\t\t\tmemset(&gl, 0, sizeof(gl));\n\t\t\tr = glob(arg2, GLOB_TILDE, NULL, &gl);\n\t\t\tif (r == GLOB_NOMATCH) {\n\t\t\t\tdebug(\"%.200s line %d: include %s matched no \"\n\t\t\t\t    \"files\",filename, linenum, arg2);\n\t\t\t\tfree(arg2);\n\t\t\t\tcontinue;\n\t\t\t} else if (r != 0 || gl.gl_pathc < 0)\n\t\t\t\tfatal(\"%.200s line %d: glob failed for %s.\",\n\t\t\t\t    filename, linenum, arg2);\n\t\t\tfree(arg2);\n\t\t\toactive = *activep;\n\t\t\tfor (i = 0; i < (u_int)gl.gl_pathc; i++) {\n\t\t\t\tdebug3(\"%.200s line %d: Including file %s \"\n\t\t\t\t    \"depth %d%s\", filename, linenum,\n\t\t\t\t    gl.gl_pathv[i], depth,\n\t\t\t\t    oactive ? \"\" : \" (parse only)\");\n\t\t\t\tr = read_config_file_depth(gl.gl_pathv[i],\n\t\t\t\t    pw, host, original_host, options,\n\t\t\t\t    flags | SSHCONF_CHECKPERM |\n\t\t\t\t    (oactive ? 0 : SSHCONF_NEVERMATCH),\n\t\t\t\t    activep, depth + 1);\n\t\t\t\tif (r != 1 && errno != ENOENT) {\n\t\t\t\t\tfatal(\"Can't open user config file \"\n\t\t\t\t\t    \"%.100s: %.100s\", gl.gl_pathv[i],\n\t\t\t\t\t    strerror(errno));\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * don't let Match in includes clobber the\n\t\t\t\t * containing file's Match state.\n\t\t\t\t */\n\t\t\t\t*activep = oactive;\n\t\t\t\tif (r != 1)\n\t\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\tglobfree(&gl);\n\t\t}\n\t\tif (value != 0)\n\t\t\treturn value;\n\t\tbreak;\n\n\tcase oIPQoS:\n\t\targ = strdelim(&s);\n\t\tif ((value = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\targ = strdelim(&s);\n\t\tif (arg == NULL)\n\t\t\tvalue2 = value;\n\t\telse if ((value2 = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep) {\n\t\t\toptions->ip_qos_interactive = value;\n\t\t\toptions->ip_qos_bulk = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oRequestTTY:\n\t\tintptr = &options->request_tty;\n\t\tmultistate_ptr = multistate_requesttty;\n\t\tgoto parse_multistate;\n\n\tcase oIgnoreUnknown:\n\t\tcharptr = &options->ignored_unknown;\n\t\tgoto parse_string;\n\n\tcase oProxyUseFdpass:\n\t\tintptr = &options->proxy_use_fdpass;\n\t\tgoto parse_flag;\n\n\tcase oCanonicalDomains:\n\t\tvalue = options->num_canonical_domains != 0;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\tif (!valid_domain(arg, 1, &errstr)) {\n\t\t\t\tfatal(\"%s line %d: %s\", filename, linenum,\n\t\t\t\t    errstr);\n\t\t\t}\n\t\t\tif (!*activep || value)\n\t\t\t\tcontinue;\n\t\t\tif (options->num_canonical_domains >= MAX_CANON_DOMAINS)\n\t\t\t\tfatal(\"%s line %d: too many hostname suffixes.\",\n\t\t\t\t    filename, linenum);\n\t\t\toptions->canonical_domains[\n\t\t\t    options->num_canonical_domains++] = xstrdup(arg);\n\t\t}\n\t\tbreak;\n\n\tcase oCanonicalizePermittedCNAMEs:\n\t\tvalue = options->num_permitted_cnames != 0;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\t/* Either '*' for everything or 'list:list' */\n\t\t\tif (strcmp(arg, \"*\") == 0)\n\t\t\t\targ2 = arg;\n\t\t\telse {\n\t\t\t\tlowercase(arg);\n\t\t\t\tif ((arg2 = strchr(arg, ':')) == NULL ||\n\t\t\t\t    arg2[1] == '\\0') {\n\t\t\t\t\tfatal(\"%s line %d: \"\n\t\t\t\t\t    \"Invalid permitted CNAME \\\"%s\\\"\",\n\t\t\t\t\t    filename, linenum, arg);\n\t\t\t\t}\n\t\t\t\t*arg2 = '\\0';\n\t\t\t\targ2++;\n\t\t\t}\n\t\t\tif (!*activep || value)\n\t\t\t\tcontinue;\n\t\t\tif (options->num_permitted_cnames >= MAX_CANON_DOMAINS)\n\t\t\t\tfatal(\"%s line %d: too many permitted CNAMEs.\",\n\t\t\t\t    filename, linenum);\n\t\t\tcname = options->permitted_cnames +\n\t\t\t    options->num_permitted_cnames++;\n\t\t\tcname->source_list = xstrdup(arg);\n\t\t\tcname->target_list = xstrdup(arg2);\n\t\t}\n\t\tbreak;\n\n\tcase oCanonicalizeHostname:\n\t\tintptr = &options->canonicalize_hostname;\n\t\tmultistate_ptr = multistate_canonicalizehostname;\n\t\tgoto parse_multistate;\n\n\tcase oCanonicalizeMaxDots:\n\t\tintptr = &options->canonicalize_max_dots;\n\t\tgoto parse_int;\n\n\tcase oCanonicalizeFallbackLocal:\n\t\tintptr = &options->canonicalize_fallback_local;\n\t\tgoto parse_flag;\n\n\tcase oStreamLocalBindMask:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing StreamLocalBindMask argument.\", filename, linenum);\n\t\t/* Parse mode in octal format */\n\t\tvalue = strtol(arg, &endofnumber, 8);\n\t\tif (arg == endofnumber || value < 0 || value > 0777)\n\t\t\tfatal(\"%.200s line %d: Bad mask.\", filename, linenum);\n\t\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)value;\n\t\tbreak;\n\n\tcase oStreamLocalBindUnlink:\n\t\tintptr = &options->fwd_opts.streamlocal_bind_unlink;\n\t\tgoto parse_flag;\n\n\tcase oRevokedHostKeys:\n\t\tcharptr = &options->revoked_host_keys;\n\t\tgoto parse_string;\n\n\tcase oFingerprintHash:\n\t\tintptr = &options->fingerprint_hash;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = ssh_digest_alg_by_name(arg)) == -1)\n\t\t\tfatal(\"%.200s line %d: Invalid hash algorithm \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oUpdateHostkeys:\n\t\tintptr = &options->update_hostkeys;\n\t\tmultistate_ptr = multistate_yesnoask;\n\t\tgoto parse_multistate;\n\n\tcase oHostbasedKeyTypes:\n\t\tcharptr = &options->hostbased_key_types;\n\t\tgoto parse_keytypes;\n\n\tcase oPubkeyAcceptedKeyTypes:\n\t\tcharptr = &options->pubkey_key_types;\n\t\tgoto parse_keytypes;\n\n\tcase oAddKeysToAgent:\n\t\tintptr = &options->add_keys_to_agent;\n\t\tmultistate_ptr = multistate_yesnoaskconfirm;\n\t\tgoto parse_multistate;\n\n\tcase oIdentityAgent:\n\t\tcharptr = &options->identity_agent;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t/* Extra validation if the string represents an env var. */\n\t\tif (arg[0] == '$' && !valid_env_name(arg + 1)) {\n\t\t\tfatal(\"%.200s line %d: Invalid environment name %s.\",\n\t\t\t    filename, linenum, arg);\n\t\t}\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oDeprecated:\n\t\tdebug(\"%s line %d: Deprecated option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn 0;\n\n\tcase oUnsupported:\n\t\terror(\"%s line %d: Unsupported option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn 0;\n\n\tdefault:\n\t\tfatal(\"%s: Unimplemented opcode %d\", __func__, opcode);\n\t}\n\n\t/* Check that there is no garbage at end of line. */\n\tif ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\tfatal(\"%.200s line %d: garbage at end of line; \\\"%.200s\\\".\",\n\t\t    filename, linenum, arg);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "process_config_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "821-828",
    "snippet": "int\nprocess_config_line(Options *options, struct passwd *pw, const char *host,\n    const char *original_host, char *line, const char *filename,\n    int linenum, int *activep, int flags)\n{\n\treturn process_config_line_depth(options, pw, host, original_host,\n\t    line, filename, linenum, activep, flags, 0);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_config_line_depth",
          "args": [
            "options",
            "pw",
            "host",
            "original_host",
            "line",
            "filename",
            "linenum",
            "activep",
            "flags",
            "0"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "process_config_line_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "831-1745",
          "snippet": "static int\nprocess_config_line_depth(Options *options, struct passwd *pw, const char *host,\n    const char *original_host, char *line, const char *filename,\n    int linenum, int *activep, int flags, int depth)\n{\n\tchar *s, **charptr, *endofnumber, *keyword, *arg, *arg2;\n\tchar **cpptr, fwdarg[256];\n\tu_int i, *uintptr, max_entries = 0;\n\tint r, oactive, negated, opcode, *intptr, value, value2, cmdline = 0;\n\tint remotefwd, dynamicfwd;\n\tLogLevel *log_level_ptr;\n\tSyslogFacility *log_facility_ptr;\n\tlong long val64;\n\tsize_t len;\n\tstruct Forward fwd;\n\tconst struct multistate *multistate_ptr;\n\tstruct allowed_cname *cname;\n\tglob_t gl;\n\tconst char *errstr;\n\n\tif (activep == NULL) { /* We are processing a command line directive */\n\t\tcmdline = 1;\n\t\tactivep = &cmdline;\n\t}\n\n\t/* Strip trailing whitespace. Allow \\f (form feed) at EOL only */\n\tif ((len = strlen(line)) == 0)\n\t\treturn 0;\n\tfor (len--; len > 0; len--) {\n\t\tif (strchr(WHITESPACE \"\\f\", line[len]) == NULL)\n\t\t\tbreak;\n\t\tline[len] = '\\0';\n\t}\n\n\ts = line;\n\t/* Get the keyword. (Each line is supposed to begin with a keyword). */\n\tif ((keyword = strdelim(&s)) == NULL)\n\t\treturn 0;\n\t/* Ignore leading whitespace. */\n\tif (*keyword == '\\0')\n\t\tkeyword = strdelim(&s);\n\tif (keyword == NULL || !*keyword || *keyword == '\\n' || *keyword == '#')\n\t\treturn 0;\n\t/* Match lowercase keyword */\n\tlowercase(keyword);\n\n\topcode = parse_token(keyword, filename, linenum,\n\t    options->ignored_unknown);\n\n\tswitch (opcode) {\n\tcase oBadOption:\n\t\t/* don't panic, but count bad options */\n\t\treturn -1;\n\tcase oIgnore:\n\t\treturn 0;\n\tcase oIgnoredUnknownOption:\n\t\tdebug(\"%s line %d: Ignored unknown option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn 0;\n\tcase oConnectTimeout:\n\t\tintptr = &options->connection_timeout;\nparse_time:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing time value.\",\n\t\t\t    filename, linenum);\n\t\tif (strcmp(arg, \"none\") == 0)\n\t\t\tvalue = -1;\n\t\telse if ((value = convtime(arg)) == -1)\n\t\t\tfatal(\"%s line %d: invalid time value.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oForwardAgent:\n\t\tintptr = &options->forward_agent;\n parse_flag:\n\t\tmultistate_ptr = multistate_flag;\n parse_multistate:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; multistate_ptr[i].key != NULL; i++) {\n\t\t\tif (strcasecmp(arg, multistate_ptr[i].key) == 0) {\n\t\t\t\tvalue = multistate_ptr[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: unsupported option \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oForwardX11:\n\t\tintptr = &options->forward_x11;\n\t\tgoto parse_flag;\n\n\tcase oForwardX11Trusted:\n\t\tintptr = &options->forward_x11_trusted;\n\t\tgoto parse_flag;\n\n\tcase oForwardX11Timeout:\n\t\tintptr = &options->forward_x11_timeout;\n\t\tgoto parse_time;\n\n\tcase oGatewayPorts:\n\t\tintptr = &options->fwd_opts.gateway_ports;\n\t\tgoto parse_flag;\n\n\tcase oExitOnForwardFailure:\n\t\tintptr = &options->exit_on_forward_failure;\n\t\tgoto parse_flag;\n\n\tcase oPasswordAuthentication:\n\t\tintptr = &options->password_authentication;\n\t\tgoto parse_flag;\n\n\tcase oKbdInteractiveAuthentication:\n\t\tintptr = &options->kbd_interactive_authentication;\n\t\tgoto parse_flag;\n\n\tcase oKbdInteractiveDevices:\n\t\tcharptr = &options->kbd_interactive_devices;\n\t\tgoto parse_string;\n\n\tcase oPubkeyAuthentication:\n\t\tintptr = &options->pubkey_authentication;\n\t\tgoto parse_flag;\n\n\tcase oHostbasedAuthentication:\n\t\tintptr = &options->hostbased_authentication;\n\t\tgoto parse_flag;\n\n\tcase oChallengeResponseAuthentication:\n\t\tintptr = &options->challenge_response_authentication;\n\t\tgoto parse_flag;\n\n\tcase oGssAuthentication:\n\t\tintptr = &options->gss_authentication;\n\t\tgoto parse_flag;\n\n\tcase oGssDelegateCreds:\n\t\tintptr = &options->gss_deleg_creds;\n\t\tgoto parse_flag;\n\n\tcase oBatchMode:\n\t\tintptr = &options->batch_mode;\n\t\tgoto parse_flag;\n\n\tcase oCheckHostIP:\n\t\tintptr = &options->check_host_ip;\n\t\tgoto parse_flag;\n\n\tcase oVerifyHostKeyDNS:\n\t\tintptr = &options->verify_host_key_dns;\n\t\tmultistate_ptr = multistate_yesnoask;\n\t\tgoto parse_multistate;\n\n\tcase oStrictHostKeyChecking:\n\t\tintptr = &options->strict_host_key_checking;\n\t\tmultistate_ptr = multistate_strict_hostkey;\n\t\tgoto parse_multistate;\n\n\tcase oCompression:\n\t\tintptr = &options->compression;\n\t\tgoto parse_flag;\n\n\tcase oTCPKeepAlive:\n\t\tintptr = &options->tcp_keep_alive;\n\t\tgoto parse_flag;\n\n\tcase oNoHostAuthenticationForLocalhost:\n\t\tintptr = &options->no_host_authentication_for_localhost;\n\t\tgoto parse_flag;\n\n\tcase oNumberOfPasswordPrompts:\n\t\tintptr = &options->number_of_password_prompts;\n\t\tgoto parse_int;\n\n\tcase oRekeyLimit:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tif (strcmp(arg, \"default\") == 0) {\n\t\t\tval64 = 0;\n\t\t} else {\n\t\t\tif (scan_scaled(arg, &val64) == -1)\n\t\t\t\tfatal(\"%.200s line %d: Bad number '%s': %s\",\n\t\t\t\t    filename, linenum, arg, strerror(errno));\n\t\t\tif (val64 != 0 && val64 < 16)\n\t\t\t\tfatal(\"%.200s line %d: RekeyLimit too small\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\tif (*activep && options->rekey_limit == -1)\n\t\t\toptions->rekey_limit = val64;\n\t\tif (s != NULL) { /* optional rekey interval present */\n\t\t\tif (strcmp(s, \"none\") == 0) {\n\t\t\t\t(void)strdelim(&s);\t/* discard */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tintptr = &options->rekey_interval;\n\t\t\tgoto parse_time;\n\t\t}\n\t\tbreak;\n\n\tcase oIdentityFile:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (*activep) {\n\t\t\tintptr = &options->num_identity_files;\n\t\t\tif (*intptr >= SSH_MAX_IDENTITY_FILES)\n\t\t\t\tfatal(\"%.200s line %d: Too many identity files specified (max %d).\",\n\t\t\t\t    filename, linenum, SSH_MAX_IDENTITY_FILES);\n\t\t\tadd_identity_file(options, NULL,\n\t\t\t    arg, flags & SSHCONF_USERCONF);\n\t\t}\n\t\tbreak;\n\n\tcase oCertificateFile:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep) {\n\t\t\tintptr = &options->num_certificate_files;\n\t\t\tif (*intptr >= SSH_MAX_CERTIFICATE_FILES) {\n\t\t\t\tfatal(\"%.200s line %d: Too many certificate \"\n\t\t\t\t    \"files specified (max %d).\",\n\t\t\t\t    filename, linenum,\n\t\t\t\t    SSH_MAX_CERTIFICATE_FILES);\n\t\t\t}\n\t\t\tadd_certificate_file(options, arg,\n\t\t\t    flags & SSHCONF_USERCONF);\n\t\t}\n\t\tbreak;\n\n\tcase oXAuthLocation:\n\t\tcharptr=&options->xauth_location;\n\t\tgoto parse_string;\n\n\tcase oUser:\n\t\tcharptr = &options->user;\nparse_string:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oGlobalKnownHostsFile:\n\t\tcpptr = (char **)&options->system_hostfiles;\n\t\tuintptr = &options->num_system_hostfiles;\n\t\tmax_entries = SSH_MAX_HOSTS_FILES;\nparse_char_array:\n\t\tif (*activep && *uintptr == 0) {\n\t\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\t\tif ((*uintptr) >= max_entries)\n\t\t\t\t\tfatal(\"%s line %d: \"\n\t\t\t\t\t    \"too many authorized keys files.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\tcpptr[(*uintptr)++] = xstrdup(arg);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase oUserKnownHostsFile:\n\t\tcpptr = (char **)&options->user_hostfiles;\n\t\tuintptr = &options->num_user_hostfiles;\n\t\tmax_entries = SSH_MAX_HOSTS_FILES;\n\t\tgoto parse_char_array;\n\n\tcase oHostName:\n\t\tcharptr = &options->hostname;\n\t\tgoto parse_string;\n\n\tcase oHostKeyAlias:\n\t\tcharptr = &options->host_key_alias;\n\t\tgoto parse_string;\n\n\tcase oPreferredAuthentications:\n\t\tcharptr = &options->preferred_authentications;\n\t\tgoto parse_string;\n\n\tcase oBindAddress:\n\t\tcharptr = &options->bind_address;\n\t\tgoto parse_string;\n\n\tcase oBindInterface:\n\t\tcharptr = &options->bind_interface;\n\t\tgoto parse_string;\n\n\tcase oPKCS11Provider:\n\t\tcharptr = &options->pkcs11_provider;\n\t\tgoto parse_string;\n\n\tcase oProxyCommand:\n\t\tcharptr = &options->proxy_command;\n\t\t/* Ignore ProxyCommand if ProxyJump already specified */\n\t\tif (options->jump_host != NULL)\n\t\t\tcharptr = &options->jump_host; /* Skip below */\nparse_command:\n\t\tif (s == NULL)\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tlen = strspn(s, WHITESPACE \"=\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(s + len);\n\t\treturn 0;\n\n\tcase oProxyJump:\n\t\tif (s == NULL) {\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t}\n\t\tlen = strspn(s, WHITESPACE \"=\");\n\t\tif (parse_jump(s + len, options, *activep) == -1) {\n\t\t\tfatal(\"%.200s line %d: Invalid ProxyJump \\\"%s\\\"\",\n\t\t\t    filename, linenum, s + len);\n\t\t}\n\t\treturn 0;\n\n\tcase oPort:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = a2port(arg);\n\t\tif (value <= 0)\n\t\t\tfatal(\"%.200s line %d: Bad port '%s'.\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && options->port == -1)\n\t\t\toptions->port = value;\n\t\tbreak;\n\n\tcase oConnectionAttempts:\n\t\tintptr = &options->connection_attempts;\nparse_int:\n\t\targ = strdelim(&s);\n\t\tif ((errstr = atoi_err(arg, &value)) != NULL)\n\t\t\tfatal(\"%s line %d: integer value %s.\",\n\t\t\t    filename, linenum, errstr);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oCiphers:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !ciphers_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%.200s line %d: Bad SSH2 cipher spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && options->ciphers == NULL)\n\t\t\toptions->ciphers = xstrdup(arg);\n\t\tbreak;\n\n\tcase oMacs:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !mac_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%.200s line %d: Bad SSH2 Mac spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && options->macs == NULL)\n\t\t\toptions->macs = xstrdup(arg);\n\t\tbreak;\n\n\tcase oKexAlgorithms:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !kex_names_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%.200s line %d: Bad SSH2 KexAlgorithms '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && options->kex_algorithms == NULL)\n\t\t\toptions->kex_algorithms = xstrdup(arg);\n\t\tbreak;\n\n\tcase oHostKeyAlgorithms:\n\t\tcharptr = &options->hostkeyalgorithms;\nparse_keytypes:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !sshkey_names_valid2(*arg == '+' ? arg + 1 : arg, 1))\n\t\t\tfatal(\"%s line %d: Bad key types '%s'.\",\n\t\t\t\tfilename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oCASignatureAlgorithms:\n\t\tcharptr = &options->ca_sign_algorithms;\n\t\tgoto parse_keytypes;\n\n\tcase oLogLevel:\n\t\tlog_level_ptr = &options->log_level;\n\t\targ = strdelim(&s);\n\t\tvalue = log_level_number(arg);\n\t\tif (value == SYSLOG_LEVEL_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log level '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *log_level_ptr == SYSLOG_LEVEL_NOT_SET)\n\t\t\t*log_level_ptr = (LogLevel) value;\n\t\tbreak;\n\n\tcase oLogFacility:\n\t\tlog_facility_ptr = &options->log_facility;\n\t\targ = strdelim(&s);\n\t\tvalue = log_facility_number(arg);\n\t\tif (value == SYSLOG_FACILITY_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log facility '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*log_facility_ptr == -1)\n\t\t\t*log_facility_ptr = (SyslogFacility) value;\n\t\tbreak;\n\n\tcase oLocalForward:\n\tcase oRemoteForward:\n\tcase oDynamicForward:\n\t\targ = strdelim(&s);\n\t\tif (arg == NULL || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing port argument.\",\n\t\t\t    filename, linenum);\n\n\t\tremotefwd = (opcode == oRemoteForward);\n\t\tdynamicfwd = (opcode == oDynamicForward);\n\n\t\tif (!dynamicfwd) {\n\t\t\targ2 = strdelim(&s);\n\t\t\tif (arg2 == NULL || *arg2 == '\\0') {\n\t\t\t\tif (remotefwd)\n\t\t\t\t\tdynamicfwd = 1;\n\t\t\t\telse\n\t\t\t\t\tfatal(\"%.200s line %d: Missing target \"\n\t\t\t\t\t    \"argument.\", filename, linenum);\n\t\t\t} else {\n\t\t\t\t/* construct a string for parse_forward */\n\t\t\t\tsnprintf(fwdarg, sizeof(fwdarg), \"%s:%s\", arg,\n\t\t\t\t    arg2);\n\t\t\t}\n\t\t}\n\t\tif (dynamicfwd)\n\t\t\tstrlcpy(fwdarg, arg, sizeof(fwdarg));\n\n\t\tif (parse_forward(&fwd, fwdarg, dynamicfwd, remotefwd) == 0)\n\t\t\tfatal(\"%.200s line %d: Bad forwarding specification.\",\n\t\t\t    filename, linenum);\n\n\t\tif (*activep) {\n\t\t\tif (remotefwd) {\n\t\t\t\tadd_remote_forward(options, &fwd);\n\t\t\t} else {\n\t\t\t\tadd_local_forward(options, &fwd);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase oClearAllForwardings:\n\t\tintptr = &options->clear_forwardings;\n\t\tgoto parse_flag;\n\n\tcase oHost:\n\t\tif (cmdline)\n\t\t\tfatal(\"Host directive not supported as a command-line \"\n\t\t\t    \"option\");\n\t\t*activep = 0;\n\t\targ2 = NULL;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\tif ((flags & SSHCONF_NEVERMATCH) != 0)\n\t\t\t\tbreak;\n\t\t\tnegated = *arg == '!';\n\t\t\tif (negated)\n\t\t\t\targ++;\n\t\t\tif (match_pattern(host, arg)) {\n\t\t\t\tif (negated) {\n\t\t\t\t\tdebug(\"%.200s line %d: Skipping Host \"\n\t\t\t\t\t    \"block because of negated match \"\n\t\t\t\t\t    \"for %.100s\", filename, linenum,\n\t\t\t\t\t    arg);\n\t\t\t\t\t*activep = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!*activep)\n\t\t\t\t\targ2 = arg; /* logged below */\n\t\t\t\t*activep = 1;\n\t\t\t}\n\t\t}\n\t\tif (*activep)\n\t\t\tdebug(\"%.200s line %d: Applying options for %.100s\",\n\t\t\t    filename, linenum, arg2);\n\t\t/* Avoid garbage check below, as strdelim is done. */\n\t\treturn 0;\n\n\tcase oMatch:\n\t\tif (cmdline)\n\t\t\tfatal(\"Host directive not supported as a command-line \"\n\t\t\t    \"option\");\n\t\tvalue = match_cfg_line(options, &s, pw, host, original_host,\n\t\t    flags & SSHCONF_POSTCANON, filename, linenum);\n\t\tif (value < 0)\n\t\t\tfatal(\"%.200s line %d: Bad Match condition\", filename,\n\t\t\t    linenum);\n\t\t*activep = (flags & SSHCONF_NEVERMATCH) ? 0 : value;\n\t\tbreak;\n\n\tcase oEscapeChar:\n\t\tintptr = &options->escape_char;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (strcmp(arg, \"none\") == 0)\n\t\t\tvalue = SSH_ESCAPECHAR_NONE;\n\t\telse if (arg[1] == '\\0')\n\t\t\tvalue = (u_char) arg[0];\n\t\telse if (arg[0] == '^' && arg[2] == 0 &&\n\t\t    (u_char) arg[1] >= 64 && (u_char) arg[1] < 128)\n\t\t\tvalue = (u_char) arg[1] & 31;\n\t\telse {\n\t\t\tfatal(\"%.200s line %d: Bad escape character.\",\n\t\t\t    filename, linenum);\n\t\t\t/* NOTREACHED */\n\t\t\tvalue = 0;\t/* Avoid compiler warning. */\n\t\t}\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oAddressFamily:\n\t\tintptr = &options->address_family;\n\t\tmultistate_ptr = multistate_addressfamily;\n\t\tgoto parse_multistate;\n\n\tcase oEnableSSHKeysign:\n\t\tintptr = &options->enable_ssh_keysign;\n\t\tgoto parse_flag;\n\n\tcase oIdentitiesOnly:\n\t\tintptr = &options->identities_only;\n\t\tgoto parse_flag;\n\n\tcase oServerAliveInterval:\n\t\tintptr = &options->server_alive_interval;\n\t\tgoto parse_time;\n\n\tcase oServerAliveCountMax:\n\t\tintptr = &options->server_alive_count_max;\n\t\tgoto parse_int;\n\n\tcase oSendEnv:\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') != NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment name.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tif (*arg == '-') {\n\t\t\t\t/* Removing an env var */\n\t\t\t\trm_env(options, arg, filename, linenum);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/* Adding an env var */\n\t\t\t\tif (options->num_send_env >= INT_MAX)\n\t\t\t\t\tfatal(\"%s line %d: too many send env.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\toptions->send_env = xrecallocarray(\n\t\t\t\t    options->send_env, options->num_send_env,\n\t\t\t\t    options->num_send_env + 1,\n\t\t\t\t    sizeof(*options->send_env));\n\t\t\t\toptions->send_env[options->num_send_env++] =\n\t\t\t\t    xstrdup(arg);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase oSetEnv:\n\t\tvalue = options->num_setenv;\n\t\twhile ((arg = strdelimw(&s)) != NULL && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') == NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid SetEnv.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep || value != 0)\n\t\t\t\tcontinue;\n\t\t\t/* Adding a setenv var */\n\t\t\tif (options->num_setenv >= INT_MAX)\n\t\t\t\tfatal(\"%s line %d: too many SetEnv.\",\n\t\t\t\t    filename, linenum);\n\t\t\toptions->setenv = xrecallocarray(\n\t\t\t    options->setenv, options->num_setenv,\n\t\t\t    options->num_setenv + 1, sizeof(*options->setenv));\n\t\t\toptions->setenv[options->num_setenv++] = xstrdup(arg);\n\t\t}\n\t\tbreak;\n\n\tcase oControlPath:\n\t\tcharptr = &options->control_path;\n\t\tgoto parse_string;\n\n\tcase oControlMaster:\n\t\tintptr = &options->control_master;\n\t\tmultistate_ptr = multistate_controlmaster;\n\t\tgoto parse_multistate;\n\n\tcase oControlPersist:\n\t\t/* no/false/yes/true, or a time spec */\n\t\tintptr = &options->control_persist;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing ControlPersist\"\n\t\t\t    \" argument.\", filename, linenum);\n\t\tvalue = 0;\n\t\tvalue2 = 0;\t/* timeout */\n\t\tif (strcmp(arg, \"no\") == 0 || strcmp(arg, \"false\") == 0)\n\t\t\tvalue = 0;\n\t\telse if (strcmp(arg, \"yes\") == 0 || strcmp(arg, \"true\") == 0)\n\t\t\tvalue = 1;\n\t\telse if ((value2 = convtime(arg)) >= 0)\n\t\t\tvalue = 1;\n\t\telse\n\t\t\tfatal(\"%.200s line %d: Bad ControlPersist argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1) {\n\t\t\t*intptr = value;\n\t\t\toptions->control_persist_timeout = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oHashKnownHosts:\n\t\tintptr = &options->hash_known_hosts;\n\t\tgoto parse_flag;\n\n\tcase oTunnel:\n\t\tintptr = &options->tun_open;\n\t\tmultistate_ptr = multistate_tunnel;\n\t\tgoto parse_multistate;\n\n\tcase oTunnelDevice:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tvalue = a2tun(arg, &value2);\n\t\tif (value == SSH_TUNID_ERR)\n\t\t\tfatal(\"%.200s line %d: Bad tun device.\", filename, linenum);\n\t\tif (*activep) {\n\t\t\toptions->tun_local = value;\n\t\t\toptions->tun_remote = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oLocalCommand:\n\t\tcharptr = &options->local_command;\n\t\tgoto parse_command;\n\n\tcase oPermitLocalCommand:\n\t\tintptr = &options->permit_local_command;\n\t\tgoto parse_flag;\n\n\tcase oRemoteCommand:\n\t\tcharptr = &options->remote_command;\n\t\tgoto parse_command;\n\n\tcase oVisualHostKey:\n\t\tintptr = &options->visual_host_key;\n\t\tgoto parse_flag;\n\n\tcase oInclude:\n\t\tif (cmdline)\n\t\t\tfatal(\"Include directive not supported as a \"\n\t\t\t    \"command-line option\");\n\t\tvalue = 0;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\t/*\n\t\t\t * Ensure all paths are anchored. User configuration\n\t\t\t * files may begin with '~/' but system configurations\n\t\t\t * must not. If the path is relative, then treat it\n\t\t\t * as living in ~/.ssh for user configurations or\n\t\t\t * /etc/ssh for system ones.\n\t\t\t */\n\t\t\tif (*arg == '~' && (flags & SSHCONF_USERCONF) == 0)\n\t\t\t\tfatal(\"%.200s line %d: bad include path %s.\",\n\t\t\t\t    filename, linenum, arg);\n\t\t\tif (*arg != '/' && *arg != '~') {\n\t\t\t\txasprintf(&arg2, \"%s/%s\",\n\t\t\t\t    (flags & SSHCONF_USERCONF) ?\n\t\t\t\t    \"~/\" _PATH_SSH_USER_DIR : SSHDIR, arg);\n\t\t\t} else\n\t\t\t\targ2 = xstrdup(arg);\n\t\t\tmemset(&gl, 0, sizeof(gl));\n\t\t\tr = glob(arg2, GLOB_TILDE, NULL, &gl);\n\t\t\tif (r == GLOB_NOMATCH) {\n\t\t\t\tdebug(\"%.200s line %d: include %s matched no \"\n\t\t\t\t    \"files\",filename, linenum, arg2);\n\t\t\t\tfree(arg2);\n\t\t\t\tcontinue;\n\t\t\t} else if (r != 0 || gl.gl_pathc < 0)\n\t\t\t\tfatal(\"%.200s line %d: glob failed for %s.\",\n\t\t\t\t    filename, linenum, arg2);\n\t\t\tfree(arg2);\n\t\t\toactive = *activep;\n\t\t\tfor (i = 0; i < (u_int)gl.gl_pathc; i++) {\n\t\t\t\tdebug3(\"%.200s line %d: Including file %s \"\n\t\t\t\t    \"depth %d%s\", filename, linenum,\n\t\t\t\t    gl.gl_pathv[i], depth,\n\t\t\t\t    oactive ? \"\" : \" (parse only)\");\n\t\t\t\tr = read_config_file_depth(gl.gl_pathv[i],\n\t\t\t\t    pw, host, original_host, options,\n\t\t\t\t    flags | SSHCONF_CHECKPERM |\n\t\t\t\t    (oactive ? 0 : SSHCONF_NEVERMATCH),\n\t\t\t\t    activep, depth + 1);\n\t\t\t\tif (r != 1 && errno != ENOENT) {\n\t\t\t\t\tfatal(\"Can't open user config file \"\n\t\t\t\t\t    \"%.100s: %.100s\", gl.gl_pathv[i],\n\t\t\t\t\t    strerror(errno));\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * don't let Match in includes clobber the\n\t\t\t\t * containing file's Match state.\n\t\t\t\t */\n\t\t\t\t*activep = oactive;\n\t\t\t\tif (r != 1)\n\t\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\tglobfree(&gl);\n\t\t}\n\t\tif (value != 0)\n\t\t\treturn value;\n\t\tbreak;\n\n\tcase oIPQoS:\n\t\targ = strdelim(&s);\n\t\tif ((value = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\targ = strdelim(&s);\n\t\tif (arg == NULL)\n\t\t\tvalue2 = value;\n\t\telse if ((value2 = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep) {\n\t\t\toptions->ip_qos_interactive = value;\n\t\t\toptions->ip_qos_bulk = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oRequestTTY:\n\t\tintptr = &options->request_tty;\n\t\tmultistate_ptr = multistate_requesttty;\n\t\tgoto parse_multistate;\n\n\tcase oIgnoreUnknown:\n\t\tcharptr = &options->ignored_unknown;\n\t\tgoto parse_string;\n\n\tcase oProxyUseFdpass:\n\t\tintptr = &options->proxy_use_fdpass;\n\t\tgoto parse_flag;\n\n\tcase oCanonicalDomains:\n\t\tvalue = options->num_canonical_domains != 0;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\tif (!valid_domain(arg, 1, &errstr)) {\n\t\t\t\tfatal(\"%s line %d: %s\", filename, linenum,\n\t\t\t\t    errstr);\n\t\t\t}\n\t\t\tif (!*activep || value)\n\t\t\t\tcontinue;\n\t\t\tif (options->num_canonical_domains >= MAX_CANON_DOMAINS)\n\t\t\t\tfatal(\"%s line %d: too many hostname suffixes.\",\n\t\t\t\t    filename, linenum);\n\t\t\toptions->canonical_domains[\n\t\t\t    options->num_canonical_domains++] = xstrdup(arg);\n\t\t}\n\t\tbreak;\n\n\tcase oCanonicalizePermittedCNAMEs:\n\t\tvalue = options->num_permitted_cnames != 0;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\t/* Either '*' for everything or 'list:list' */\n\t\t\tif (strcmp(arg, \"*\") == 0)\n\t\t\t\targ2 = arg;\n\t\t\telse {\n\t\t\t\tlowercase(arg);\n\t\t\t\tif ((arg2 = strchr(arg, ':')) == NULL ||\n\t\t\t\t    arg2[1] == '\\0') {\n\t\t\t\t\tfatal(\"%s line %d: \"\n\t\t\t\t\t    \"Invalid permitted CNAME \\\"%s\\\"\",\n\t\t\t\t\t    filename, linenum, arg);\n\t\t\t\t}\n\t\t\t\t*arg2 = '\\0';\n\t\t\t\targ2++;\n\t\t\t}\n\t\t\tif (!*activep || value)\n\t\t\t\tcontinue;\n\t\t\tif (options->num_permitted_cnames >= MAX_CANON_DOMAINS)\n\t\t\t\tfatal(\"%s line %d: too many permitted CNAMEs.\",\n\t\t\t\t    filename, linenum);\n\t\t\tcname = options->permitted_cnames +\n\t\t\t    options->num_permitted_cnames++;\n\t\t\tcname->source_list = xstrdup(arg);\n\t\t\tcname->target_list = xstrdup(arg2);\n\t\t}\n\t\tbreak;\n\n\tcase oCanonicalizeHostname:\n\t\tintptr = &options->canonicalize_hostname;\n\t\tmultistate_ptr = multistate_canonicalizehostname;\n\t\tgoto parse_multistate;\n\n\tcase oCanonicalizeMaxDots:\n\t\tintptr = &options->canonicalize_max_dots;\n\t\tgoto parse_int;\n\n\tcase oCanonicalizeFallbackLocal:\n\t\tintptr = &options->canonicalize_fallback_local;\n\t\tgoto parse_flag;\n\n\tcase oStreamLocalBindMask:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing StreamLocalBindMask argument.\", filename, linenum);\n\t\t/* Parse mode in octal format */\n\t\tvalue = strtol(arg, &endofnumber, 8);\n\t\tif (arg == endofnumber || value < 0 || value > 0777)\n\t\t\tfatal(\"%.200s line %d: Bad mask.\", filename, linenum);\n\t\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)value;\n\t\tbreak;\n\n\tcase oStreamLocalBindUnlink:\n\t\tintptr = &options->fwd_opts.streamlocal_bind_unlink;\n\t\tgoto parse_flag;\n\n\tcase oRevokedHostKeys:\n\t\tcharptr = &options->revoked_host_keys;\n\t\tgoto parse_string;\n\n\tcase oFingerprintHash:\n\t\tintptr = &options->fingerprint_hash;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = ssh_digest_alg_by_name(arg)) == -1)\n\t\t\tfatal(\"%.200s line %d: Invalid hash algorithm \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oUpdateHostkeys:\n\t\tintptr = &options->update_hostkeys;\n\t\tmultistate_ptr = multistate_yesnoask;\n\t\tgoto parse_multistate;\n\n\tcase oHostbasedKeyTypes:\n\t\tcharptr = &options->hostbased_key_types;\n\t\tgoto parse_keytypes;\n\n\tcase oPubkeyAcceptedKeyTypes:\n\t\tcharptr = &options->pubkey_key_types;\n\t\tgoto parse_keytypes;\n\n\tcase oAddKeysToAgent:\n\t\tintptr = &options->add_keys_to_agent;\n\t\tmultistate_ptr = multistate_yesnoaskconfirm;\n\t\tgoto parse_multistate;\n\n\tcase oIdentityAgent:\n\t\tcharptr = &options->identity_agent;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t/* Extra validation if the string represents an env var. */\n\t\tif (arg[0] == '$' && !valid_env_name(arg + 1)) {\n\t\t\tfatal(\"%.200s line %d: Invalid environment name %s.\",\n\t\t\t    filename, linenum, arg);\n\t\t}\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oDeprecated:\n\t\tdebug(\"%s line %d: Deprecated option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn 0;\n\n\tcase oUnsupported:\n\t\terror(\"%s line %d: Unsupported option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn 0;\n\n\tdefault:\n\t\tfatal(\"%s: Unimplemented opcode %d\", __func__, opcode);\n\t}\n\n\t/* Check that there is no garbage at end of line. */\n\tif ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\tfatal(\"%.200s line %d: garbage at end of line; \\\"%.200s\\\".\",\n\t\t    filename, linenum, arg);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define WHITESPACE \" \\t\\r\\n\""
          ],
          "globals_used": [
            "static int read_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int depth);",
            "static int process_config_line_depth(Options *options, struct passwd *pw,\n    const char *host, const char *original_host, char *line,\n    const char *filename, int linenum, int *activep, int flags, int depth);",
            "static const struct multistate multistate_flag[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_yesnoask[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_strict_hostkey[] = {\n\t{ \"true\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"false\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"yes\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"no\",\t\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"ask\",\t\t\tSSH_STRICT_HOSTKEY_ASK },\n\t{ \"off\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"accept-new\",\t\t\tSSH_STRICT_HOSTKEY_NEW },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_yesnoaskconfirm[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ \"confirm\",\t\t\t3 },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_controlmaster[] = {\n\t{ \"true\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"yes\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"false\",\t\t\tSSHCTL_MASTER_NO },\n\t{ \"no\",\t\t\t\tSSHCTL_MASTER_NO },\n\t{ \"auto\",\t\t\tSSHCTL_MASTER_AUTO },\n\t{ \"ask\",\t\t\tSSHCTL_MASTER_ASK },\n\t{ \"autoask\",\t\t\tSSHCTL_MASTER_AUTO_ASK },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_tunnel[] = {\n\t{ \"ethernet\",\t\t\tSSH_TUNMODE_ETHERNET },\n\t{ \"point-to-point\",\t\tSSH_TUNMODE_POINTOPOINT },\n\t{ \"true\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"yes\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"false\",\t\t\tSSH_TUNMODE_NO },\n\t{ \"no\",\t\t\t\tSSH_TUNMODE_NO },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_requesttty[] = {\n\t{ \"true\",\t\t\tREQUEST_TTY_YES },\n\t{ \"yes\",\t\t\tREQUEST_TTY_YES },\n\t{ \"false\",\t\t\tREQUEST_TTY_NO },\n\t{ \"no\",\t\t\t\tREQUEST_TTY_NO },\n\t{ \"force\",\t\t\tREQUEST_TTY_FORCE },\n\t{ \"auto\",\t\t\tREQUEST_TTY_AUTO },\n\t{ NULL, -1 }\n};",
            "static const struct multistate multistate_canonicalizehostname[] = {\n\t{ \"true\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"false\",\t\t\tSSH_CANONICALISE_NO },\n\t{ \"yes\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"no\",\t\t\t\tSSH_CANONICALISE_NO },\n\t{ \"always\",\t\t\tSSH_CANONICALISE_ALWAYS },\n\t{ NULL, -1 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define WHITESPACE \" \\t\\r\\n\"\n\nstatic int read_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int depth);\nstatic int process_config_line_depth(Options *options, struct passwd *pw,\n    const char *host, const char *original_host, char *line,\n    const char *filename, int linenum, int *activep, int flags, int depth);\nstatic const struct multistate multistate_flag[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_yesnoask[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_strict_hostkey[] = {\n\t{ \"true\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"false\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"yes\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"no\",\t\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"ask\",\t\t\tSSH_STRICT_HOSTKEY_ASK },\n\t{ \"off\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"accept-new\",\t\t\tSSH_STRICT_HOSTKEY_NEW },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_yesnoaskconfirm[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ \"confirm\",\t\t\t3 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_controlmaster[] = {\n\t{ \"true\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"yes\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"false\",\t\t\tSSHCTL_MASTER_NO },\n\t{ \"no\",\t\t\t\tSSHCTL_MASTER_NO },\n\t{ \"auto\",\t\t\tSSHCTL_MASTER_AUTO },\n\t{ \"ask\",\t\t\tSSHCTL_MASTER_ASK },\n\t{ \"autoask\",\t\t\tSSHCTL_MASTER_AUTO_ASK },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_tunnel[] = {\n\t{ \"ethernet\",\t\t\tSSH_TUNMODE_ETHERNET },\n\t{ \"point-to-point\",\t\tSSH_TUNMODE_POINTOPOINT },\n\t{ \"true\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"yes\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"false\",\t\t\tSSH_TUNMODE_NO },\n\t{ \"no\",\t\t\t\tSSH_TUNMODE_NO },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_requesttty[] = {\n\t{ \"true\",\t\t\tREQUEST_TTY_YES },\n\t{ \"yes\",\t\t\tREQUEST_TTY_YES },\n\t{ \"false\",\t\t\tREQUEST_TTY_NO },\n\t{ \"no\",\t\t\t\tREQUEST_TTY_NO },\n\t{ \"force\",\t\t\tREQUEST_TTY_FORCE },\n\t{ \"auto\",\t\t\tREQUEST_TTY_AUTO },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_canonicalizehostname[] = {\n\t{ \"true\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"false\",\t\t\tSSH_CANONICALISE_NO },\n\t{ \"yes\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"no\",\t\t\t\tSSH_CANONICALISE_NO },\n\t{ \"always\",\t\t\tSSH_CANONICALISE_ALWAYS },\n\t{ NULL, -1 }\n};\n\nstatic int\nprocess_config_line_depth(Options *options, struct passwd *pw, const char *host,\n    const char *original_host, char *line, const char *filename,\n    int linenum, int *activep, int flags, int depth)\n{\n\tchar *s, **charptr, *endofnumber, *keyword, *arg, *arg2;\n\tchar **cpptr, fwdarg[256];\n\tu_int i, *uintptr, max_entries = 0;\n\tint r, oactive, negated, opcode, *intptr, value, value2, cmdline = 0;\n\tint remotefwd, dynamicfwd;\n\tLogLevel *log_level_ptr;\n\tSyslogFacility *log_facility_ptr;\n\tlong long val64;\n\tsize_t len;\n\tstruct Forward fwd;\n\tconst struct multistate *multistate_ptr;\n\tstruct allowed_cname *cname;\n\tglob_t gl;\n\tconst char *errstr;\n\n\tif (activep == NULL) { /* We are processing a command line directive */\n\t\tcmdline = 1;\n\t\tactivep = &cmdline;\n\t}\n\n\t/* Strip trailing whitespace. Allow \\f (form feed) at EOL only */\n\tif ((len = strlen(line)) == 0)\n\t\treturn 0;\n\tfor (len--; len > 0; len--) {\n\t\tif (strchr(WHITESPACE \"\\f\", line[len]) == NULL)\n\t\t\tbreak;\n\t\tline[len] = '\\0';\n\t}\n\n\ts = line;\n\t/* Get the keyword. (Each line is supposed to begin with a keyword). */\n\tif ((keyword = strdelim(&s)) == NULL)\n\t\treturn 0;\n\t/* Ignore leading whitespace. */\n\tif (*keyword == '\\0')\n\t\tkeyword = strdelim(&s);\n\tif (keyword == NULL || !*keyword || *keyword == '\\n' || *keyword == '#')\n\t\treturn 0;\n\t/* Match lowercase keyword */\n\tlowercase(keyword);\n\n\topcode = parse_token(keyword, filename, linenum,\n\t    options->ignored_unknown);\n\n\tswitch (opcode) {\n\tcase oBadOption:\n\t\t/* don't panic, but count bad options */\n\t\treturn -1;\n\tcase oIgnore:\n\t\treturn 0;\n\tcase oIgnoredUnknownOption:\n\t\tdebug(\"%s line %d: Ignored unknown option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn 0;\n\tcase oConnectTimeout:\n\t\tintptr = &options->connection_timeout;\nparse_time:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing time value.\",\n\t\t\t    filename, linenum);\n\t\tif (strcmp(arg, \"none\") == 0)\n\t\t\tvalue = -1;\n\t\telse if ((value = convtime(arg)) == -1)\n\t\t\tfatal(\"%s line %d: invalid time value.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oForwardAgent:\n\t\tintptr = &options->forward_agent;\n parse_flag:\n\t\tmultistate_ptr = multistate_flag;\n parse_multistate:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; multistate_ptr[i].key != NULL; i++) {\n\t\t\tif (strcasecmp(arg, multistate_ptr[i].key) == 0) {\n\t\t\t\tvalue = multistate_ptr[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: unsupported option \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oForwardX11:\n\t\tintptr = &options->forward_x11;\n\t\tgoto parse_flag;\n\n\tcase oForwardX11Trusted:\n\t\tintptr = &options->forward_x11_trusted;\n\t\tgoto parse_flag;\n\n\tcase oForwardX11Timeout:\n\t\tintptr = &options->forward_x11_timeout;\n\t\tgoto parse_time;\n\n\tcase oGatewayPorts:\n\t\tintptr = &options->fwd_opts.gateway_ports;\n\t\tgoto parse_flag;\n\n\tcase oExitOnForwardFailure:\n\t\tintptr = &options->exit_on_forward_failure;\n\t\tgoto parse_flag;\n\n\tcase oPasswordAuthentication:\n\t\tintptr = &options->password_authentication;\n\t\tgoto parse_flag;\n\n\tcase oKbdInteractiveAuthentication:\n\t\tintptr = &options->kbd_interactive_authentication;\n\t\tgoto parse_flag;\n\n\tcase oKbdInteractiveDevices:\n\t\tcharptr = &options->kbd_interactive_devices;\n\t\tgoto parse_string;\n\n\tcase oPubkeyAuthentication:\n\t\tintptr = &options->pubkey_authentication;\n\t\tgoto parse_flag;\n\n\tcase oHostbasedAuthentication:\n\t\tintptr = &options->hostbased_authentication;\n\t\tgoto parse_flag;\n\n\tcase oChallengeResponseAuthentication:\n\t\tintptr = &options->challenge_response_authentication;\n\t\tgoto parse_flag;\n\n\tcase oGssAuthentication:\n\t\tintptr = &options->gss_authentication;\n\t\tgoto parse_flag;\n\n\tcase oGssDelegateCreds:\n\t\tintptr = &options->gss_deleg_creds;\n\t\tgoto parse_flag;\n\n\tcase oBatchMode:\n\t\tintptr = &options->batch_mode;\n\t\tgoto parse_flag;\n\n\tcase oCheckHostIP:\n\t\tintptr = &options->check_host_ip;\n\t\tgoto parse_flag;\n\n\tcase oVerifyHostKeyDNS:\n\t\tintptr = &options->verify_host_key_dns;\n\t\tmultistate_ptr = multistate_yesnoask;\n\t\tgoto parse_multistate;\n\n\tcase oStrictHostKeyChecking:\n\t\tintptr = &options->strict_host_key_checking;\n\t\tmultistate_ptr = multistate_strict_hostkey;\n\t\tgoto parse_multistate;\n\n\tcase oCompression:\n\t\tintptr = &options->compression;\n\t\tgoto parse_flag;\n\n\tcase oTCPKeepAlive:\n\t\tintptr = &options->tcp_keep_alive;\n\t\tgoto parse_flag;\n\n\tcase oNoHostAuthenticationForLocalhost:\n\t\tintptr = &options->no_host_authentication_for_localhost;\n\t\tgoto parse_flag;\n\n\tcase oNumberOfPasswordPrompts:\n\t\tintptr = &options->number_of_password_prompts;\n\t\tgoto parse_int;\n\n\tcase oRekeyLimit:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\tif (strcmp(arg, \"default\") == 0) {\n\t\t\tval64 = 0;\n\t\t} else {\n\t\t\tif (scan_scaled(arg, &val64) == -1)\n\t\t\t\tfatal(\"%.200s line %d: Bad number '%s': %s\",\n\t\t\t\t    filename, linenum, arg, strerror(errno));\n\t\t\tif (val64 != 0 && val64 < 16)\n\t\t\t\tfatal(\"%.200s line %d: RekeyLimit too small\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\tif (*activep && options->rekey_limit == -1)\n\t\t\toptions->rekey_limit = val64;\n\t\tif (s != NULL) { /* optional rekey interval present */\n\t\t\tif (strcmp(s, \"none\") == 0) {\n\t\t\t\t(void)strdelim(&s);\t/* discard */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tintptr = &options->rekey_interval;\n\t\t\tgoto parse_time;\n\t\t}\n\t\tbreak;\n\n\tcase oIdentityFile:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (*activep) {\n\t\t\tintptr = &options->num_identity_files;\n\t\t\tif (*intptr >= SSH_MAX_IDENTITY_FILES)\n\t\t\t\tfatal(\"%.200s line %d: Too many identity files specified (max %d).\",\n\t\t\t\t    filename, linenum, SSH_MAX_IDENTITY_FILES);\n\t\t\tadd_identity_file(options, NULL,\n\t\t\t    arg, flags & SSHCONF_USERCONF);\n\t\t}\n\t\tbreak;\n\n\tcase oCertificateFile:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep) {\n\t\t\tintptr = &options->num_certificate_files;\n\t\t\tif (*intptr >= SSH_MAX_CERTIFICATE_FILES) {\n\t\t\t\tfatal(\"%.200s line %d: Too many certificate \"\n\t\t\t\t    \"files specified (max %d).\",\n\t\t\t\t    filename, linenum,\n\t\t\t\t    SSH_MAX_CERTIFICATE_FILES);\n\t\t\t}\n\t\t\tadd_certificate_file(options, arg,\n\t\t\t    flags & SSHCONF_USERCONF);\n\t\t}\n\t\tbreak;\n\n\tcase oXAuthLocation:\n\t\tcharptr=&options->xauth_location;\n\t\tgoto parse_string;\n\n\tcase oUser:\n\t\tcharptr = &options->user;\nparse_string:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oGlobalKnownHostsFile:\n\t\tcpptr = (char **)&options->system_hostfiles;\n\t\tuintptr = &options->num_system_hostfiles;\n\t\tmax_entries = SSH_MAX_HOSTS_FILES;\nparse_char_array:\n\t\tif (*activep && *uintptr == 0) {\n\t\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\t\tif ((*uintptr) >= max_entries)\n\t\t\t\t\tfatal(\"%s line %d: \"\n\t\t\t\t\t    \"too many authorized keys files.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\tcpptr[(*uintptr)++] = xstrdup(arg);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase oUserKnownHostsFile:\n\t\tcpptr = (char **)&options->user_hostfiles;\n\t\tuintptr = &options->num_user_hostfiles;\n\t\tmax_entries = SSH_MAX_HOSTS_FILES;\n\t\tgoto parse_char_array;\n\n\tcase oHostName:\n\t\tcharptr = &options->hostname;\n\t\tgoto parse_string;\n\n\tcase oHostKeyAlias:\n\t\tcharptr = &options->host_key_alias;\n\t\tgoto parse_string;\n\n\tcase oPreferredAuthentications:\n\t\tcharptr = &options->preferred_authentications;\n\t\tgoto parse_string;\n\n\tcase oBindAddress:\n\t\tcharptr = &options->bind_address;\n\t\tgoto parse_string;\n\n\tcase oBindInterface:\n\t\tcharptr = &options->bind_interface;\n\t\tgoto parse_string;\n\n\tcase oPKCS11Provider:\n\t\tcharptr = &options->pkcs11_provider;\n\t\tgoto parse_string;\n\n\tcase oProxyCommand:\n\t\tcharptr = &options->proxy_command;\n\t\t/* Ignore ProxyCommand if ProxyJump already specified */\n\t\tif (options->jump_host != NULL)\n\t\t\tcharptr = &options->jump_host; /* Skip below */\nparse_command:\n\t\tif (s == NULL)\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tlen = strspn(s, WHITESPACE \"=\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(s + len);\n\t\treturn 0;\n\n\tcase oProxyJump:\n\t\tif (s == NULL) {\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t}\n\t\tlen = strspn(s, WHITESPACE \"=\");\n\t\tif (parse_jump(s + len, options, *activep) == -1) {\n\t\t\tfatal(\"%.200s line %d: Invalid ProxyJump \\\"%s\\\"\",\n\t\t\t    filename, linenum, s + len);\n\t\t}\n\t\treturn 0;\n\n\tcase oPort:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = a2port(arg);\n\t\tif (value <= 0)\n\t\t\tfatal(\"%.200s line %d: Bad port '%s'.\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && options->port == -1)\n\t\t\toptions->port = value;\n\t\tbreak;\n\n\tcase oConnectionAttempts:\n\t\tintptr = &options->connection_attempts;\nparse_int:\n\t\targ = strdelim(&s);\n\t\tif ((errstr = atoi_err(arg, &value)) != NULL)\n\t\t\tfatal(\"%s line %d: integer value %s.\",\n\t\t\t    filename, linenum, errstr);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oCiphers:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !ciphers_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%.200s line %d: Bad SSH2 cipher spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && options->ciphers == NULL)\n\t\t\toptions->ciphers = xstrdup(arg);\n\t\tbreak;\n\n\tcase oMacs:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (*arg != '-' && !mac_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%.200s line %d: Bad SSH2 Mac spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && options->macs == NULL)\n\t\t\toptions->macs = xstrdup(arg);\n\t\tbreak;\n\n\tcase oKexAlgorithms:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !kex_names_valid(*arg == '+' ? arg + 1 : arg))\n\t\t\tfatal(\"%.200s line %d: Bad SSH2 KexAlgorithms '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && options->kex_algorithms == NULL)\n\t\t\toptions->kex_algorithms = xstrdup(arg);\n\t\tbreak;\n\n\tcase oHostKeyAlgorithms:\n\t\tcharptr = &options->hostkeyalgorithms;\nparse_keytypes:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !sshkey_names_valid2(*arg == '+' ? arg + 1 : arg, 1))\n\t\t\tfatal(\"%s line %d: Bad key types '%s'.\",\n\t\t\t\tfilename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oCASignatureAlgorithms:\n\t\tcharptr = &options->ca_sign_algorithms;\n\t\tgoto parse_keytypes;\n\n\tcase oLogLevel:\n\t\tlog_level_ptr = &options->log_level;\n\t\targ = strdelim(&s);\n\t\tvalue = log_level_number(arg);\n\t\tif (value == SYSLOG_LEVEL_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log level '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *log_level_ptr == SYSLOG_LEVEL_NOT_SET)\n\t\t\t*log_level_ptr = (LogLevel) value;\n\t\tbreak;\n\n\tcase oLogFacility:\n\t\tlog_facility_ptr = &options->log_facility;\n\t\targ = strdelim(&s);\n\t\tvalue = log_facility_number(arg);\n\t\tif (value == SYSLOG_FACILITY_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log facility '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*log_facility_ptr == -1)\n\t\t\t*log_facility_ptr = (SyslogFacility) value;\n\t\tbreak;\n\n\tcase oLocalForward:\n\tcase oRemoteForward:\n\tcase oDynamicForward:\n\t\targ = strdelim(&s);\n\t\tif (arg == NULL || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing port argument.\",\n\t\t\t    filename, linenum);\n\n\t\tremotefwd = (opcode == oRemoteForward);\n\t\tdynamicfwd = (opcode == oDynamicForward);\n\n\t\tif (!dynamicfwd) {\n\t\t\targ2 = strdelim(&s);\n\t\t\tif (arg2 == NULL || *arg2 == '\\0') {\n\t\t\t\tif (remotefwd)\n\t\t\t\t\tdynamicfwd = 1;\n\t\t\t\telse\n\t\t\t\t\tfatal(\"%.200s line %d: Missing target \"\n\t\t\t\t\t    \"argument.\", filename, linenum);\n\t\t\t} else {\n\t\t\t\t/* construct a string for parse_forward */\n\t\t\t\tsnprintf(fwdarg, sizeof(fwdarg), \"%s:%s\", arg,\n\t\t\t\t    arg2);\n\t\t\t}\n\t\t}\n\t\tif (dynamicfwd)\n\t\t\tstrlcpy(fwdarg, arg, sizeof(fwdarg));\n\n\t\tif (parse_forward(&fwd, fwdarg, dynamicfwd, remotefwd) == 0)\n\t\t\tfatal(\"%.200s line %d: Bad forwarding specification.\",\n\t\t\t    filename, linenum);\n\n\t\tif (*activep) {\n\t\t\tif (remotefwd) {\n\t\t\t\tadd_remote_forward(options, &fwd);\n\t\t\t} else {\n\t\t\t\tadd_local_forward(options, &fwd);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase oClearAllForwardings:\n\t\tintptr = &options->clear_forwardings;\n\t\tgoto parse_flag;\n\n\tcase oHost:\n\t\tif (cmdline)\n\t\t\tfatal(\"Host directive not supported as a command-line \"\n\t\t\t    \"option\");\n\t\t*activep = 0;\n\t\targ2 = NULL;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\tif ((flags & SSHCONF_NEVERMATCH) != 0)\n\t\t\t\tbreak;\n\t\t\tnegated = *arg == '!';\n\t\t\tif (negated)\n\t\t\t\targ++;\n\t\t\tif (match_pattern(host, arg)) {\n\t\t\t\tif (negated) {\n\t\t\t\t\tdebug(\"%.200s line %d: Skipping Host \"\n\t\t\t\t\t    \"block because of negated match \"\n\t\t\t\t\t    \"for %.100s\", filename, linenum,\n\t\t\t\t\t    arg);\n\t\t\t\t\t*activep = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!*activep)\n\t\t\t\t\targ2 = arg; /* logged below */\n\t\t\t\t*activep = 1;\n\t\t\t}\n\t\t}\n\t\tif (*activep)\n\t\t\tdebug(\"%.200s line %d: Applying options for %.100s\",\n\t\t\t    filename, linenum, arg2);\n\t\t/* Avoid garbage check below, as strdelim is done. */\n\t\treturn 0;\n\n\tcase oMatch:\n\t\tif (cmdline)\n\t\t\tfatal(\"Host directive not supported as a command-line \"\n\t\t\t    \"option\");\n\t\tvalue = match_cfg_line(options, &s, pw, host, original_host,\n\t\t    flags & SSHCONF_POSTCANON, filename, linenum);\n\t\tif (value < 0)\n\t\t\tfatal(\"%.200s line %d: Bad Match condition\", filename,\n\t\t\t    linenum);\n\t\t*activep = (flags & SSHCONF_NEVERMATCH) ? 0 : value;\n\t\tbreak;\n\n\tcase oEscapeChar:\n\t\tintptr = &options->escape_char;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tif (strcmp(arg, \"none\") == 0)\n\t\t\tvalue = SSH_ESCAPECHAR_NONE;\n\t\telse if (arg[1] == '\\0')\n\t\t\tvalue = (u_char) arg[0];\n\t\telse if (arg[0] == '^' && arg[2] == 0 &&\n\t\t    (u_char) arg[1] >= 64 && (u_char) arg[1] < 128)\n\t\t\tvalue = (u_char) arg[1] & 31;\n\t\telse {\n\t\t\tfatal(\"%.200s line %d: Bad escape character.\",\n\t\t\t    filename, linenum);\n\t\t\t/* NOTREACHED */\n\t\t\tvalue = 0;\t/* Avoid compiler warning. */\n\t\t}\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oAddressFamily:\n\t\tintptr = &options->address_family;\n\t\tmultistate_ptr = multistate_addressfamily;\n\t\tgoto parse_multistate;\n\n\tcase oEnableSSHKeysign:\n\t\tintptr = &options->enable_ssh_keysign;\n\t\tgoto parse_flag;\n\n\tcase oIdentitiesOnly:\n\t\tintptr = &options->identities_only;\n\t\tgoto parse_flag;\n\n\tcase oServerAliveInterval:\n\t\tintptr = &options->server_alive_interval;\n\t\tgoto parse_time;\n\n\tcase oServerAliveCountMax:\n\t\tintptr = &options->server_alive_count_max;\n\t\tgoto parse_int;\n\n\tcase oSendEnv:\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') != NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment name.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tif (*arg == '-') {\n\t\t\t\t/* Removing an env var */\n\t\t\t\trm_env(options, arg, filename, linenum);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/* Adding an env var */\n\t\t\t\tif (options->num_send_env >= INT_MAX)\n\t\t\t\t\tfatal(\"%s line %d: too many send env.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\toptions->send_env = xrecallocarray(\n\t\t\t\t    options->send_env, options->num_send_env,\n\t\t\t\t    options->num_send_env + 1,\n\t\t\t\t    sizeof(*options->send_env));\n\t\t\t\toptions->send_env[options->num_send_env++] =\n\t\t\t\t    xstrdup(arg);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase oSetEnv:\n\t\tvalue = options->num_setenv;\n\t\twhile ((arg = strdelimw(&s)) != NULL && *arg != '\\0') {\n\t\t\tif (strchr(arg, '=') == NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid SetEnv.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep || value != 0)\n\t\t\t\tcontinue;\n\t\t\t/* Adding a setenv var */\n\t\t\tif (options->num_setenv >= INT_MAX)\n\t\t\t\tfatal(\"%s line %d: too many SetEnv.\",\n\t\t\t\t    filename, linenum);\n\t\t\toptions->setenv = xrecallocarray(\n\t\t\t    options->setenv, options->num_setenv,\n\t\t\t    options->num_setenv + 1, sizeof(*options->setenv));\n\t\t\toptions->setenv[options->num_setenv++] = xstrdup(arg);\n\t\t}\n\t\tbreak;\n\n\tcase oControlPath:\n\t\tcharptr = &options->control_path;\n\t\tgoto parse_string;\n\n\tcase oControlMaster:\n\t\tintptr = &options->control_master;\n\t\tmultistate_ptr = multistate_controlmaster;\n\t\tgoto parse_multistate;\n\n\tcase oControlPersist:\n\t\t/* no/false/yes/true, or a time spec */\n\t\tintptr = &options->control_persist;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing ControlPersist\"\n\t\t\t    \" argument.\", filename, linenum);\n\t\tvalue = 0;\n\t\tvalue2 = 0;\t/* timeout */\n\t\tif (strcmp(arg, \"no\") == 0 || strcmp(arg, \"false\") == 0)\n\t\t\tvalue = 0;\n\t\telse if (strcmp(arg, \"yes\") == 0 || strcmp(arg, \"true\") == 0)\n\t\t\tvalue = 1;\n\t\telse if ((value2 = convtime(arg)) >= 0)\n\t\t\tvalue = 1;\n\t\telse\n\t\t\tfatal(\"%.200s line %d: Bad ControlPersist argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1) {\n\t\t\t*intptr = value;\n\t\t\toptions->control_persist_timeout = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oHashKnownHosts:\n\t\tintptr = &options->hash_known_hosts;\n\t\tgoto parse_flag;\n\n\tcase oTunnel:\n\t\tintptr = &options->tun_open;\n\t\tmultistate_ptr = multistate_tunnel;\n\t\tgoto parse_multistate;\n\n\tcase oTunnelDevice:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\", filename, linenum);\n\t\tvalue = a2tun(arg, &value2);\n\t\tif (value == SSH_TUNID_ERR)\n\t\t\tfatal(\"%.200s line %d: Bad tun device.\", filename, linenum);\n\t\tif (*activep) {\n\t\t\toptions->tun_local = value;\n\t\t\toptions->tun_remote = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oLocalCommand:\n\t\tcharptr = &options->local_command;\n\t\tgoto parse_command;\n\n\tcase oPermitLocalCommand:\n\t\tintptr = &options->permit_local_command;\n\t\tgoto parse_flag;\n\n\tcase oRemoteCommand:\n\t\tcharptr = &options->remote_command;\n\t\tgoto parse_command;\n\n\tcase oVisualHostKey:\n\t\tintptr = &options->visual_host_key;\n\t\tgoto parse_flag;\n\n\tcase oInclude:\n\t\tif (cmdline)\n\t\t\tfatal(\"Include directive not supported as a \"\n\t\t\t    \"command-line option\");\n\t\tvalue = 0;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\t/*\n\t\t\t * Ensure all paths are anchored. User configuration\n\t\t\t * files may begin with '~/' but system configurations\n\t\t\t * must not. If the path is relative, then treat it\n\t\t\t * as living in ~/.ssh for user configurations or\n\t\t\t * /etc/ssh for system ones.\n\t\t\t */\n\t\t\tif (*arg == '~' && (flags & SSHCONF_USERCONF) == 0)\n\t\t\t\tfatal(\"%.200s line %d: bad include path %s.\",\n\t\t\t\t    filename, linenum, arg);\n\t\t\tif (*arg != '/' && *arg != '~') {\n\t\t\t\txasprintf(&arg2, \"%s/%s\",\n\t\t\t\t    (flags & SSHCONF_USERCONF) ?\n\t\t\t\t    \"~/\" _PATH_SSH_USER_DIR : SSHDIR, arg);\n\t\t\t} else\n\t\t\t\targ2 = xstrdup(arg);\n\t\t\tmemset(&gl, 0, sizeof(gl));\n\t\t\tr = glob(arg2, GLOB_TILDE, NULL, &gl);\n\t\t\tif (r == GLOB_NOMATCH) {\n\t\t\t\tdebug(\"%.200s line %d: include %s matched no \"\n\t\t\t\t    \"files\",filename, linenum, arg2);\n\t\t\t\tfree(arg2);\n\t\t\t\tcontinue;\n\t\t\t} else if (r != 0 || gl.gl_pathc < 0)\n\t\t\t\tfatal(\"%.200s line %d: glob failed for %s.\",\n\t\t\t\t    filename, linenum, arg2);\n\t\t\tfree(arg2);\n\t\t\toactive = *activep;\n\t\t\tfor (i = 0; i < (u_int)gl.gl_pathc; i++) {\n\t\t\t\tdebug3(\"%.200s line %d: Including file %s \"\n\t\t\t\t    \"depth %d%s\", filename, linenum,\n\t\t\t\t    gl.gl_pathv[i], depth,\n\t\t\t\t    oactive ? \"\" : \" (parse only)\");\n\t\t\t\tr = read_config_file_depth(gl.gl_pathv[i],\n\t\t\t\t    pw, host, original_host, options,\n\t\t\t\t    flags | SSHCONF_CHECKPERM |\n\t\t\t\t    (oactive ? 0 : SSHCONF_NEVERMATCH),\n\t\t\t\t    activep, depth + 1);\n\t\t\t\tif (r != 1 && errno != ENOENT) {\n\t\t\t\t\tfatal(\"Can't open user config file \"\n\t\t\t\t\t    \"%.100s: %.100s\", gl.gl_pathv[i],\n\t\t\t\t\t    strerror(errno));\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * don't let Match in includes clobber the\n\t\t\t\t * containing file's Match state.\n\t\t\t\t */\n\t\t\t\t*activep = oactive;\n\t\t\t\tif (r != 1)\n\t\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\tglobfree(&gl);\n\t\t}\n\t\tif (value != 0)\n\t\t\treturn value;\n\t\tbreak;\n\n\tcase oIPQoS:\n\t\targ = strdelim(&s);\n\t\tif ((value = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\targ = strdelim(&s);\n\t\tif (arg == NULL)\n\t\t\tvalue2 = value;\n\t\telse if ((value2 = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep) {\n\t\t\toptions->ip_qos_interactive = value;\n\t\t\toptions->ip_qos_bulk = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oRequestTTY:\n\t\tintptr = &options->request_tty;\n\t\tmultistate_ptr = multistate_requesttty;\n\t\tgoto parse_multistate;\n\n\tcase oIgnoreUnknown:\n\t\tcharptr = &options->ignored_unknown;\n\t\tgoto parse_string;\n\n\tcase oProxyUseFdpass:\n\t\tintptr = &options->proxy_use_fdpass;\n\t\tgoto parse_flag;\n\n\tcase oCanonicalDomains:\n\t\tvalue = options->num_canonical_domains != 0;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\tif (!valid_domain(arg, 1, &errstr)) {\n\t\t\t\tfatal(\"%s line %d: %s\", filename, linenum,\n\t\t\t\t    errstr);\n\t\t\t}\n\t\t\tif (!*activep || value)\n\t\t\t\tcontinue;\n\t\t\tif (options->num_canonical_domains >= MAX_CANON_DOMAINS)\n\t\t\t\tfatal(\"%s line %d: too many hostname suffixes.\",\n\t\t\t\t    filename, linenum);\n\t\t\toptions->canonical_domains[\n\t\t\t    options->num_canonical_domains++] = xstrdup(arg);\n\t\t}\n\t\tbreak;\n\n\tcase oCanonicalizePermittedCNAMEs:\n\t\tvalue = options->num_permitted_cnames != 0;\n\t\twhile ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\t\t/* Either '*' for everything or 'list:list' */\n\t\t\tif (strcmp(arg, \"*\") == 0)\n\t\t\t\targ2 = arg;\n\t\t\telse {\n\t\t\t\tlowercase(arg);\n\t\t\t\tif ((arg2 = strchr(arg, ':')) == NULL ||\n\t\t\t\t    arg2[1] == '\\0') {\n\t\t\t\t\tfatal(\"%s line %d: \"\n\t\t\t\t\t    \"Invalid permitted CNAME \\\"%s\\\"\",\n\t\t\t\t\t    filename, linenum, arg);\n\t\t\t\t}\n\t\t\t\t*arg2 = '\\0';\n\t\t\t\targ2++;\n\t\t\t}\n\t\t\tif (!*activep || value)\n\t\t\t\tcontinue;\n\t\t\tif (options->num_permitted_cnames >= MAX_CANON_DOMAINS)\n\t\t\t\tfatal(\"%s line %d: too many permitted CNAMEs.\",\n\t\t\t\t    filename, linenum);\n\t\t\tcname = options->permitted_cnames +\n\t\t\t    options->num_permitted_cnames++;\n\t\t\tcname->source_list = xstrdup(arg);\n\t\t\tcname->target_list = xstrdup(arg2);\n\t\t}\n\t\tbreak;\n\n\tcase oCanonicalizeHostname:\n\t\tintptr = &options->canonicalize_hostname;\n\t\tmultistate_ptr = multistate_canonicalizehostname;\n\t\tgoto parse_multistate;\n\n\tcase oCanonicalizeMaxDots:\n\t\tintptr = &options->canonicalize_max_dots;\n\t\tgoto parse_int;\n\n\tcase oCanonicalizeFallbackLocal:\n\t\tintptr = &options->canonicalize_fallback_local;\n\t\tgoto parse_flag;\n\n\tcase oStreamLocalBindMask:\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing StreamLocalBindMask argument.\", filename, linenum);\n\t\t/* Parse mode in octal format */\n\t\tvalue = strtol(arg, &endofnumber, 8);\n\t\tif (arg == endofnumber || value < 0 || value > 0777)\n\t\t\tfatal(\"%.200s line %d: Bad mask.\", filename, linenum);\n\t\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)value;\n\t\tbreak;\n\n\tcase oStreamLocalBindUnlink:\n\t\tintptr = &options->fwd_opts.streamlocal_bind_unlink;\n\t\tgoto parse_flag;\n\n\tcase oRevokedHostKeys:\n\t\tcharptr = &options->revoked_host_keys;\n\t\tgoto parse_string;\n\n\tcase oFingerprintHash:\n\t\tintptr = &options->fingerprint_hash;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = ssh_digest_alg_by_name(arg)) == -1)\n\t\t\tfatal(\"%.200s line %d: Invalid hash algorithm \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oUpdateHostkeys:\n\t\tintptr = &options->update_hostkeys;\n\t\tmultistate_ptr = multistate_yesnoask;\n\t\tgoto parse_multistate;\n\n\tcase oHostbasedKeyTypes:\n\t\tcharptr = &options->hostbased_key_types;\n\t\tgoto parse_keytypes;\n\n\tcase oPubkeyAcceptedKeyTypes:\n\t\tcharptr = &options->pubkey_key_types;\n\t\tgoto parse_keytypes;\n\n\tcase oAddKeysToAgent:\n\t\tintptr = &options->add_keys_to_agent;\n\t\tmultistate_ptr = multistate_yesnoaskconfirm;\n\t\tgoto parse_multistate;\n\n\tcase oIdentityAgent:\n\t\tcharptr = &options->identity_agent;\n\t\targ = strdelim(&s);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t/* Extra validation if the string represents an env var. */\n\t\tif (arg[0] == '$' && !valid_env_name(arg + 1)) {\n\t\t\tfatal(\"%.200s line %d: Invalid environment name %s.\",\n\t\t\t    filename, linenum, arg);\n\t\t}\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oDeprecated:\n\t\tdebug(\"%s line %d: Deprecated option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn 0;\n\n\tcase oUnsupported:\n\t\terror(\"%s line %d: Unsupported option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn 0;\n\n\tdefault:\n\t\tfatal(\"%s: Unimplemented opcode %d\", __func__, opcode);\n\t}\n\n\t/* Check that there is no garbage at end of line. */\n\tif ((arg = strdelim(&s)) != NULL && *arg != '\\0') {\n\t\tfatal(\"%.200s line %d: garbage at end of line; \\\"%.200s\\\".\",\n\t\t    filename, linenum, arg);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nprocess_config_line(Options *options, struct passwd *pw, const char *host,\n    const char *original_host, char *line, const char *filename,\n    int linenum, int *activep, int flags)\n{\n\treturn process_config_line_depth(options, pw, host, original_host,\n\t    line, filename, linenum, activep, flags, 0);\n}"
  },
  {
    "function_name": "parse_token",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "718-733",
    "snippet": "static OpCodes\nparse_token(const char *cp, const char *filename, int linenum,\n    const char *ignored_unknown)\n{\n\tint i;\n\n\tfor (i = 0; keywords[i].name; i++)\n\t\tif (strcmp(cp, keywords[i].name) == 0)\n\t\t\treturn keywords[i].opcode;\n\tif (ignored_unknown != NULL &&\n\t    match_pattern_list(cp, ignored_unknown, 1) == 1)\n\t\treturn oIgnoredUnknownOption;\n\terror(\"%s: line %d: Bad configuration option: %s\",\n\t    filename, linenum, cp);\n\treturn oBadOption;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t/* Deprecated options */\n\t{ \"protocol\", oIgnore }, /* NB. silently ignored */\n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t/* Unsupported options */\n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\n\t/* Sometimes-unsupported options */\n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"smartcarddevice\", oPKCS11Provider },\n\t{ \"pkcs11provider\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t    /* alias */\n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"challengeresponseauthentication\", oChallengeResponseAuthentication },\n\t{ \"skeyauthentication\", oUnsupported },\n\t{ \"tisauthentication\", oChallengeResponseAuthentication },  /* alias */\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t/* obsolete */\n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostName },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t/* obsolete */\n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedkeytypes\", oHostbasedKeyTypes },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedKeyTypes },\n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\n\t{ NULL, oBadOption }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: line %d: Bad configuration option: %s\"",
            "filename",
            "linenum",
            "cp"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_pattern_list",
          "args": [
            "cp",
            "ignored_unknown",
            "1"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "120-171",
          "snippet": "int\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cp",
            "keywords[i].name"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t/* Deprecated options */\n\t{ \"protocol\", oIgnore }, /* NB. silently ignored */\n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t/* Unsupported options */\n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\n\t/* Sometimes-unsupported options */\n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"smartcarddevice\", oPKCS11Provider },\n\t{ \"pkcs11provider\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t    /* alias */\n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"challengeresponseauthentication\", oChallengeResponseAuthentication },\n\t{ \"skeyauthentication\", oUnsupported },\n\t{ \"tisauthentication\", oChallengeResponseAuthentication },  /* alias */\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t/* obsolete */\n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostName },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t/* obsolete */\n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedkeytypes\", oHostbasedKeyTypes },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedKeyTypes },\n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\n\t{ NULL, oBadOption }\n};\n\nstatic OpCodes\nparse_token(const char *cp, const char *filename, int linenum,\n    const char *ignored_unknown)\n{\n\tint i;\n\n\tfor (i = 0; keywords[i].name; i++)\n\t\tif (strcmp(cp, keywords[i].name) == 0)\n\t\t\treturn keywords[i].opcode;\n\tif (ignored_unknown != NULL &&\n\t    match_pattern_list(cp, ignored_unknown, 1) == 1)\n\t\treturn oIgnoredUnknownOption;\n\terror(\"%s: line %d: Bad configuration option: %s\",\n\t    filename, linenum, cp);\n\treturn oBadOption;\n}"
  },
  {
    "function_name": "rm_env",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "687-713",
    "snippet": "static void\nrm_env(Options *options, const char *arg, const char *filename, int linenum)\n{\n\tint i, j;\n\tchar *cp;\n\n\t/* Remove an environment variable */\n\tfor (i = 0; i < options->num_send_env; ) {\n\t\tcp = xstrdup(options->send_env[i]);\n\t\tif (!match_pattern(cp, arg + 1)) {\n\t\t\tfree(cp);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tdebug3(\"%s line %d: removing environment %s\",\n\t\t    filename, linenum, cp);\n\t\tfree(cp);\n\t\tfree(options->send_env[i]);\n\t\toptions->send_env[i] = NULL;\n\t\tfor (j = i; j < options->num_send_env - 1; j++) {\n\t\t\toptions->send_env[j] = options->send_env[j + 1];\n\t\t\toptions->send_env[j + 1] = NULL;\n\t\t}\n\t\toptions->num_send_env--;\n\t\t/* NB. don't increment i */\n\t}\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "options->send_env[i]"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s line %d: removing environment %s\"",
            "filename",
            "linenum",
            "cp"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_pattern",
          "args": [
            "cp",
            "arg + 1"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "56-112",
          "snippet": "int\nmatch_pattern(const char *s, const char *pattern)\n{\n\tfor (;;) {\n\t\t/* If at end of pattern, accept if also at end of string. */\n\t\tif (!*pattern)\n\t\t\treturn !*s;\n\n\t\tif (*pattern == '*') {\n\t\t\t/* Skip the asterisk. */\n\t\t\tpattern++;\n\n\t\t\t/* If at end of pattern, accept immediately. */\n\t\t\tif (!*pattern)\n\t\t\t\treturn 1;\n\n\t\t\t/* If next character in pattern is known, optimize. */\n\t\t\tif (*pattern != '?' && *pattern != '*') {\n\t\t\t\t/*\n\t\t\t\t * Look instances of the next character in\n\t\t\t\t * pattern, and try to match starting from\n\t\t\t\t * those.\n\t\t\t\t */\n\t\t\t\tfor (; *s; s++)\n\t\t\t\t\tif (*s == *pattern &&\n\t\t\t\t\t    match_pattern(s + 1, pattern + 1))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t/* Failed. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Move ahead one character at a time and try to\n\t\t\t * match at each position.\n\t\t\t */\n\t\t\tfor (; *s; s++)\n\t\t\t\tif (match_pattern(s, pattern))\n\t\t\t\t\treturn 1;\n\t\t\t/* Failed. */\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * There must be at least one more character in the string.\n\t\t * If we are at the end, fail.\n\t\t */\n\t\tif (!*s)\n\t\t\treturn 0;\n\n\t\t/* Check if the next character of the string is acceptable. */\n\t\tif (*pattern != '?' && *pattern != *s)\n\t\t\treturn 0;\n\n\t\t/* Move to the next character, both in string and in pattern. */\n\t\ts++;\n\t\tpattern++;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern(const char *s, const char *pattern)\n{\n\tfor (;;) {\n\t\t/* If at end of pattern, accept if also at end of string. */\n\t\tif (!*pattern)\n\t\t\treturn !*s;\n\n\t\tif (*pattern == '*') {\n\t\t\t/* Skip the asterisk. */\n\t\t\tpattern++;\n\n\t\t\t/* If at end of pattern, accept immediately. */\n\t\t\tif (!*pattern)\n\t\t\t\treturn 1;\n\n\t\t\t/* If next character in pattern is known, optimize. */\n\t\t\tif (*pattern != '?' && *pattern != '*') {\n\t\t\t\t/*\n\t\t\t\t * Look instances of the next character in\n\t\t\t\t * pattern, and try to match starting from\n\t\t\t\t * those.\n\t\t\t\t */\n\t\t\t\tfor (; *s; s++)\n\t\t\t\t\tif (*s == *pattern &&\n\t\t\t\t\t    match_pattern(s + 1, pattern + 1))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t/* Failed. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Move ahead one character at a time and try to\n\t\t\t * match at each position.\n\t\t\t */\n\t\t\tfor (; *s; s++)\n\t\t\t\tif (match_pattern(s, pattern))\n\t\t\t\t\treturn 1;\n\t\t\t/* Failed. */\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * There must be at least one more character in the string.\n\t\t * If we are at the end, fail.\n\t\t */\n\t\tif (!*s)\n\t\t\treturn 0;\n\n\t\t/* Check if the next character of the string is acceptable. */\n\t\tif (*pattern != '?' && *pattern != *s)\n\t\t\treturn 0;\n\n\t\t/* Move to the next character, both in string and in pattern. */\n\t\ts++;\n\t\tpattern++;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "options->send_env[i]"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nrm_env(Options *options, const char *arg, const char *filename, int linenum)\n{\n\tint i, j;\n\tchar *cp;\n\n\t/* Remove an environment variable */\n\tfor (i = 0; i < options->num_send_env; ) {\n\t\tcp = xstrdup(options->send_env[i]);\n\t\tif (!match_pattern(cp, arg + 1)) {\n\t\t\tfree(cp);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tdebug3(\"%s line %d: removing environment %s\",\n\t\t    filename, linenum, cp);\n\t\tfree(cp);\n\t\tfree(options->send_env[i]);\n\t\toptions->send_env[i] = NULL;\n\t\tfor (j = i; j < options->num_send_env - 1; j++) {\n\t\t\toptions->send_env[j] = options->send_env[j + 1];\n\t\t\toptions->send_env[j + 1] = NULL;\n\t\t}\n\t\toptions->num_send_env--;\n\t\t/* NB. don't increment i */\n\t}\n}"
  },
  {
    "function_name": "match_cfg_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "540-684",
    "snippet": "static int\nmatch_cfg_line(Options *options, char **condition, struct passwd *pw,\n    const char *host_arg, const char *original_host, int post_canon,\n    const char *filename, int linenum)\n{\n\tchar *arg, *oattrib, *attrib, *cmd, *cp = *condition, *host, *criteria;\n\tconst char *ruser;\n\tint r, port, this_result, result = 1, attributes = 0, negate;\n\tchar thishost[NI_MAXHOST], shorthost[NI_MAXHOST], portstr[NI_MAXSERV];\n\tchar uidstr[32];\n\n\t/*\n\t * Configuration is likely to be incomplete at this point so we\n\t * must be prepared to use default values.\n\t */\n\tport = options->port <= 0 ? default_ssh_port() : options->port;\n\truser = options->user == NULL ? pw->pw_name : options->user;\n\tif (post_canon) {\n\t\thost = xstrdup(options->hostname);\n\t} else if (options->hostname != NULL) {\n\t\t/* NB. Please keep in sync with ssh.c:main() */\n\t\thost = percent_expand(options->hostname,\n\t\t    \"h\", host_arg, (char *)NULL);\n\t} else {\n\t\thost = xstrdup(host_arg);\n\t}\n\n\tdebug2(\"checking match for '%s' host %s originally %s\",\n\t    cp, host, original_host);\n\twhile ((oattrib = attrib = strdelim(&cp)) && *attrib != '\\0') {\n\t\tcriteria = NULL;\n\t\tthis_result = 1;\n\t\tif ((negate = attrib[0] == '!'))\n\t\t\tattrib++;\n\t\t/* criteria \"all\" and \"canonical\" have no argument */\n\t\tif (strcasecmp(attrib, \"all\") == 0) {\n\t\t\tif (attributes > 1 ||\n\t\t\t    ((arg = strdelim(&cp)) != NULL && *arg != '\\0')) {\n\t\t\t\terror(\"%.200s line %d: '%s' cannot be combined \"\n\t\t\t\t    \"with other Match attributes\",\n\t\t\t\t    filename, linenum, oattrib);\n\t\t\t\tresult = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (result)\n\t\t\t\tresult = negate ? 0 : 1;\n\t\t\tgoto out;\n\t\t}\n\t\tattributes++;\n\t\tif (strcasecmp(attrib, \"canonical\") == 0) {\n\t\t\tr = !!post_canon;  /* force bitmask member to boolean */\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t\tdebug3(\"%.200s line %d: %smatched '%s'\",\n\t\t\t    filename, linenum,\n\t\t\t    this_result ? \"\" : \"not \", oattrib);\n\t\t\tcontinue;\n\t\t}\n\t\t/* All other criteria require an argument */\n\t\tif ((arg = strdelim(&cp)) == NULL || *arg == '\\0') {\n\t\t\terror(\"Missing Match criteria for %s\", attrib);\n\t\t\tresult = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcasecmp(attrib, \"host\") == 0) {\n\t\t\tcriteria = xstrdup(host);\n\t\t\tr = match_hostname(host, arg) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"originalhost\") == 0) {\n\t\t\tcriteria = xstrdup(original_host);\n\t\t\tr = match_hostname(original_host, arg) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"user\") == 0) {\n\t\t\tcriteria = xstrdup(ruser);\n\t\t\tr = match_pattern_list(ruser, arg, 0) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"localuser\") == 0) {\n\t\t\tcriteria = xstrdup(pw->pw_name);\n\t\t\tr = match_pattern_list(pw->pw_name, arg, 0) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"exec\") == 0) {\n\t\t\tif (gethostname(thishost, sizeof(thishost)) == -1)\n\t\t\t\tfatal(\"gethostname: %s\", strerror(errno));\n\t\t\tstrlcpy(shorthost, thishost, sizeof(shorthost));\n\t\t\tshorthost[strcspn(thishost, \".\")] = '\\0';\n\t\t\tsnprintf(portstr, sizeof(portstr), \"%d\", port);\n\t\t\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t\t\t    (unsigned long long)pw->pw_uid);\n\n\t\t\tcmd = percent_expand(arg,\n\t\t\t    \"L\", shorthost,\n\t\t\t    \"d\", pw->pw_dir,\n\t\t\t    \"h\", host,\n\t\t\t    \"l\", thishost,\n\t\t\t    \"n\", original_host,\n\t\t\t    \"p\", portstr,\n\t\t\t    \"r\", ruser,\n\t\t\t    \"u\", pw->pw_name,\n\t\t\t    \"i\", uidstr,\n\t\t\t    (char *)NULL);\n\t\t\tif (result != 1) {\n\t\t\t\t/* skip execution if prior predicate failed */\n\t\t\t\tdebug3(\"%.200s line %d: skipped exec \"\n\t\t\t\t    \"\\\"%.100s\\\"\", filename, linenum, cmd);\n\t\t\t\tfree(cmd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr = execute_in_shell(cmd);\n\t\t\tif (r == -1) {\n\t\t\t\tfatal(\"%.200s line %d: match exec \"\n\t\t\t\t    \"'%.100s' error\", filename,\n\t\t\t\t    linenum, cmd);\n\t\t\t}\n\t\t\tcriteria = xstrdup(cmd);\n\t\t\tfree(cmd);\n\t\t\t/* Force exit status to boolean */\n\t\t\tr = r == 0;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else {\n\t\t\terror(\"Unsupported Match attribute %s\", attrib);\n\t\t\tresult = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tdebug3(\"%.200s line %d: %smatched '%s \\\"%.100s\\\"' \",\n\t\t    filename, linenum, this_result ? \"\": \"not \",\n\t\t    oattrib, criteria);\n\t\tfree(criteria);\n\t}\n\tif (attributes == 0) {\n\t\terror(\"One or more attributes required for Match\");\n\t\tresult = -1;\n\t\tgoto out;\n\t}\n out:\n\tif (result != -1)\n\t\tdebug2(\"match %sfound\", result ? \"\" : \"not \");\n\t*condition = cp;\n\tfree(host);\n\treturn result;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "host"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"match %sfound\"",
            "result ? \"\" : \"not \""
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"One or more attributes required for Match\""
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%.200s line %d: %smatched '%s \\\"%.100s\\\"' \"",
            "filename",
            "linenum",
            "this_result ? \"\": \"not \"",
            "oattrib",
            "criteria"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "cmd"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%.200s line %d: match exec \"\n\t\t\t\t    \"'%.100s' error\"",
            "filename",
            "linenum",
            "cmd"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute_in_shell",
          "args": [
            "cmd"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "execute_in_shell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "478-535",
          "snippet": "static int\nexecute_in_shell(const char *cmd)\n{\n\tchar *shell;\n\tpid_t pid;\n\tint devnull, status;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL)\n\t\tshell = _PATH_BSHELL;\n\n\t/* Need this to redirect subprocess stdin/out */\n\tif ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1)\n\t\tfatal(\"open(/dev/null): %s\", strerror(errno));\n\n\tdebug(\"Executing command: '%.500s'\", cmd);\n\n\t/* Fork and execute the command. */\n\tif ((pid = fork()) == 0) {\n\t\tchar *argv[4];\n\n\t\t/* Redirect child stdin and stdout. Leave stderr */\n\t\tif (dup2(devnull, STDIN_FILENO) == -1)\n\t\t\tfatal(\"dup2: %s\", strerror(errno));\n\t\tif (dup2(devnull, STDOUT_FILENO) == -1)\n\t\t\tfatal(\"dup2: %s\", strerror(errno));\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t\tclosefrom(STDERR_FILENO + 1);\n\n\t\targv[0] = shell;\n\t\targv[1] = \"-c\";\n\t\targv[2] = xstrdup(cmd);\n\t\targv[3] = NULL;\n\n\t\texecv(argv[0], argv);\n\t\terror(\"Unable to execute '%.100s': %s\", cmd, strerror(errno));\n\t\t/* Die with signal to make this error apparent to parent. */\n\t\tsignal(SIGTERM, SIG_DFL);\n\t\tkill(getpid(), SIGTERM);\n\t\t_exit(1);\n\t}\n\t/* Parent. */\n\tif (pid < 0)\n\t\tfatal(\"%s: fork: %.100s\", __func__, strerror(errno));\n\n\tclose(devnull);\n\n\twhile (waitpid(pid, &status, 0) == -1) {\n\t\tif (errno != EINTR && errno != EAGAIN)\n\t\t\tfatal(\"%s: waitpid: %s\", __func__, strerror(errno));\n\t}\n\tif (!WIFEXITED(status)) {\n\t\terror(\"command '%.100s' exited abnormally\", cmd);\n\t\treturn -1;\n\t}\n\tdebug3(\"command returned status %d\", WEXITSTATUS(status));\n\treturn WEXITSTATUS(status);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nexecute_in_shell(const char *cmd)\n{\n\tchar *shell;\n\tpid_t pid;\n\tint devnull, status;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL)\n\t\tshell = _PATH_BSHELL;\n\n\t/* Need this to redirect subprocess stdin/out */\n\tif ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1)\n\t\tfatal(\"open(/dev/null): %s\", strerror(errno));\n\n\tdebug(\"Executing command: '%.500s'\", cmd);\n\n\t/* Fork and execute the command. */\n\tif ((pid = fork()) == 0) {\n\t\tchar *argv[4];\n\n\t\t/* Redirect child stdin and stdout. Leave stderr */\n\t\tif (dup2(devnull, STDIN_FILENO) == -1)\n\t\t\tfatal(\"dup2: %s\", strerror(errno));\n\t\tif (dup2(devnull, STDOUT_FILENO) == -1)\n\t\t\tfatal(\"dup2: %s\", strerror(errno));\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t\tclosefrom(STDERR_FILENO + 1);\n\n\t\targv[0] = shell;\n\t\targv[1] = \"-c\";\n\t\targv[2] = xstrdup(cmd);\n\t\targv[3] = NULL;\n\n\t\texecv(argv[0], argv);\n\t\terror(\"Unable to execute '%.100s': %s\", cmd, strerror(errno));\n\t\t/* Die with signal to make this error apparent to parent. */\n\t\tsignal(SIGTERM, SIG_DFL);\n\t\tkill(getpid(), SIGTERM);\n\t\t_exit(1);\n\t}\n\t/* Parent. */\n\tif (pid < 0)\n\t\tfatal(\"%s: fork: %.100s\", __func__, strerror(errno));\n\n\tclose(devnull);\n\n\twhile (waitpid(pid, &status, 0) == -1) {\n\t\tif (errno != EINTR && errno != EAGAIN)\n\t\t\tfatal(\"%s: waitpid: %s\", __func__, strerror(errno));\n\t}\n\tif (!WIFEXITED(status)) {\n\t\terror(\"command '%.100s' exited abnormally\", cmd);\n\t\treturn -1;\n\t}\n\tdebug3(\"command returned status %d\", WEXITSTATUS(status));\n\treturn WEXITSTATUS(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percent_expand",
          "args": [
            "arg",
            "\"L\"",
            "shorthost",
            "\"d\"",
            "pw->pw_dir",
            "\"h\"",
            "host",
            "\"l\"",
            "thishost",
            "\"n\"",
            "original_host",
            "\"p\"",
            "portstr",
            "\"r\"",
            "ruser",
            "\"u\"",
            "pw->pw_name",
            "\"i\"",
            "uidstr",
            "(char *)NULL"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "percent_expand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "973-1029",
          "snippet": "char *\npercent_expand(const char *string, ...)\n{\n#define EXPAND_MAX_KEYS\t16\n\tu_int num_keys, i, j;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tchar buf[4096];\n\tva_list ap;\n\n\t/* Gather keys */\n\tva_start(ap, string);\n\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\tif (keys[num_keys].key == NULL)\n\t\t\tbreak;\n\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\tif (keys[num_keys].repl == NULL)\n\t\t\tfatal(\"%s: NULL replacement\", __func__);\n\t}\n\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\tfatal(\"%s: too many keys\", __func__);\n\tva_end(ap);\n\n\t/* Expand string */\n\t*buf = '\\0';\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\tif (*string != '%') {\n append:\n\t\t\tbuf[i++] = *string;\n\t\t\tif (i >= sizeof(buf))\n\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\tbuf[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0')\n\t\t\tfatal(\"%s: invalid format\", __func__);\n\t\tfor (j = 0; j < num_keys; j++) {\n\t\t\tif (strchr(keys[j].key, *string) != NULL) {\n\t\t\t\ti = strlcat(buf, keys[j].repl, sizeof(buf));\n\t\t\t\tif (i >= sizeof(buf))\n\t\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= num_keys)\n\t\t\tfatal(\"%s: unknown key %%%c\", __func__, *string);\n\t}\n\treturn (xstrdup(buf));\n#undef EXPAND_MAX_KEYS\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define EXPAND_MAX_KEYS\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define EXPAND_MAX_KEYS\t16\n\nchar *\npercent_expand(const char *string, ...)\n{\n#define EXPAND_MAX_KEYS\t16\n\tu_int num_keys, i, j;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tchar buf[4096];\n\tva_list ap;\n\n\t/* Gather keys */\n\tva_start(ap, string);\n\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\tif (keys[num_keys].key == NULL)\n\t\t\tbreak;\n\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\tif (keys[num_keys].repl == NULL)\n\t\t\tfatal(\"%s: NULL replacement\", __func__);\n\t}\n\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\tfatal(\"%s: too many keys\", __func__);\n\tva_end(ap);\n\n\t/* Expand string */\n\t*buf = '\\0';\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\tif (*string != '%') {\n append:\n\t\t\tbuf[i++] = *string;\n\t\t\tif (i >= sizeof(buf))\n\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\tbuf[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0')\n\t\t\tfatal(\"%s: invalid format\", __func__);\n\t\tfor (j = 0; j < num_keys; j++) {\n\t\t\tif (strchr(keys[j].key, *string) != NULL) {\n\t\t\t\ti = strlcat(buf, keys[j].repl, sizeof(buf));\n\t\t\t\tif (i >= sizeof(buf))\n\t\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= num_keys)\n\t\t\tfatal(\"%s: unknown key %%%c\", __func__, *string);\n\t}\n\treturn (xstrdup(buf));\n#undef EXPAND_MAX_KEYS\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "uidstr",
            "sizeof(uidstr)",
            "\"%llu\"",
            "(unsigned long long)pw->pw_uid"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "thishost",
            "\".\""
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "shorthost",
            "thishost",
            "sizeof(shorthost)"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"gethostname: %s\"",
            "strerror(errno)"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gethostname",
          "args": [
            "thishost",
            "sizeof(thishost)"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "attrib",
            "\"exec\""
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_pattern_list",
          "args": [
            "pw->pw_name",
            "arg",
            "0"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "120-171",
          "snippet": "int\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "attrib",
            "\"localuser\""
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "attrib",
            "\"user\""
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_hostname",
          "args": [
            "original_host",
            "arg"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "match_hostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "179-189",
          "snippet": "int\nmatch_hostname(const char *host, const char *pattern)\n{\n\tchar *hostcopy = xstrdup(host);\n\tint r;\n\n\tlowercase(hostcopy);\n\tr = match_pattern_list(hostcopy, pattern, 1);\n\tfree(hostcopy);\n\treturn r;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_hostname(const char *host, const char *pattern)\n{\n\tchar *hostcopy = xstrdup(host);\n\tint r;\n\n\tlowercase(hostcopy);\n\tr = match_pattern_list(hostcopy, pattern, 1);\n\tfree(hostcopy);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "attrib",
            "\"originalhost\""
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "attrib",
            "\"host\""
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdelim",
          "args": [
            "&cp"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "strdelimw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "296-300",
          "snippet": "char *\nstrdelimw(char **s)\n{\n\treturn strdelim_internal(s, 0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nstrdelimw(char **s)\n{\n\treturn strdelim_internal(s, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "attrib",
            "\"canonical\""
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "attrib",
            "\"all\""
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "default_ssh_port",
          "args": [],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "default_ssh_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "461-472",
          "snippet": "int\ndefault_ssh_port(void)\n{\n\tstatic int port;\n\tstruct servent *sp;\n\n\tif (port == 0) {\n\t\tsp = getservbyname(SSH_SERVICE_NAME, \"tcp\");\n\t\tport = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;\n\t}\n\treturn port;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndefault_ssh_port(void)\n{\n\tstatic int port;\n\tstruct servent *sp;\n\n\tif (port == 0) {\n\t\tsp = getservbyname(SSH_SERVICE_NAME, \"tcp\");\n\t\tport = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;\n\t}\n\treturn port;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nmatch_cfg_line(Options *options, char **condition, struct passwd *pw,\n    const char *host_arg, const char *original_host, int post_canon,\n    const char *filename, int linenum)\n{\n\tchar *arg, *oattrib, *attrib, *cmd, *cp = *condition, *host, *criteria;\n\tconst char *ruser;\n\tint r, port, this_result, result = 1, attributes = 0, negate;\n\tchar thishost[NI_MAXHOST], shorthost[NI_MAXHOST], portstr[NI_MAXSERV];\n\tchar uidstr[32];\n\n\t/*\n\t * Configuration is likely to be incomplete at this point so we\n\t * must be prepared to use default values.\n\t */\n\tport = options->port <= 0 ? default_ssh_port() : options->port;\n\truser = options->user == NULL ? pw->pw_name : options->user;\n\tif (post_canon) {\n\t\thost = xstrdup(options->hostname);\n\t} else if (options->hostname != NULL) {\n\t\t/* NB. Please keep in sync with ssh.c:main() */\n\t\thost = percent_expand(options->hostname,\n\t\t    \"h\", host_arg, (char *)NULL);\n\t} else {\n\t\thost = xstrdup(host_arg);\n\t}\n\n\tdebug2(\"checking match for '%s' host %s originally %s\",\n\t    cp, host, original_host);\n\twhile ((oattrib = attrib = strdelim(&cp)) && *attrib != '\\0') {\n\t\tcriteria = NULL;\n\t\tthis_result = 1;\n\t\tif ((negate = attrib[0] == '!'))\n\t\t\tattrib++;\n\t\t/* criteria \"all\" and \"canonical\" have no argument */\n\t\tif (strcasecmp(attrib, \"all\") == 0) {\n\t\t\tif (attributes > 1 ||\n\t\t\t    ((arg = strdelim(&cp)) != NULL && *arg != '\\0')) {\n\t\t\t\terror(\"%.200s line %d: '%s' cannot be combined \"\n\t\t\t\t    \"with other Match attributes\",\n\t\t\t\t    filename, linenum, oattrib);\n\t\t\t\tresult = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (result)\n\t\t\t\tresult = negate ? 0 : 1;\n\t\t\tgoto out;\n\t\t}\n\t\tattributes++;\n\t\tif (strcasecmp(attrib, \"canonical\") == 0) {\n\t\t\tr = !!post_canon;  /* force bitmask member to boolean */\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t\tdebug3(\"%.200s line %d: %smatched '%s'\",\n\t\t\t    filename, linenum,\n\t\t\t    this_result ? \"\" : \"not \", oattrib);\n\t\t\tcontinue;\n\t\t}\n\t\t/* All other criteria require an argument */\n\t\tif ((arg = strdelim(&cp)) == NULL || *arg == '\\0') {\n\t\t\terror(\"Missing Match criteria for %s\", attrib);\n\t\t\tresult = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcasecmp(attrib, \"host\") == 0) {\n\t\t\tcriteria = xstrdup(host);\n\t\t\tr = match_hostname(host, arg) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"originalhost\") == 0) {\n\t\t\tcriteria = xstrdup(original_host);\n\t\t\tr = match_hostname(original_host, arg) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"user\") == 0) {\n\t\t\tcriteria = xstrdup(ruser);\n\t\t\tr = match_pattern_list(ruser, arg, 0) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"localuser\") == 0) {\n\t\t\tcriteria = xstrdup(pw->pw_name);\n\t\t\tr = match_pattern_list(pw->pw_name, arg, 0) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"exec\") == 0) {\n\t\t\tif (gethostname(thishost, sizeof(thishost)) == -1)\n\t\t\t\tfatal(\"gethostname: %s\", strerror(errno));\n\t\t\tstrlcpy(shorthost, thishost, sizeof(shorthost));\n\t\t\tshorthost[strcspn(thishost, \".\")] = '\\0';\n\t\t\tsnprintf(portstr, sizeof(portstr), \"%d\", port);\n\t\t\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t\t\t    (unsigned long long)pw->pw_uid);\n\n\t\t\tcmd = percent_expand(arg,\n\t\t\t    \"L\", shorthost,\n\t\t\t    \"d\", pw->pw_dir,\n\t\t\t    \"h\", host,\n\t\t\t    \"l\", thishost,\n\t\t\t    \"n\", original_host,\n\t\t\t    \"p\", portstr,\n\t\t\t    \"r\", ruser,\n\t\t\t    \"u\", pw->pw_name,\n\t\t\t    \"i\", uidstr,\n\t\t\t    (char *)NULL);\n\t\t\tif (result != 1) {\n\t\t\t\t/* skip execution if prior predicate failed */\n\t\t\t\tdebug3(\"%.200s line %d: skipped exec \"\n\t\t\t\t    \"\\\"%.100s\\\"\", filename, linenum, cmd);\n\t\t\t\tfree(cmd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr = execute_in_shell(cmd);\n\t\t\tif (r == -1) {\n\t\t\t\tfatal(\"%.200s line %d: match exec \"\n\t\t\t\t    \"'%.100s' error\", filename,\n\t\t\t\t    linenum, cmd);\n\t\t\t}\n\t\t\tcriteria = xstrdup(cmd);\n\t\t\tfree(cmd);\n\t\t\t/* Force exit status to boolean */\n\t\t\tr = r == 0;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else {\n\t\t\terror(\"Unsupported Match attribute %s\", attrib);\n\t\t\tresult = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tdebug3(\"%.200s line %d: %smatched '%s \\\"%.100s\\\"' \",\n\t\t    filename, linenum, this_result ? \"\": \"not \",\n\t\t    oattrib, criteria);\n\t\tfree(criteria);\n\t}\n\tif (attributes == 0) {\n\t\terror(\"One or more attributes required for Match\");\n\t\tresult = -1;\n\t\tgoto out;\n\t}\n out:\n\tif (result != -1)\n\t\tdebug2(\"match %sfound\", result ? \"\" : \"not \");\n\t*condition = cp;\n\tfree(host);\n\treturn result;\n}"
  },
  {
    "function_name": "execute_in_shell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "478-535",
    "snippet": "static int\nexecute_in_shell(const char *cmd)\n{\n\tchar *shell;\n\tpid_t pid;\n\tint devnull, status;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL)\n\t\tshell = _PATH_BSHELL;\n\n\t/* Need this to redirect subprocess stdin/out */\n\tif ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1)\n\t\tfatal(\"open(/dev/null): %s\", strerror(errno));\n\n\tdebug(\"Executing command: '%.500s'\", cmd);\n\n\t/* Fork and execute the command. */\n\tif ((pid = fork()) == 0) {\n\t\tchar *argv[4];\n\n\t\t/* Redirect child stdin and stdout. Leave stderr */\n\t\tif (dup2(devnull, STDIN_FILENO) == -1)\n\t\t\tfatal(\"dup2: %s\", strerror(errno));\n\t\tif (dup2(devnull, STDOUT_FILENO) == -1)\n\t\t\tfatal(\"dup2: %s\", strerror(errno));\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t\tclosefrom(STDERR_FILENO + 1);\n\n\t\targv[0] = shell;\n\t\targv[1] = \"-c\";\n\t\targv[2] = xstrdup(cmd);\n\t\targv[3] = NULL;\n\n\t\texecv(argv[0], argv);\n\t\terror(\"Unable to execute '%.100s': %s\", cmd, strerror(errno));\n\t\t/* Die with signal to make this error apparent to parent. */\n\t\tsignal(SIGTERM, SIG_DFL);\n\t\tkill(getpid(), SIGTERM);\n\t\t_exit(1);\n\t}\n\t/* Parent. */\n\tif (pid < 0)\n\t\tfatal(\"%s: fork: %.100s\", __func__, strerror(errno));\n\n\tclose(devnull);\n\n\twhile (waitpid(pid, &status, 0) == -1) {\n\t\tif (errno != EINTR && errno != EAGAIN)\n\t\t\tfatal(\"%s: waitpid: %s\", __func__, strerror(errno));\n\t}\n\tif (!WIFEXITED(status)) {\n\t\terror(\"command '%.100s' exited abnormally\", cmd);\n\t\treturn -1;\n\t}\n\tdebug3(\"command returned status %d\", WEXITSTATUS(status));\n\treturn WEXITSTATUS(status);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"command returned status %d\"",
            "WEXITSTATUS(status)"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"command '%.100s' exited abnormally\"",
            "cmd"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: waitpid: %s\"",
            "__func__",
            "strerror(errno)"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "devnull"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "getpid()",
            "SIGTERM"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "SIG_DFL"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execv",
          "args": [
            "argv[0]",
            "argv"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "cmd"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "closefrom",
          "args": [
            "STDERR_FILENO + 1"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"dup2: %s\"",
            "strerror(errno)"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "devnull",
            "STDOUT_FILENO"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "devnull",
            "STDIN_FILENO"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "69-78",
          "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_DEVNULL",
            "O_RDWR"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "901-909",
          "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SHELL\""
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "pam_getenvlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "254-263",
          "snippet": "static char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nexecute_in_shell(const char *cmd)\n{\n\tchar *shell;\n\tpid_t pid;\n\tint devnull, status;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL)\n\t\tshell = _PATH_BSHELL;\n\n\t/* Need this to redirect subprocess stdin/out */\n\tif ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1)\n\t\tfatal(\"open(/dev/null): %s\", strerror(errno));\n\n\tdebug(\"Executing command: '%.500s'\", cmd);\n\n\t/* Fork and execute the command. */\n\tif ((pid = fork()) == 0) {\n\t\tchar *argv[4];\n\n\t\t/* Redirect child stdin and stdout. Leave stderr */\n\t\tif (dup2(devnull, STDIN_FILENO) == -1)\n\t\t\tfatal(\"dup2: %s\", strerror(errno));\n\t\tif (dup2(devnull, STDOUT_FILENO) == -1)\n\t\t\tfatal(\"dup2: %s\", strerror(errno));\n\t\tif (devnull > STDERR_FILENO)\n\t\t\tclose(devnull);\n\t\tclosefrom(STDERR_FILENO + 1);\n\n\t\targv[0] = shell;\n\t\targv[1] = \"-c\";\n\t\targv[2] = xstrdup(cmd);\n\t\targv[3] = NULL;\n\n\t\texecv(argv[0], argv);\n\t\terror(\"Unable to execute '%.100s': %s\", cmd, strerror(errno));\n\t\t/* Die with signal to make this error apparent to parent. */\n\t\tsignal(SIGTERM, SIG_DFL);\n\t\tkill(getpid(), SIGTERM);\n\t\t_exit(1);\n\t}\n\t/* Parent. */\n\tif (pid < 0)\n\t\tfatal(\"%s: fork: %.100s\", __func__, strerror(errno));\n\n\tclose(devnull);\n\n\twhile (waitpid(pid, &status, 0) == -1) {\n\t\tif (errno != EINTR && errno != EAGAIN)\n\t\t\tfatal(\"%s: waitpid: %s\", __func__, strerror(errno));\n\t}\n\tif (!WIFEXITED(status)) {\n\t\terror(\"command '%.100s' exited abnormally\", cmd);\n\t\treturn -1;\n\t}\n\tdebug3(\"command returned status %d\", WEXITSTATUS(status));\n\treturn WEXITSTATUS(status);\n}"
  },
  {
    "function_name": "default_ssh_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "461-472",
    "snippet": "int\ndefault_ssh_port(void)\n{\n\tstatic int port;\n\tstruct servent *sp;\n\n\tif (port == 0) {\n\t\tsp = getservbyname(SSH_SERVICE_NAME, \"tcp\");\n\t\tport = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;\n\t}\n\treturn port;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "sp->s_port"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getservbyname",
          "args": [
            "SSH_SERVICE_NAME",
            "\"tcp\""
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndefault_ssh_port(void)\n{\n\tstatic int port;\n\tstruct servent *sp;\n\n\tif (port == 0) {\n\t\tsp = getservbyname(SSH_SERVICE_NAME, \"tcp\");\n\t\tport = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;\n\t}\n\treturn port;\n}"
  },
  {
    "function_name": "add_identity_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "430-459",
    "snippet": "void\nadd_identity_file(Options *options, const char *dir, const char *filename,\n    int userprovided)\n{\n\tchar *path;\n\tint i;\n\n\tif (options->num_identity_files >= SSH_MAX_IDENTITY_FILES)\n\t\tfatal(\"Too many identity files specified (max %d)\",\n\t\t    SSH_MAX_IDENTITY_FILES);\n\n\tif (dir == NULL) /* no dir, filename is absolute */\n\t\tpath = xstrdup(filename);\n\telse if (xasprintf(&path, \"%s%s\", dir, filename) >= PATH_MAX)\n\t\tfatal(\"Identity file path %s too long\", path);\n\n\t/* Avoid registering duplicates */\n\tfor (i = 0; i < options->num_identity_files; i++) {\n\t\tif (options->identity_file_userprovided[i] == userprovided &&\n\t\t    strcmp(options->identity_files[i], path) == 0) {\n\t\t\tdebug2(\"%s: ignoring duplicate key %s\", __func__, path);\n\t\t\tfree(path);\n\t\t\treturn;\n\t\t}\n\t}\n\n\toptions->identity_file_userprovided[options->num_identity_files] =\n\t    userprovided;\n\toptions->identity_files[options->num_identity_files++] = path;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: ignoring duplicate key %s\"",
            "__func__",
            "path"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "options->identity_files[i]",
            "path"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Identity file path %s too long\"",
            "path"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&path",
            "\"%s%s\"",
            "dir",
            "filename"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "filename"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nadd_identity_file(Options *options, const char *dir, const char *filename,\n    int userprovided)\n{\n\tchar *path;\n\tint i;\n\n\tif (options->num_identity_files >= SSH_MAX_IDENTITY_FILES)\n\t\tfatal(\"Too many identity files specified (max %d)\",\n\t\t    SSH_MAX_IDENTITY_FILES);\n\n\tif (dir == NULL) /* no dir, filename is absolute */\n\t\tpath = xstrdup(filename);\n\telse if (xasprintf(&path, \"%s%s\", dir, filename) >= PATH_MAX)\n\t\tfatal(\"Identity file path %s too long\", path);\n\n\t/* Avoid registering duplicates */\n\tfor (i = 0; i < options->num_identity_files; i++) {\n\t\tif (options->identity_file_userprovided[i] == userprovided &&\n\t\t    strcmp(options->identity_files[i], path) == 0) {\n\t\t\tdebug2(\"%s: ignoring duplicate key %s\", __func__, path);\n\t\t\tfree(path);\n\t\t\treturn;\n\t\t}\n\t}\n\n\toptions->identity_file_userprovided[options->num_identity_files] =\n\t    userprovided;\n\toptions->identity_files[options->num_identity_files++] = path;\n}"
  },
  {
    "function_name": "add_certificate_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "406-428",
    "snippet": "void\nadd_certificate_file(Options *options, const char *path, int userprovided)\n{\n\tint i;\n\n\tif (options->num_certificate_files >= SSH_MAX_CERTIFICATE_FILES)\n\t\tfatal(\"Too many certificate files specified (max %d)\",\n\t\t    SSH_MAX_CERTIFICATE_FILES);\n\n\t/* Avoid registering duplicates */\n\tfor (i = 0; i < options->num_certificate_files; i++) {\n\t\tif (options->certificate_file_userprovided[i] == userprovided &&\n\t\t    strcmp(options->certificate_files[i], path) == 0) {\n\t\t\tdebug2(\"%s: ignoring duplicate key %s\", __func__, path);\n\t\t\treturn;\n\t\t}\n\t}\n\n\toptions->certificate_file_userprovided[options->num_certificate_files] =\n\t    userprovided;\n\toptions->certificate_files[options->num_certificate_files++] =\n\t    xstrdup(path);\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "path"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: ignoring duplicate key %s\"",
            "__func__",
            "path"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "options->certificate_files[i]",
            "path"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Too many certificate files specified (max %d)\"",
            "SSH_MAX_CERTIFICATE_FILES"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nadd_certificate_file(Options *options, const char *path, int userprovided)\n{\n\tint i;\n\n\tif (options->num_certificate_files >= SSH_MAX_CERTIFICATE_FILES)\n\t\tfatal(\"Too many certificate files specified (max %d)\",\n\t\t    SSH_MAX_CERTIFICATE_FILES);\n\n\t/* Avoid registering duplicates */\n\tfor (i = 0; i < options->num_certificate_files; i++) {\n\t\tif (options->certificate_file_userprovided[i] == userprovided &&\n\t\t    strcmp(options->certificate_files[i], path) == 0) {\n\t\t\tdebug2(\"%s: ignoring duplicate key %s\", __func__, path);\n\t\t\treturn;\n\t\t}\n\t}\n\n\toptions->certificate_file_userprovided[options->num_certificate_files] =\n\t    userprovided;\n\toptions->certificate_files[options->num_certificate_files++] =\n\t    xstrdup(path);\n}"
  },
  {
    "function_name": "clear_forwardings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "376-404",
    "snippet": "static void\nclear_forwardings(Options *options)\n{\n\tint i;\n\n\tfor (i = 0; i < options->num_local_forwards; i++) {\n\t\tfree(options->local_forwards[i].listen_host);\n\t\tfree(options->local_forwards[i].listen_path);\n\t\tfree(options->local_forwards[i].connect_host);\n\t\tfree(options->local_forwards[i].connect_path);\n\t}\n\tif (options->num_local_forwards > 0) {\n\t\tfree(options->local_forwards);\n\t\toptions->local_forwards = NULL;\n\t}\n\toptions->num_local_forwards = 0;\n\tfor (i = 0; i < options->num_remote_forwards; i++) {\n\t\tfree(options->remote_forwards[i].listen_host);\n\t\tfree(options->remote_forwards[i].listen_path);\n\t\tfree(options->remote_forwards[i].connect_host);\n\t\tfree(options->remote_forwards[i].connect_path);\n\t}\n\tif (options->num_remote_forwards > 0) {\n\t\tfree(options->remote_forwards);\n\t\toptions->remote_forwards = NULL;\n\t}\n\toptions->num_remote_forwards = 0;\n\toptions->tun_open = SSH_TUNMODE_NO;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "options->remote_forwards"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nclear_forwardings(Options *options)\n{\n\tint i;\n\n\tfor (i = 0; i < options->num_local_forwards; i++) {\n\t\tfree(options->local_forwards[i].listen_host);\n\t\tfree(options->local_forwards[i].listen_path);\n\t\tfree(options->local_forwards[i].connect_host);\n\t\tfree(options->local_forwards[i].connect_path);\n\t}\n\tif (options->num_local_forwards > 0) {\n\t\tfree(options->local_forwards);\n\t\toptions->local_forwards = NULL;\n\t}\n\toptions->num_local_forwards = 0;\n\tfor (i = 0; i < options->num_remote_forwards; i++) {\n\t\tfree(options->remote_forwards[i].listen_host);\n\t\tfree(options->remote_forwards[i].listen_path);\n\t\tfree(options->remote_forwards[i].connect_host);\n\t\tfree(options->remote_forwards[i].connect_path);\n\t}\n\tif (options->num_remote_forwards > 0) {\n\t\tfree(options->remote_forwards);\n\t\toptions->remote_forwards = NULL;\n\t}\n\toptions->num_remote_forwards = 0;\n\toptions->tun_open = SSH_TUNMODE_NO;\n}"
  },
  {
    "function_name": "add_remote_forward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "350-374",
    "snippet": "void\nadd_remote_forward(Options *options, const struct Forward *newfwd)\n{\n\tstruct Forward *fwd;\n\tint i;\n\n\t/* Don't add duplicates */\n\tfor (i = 0; i < options->num_remote_forwards; i++) {\n\t\tif (forward_equals(newfwd, options->remote_forwards + i))\n\t\t\treturn;\n\t}\n\toptions->remote_forwards = xreallocarray(options->remote_forwards,\n\t    options->num_remote_forwards + 1,\n\t    sizeof(*options->remote_forwards));\n\tfwd = &options->remote_forwards[options->num_remote_forwards++];\n\n\tfwd->listen_host = newfwd->listen_host;\n\tfwd->listen_port = newfwd->listen_port;\n\tfwd->listen_path = newfwd->listen_path;\n\tfwd->connect_host = newfwd->connect_host;\n\tfwd->connect_port = newfwd->connect_port;\n\tfwd->connect_path = newfwd->connect_path;\n\tfwd->handle = newfwd->handle;\n\tfwd->allocated_port = 0;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xreallocarray",
          "args": [
            "options->remote_forwards",
            "options->num_remote_forwards + 1",
            "sizeof(*options->remote_forwards)"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "xreallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "68-78",
          "snippet": "void *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "forward_equals",
          "args": [
            "newfwd",
            "options->remote_forwards + i"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "forward_equals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1564-1581",
          "snippet": "int\nforward_equals(const struct Forward *a, const struct Forward *b)\n{\n\tif (strcmp_maybe_null(a->listen_host, b->listen_host) == 0)\n\t\treturn 0;\n\tif (a->listen_port != b->listen_port)\n\t\treturn 0;\n\tif (strcmp_maybe_null(a->listen_path, b->listen_path) == 0)\n\t\treturn 0;\n\tif (strcmp_maybe_null(a->connect_host, b->connect_host) == 0)\n\t\treturn 0;\n\tif (a->connect_port != b->connect_port)\n\t\treturn 0;\n\tif (strcmp_maybe_null(a->connect_path, b->connect_path) == 0)\n\t\treturn 0;\n\t/* allocated_port and handle are not checked */\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nforward_equals(const struct Forward *a, const struct Forward *b)\n{\n\tif (strcmp_maybe_null(a->listen_host, b->listen_host) == 0)\n\t\treturn 0;\n\tif (a->listen_port != b->listen_port)\n\t\treturn 0;\n\tif (strcmp_maybe_null(a->listen_path, b->listen_path) == 0)\n\t\treturn 0;\n\tif (strcmp_maybe_null(a->connect_host, b->connect_host) == 0)\n\t\treturn 0;\n\tif (a->connect_port != b->connect_port)\n\t\treturn 0;\n\tif (strcmp_maybe_null(a->connect_path, b->connect_path) == 0)\n\t\treturn 0;\n\t/* allocated_port and handle are not checked */\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nadd_remote_forward(Options *options, const struct Forward *newfwd)\n{\n\tstruct Forward *fwd;\n\tint i;\n\n\t/* Don't add duplicates */\n\tfor (i = 0; i < options->num_remote_forwards; i++) {\n\t\tif (forward_equals(newfwd, options->remote_forwards + i))\n\t\t\treturn;\n\t}\n\toptions->remote_forwards = xreallocarray(options->remote_forwards,\n\t    options->num_remote_forwards + 1,\n\t    sizeof(*options->remote_forwards));\n\tfwd = &options->remote_forwards[options->num_remote_forwards++];\n\n\tfwd->listen_host = newfwd->listen_host;\n\tfwd->listen_port = newfwd->listen_port;\n\tfwd->listen_path = newfwd->listen_path;\n\tfwd->connect_host = newfwd->connect_host;\n\tfwd->connect_port = newfwd->connect_port;\n\tfwd->connect_path = newfwd->connect_path;\n\tfwd->handle = newfwd->handle;\n\tfwd->allocated_port = 0;\n}"
  },
  {
    "function_name": "add_local_forward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
    "lines": "321-343",
    "snippet": "void\nadd_local_forward(Options *options, const struct Forward *newfwd)\n{\n\tstruct Forward *fwd;\n\tint i;\n\n\t/* Don't add duplicates */\n\tfor (i = 0; i < options->num_local_forwards; i++) {\n\t\tif (forward_equals(newfwd, options->local_forwards + i))\n\t\t\treturn;\n\t}\n\toptions->local_forwards = xreallocarray(options->local_forwards,\n\t    options->num_local_forwards + 1,\n\t    sizeof(*options->local_forwards));\n\tfwd = &options->local_forwards[options->num_local_forwards++];\n\n\tfwd->listen_host = newfwd->listen_host;\n\tfwd->listen_port = newfwd->listen_port;\n\tfwd->listen_path = newfwd->listen_path;\n\tfwd->connect_host = newfwd->connect_host;\n\tfwd->connect_port = newfwd->connect_port;\n\tfwd->connect_path = newfwd->connect_path;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"myproposal.h\"",
      "#include \"uidswap.h\"",
      "#include \"mac.h\"",
      "#include \"kex.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <vis.h>",
      "#include <util.h>",
      "# include \"openbsd-compat/glob.h\"",
      "# include <glob.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xreallocarray",
          "args": [
            "options->local_forwards",
            "options->num_local_forwards + 1",
            "sizeof(*options->local_forwards)"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "xreallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "68-78",
          "snippet": "void *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "forward_equals",
          "args": [
            "newfwd",
            "options->local_forwards + i"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "forward_equals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1564-1581",
          "snippet": "int\nforward_equals(const struct Forward *a, const struct Forward *b)\n{\n\tif (strcmp_maybe_null(a->listen_host, b->listen_host) == 0)\n\t\treturn 0;\n\tif (a->listen_port != b->listen_port)\n\t\treturn 0;\n\tif (strcmp_maybe_null(a->listen_path, b->listen_path) == 0)\n\t\treturn 0;\n\tif (strcmp_maybe_null(a->connect_host, b->connect_host) == 0)\n\t\treturn 0;\n\tif (a->connect_port != b->connect_port)\n\t\treturn 0;\n\tif (strcmp_maybe_null(a->connect_path, b->connect_path) == 0)\n\t\treturn 0;\n\t/* allocated_port and handle are not checked */\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nforward_equals(const struct Forward *a, const struct Forward *b)\n{\n\tif (strcmp_maybe_null(a->listen_host, b->listen_host) == 0)\n\t\treturn 0;\n\tif (a->listen_port != b->listen_port)\n\t\treturn 0;\n\tif (strcmp_maybe_null(a->listen_path, b->listen_path) == 0)\n\t\treturn 0;\n\tif (strcmp_maybe_null(a->connect_host, b->connect_host) == 0)\n\t\treturn 0;\n\tif (a->connect_port != b->connect_port)\n\t\treturn 0;\n\tif (strcmp_maybe_null(a->connect_path, b->connect_path) == 0)\n\t\treturn 0;\n\t/* allocated_port and handle are not checked */\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nadd_local_forward(Options *options, const struct Forward *newfwd)\n{\n\tstruct Forward *fwd;\n\tint i;\n\n\t/* Don't add duplicates */\n\tfor (i = 0; i < options->num_local_forwards; i++) {\n\t\tif (forward_equals(newfwd, options->local_forwards + i))\n\t\t\treturn;\n\t}\n\toptions->local_forwards = xreallocarray(options->local_forwards,\n\t    options->num_local_forwards + 1,\n\t    sizeof(*options->local_forwards));\n\tfwd = &options->local_forwards[options->num_local_forwards++];\n\n\tfwd->listen_host = newfwd->listen_host;\n\tfwd->listen_port = newfwd->listen_port;\n\tfwd->listen_path = newfwd->listen_path;\n\tfwd->connect_host = newfwd->connect_host;\n\tfwd->connect_port = newfwd->connect_port;\n\tfwd->connect_path = newfwd->connect_path;\n}"
  }
]