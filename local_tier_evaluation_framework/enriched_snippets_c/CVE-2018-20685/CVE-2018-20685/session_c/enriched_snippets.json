[
  {
    "function_name": "session_get_remote_name_or_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2703-2713",
    "snippet": "const char *\nsession_get_remote_name_or_ip(struct ssh *ssh, u_int utmp_size, int use_dns)\n{\n\tconst char *remote = \"\";\n\n\tif (utmp_size > 0)\n\t\tremote = auth_get_canonical_hostname(ssh, use_dns);\n\tif (utmp_size == 0 || strlen(remote) > utmp_size)\n\t\tremote = ssh_remote_ipaddr(ssh);\n\treturn remote;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "remote"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_get_canonical_hostname",
          "args": [
            "ssh",
            "use_dns"
          ],
          "line": 2709
        },
        "resolved": true,
        "details": {
          "function_name": "auth_get_canonical_hostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "839-852",
          "snippet": "const char *\nauth_get_canonical_hostname(struct ssh *ssh, int use_dns)\n{\n\tstatic char *dnsname;\n\n\tif (!use_dns)\n\t\treturn ssh_remote_ipaddr(ssh);\n\telse if (dnsname != NULL)\n\t\treturn dnsname;\n\telse {\n\t\tdnsname = remote_hostname(ssh);\n\t\treturn dnsname;\n\t}\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nauth_get_canonical_hostname(struct ssh *ssh, int use_dns)\n{\n\tstatic char *dnsname;\n\n\tif (!use_dns)\n\t\treturn ssh_remote_ipaddr(ssh);\n\telse if (dnsname != NULL)\n\t\treturn dnsname;\n\telse {\n\t\tdnsname = remote_hostname(ssh);\n\t\treturn dnsname;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsession_get_remote_name_or_ip(struct ssh *ssh, u_int utmp_size, int use_dns)\n{\n\tconst char *remote = \"\";\n\n\tif (utmp_size > 0)\n\t\tremote = auth_get_canonical_hostname(ssh, use_dns);\n\tif (utmp_size == 0 || strlen(remote) > utmp_size)\n\t\tremote = ssh_remote_ipaddr(ssh);\n\treturn remote;\n}"
  },
  {
    "function_name": "do_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2641-2699",
    "snippet": "void\ndo_cleanup(struct ssh *ssh, Authctxt *authctxt)\n{\n\tstatic int called = 0;\n\n\tdebug(\"do_cleanup\");\n\n\t/* no cleanup if we're in the child for login shell */\n\tif (is_child)\n\t\treturn;\n\n\t/* avoid double cleanup */\n\tif (called)\n\t\treturn;\n\tcalled = 1;\n\n\tif (authctxt == NULL)\n\t\treturn;\n\n#ifdef USE_PAM\n\tif (options.use_pam) {\n\t\tsshpam_cleanup();\n\t\tsshpam_thread_cleanup();\n\t}\n#endif\n\n\tif (!authctxt->authenticated)\n\t\treturn;\n\n#ifdef KRB5\n\tif (options.kerberos_ticket_cleanup &&\n\t    authctxt->krb5_ctx)\n\t\tkrb5_cleanup_proc(authctxt);\n#endif\n\n#ifdef GSSAPI\n\tif (options.gss_cleanup_creds)\n\t\tssh_gssapi_cleanup_creds();\n#endif\n\n\t/* remove agent socket */\n\tauth_sock_cleanup_proc(authctxt->pw);\n\n\t/* remove userauth info */\n\tif (auth_info_file != NULL) {\n\t\ttemporarily_use_uid(authctxt->pw);\n\t\tunlink(auth_info_file);\n\t\trestore_uid();\n\t\tfree(auth_info_file);\n\t\tauth_info_file = NULL;\n\t}\n\n\t/*\n\t * Cleanup ptys/utmp only if privsep is disabled,\n\t * or if running in monitor.\n\t */\n\tif (!use_privsep || mm_is_monitor())\n\t\tsession_destroy_all(ssh, session_pty_cleanup2);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void do_authenticated2(struct ssh *, Authctxt *);",
      "extern ServerOptions options;",
      "static int is_child = 0;",
      "static char *auth_info_file = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "session_destroy_all",
          "args": [
            "ssh",
            "session_pty_cleanup2"
          ],
          "line": 2698
        },
        "resolved": true,
        "details": {
          "function_name": "session_destroy_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2507-2520",
          "snippet": "void\nsession_destroy_all(struct ssh *ssh, void (*closefunc)(Session *))\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used) {\n\t\t\tif (closefunc != NULL)\n\t\t\t\tclosefunc(s);\n\t\t\telse\n\t\t\t\tsession_close(ssh, s);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "static int sessions_nalloc = 0;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nvoid\nsession_destroy_all(struct ssh *ssh, void (*closefunc)(Session *))\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used) {\n\t\t\tif (closefunc != NULL)\n\t\t\t\tclosefunc(s);\n\t\t\telse\n\t\t\t\tsession_close(ssh, s);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_is_monitor",
          "args": [],
          "line": 2697
        },
        "resolved": true,
        "details": {
          "function_name": "mm_is_monitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "111-119",
          "snippet": "int\nmm_is_monitor(void)\n{\n\t/*\n\t * m_pid is only set in the privileged part, and\n\t * points to the unprivileged child.\n\t */\n\treturn (pmonitor && pmonitor->m_pid > 0);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct monitor *pmonitor;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern struct monitor *pmonitor;\n\nint\nmm_is_monitor(void)\n{\n\t/*\n\t * m_pid is only set in the privileged part, and\n\t * points to the unprivileged child.\n\t */\n\treturn (pmonitor && pmonitor->m_pid > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "auth_info_file"
          ],
          "line": 2689
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_uid",
          "args": [],
          "line": 2688
        },
        "resolved": true,
        "details": {
          "function_name": "restore_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "141-172",
          "snippet": "void\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "auth_info_file"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "temporarily_use_uid",
          "args": [
            "authctxt->pw"
          ],
          "line": 2686
        },
        "resolved": true,
        "details": {
          "function_name": "temporarily_use_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "60-136",
          "snippet": "void\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static uid_t\tuser_groups_uid;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic uid_t\tuser_groups_uid;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_sock_cleanup_proc",
          "args": [
            "authctxt->pw"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "auth_sock_cleanup_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "176-186",
          "snippet": "static void\nauth_sock_cleanup_proc(struct passwd *pw)\n{\n\tif (auth_sock_name != NULL) {\n\t\ttemporarily_use_uid(pw);\n\t\tunlink(auth_sock_name);\n\t\trmdir(auth_sock_dir);\n\t\tauth_sock_name = NULL;\n\t\trestore_uid();\n\t}\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *auth_sock_name = NULL;",
            "static char *auth_sock_dir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *auth_sock_name = NULL;\nstatic char *auth_sock_dir = NULL;\n\nstatic void\nauth_sock_cleanup_proc(struct passwd *pw)\n{\n\tif (auth_sock_name != NULL) {\n\t\ttemporarily_use_uid(pw);\n\t\tunlink(auth_sock_name);\n\t\trmdir(auth_sock_dir);\n\t\tauth_sock_name = NULL;\n\t\trestore_uid();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_cleanup_creds",
          "args": [],
          "line": 2678
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_cleanup_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-serv.c",
          "lines": "319-328",
          "snippet": "void\nssh_gssapi_cleanup_creds(void)\n{\n\tif (gssapi_client.store.filename != NULL) {\n\t\t/* Unlink probably isn't sufficient */\n\t\tdebug(\"removing gssapi cred file\\\"%s\\\"\",\n\t\t    gssapi_client.store.filename);\n\t\tunlink(gssapi_client.store.filename);\n\t}\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_gssapi_cleanup_creds(void)\n{\n\tif (gssapi_client.store.filename != NULL) {\n\t\t/* Unlink probably isn't sufficient */\n\t\tdebug(\"removing gssapi cred file\\\"%s\\\"\",\n\t\t    gssapi_client.store.filename);\n\t\tunlink(gssapi_client.store.filename);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_cleanup_proc",
          "args": [
            "authctxt"
          ],
          "line": 2673
        },
        "resolved": true,
        "details": {
          "function_name": "krb5_cleanup_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-krb5.c",
          "lines": "222-238",
          "snippet": "void\nkrb5_cleanup_proc(Authctxt *authctxt)\n{\n\tdebug(\"krb5_cleanup_proc called\");\n\tif (authctxt->krb5_fwd_ccache) {\n\t\tkrb5_cc_destroy(authctxt->krb5_ctx, authctxt->krb5_fwd_ccache);\n\t\tauthctxt->krb5_fwd_ccache = NULL;\n\t}\n\tif (authctxt->krb5_user) {\n\t\tkrb5_free_principal(authctxt->krb5_ctx, authctxt->krb5_user);\n\t\tauthctxt->krb5_user = NULL;\n\t}\n\tif (authctxt->krb5_ctx) {\n\t\tkrb5_free_context(authctxt->krb5_ctx);\n\t\tauthctxt->krb5_ctx = NULL;\n\t}\n}",
          "includes": [
            "#include <krb5.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <krb5.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nkrb5_cleanup_proc(Authctxt *authctxt)\n{\n\tdebug(\"krb5_cleanup_proc called\");\n\tif (authctxt->krb5_fwd_ccache) {\n\t\tkrb5_cc_destroy(authctxt->krb5_ctx, authctxt->krb5_fwd_ccache);\n\t\tauthctxt->krb5_fwd_ccache = NULL;\n\t}\n\tif (authctxt->krb5_user) {\n\t\tkrb5_free_principal(authctxt->krb5_ctx, authctxt->krb5_user);\n\t\tauthctxt->krb5_user = NULL;\n\t}\n\tif (authctxt->krb5_ctx) {\n\t\tkrb5_free_context(authctxt->krb5_ctx);\n\t\tauthctxt->krb5_ctx = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpam_thread_cleanup",
          "args": [],
          "line": 2663
        },
        "resolved": true,
        "details": {
          "function_name": "sshpam_thread_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "580-594",
          "snippet": "void\nsshpam_thread_cleanup(void)\n{\n\tstruct pam_ctxt *ctxt = cleanup_ctxt;\n\n\tdebug3(\"PAM: %s entering\", __func__);\n\tif (ctxt != NULL && ctxt->pam_thread != 0) {\n\t\tpthread_cancel(ctxt->pam_thread);\n\t\tpthread_join(ctxt->pam_thread, NULL);\n\t\tclose(ctxt->pam_psock);\n\t\tclose(ctxt->pam_csock);\n\t\tmemset(ctxt, 0, sizeof(*ctxt));\n\t\tcleanup_ctxt = NULL;\n\t}\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define pthread_join\tfake_pthread_join",
            "#define pthread_cancel\tfake_pthread_cancel"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define pthread_join\tfake_pthread_join\n#define pthread_cancel\tfake_pthread_cancel\n\nvoid\nsshpam_thread_cleanup(void)\n{\n\tstruct pam_ctxt *ctxt = cleanup_ctxt;\n\n\tdebug3(\"PAM: %s entering\", __func__);\n\tif (ctxt != NULL && ctxt->pam_thread != 0) {\n\t\tpthread_cancel(ctxt->pam_thread);\n\t\tpthread_join(ctxt->pam_thread, NULL);\n\t\tclose(ctxt->pam_psock);\n\t\tclose(ctxt->pam_csock);\n\t\tmemset(ctxt, 0, sizeof(*ctxt));\n\t\tcleanup_ctxt = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpam_cleanup",
          "args": [],
          "line": 2662
        },
        "resolved": true,
        "details": {
          "function_name": "sshpam_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "649-669",
          "snippet": "void\nsshpam_cleanup(void)\n{\n\tif (sshpam_handle == NULL || (use_privsep && !mm_is_monitor()))\n\t\treturn;\n\tdebug(\"PAM: cleanup\");\n\tpam_set_item(sshpam_handle, PAM_CONV, (const void *)&null_conv);\n\tif (sshpam_session_open) {\n\t\tdebug(\"PAM: closing session\");\n\t\tpam_close_session(sshpam_handle, PAM_SILENT);\n\t\tsshpam_session_open = 0;\n\t}\n\tif (sshpam_cred_established) {\n\t\tdebug(\"PAM: deleting credentials\");\n\t\tpam_setcred(sshpam_handle, PAM_DELETE_CRED);\n\t\tsshpam_cred_established = 0;\n\t}\n\tsshpam_authenticated = 0;\n\tpam_end(sshpam_handle, sshpam_err);\n\tsshpam_handle = NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshpam_cleanup(void)\n{\n\tif (sshpam_handle == NULL || (use_privsep && !mm_is_monitor()))\n\t\treturn;\n\tdebug(\"PAM: cleanup\");\n\tpam_set_item(sshpam_handle, PAM_CONV, (const void *)&null_conv);\n\tif (sshpam_session_open) {\n\t\tdebug(\"PAM: closing session\");\n\t\tpam_close_session(sshpam_handle, PAM_SILENT);\n\t\tsshpam_session_open = 0;\n\t}\n\tif (sshpam_cred_established) {\n\t\tdebug(\"PAM: deleting credentials\");\n\t\tpam_setcred(sshpam_handle, PAM_DELETE_CRED);\n\t\tsshpam_cred_established = 0;\n\t}\n\tsshpam_authenticated = 0;\n\tpam_end(sshpam_handle, sshpam_err);\n\tsshpam_handle = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"do_cleanup\""
          ],
          "line": 2646
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void do_authenticated2(struct ssh *, Authctxt *);\nextern ServerOptions options;\nstatic int is_child = 0;\nstatic char *auth_info_file = NULL;\n\nvoid\ndo_cleanup(struct ssh *ssh, Authctxt *authctxt)\n{\n\tstatic int called = 0;\n\n\tdebug(\"do_cleanup\");\n\n\t/* no cleanup if we're in the child for login shell */\n\tif (is_child)\n\t\treturn;\n\n\t/* avoid double cleanup */\n\tif (called)\n\t\treturn;\n\tcalled = 1;\n\n\tif (authctxt == NULL)\n\t\treturn;\n\n#ifdef USE_PAM\n\tif (options.use_pam) {\n\t\tsshpam_cleanup();\n\t\tsshpam_thread_cleanup();\n\t}\n#endif\n\n\tif (!authctxt->authenticated)\n\t\treturn;\n\n#ifdef KRB5\n\tif (options.kerberos_ticket_cleanup &&\n\t    authctxt->krb5_ctx)\n\t\tkrb5_cleanup_proc(authctxt);\n#endif\n\n#ifdef GSSAPI\n\tif (options.gss_cleanup_creds)\n\t\tssh_gssapi_cleanup_creds();\n#endif\n\n\t/* remove agent socket */\n\tauth_sock_cleanup_proc(authctxt->pw);\n\n\t/* remove userauth info */\n\tif (auth_info_file != NULL) {\n\t\ttemporarily_use_uid(authctxt->pw);\n\t\tunlink(auth_info_file);\n\t\trestore_uid();\n\t\tfree(auth_info_file);\n\t\tauth_info_file = NULL;\n\t}\n\n\t/*\n\t * Cleanup ptys/utmp only if privsep is disabled,\n\t * or if running in monitor.\n\t */\n\tif (!use_privsep || mm_is_monitor())\n\t\tsession_destroy_all(ssh, session_pty_cleanup2);\n}"
  },
  {
    "function_name": "do_authenticated2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2635-2639",
    "snippet": "static void\ndo_authenticated2(struct ssh *ssh, Authctxt *authctxt)\n{\n\tserver_loop2(ssh, authctxt);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void do_authenticated2(struct ssh *, Authctxt *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "server_loop2",
          "args": [
            "ssh",
            "authctxt"
          ],
          "line": 2638
        },
        "resolved": true,
        "details": {
          "function_name": "server_loop2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/serverloop.c",
          "lines": "378-443",
          "snippet": "void\nserver_loop2(struct ssh *ssh, Authctxt *authctxt)\n{\n\tfd_set *readset = NULL, *writeset = NULL;\n\tint max_fd;\n\tu_int nalloc = 0, connection_in, connection_out;\n\tu_int64_t rekey_timeout_ms = 0;\n\n\tdebug(\"Entering interactive session for SSH2.\");\n\n\tsignal(SIGCHLD, sigchld_handler);\n\tchild_terminated = 0;\n\tconnection_in = packet_get_connection_in();\n\tconnection_out = packet_get_connection_out();\n\n\tif (!use_privsep) {\n\t\tsignal(SIGTERM, sigterm_handler);\n\t\tsignal(SIGINT, sigterm_handler);\n\t\tsignal(SIGQUIT, sigterm_handler);\n\t}\n\n\tnotify_setup();\n\n\tmax_fd = MAXIMUM(connection_in, connection_out);\n\tmax_fd = MAXIMUM(max_fd, notify_pipe[0]);\n\n\tserver_init_dispatch();\n\n\tfor (;;) {\n\t\tprocess_buffered_input_packets(ssh);\n\n\t\tif (!ssh_packet_is_rekeying(ssh) &&\n\t\t    packet_not_very_much_data_to_write())\n\t\t\tchannel_output_poll(ssh);\n\t\tif (options.rekey_interval > 0 && !ssh_packet_is_rekeying(ssh))\n\t\t\trekey_timeout_ms = packet_get_rekey_timeout() * 1000;\n\t\telse\n\t\t\trekey_timeout_ms = 0;\n\n\t\twait_until_can_do_something(ssh, connection_in, connection_out,\n\t\t    &readset, &writeset, &max_fd, &nalloc, rekey_timeout_ms);\n\n\t\tif (received_sigterm) {\n\t\t\tlogit(\"Exiting on signal %d\", (int)received_sigterm);\n\t\t\t/* Clean up sessions, utmp, etc. */\n\t\t\tcleanup_exit(255);\n\t\t}\n\n\t\tcollect_children(ssh);\n\t\tif (!ssh_packet_is_rekeying(ssh))\n\t\t\tchannel_after_select(ssh, readset, writeset);\n\t\tif (process_input(ssh, readset, connection_in) < 0)\n\t\t\tbreak;\n\t\tprocess_output(writeset, connection_out);\n\t}\n\tcollect_children(ssh);\n\n\tfree(readset);\n\tfree(writeset);\n\n\t/* free all channels, no more reads and writes */\n\tchannel_free_all(ssh);\n\n\t/* free remaining sessions, e.g. remove wtmp entries */\n\tsession_destroy_all(ssh, NULL);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"serverloop.h\"",
            "#include \"auth-options.h\"",
            "#include \"dispatch.h\"",
            "#include \"session.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"sshpty.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "extern int use_privsep;",
            "static volatile sig_atomic_t child_terminated = 0;",
            "static volatile sig_atomic_t received_sigterm = 0;",
            "static void server_init_dispatch(void);",
            "static int notify_pipe[2];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"serverloop.h\"\n#include \"auth-options.h\"\n#include \"dispatch.h\"\n#include \"session.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"sshpty.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <signal.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern int use_privsep;\nstatic volatile sig_atomic_t child_terminated = 0;\nstatic volatile sig_atomic_t received_sigterm = 0;\nstatic void server_init_dispatch(void);\nstatic int notify_pipe[2];\n\nvoid\nserver_loop2(struct ssh *ssh, Authctxt *authctxt)\n{\n\tfd_set *readset = NULL, *writeset = NULL;\n\tint max_fd;\n\tu_int nalloc = 0, connection_in, connection_out;\n\tu_int64_t rekey_timeout_ms = 0;\n\n\tdebug(\"Entering interactive session for SSH2.\");\n\n\tsignal(SIGCHLD, sigchld_handler);\n\tchild_terminated = 0;\n\tconnection_in = packet_get_connection_in();\n\tconnection_out = packet_get_connection_out();\n\n\tif (!use_privsep) {\n\t\tsignal(SIGTERM, sigterm_handler);\n\t\tsignal(SIGINT, sigterm_handler);\n\t\tsignal(SIGQUIT, sigterm_handler);\n\t}\n\n\tnotify_setup();\n\n\tmax_fd = MAXIMUM(connection_in, connection_out);\n\tmax_fd = MAXIMUM(max_fd, notify_pipe[0]);\n\n\tserver_init_dispatch();\n\n\tfor (;;) {\n\t\tprocess_buffered_input_packets(ssh);\n\n\t\tif (!ssh_packet_is_rekeying(ssh) &&\n\t\t    packet_not_very_much_data_to_write())\n\t\t\tchannel_output_poll(ssh);\n\t\tif (options.rekey_interval > 0 && !ssh_packet_is_rekeying(ssh))\n\t\t\trekey_timeout_ms = packet_get_rekey_timeout() * 1000;\n\t\telse\n\t\t\trekey_timeout_ms = 0;\n\n\t\twait_until_can_do_something(ssh, connection_in, connection_out,\n\t\t    &readset, &writeset, &max_fd, &nalloc, rekey_timeout_ms);\n\n\t\tif (received_sigterm) {\n\t\t\tlogit(\"Exiting on signal %d\", (int)received_sigterm);\n\t\t\t/* Clean up sessions, utmp, etc. */\n\t\t\tcleanup_exit(255);\n\t\t}\n\n\t\tcollect_children(ssh);\n\t\tif (!ssh_packet_is_rekeying(ssh))\n\t\t\tchannel_after_select(ssh, readset, writeset);\n\t\tif (process_input(ssh, readset, connection_in) < 0)\n\t\t\tbreak;\n\t\tprocess_output(writeset, connection_out);\n\t}\n\tcollect_children(ssh);\n\n\tfree(readset);\n\tfree(writeset);\n\n\t/* free all channels, no more reads and writes */\n\tchannel_free_all(ssh);\n\n\t/* free remaining sessions, e.g. remove wtmp entries */\n\tsession_destroy_all(ssh, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void do_authenticated2(struct ssh *, Authctxt *);\n\nstatic void\ndo_authenticated2(struct ssh *ssh, Authctxt *authctxt)\n{\n\tserver_loop2(ssh, authctxt);\n}"
  },
  {
    "function_name": "session_setup_x11fwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2559-2633",
    "snippet": "int\nsession_setup_x11fwd(struct ssh *ssh, Session *s)\n{\n\tstruct stat st;\n\tchar display[512], auth_display[512];\n\tchar hostname[NI_MAXHOST];\n\tu_int i;\n\n\tif (!auth_opts->permit_x11_forwarding_flag) {\n\t\tpacket_send_debug(\"X11 forwarding disabled by key options.\");\n\t\treturn 0;\n\t}\n\tif (!options.x11_forwarding) {\n\t\tdebug(\"X11 forwarding disabled in server configuration file.\");\n\t\treturn 0;\n\t}\n\tif (options.xauth_location == NULL ||\n\t    (stat(options.xauth_location, &st) == -1)) {\n\t\tpacket_send_debug(\"No xauth program; cannot forward X11.\");\n\t\treturn 0;\n\t}\n\tif (s->display != NULL) {\n\t\tdebug(\"X11 display already set.\");\n\t\treturn 0;\n\t}\n\tif (x11_create_display_inet(ssh, options.x11_display_offset,\n\t    options.x11_use_localhost, s->single_connection,\n\t    &s->display_number, &s->x11_chanids) == -1) {\n\t\tdebug(\"x11_create_display_inet failed.\");\n\t\treturn 0;\n\t}\n\tfor (i = 0; s->x11_chanids[i] != -1; i++) {\n\t\tchannel_register_cleanup(ssh, s->x11_chanids[i],\n\t\t    session_close_single_x11, 0);\n\t}\n\n\t/* Set up a suitable value for the DISPLAY variable. */\n\tif (gethostname(hostname, sizeof(hostname)) < 0)\n\t\tfatal(\"gethostname: %.100s\", strerror(errno));\n\t/*\n\t * auth_display must be used as the displayname when the\n\t * authorization entry is added with xauth(1).  This will be\n\t * different than the DISPLAY string for localhost displays.\n\t */\n\tif (options.x11_use_localhost) {\n\t\tsnprintf(display, sizeof display, \"localhost:%u.%u\",\n\t\t    s->display_number, s->screen);\n\t\tsnprintf(auth_display, sizeof auth_display, \"unix:%u.%u\",\n\t\t    s->display_number, s->screen);\n\t\ts->display = xstrdup(display);\n\t\ts->auth_display = xstrdup(auth_display);\n\t} else {\n#ifdef IPADDR_IN_DISPLAY\n\t\tstruct hostent *he;\n\t\tstruct in_addr my_addr;\n\n\t\the = gethostbyname(hostname);\n\t\tif (he == NULL) {\n\t\t\terror(\"Can't get IP address for X11 DISPLAY.\");\n\t\t\tpacket_send_debug(\"Can't get IP address for X11 DISPLAY.\");\n\t\t\treturn 0;\n\t\t}\n\t\tmemcpy(&my_addr, he->h_addr_list[0], sizeof(struct in_addr));\n\t\tsnprintf(display, sizeof display, \"%.50s:%u.%u\", inet_ntoa(my_addr),\n\t\t    s->display_number, s->screen);\n#else\n\t\tsnprintf(display, sizeof display, \"%.400s:%u.%u\", hostname,\n\t\t    s->display_number, s->screen);\n#endif\n\t\ts->display = xstrdup(display);\n\t\ts->auth_display = xstrdup(display);\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "extern ServerOptions options;",
      "extern struct sshauthopt *auth_opts;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "display"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "display",
            "sizeof display",
            "\"%.400s:%u.%u\"",
            "hostname",
            "s->display_number",
            "s->screen"
          ],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_ntoa",
          "args": [
            "my_addr"
          ],
          "line": 2622
        },
        "resolved": true,
        "details": {
          "function_name": "inet_ntoa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/inet_ntoa.c",
          "lines": "46-57",
          "snippet": "char *\ninet_ntoa(struct in_addr in)\n{\n\tstatic char b[18];\n\tchar *p;\n\n\tp = (char *)&in;\n#define\tUC(b)\t(((int)b)&0xff)\n\t(void)snprintf(b, sizeof(b),\n\t    \"%u.%u.%u.%u\", UC(p[0]), UC(p[1]), UC(p[2]), UC(p[3]));\n\treturn (b);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ninet_ntoa(struct in_addr in)\n{\n\tstatic char b[18];\n\tchar *p;\n\n\tp = (char *)&in;\n#define\tUC(b)\t(((int)b)&0xff)\n\t(void)snprintf(b, sizeof(b),\n\t    \"%u.%u.%u.%u\", UC(p[0]), UC(p[1]), UC(p[2]), UC(p[3]));\n\treturn (b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&my_addr",
            "he->h_addr_list[0]",
            "sizeof(struct in_addr)"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_send_debug",
          "args": [
            "\"Can't get IP address for X11 DISPLAY.\""
          ],
          "line": 2618
        },
        "resolved": true,
        "details": {
          "function_name": "packet_send_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "310-320",
          "snippet": "void\npacket_send_debug(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_send_debug(active_state, \"%s\", buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_send_debug(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_send_debug(active_state, \"%s\", buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Can't get IP address for X11 DISPLAY.\""
          ],
          "line": 2617
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gethostbyname",
          "args": [
            "hostname"
          ],
          "line": 2615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"gethostname: %.100s\"",
            "strerror(errno)"
          ],
          "line": 2597
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2597
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gethostname",
          "args": [
            "hostname",
            "sizeof(hostname)"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_register_cleanup",
          "args": [
            "ssh",
            "s->x11_chanids[i]",
            "session_close_single_x11",
            "0"
          ],
          "line": 2591
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "985-997",
          "snippet": "void\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"x11_create_display_inet failed.\""
          ],
          "line": 2587
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x11_create_display_inet",
          "args": [
            "ssh",
            "options.x11_display_offset",
            "options.x11_use_localhost",
            "s->single_connection",
            "&s->display_number",
            "&s->x11_chanids"
          ],
          "line": 2584
        },
        "resolved": true,
        "details": {
          "function_name": "x11_create_display_inet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4536-4637",
          "snippet": "int\nx11_create_display_inet(struct ssh *ssh, int x11_display_offset,\n    int x11_use_localhost, int single_connection,\n    u_int *display_numberp, int **chanids)\n{\n\tChannel *nc = NULL;\n\tint display_number, sock;\n\tu_short port;\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar strport[NI_MAXSERV];\n\tint gaierr, n, num_socks = 0, socks[NUM_SOCKS];\n\n\tif (chanids == NULL)\n\t\treturn -1;\n\n\tfor (display_number = x11_display_offset;\n\t    display_number < MAX_DISPLAYS;\n\t    display_number++) {\n\t\tport = 6000 + display_number;\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ssh->chanctxt->IPv4or6;\n\t\thints.ai_flags = x11_use_localhost ? 0: AI_PASSIVE;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t\tsnprintf(strport, sizeof strport, \"%d\", port);\n\t\tif ((gaierr = getaddrinfo(NULL, strport,\n\t\t    &hints, &aitop)) != 0) {\n\t\t\terror(\"getaddrinfo: %.100s\", ssh_gai_strerror(gaierr));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\t\tif (ai->ai_family != AF_INET &&\n\t\t\t    ai->ai_family != AF_INET6)\n\t\t\t\tcontinue;\n\t\t\tsock = socket(ai->ai_family, ai->ai_socktype,\n\t\t\t    ai->ai_protocol);\n\t\t\tif (sock < 0) {\n\t\t\t\tif ((errno != EINVAL) && (errno != EAFNOSUPPORT)\n#ifdef EPFNOSUPPORT\n\t\t\t\t    && (errno != EPFNOSUPPORT)\n#endif \n\t\t\t\t    ) {\n\t\t\t\t\terror(\"socket: %.100s\", strerror(errno));\n\t\t\t\t\tfreeaddrinfo(aitop);\n\t\t\t\t\treturn -1;\n\t\t\t\t} else {\n\t\t\t\t\tdebug(\"x11_create_display_inet: Socket family %d not supported\",\n\t\t\t\t\t\t ai->ai_family);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ai->ai_family == AF_INET6)\n\t\t\t\tsock_set_v6only(sock);\n\t\t\tif (x11_use_localhost)\n\t\t\t\tset_reuseaddr(sock);\n\t\t\tif (bind(sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\t\tdebug2(\"%s: bind port %d: %.100s\", __func__,\n\t\t\t\t    port, strerror(errno));\n\t\t\t\tclose(sock);\n\t\t\t\tfor (n = 0; n < num_socks; n++)\n\t\t\t\t\tclose(socks[n]);\n\t\t\t\tnum_socks = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsocks[num_socks++] = sock;\n\t\t\tif (num_socks == NUM_SOCKS)\n\t\t\t\tbreak;\n\t\t}\n\t\tfreeaddrinfo(aitop);\n\t\tif (num_socks > 0)\n\t\t\tbreak;\n\t}\n\tif (display_number >= MAX_DISPLAYS) {\n\t\terror(\"Failed to allocate internet-domain X11 display socket.\");\n\t\treturn -1;\n\t}\n\t/* Start listening for connections on the socket. */\n\tfor (n = 0; n < num_socks; n++) {\n\t\tsock = socks[n];\n\t\tif (listen(sock, SSH_LISTEN_BACKLOG) < 0) {\n\t\t\terror(\"listen: %.100s\", strerror(errno));\n\t\t\tclose(sock);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Allocate a channel for each socket. */\n\t*chanids = xcalloc(num_socks + 1, sizeof(**chanids));\n\tfor (n = 0; n < num_socks; n++) {\n\t\tsock = socks[n];\n\t\tnc = channel_new(ssh, \"x11 listener\",\n\t\t    SSH_CHANNEL_X11_LISTENER, sock, sock, -1,\n\t\t    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,\n\t\t    0, \"X11 inet listener\", 1);\n\t\tnc->single_connection = single_connection;\n\t\t(*chanids)[n] = nc->self;\n\t}\n\t(*chanids)[n] = -1;\n\n\t/* Return the display number for the DISPLAY environment variable. */\n\t*display_numberp = display_number;\n\treturn 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_DISPLAYS  1000",
            "#define\tNUM_SOCKS\t10"
          ],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_DISPLAYS  1000\n#define\tNUM_SOCKS\t10\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nint\nx11_create_display_inet(struct ssh *ssh, int x11_display_offset,\n    int x11_use_localhost, int single_connection,\n    u_int *display_numberp, int **chanids)\n{\n\tChannel *nc = NULL;\n\tint display_number, sock;\n\tu_short port;\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar strport[NI_MAXSERV];\n\tint gaierr, n, num_socks = 0, socks[NUM_SOCKS];\n\n\tif (chanids == NULL)\n\t\treturn -1;\n\n\tfor (display_number = x11_display_offset;\n\t    display_number < MAX_DISPLAYS;\n\t    display_number++) {\n\t\tport = 6000 + display_number;\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ssh->chanctxt->IPv4or6;\n\t\thints.ai_flags = x11_use_localhost ? 0: AI_PASSIVE;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t\tsnprintf(strport, sizeof strport, \"%d\", port);\n\t\tif ((gaierr = getaddrinfo(NULL, strport,\n\t\t    &hints, &aitop)) != 0) {\n\t\t\terror(\"getaddrinfo: %.100s\", ssh_gai_strerror(gaierr));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\t\tif (ai->ai_family != AF_INET &&\n\t\t\t    ai->ai_family != AF_INET6)\n\t\t\t\tcontinue;\n\t\t\tsock = socket(ai->ai_family, ai->ai_socktype,\n\t\t\t    ai->ai_protocol);\n\t\t\tif (sock < 0) {\n\t\t\t\tif ((errno != EINVAL) && (errno != EAFNOSUPPORT)\n#ifdef EPFNOSUPPORT\n\t\t\t\t    && (errno != EPFNOSUPPORT)\n#endif \n\t\t\t\t    ) {\n\t\t\t\t\terror(\"socket: %.100s\", strerror(errno));\n\t\t\t\t\tfreeaddrinfo(aitop);\n\t\t\t\t\treturn -1;\n\t\t\t\t} else {\n\t\t\t\t\tdebug(\"x11_create_display_inet: Socket family %d not supported\",\n\t\t\t\t\t\t ai->ai_family);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ai->ai_family == AF_INET6)\n\t\t\t\tsock_set_v6only(sock);\n\t\t\tif (x11_use_localhost)\n\t\t\t\tset_reuseaddr(sock);\n\t\t\tif (bind(sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\t\tdebug2(\"%s: bind port %d: %.100s\", __func__,\n\t\t\t\t    port, strerror(errno));\n\t\t\t\tclose(sock);\n\t\t\t\tfor (n = 0; n < num_socks; n++)\n\t\t\t\t\tclose(socks[n]);\n\t\t\t\tnum_socks = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsocks[num_socks++] = sock;\n\t\t\tif (num_socks == NUM_SOCKS)\n\t\t\t\tbreak;\n\t\t}\n\t\tfreeaddrinfo(aitop);\n\t\tif (num_socks > 0)\n\t\t\tbreak;\n\t}\n\tif (display_number >= MAX_DISPLAYS) {\n\t\terror(\"Failed to allocate internet-domain X11 display socket.\");\n\t\treturn -1;\n\t}\n\t/* Start listening for connections on the socket. */\n\tfor (n = 0; n < num_socks; n++) {\n\t\tsock = socks[n];\n\t\tif (listen(sock, SSH_LISTEN_BACKLOG) < 0) {\n\t\t\terror(\"listen: %.100s\", strerror(errno));\n\t\t\tclose(sock);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Allocate a channel for each socket. */\n\t*chanids = xcalloc(num_socks + 1, sizeof(**chanids));\n\tfor (n = 0; n < num_socks; n++) {\n\t\tsock = socks[n];\n\t\tnc = channel_new(ssh, \"x11 listener\",\n\t\t    SSH_CHANNEL_X11_LISTENER, sock, sock, -1,\n\t\t    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,\n\t\t    0, \"X11 inet listener\", 1);\n\t\tnc->single_connection = single_connection;\n\t\t(*chanids)[n] = nc->self;\n\t}\n\t(*chanids)[n] = -1;\n\n\t/* Return the display number for the DISPLAY environment variable. */\n\t*display_numberp = display_number;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "options.xauth_location",
            "&st"
          ],
          "line": 2576
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\n\nint\nsession_setup_x11fwd(struct ssh *ssh, Session *s)\n{\n\tstruct stat st;\n\tchar display[512], auth_display[512];\n\tchar hostname[NI_MAXHOST];\n\tu_int i;\n\n\tif (!auth_opts->permit_x11_forwarding_flag) {\n\t\tpacket_send_debug(\"X11 forwarding disabled by key options.\");\n\t\treturn 0;\n\t}\n\tif (!options.x11_forwarding) {\n\t\tdebug(\"X11 forwarding disabled in server configuration file.\");\n\t\treturn 0;\n\t}\n\tif (options.xauth_location == NULL ||\n\t    (stat(options.xauth_location, &st) == -1)) {\n\t\tpacket_send_debug(\"No xauth program; cannot forward X11.\");\n\t\treturn 0;\n\t}\n\tif (s->display != NULL) {\n\t\tdebug(\"X11 display already set.\");\n\t\treturn 0;\n\t}\n\tif (x11_create_display_inet(ssh, options.x11_display_offset,\n\t    options.x11_use_localhost, s->single_connection,\n\t    &s->display_number, &s->x11_chanids) == -1) {\n\t\tdebug(\"x11_create_display_inet failed.\");\n\t\treturn 0;\n\t}\n\tfor (i = 0; s->x11_chanids[i] != -1; i++) {\n\t\tchannel_register_cleanup(ssh, s->x11_chanids[i],\n\t\t    session_close_single_x11, 0);\n\t}\n\n\t/* Set up a suitable value for the DISPLAY variable. */\n\tif (gethostname(hostname, sizeof(hostname)) < 0)\n\t\tfatal(\"gethostname: %.100s\", strerror(errno));\n\t/*\n\t * auth_display must be used as the displayname when the\n\t * authorization entry is added with xauth(1).  This will be\n\t * different than the DISPLAY string for localhost displays.\n\t */\n\tif (options.x11_use_localhost) {\n\t\tsnprintf(display, sizeof display, \"localhost:%u.%u\",\n\t\t    s->display_number, s->screen);\n\t\tsnprintf(auth_display, sizeof auth_display, \"unix:%u.%u\",\n\t\t    s->display_number, s->screen);\n\t\ts->display = xstrdup(display);\n\t\ts->auth_display = xstrdup(auth_display);\n\t} else {\n#ifdef IPADDR_IN_DISPLAY\n\t\tstruct hostent *he;\n\t\tstruct in_addr my_addr;\n\n\t\the = gethostbyname(hostname);\n\t\tif (he == NULL) {\n\t\t\terror(\"Can't get IP address for X11 DISPLAY.\");\n\t\t\tpacket_send_debug(\"Can't get IP address for X11 DISPLAY.\");\n\t\t\treturn 0;\n\t\t}\n\t\tmemcpy(&my_addr, he->h_addr_list[0], sizeof(struct in_addr));\n\t\tsnprintf(display, sizeof display, \"%.50s:%u.%u\", inet_ntoa(my_addr),\n\t\t    s->display_number, s->screen);\n#else\n\t\tsnprintf(display, sizeof display, \"%.400s:%u.%u\", hostname,\n\t\t    s->display_number, s->screen);\n#endif\n\t\ts->display = xstrdup(display);\n\t\ts->auth_display = xstrdup(display);\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "session_proctitle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2550-2557",
    "snippet": "void\nsession_proctitle(Session *s)\n{\n\tif (s->pw == NULL)\n\t\terror(\"no user for session %d\", s->self);\n\telse\n\t\tsetproctitle(\"%s@%s\", s->pw->pw_name, session_tty_list());\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "setproctitle",
          "args": [
            "\"%s@%s\"",
            "s->pw->pw_name",
            "session_tty_list()"
          ],
          "line": 2556
        },
        "resolved": true,
        "details": {
          "function_name": "setproctitle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/setproctitle.c",
          "lines": "122-167",
          "snippet": "void\nsetproctitle(const char *fmt, ...)\n{\n#if SPT_TYPE != SPT_NONE\n\tva_list ap;\n\tchar buf[1024], ptitle[1024];\n\tsize_t len = 0;\n\tint r;\n\textern char *__progname;\n#if SPT_TYPE == SPT_PSTAT\n\tunion pstun pst;\n#endif\n\n#if SPT_TYPE == SPT_REUSEARGV\n\tif (argv_env_len <= 0)\n\t\treturn;\n#endif\n\n\tstrlcpy(buf, __progname, sizeof(buf));\n\n\tr = -1;\n\tva_start(ap, fmt);\n\tif (fmt != NULL) {\n\t\tlen = strlcat(buf, \": \", sizeof(buf));\n\t\tif (len < sizeof(buf))\n\t\t\tr = vsnprintf(buf + len, sizeof(buf) - len , fmt, ap);\n\t}\n\tva_end(ap);\n\tif (r == -1 || (size_t)r >= sizeof(buf) - len)\n\t\treturn;\n\tstrnvis(ptitle, buf, sizeof(ptitle),\n\t    VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL);\n\n#if SPT_TYPE == SPT_PSTAT\n\tpst.pst_command = ptitle;\n\tpstat(PSTAT_SETCMD, pst, strlen(ptitle), 0, 0);\n#elif SPT_TYPE == SPT_REUSEARGV\n/*\tdebug(\"setproctitle: copy \\\"%s\\\" into len %d\",\n\t    buf, argv_env_len); */\n\tlen = strlcpy(argv_start, ptitle, argv_env_len);\n\tfor(; len < argv_env_len; len++)\n\t\targv_start[len] = SPT_PADCHAR;\n#endif\n\n#endif /* SPT_NONE */\n}",
          "includes": [
            "#include <vis.h>",
            "#include <string.h>",
            "#include <sys/pstat.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SPT_REUSEARGV\t2\t/* cover argv with title information */",
            "#define SPT_PSTAT\t1\t/* use pstat(PSTAT_SETCMD, ...) */",
            "#define SPT_NONE\t0\t/* don't use it at all */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vis.h>\n#include <string.h>\n#include <sys/pstat.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\n#define SPT_REUSEARGV\t2\t/* cover argv with title information */\n#define SPT_PSTAT\t1\t/* use pstat(PSTAT_SETCMD, ...) */\n#define SPT_NONE\t0\t/* don't use it at all */\n\nvoid\nsetproctitle(const char *fmt, ...)\n{\n#if SPT_TYPE != SPT_NONE\n\tva_list ap;\n\tchar buf[1024], ptitle[1024];\n\tsize_t len = 0;\n\tint r;\n\textern char *__progname;\n#if SPT_TYPE == SPT_PSTAT\n\tunion pstun pst;\n#endif\n\n#if SPT_TYPE == SPT_REUSEARGV\n\tif (argv_env_len <= 0)\n\t\treturn;\n#endif\n\n\tstrlcpy(buf, __progname, sizeof(buf));\n\n\tr = -1;\n\tva_start(ap, fmt);\n\tif (fmt != NULL) {\n\t\tlen = strlcat(buf, \": \", sizeof(buf));\n\t\tif (len < sizeof(buf))\n\t\t\tr = vsnprintf(buf + len, sizeof(buf) - len , fmt, ap);\n\t}\n\tva_end(ap);\n\tif (r == -1 || (size_t)r >= sizeof(buf) - len)\n\t\treturn;\n\tstrnvis(ptitle, buf, sizeof(ptitle),\n\t    VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL);\n\n#if SPT_TYPE == SPT_PSTAT\n\tpst.pst_command = ptitle;\n\tpstat(PSTAT_SETCMD, pst, strlen(ptitle), 0, 0);\n#elif SPT_TYPE == SPT_REUSEARGV\n/*\tdebug(\"setproctitle: copy \\\"%s\\\" into len %d\",\n\t    buf, argv_env_len); */\n\tlen = strlcpy(argv_start, ptitle, argv_env_len);\n\tfor(; len < argv_env_len; len++)\n\t\targv_start[len] = SPT_PADCHAR;\n#endif\n\n#endif /* SPT_NONE */\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_tty_list",
          "args": [],
          "line": 2556
        },
        "resolved": true,
        "details": {
          "function_name": "session_tty_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2522-2548",
          "snippet": "static char *\nsession_tty_list(void)\n{\n\tstatic char buf[1024];\n\tint i;\n\tchar *cp;\n\n\tbuf[0] = '\\0';\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->ttyfd != -1) {\n\n\t\t\tif (strncmp(s->tty, \"/dev/\", 5) != 0) {\n\t\t\t\tcp = strrchr(s->tty, '/');\n\t\t\t\tcp = (cp == NULL) ? s->tty : cp + 1;\n\t\t\t} else\n\t\t\t\tcp = s->tty + 5;\n\n\t\t\tif (buf[0] != '\\0')\n\t\t\t\tstrlcat(buf, \",\", sizeof buf);\n\t\t\tstrlcat(buf, cp, sizeof buf);\n\t\t}\n\t}\n\tif (buf[0] == '\\0')\n\t\tstrlcpy(buf, \"notty\", sizeof buf);\n\treturn buf;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "static int sessions_nalloc = 0;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nstatic char *\nsession_tty_list(void)\n{\n\tstatic char buf[1024];\n\tint i;\n\tchar *cp;\n\n\tbuf[0] = '\\0';\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->ttyfd != -1) {\n\n\t\t\tif (strncmp(s->tty, \"/dev/\", 5) != 0) {\n\t\t\t\tcp = strrchr(s->tty, '/');\n\t\t\t\tcp = (cp == NULL) ? s->tty : cp + 1;\n\t\t\t} else\n\t\t\t\tcp = s->tty + 5;\n\n\t\t\tif (buf[0] != '\\0')\n\t\t\t\tstrlcat(buf, \",\", sizeof buf);\n\t\t\tstrlcat(buf, cp, sizeof buf);\n\t\t}\n\t}\n\tif (buf[0] == '\\0')\n\t\tstrlcpy(buf, \"notty\", sizeof buf);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"no user for session %d\"",
            "s->self"
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_proctitle(Session *s)\n{\n\tif (s->pw == NULL)\n\t\terror(\"no user for session %d\", s->self);\n\telse\n\t\tsetproctitle(\"%s@%s\", s->pw->pw_name, session_tty_list());\n}"
  },
  {
    "function_name": "session_tty_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2522-2548",
    "snippet": "static char *\nsession_tty_list(void)\n{\n\tstatic char buf[1024];\n\tint i;\n\tchar *cp;\n\n\tbuf[0] = '\\0';\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->ttyfd != -1) {\n\n\t\t\tif (strncmp(s->tty, \"/dev/\", 5) != 0) {\n\t\t\t\tcp = strrchr(s->tty, '/');\n\t\t\t\tcp = (cp == NULL) ? s->tty : cp + 1;\n\t\t\t} else\n\t\t\t\tcp = s->tty + 5;\n\n\t\t\tif (buf[0] != '\\0')\n\t\t\t\tstrlcat(buf, \",\", sizeof buf);\n\t\t\tstrlcat(buf, cp, sizeof buf);\n\t\t}\n\t}\n\tif (buf[0] == '\\0')\n\t\tstrlcpy(buf, \"notty\", sizeof buf);\n\treturn buf;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "static int sessions_nalloc = 0;",
      "static Session *sessions = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "buf",
            "\"notty\"",
            "sizeof buf"
          ],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcat",
          "args": [
            "buf",
            "cp",
            "sizeof buf"
          ],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "strlcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcat.c",
          "lines": "34-60",
          "snippet": "size_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "s->tty",
            "'/'"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "s->tty",
            "\"/dev/\"",
            "5"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nstatic char *\nsession_tty_list(void)\n{\n\tstatic char buf[1024];\n\tint i;\n\tchar *cp;\n\n\tbuf[0] = '\\0';\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->ttyfd != -1) {\n\n\t\t\tif (strncmp(s->tty, \"/dev/\", 5) != 0) {\n\t\t\t\tcp = strrchr(s->tty, '/');\n\t\t\t\tcp = (cp == NULL) ? s->tty : cp + 1;\n\t\t\t} else\n\t\t\t\tcp = s->tty + 5;\n\n\t\t\tif (buf[0] != '\\0')\n\t\t\t\tstrlcat(buf, \",\", sizeof buf);\n\t\t\tstrlcat(buf, cp, sizeof buf);\n\t\t}\n\t}\n\tif (buf[0] == '\\0')\n\t\tstrlcpy(buf, \"notty\", sizeof buf);\n\treturn buf;\n}"
  },
  {
    "function_name": "session_destroy_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2507-2520",
    "snippet": "void\nsession_destroy_all(struct ssh *ssh, void (*closefunc)(Session *))\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used) {\n\t\t\tif (closefunc != NULL)\n\t\t\t\tclosefunc(s);\n\t\t\telse\n\t\t\t\tsession_close(ssh, s);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "static int sessions_nalloc = 0;",
      "static Session *sessions = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "session_close",
          "args": [
            "ssh",
            "s"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2420-2449",
          "snippet": "void\nsession_close(struct ssh *ssh, Session *s)\n{\n\tu_int i;\n\n\tverbose(\"Close session: user %s from %.200s port %d id %d\",\n\t    s->pw->pw_name,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    s->self);\n\n\tif (s->ttyfd != -1)\n\t\tsession_pty_cleanup(s);\n\tfree(s->term);\n\tfree(s->display);\n\tfree(s->x11_chanids);\n\tfree(s->auth_display);\n\tfree(s->auth_data);\n\tfree(s->auth_proto);\n\tfree(s->subsys);\n\tif (s->env != NULL) {\n\t\tfor (i = 0; i < s->num_env; i++) {\n\t\t\tfree(s->env[i].name);\n\t\t\tfree(s->env[i].val);\n\t\t}\n\t\tfree(s->env);\n\t}\n\tsession_proctitle(s);\n\tsession_unused(s->self);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_close(struct ssh *ssh, Session *s)\n{\n\tu_int i;\n\n\tverbose(\"Close session: user %s from %.200s port %d id %d\",\n\t    s->pw->pw_name,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    s->self);\n\n\tif (s->ttyfd != -1)\n\t\tsession_pty_cleanup(s);\n\tfree(s->term);\n\tfree(s->display);\n\tfree(s->x11_chanids);\n\tfree(s->auth_display);\n\tfree(s->auth_data);\n\tfree(s->auth_proto);\n\tfree(s->subsys);\n\tif (s->env != NULL) {\n\t\tfor (i = 0; i < s->num_env; i++) {\n\t\t\tfree(s->env[i].name);\n\t\t\tfree(s->env[i].val);\n\t\t}\n\t\tfree(s->env);\n\t}\n\tsession_proctitle(s);\n\tsession_unused(s->self);\n}"
        }
      },
      {
        "call_info": {
          "callee": "closefunc",
          "args": [
            "s"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nvoid\nsession_destroy_all(struct ssh *ssh, void (*closefunc)(Session *))\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used) {\n\t\t\tif (closefunc != NULL)\n\t\t\t\tclosefunc(s);\n\t\t\telse\n\t\t\t\tsession_close(ssh, s);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "session_close_by_channel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2470-2505",
    "snippet": "void\nsession_close_by_channel(struct ssh *ssh, int id, void *arg)\n{\n\tSession *s = session_by_channel(id);\n\tu_int i;\n\n\tif (s == NULL) {\n\t\tdebug(\"%s: no session for id %d\", __func__, id);\n\t\treturn;\n\t}\n\tdebug(\"%s: channel %d child %ld\", __func__, id, (long)s->pid);\n\tif (s->pid != 0) {\n\t\tdebug(\"%s: channel %d: has child, ttyfd %d\",\n\t\t    __func__, id, s->ttyfd);\n\t\t/*\n\t\t * delay detach of session, but release pty, since\n\t\t * the fd's to the child are already closed\n\t\t */\n\t\tif (s->ttyfd != -1)\n\t\t\tsession_pty_cleanup(s);\n\t\treturn;\n\t}\n\t/* detach by removing callback */\n\tchannel_cancel_cleanup(ssh, s->chanid);\n\n\t/* Close any X11 listeners associated with this session */\n\tif (s->x11_chanids != NULL) {\n\t\tfor (i = 0; s->x11_chanids[i] != -1; i++) {\n\t\t\tsession_close_x11(ssh, s->x11_chanids[i]);\n\t\t\ts->x11_chanids[i] = -1;\n\t\t}\n\t}\n\n\ts->chanid = -1;\n\tsession_close(ssh, s);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "session_close",
          "args": [
            "ssh",
            "s"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2420-2449",
          "snippet": "void\nsession_close(struct ssh *ssh, Session *s)\n{\n\tu_int i;\n\n\tverbose(\"Close session: user %s from %.200s port %d id %d\",\n\t    s->pw->pw_name,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    s->self);\n\n\tif (s->ttyfd != -1)\n\t\tsession_pty_cleanup(s);\n\tfree(s->term);\n\tfree(s->display);\n\tfree(s->x11_chanids);\n\tfree(s->auth_display);\n\tfree(s->auth_data);\n\tfree(s->auth_proto);\n\tfree(s->subsys);\n\tif (s->env != NULL) {\n\t\tfor (i = 0; i < s->num_env; i++) {\n\t\t\tfree(s->env[i].name);\n\t\t\tfree(s->env[i].val);\n\t\t}\n\t\tfree(s->env);\n\t}\n\tsession_proctitle(s);\n\tsession_unused(s->self);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_close(struct ssh *ssh, Session *s)\n{\n\tu_int i;\n\n\tverbose(\"Close session: user %s from %.200s port %d id %d\",\n\t    s->pw->pw_name,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    s->self);\n\n\tif (s->ttyfd != -1)\n\t\tsession_pty_cleanup(s);\n\tfree(s->term);\n\tfree(s->display);\n\tfree(s->x11_chanids);\n\tfree(s->auth_display);\n\tfree(s->auth_data);\n\tfree(s->auth_proto);\n\tfree(s->subsys);\n\tif (s->env != NULL) {\n\t\tfor (i = 0; i < s->num_env; i++) {\n\t\t\tfree(s->env[i].name);\n\t\t\tfree(s->env[i].val);\n\t\t}\n\t\tfree(s->env);\n\t}\n\tsession_proctitle(s);\n\tsession_unused(s->self);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_close_x11",
          "args": [
            "ssh",
            "s->x11_chanids[i]"
          ],
          "line": 2498
        },
        "resolved": true,
        "details": {
          "function_name": "session_close_x11",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2321-2335",
          "snippet": "static void\nsession_close_x11(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL) {\n\t\tdebug(\"%s: x11 channel %d missing\", __func__, id);\n\t} else {\n\t\t/* Detach X11 listener */\n\t\tdebug(\"%s: detach x11 channel %d\", __func__, id);\n\t\tchannel_cancel_cleanup(ssh, id);\n\t\tif (c->ostate != CHAN_OUTPUT_CLOSED)\n\t\t\tchan_mark_dead(ssh, c);\n\t}\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsession_close_x11(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL) {\n\t\tdebug(\"%s: x11 channel %d missing\", __func__, id);\n\t} else {\n\t\t/* Detach X11 listener */\n\t\tdebug(\"%s: detach x11 channel %d\", __func__, id);\n\t\tchannel_cancel_cleanup(ssh, id);\n\t\tif (c->ostate != CHAN_OUTPUT_CLOSED)\n\t\t\tchan_mark_dead(ssh, c);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_cancel_cleanup",
          "args": [
            "ssh",
            "s->chanid"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "channel_cancel_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "999-1010",
          "snippet": "void\nchannel_cancel_cleanup(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = NULL;\n\tc->detach_close = 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_cancel_cleanup(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = NULL;\n\tc->detach_close = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_pty_cleanup",
          "args": [
            "s"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "session_pty_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2294-2298",
          "snippet": "void\nsession_pty_cleanup(Session *s)\n{\n\tPRIVSEP(session_pty_cleanup2(s));\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_pty_cleanup(Session *s)\n{\n\tPRIVSEP(session_pty_cleanup2(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: channel %d: has child, ttyfd %d\"",
            "__func__",
            "id",
            "s->ttyfd"
          ],
          "line": 2482
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_by_channel",
          "args": [
            "id"
          ],
          "line": 2473
        },
        "resolved": true,
        "details": {
          "function_name": "session_by_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1850-1865",
          "snippet": "static Session *\nsession_by_channel(int id)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->chanid == id) {\n\t\t\tdebug(\"session_by_channel: session %d channel %d\",\n\t\t\t    i, id);\n\t\t\treturn s;\n\t\t}\n\t}\n\tdebug(\"session_by_channel: unknown channel %d\", id);\n\tsession_dump();\n\treturn NULL;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "static int sessions_nalloc = 0;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nstatic Session *\nsession_by_channel(int id)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->chanid == id) {\n\t\t\tdebug(\"session_by_channel: session %d channel %d\",\n\t\t\t    i, id);\n\t\t\treturn s;\n\t\t}\n\t}\n\tdebug(\"session_by_channel: unknown channel %d\", id);\n\tsession_dump();\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_close_by_channel(struct ssh *ssh, int id, void *arg)\n{\n\tSession *s = session_by_channel(id);\n\tu_int i;\n\n\tif (s == NULL) {\n\t\tdebug(\"%s: no session for id %d\", __func__, id);\n\t\treturn;\n\t}\n\tdebug(\"%s: channel %d child %ld\", __func__, id, (long)s->pid);\n\tif (s->pid != 0) {\n\t\tdebug(\"%s: channel %d: has child, ttyfd %d\",\n\t\t    __func__, id, s->ttyfd);\n\t\t/*\n\t\t * delay detach of session, but release pty, since\n\t\t * the fd's to the child are already closed\n\t\t */\n\t\tif (s->ttyfd != -1)\n\t\t\tsession_pty_cleanup(s);\n\t\treturn;\n\t}\n\t/* detach by removing callback */\n\tchannel_cancel_cleanup(ssh, s->chanid);\n\n\t/* Close any X11 listeners associated with this session */\n\tif (s->x11_chanids != NULL) {\n\t\tfor (i = 0; s->x11_chanids[i] != -1; i++) {\n\t\t\tsession_close_x11(ssh, s->x11_chanids[i]);\n\t\t\ts->x11_chanids[i] = -1;\n\t\t}\n\t}\n\n\ts->chanid = -1;\n\tsession_close(ssh, s);\n}"
  },
  {
    "function_name": "session_close_by_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2451-2464",
    "snippet": "void\nsession_close_by_pid(struct ssh *ssh, pid_t pid, int status)\n{\n\tSession *s = session_by_pid(pid);\n\tif (s == NULL) {\n\t\tdebug(\"%s: no session for pid %ld\", __func__, (long)pid);\n\t\treturn;\n\t}\n\tif (s->chanid != -1)\n\t\tsession_exit_message(ssh, s, status);\n\tif (s->ttyfd != -1)\n\t\tsession_pty_cleanup(s);\n\ts->pid = 0;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "session_pty_cleanup",
          "args": [
            "s"
          ],
          "line": 2462
        },
        "resolved": true,
        "details": {
          "function_name": "session_pty_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2294-2298",
          "snippet": "void\nsession_pty_cleanup(Session *s)\n{\n\tPRIVSEP(session_pty_cleanup2(s));\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_pty_cleanup(Session *s)\n{\n\tPRIVSEP(session_pty_cleanup2(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_exit_message",
          "args": [
            "ssh",
            "s",
            "status"
          ],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "session_exit_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2369-2418",
          "snippet": "static void\nsession_exit_message(struct ssh *ssh, Session *s, int status)\n{\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, s->chanid)) == NULL)\n\t\tfatal(\"%s: session %d: no channel %d\",\n\t\t    __func__, s->self, s->chanid);\n\tdebug(\"%s: session %d channel %d pid %ld\",\n\t    __func__, s->self, s->chanid, (long)s->pid);\n\n\tif (WIFEXITED(status)) {\n\t\tchannel_request_start(ssh, s->chanid, \"exit-status\", 0);\n\t\tpacket_put_int(WEXITSTATUS(status));\n\t\tpacket_send();\n\t} else if (WIFSIGNALED(status)) {\n\t\tchannel_request_start(ssh, s->chanid, \"exit-signal\", 0);\n\t\tpacket_put_cstring(sig2name(WTERMSIG(status)));\n#ifdef WCOREDUMP\n\t\tpacket_put_char(WCOREDUMP(status)? 1 : 0);\n#else /* WCOREDUMP */\n\t\tpacket_put_char(0);\n#endif /* WCOREDUMP */\n\t\tpacket_put_cstring(\"\");\n\t\tpacket_put_cstring(\"\");\n\t\tpacket_send();\n\t} else {\n\t\t/* Some weird exit cause.  Just exit. */\n\t\tpacket_disconnect(\"wait returned status %04x.\", status);\n\t}\n\n\t/* disconnect channel */\n\tdebug(\"%s: release channel %d\", __func__, s->chanid);\n\n\t/*\n\t * Adjust cleanup callback attachment to send close messages when\n\t * the channel gets EOF. The session will be then be closed\n\t * by session_close_by_channel when the childs close their fds.\n\t */\n\tchannel_register_cleanup(ssh, c->self, session_close_by_channel, 1);\n\n\t/*\n\t * emulate a write failure with 'chan_write_failed', nobody will be\n\t * interested in data we write.\n\t * Note that we must not call 'chan_read_failed', since there could\n\t * be some more data waiting in the pipe.\n\t */\n\tif (c->ostate != CHAN_OUTPUT_CLOSED)\n\t\tchan_write_failed(ssh, c);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic void\nsession_exit_message(struct ssh *ssh, Session *s, int status)\n{\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, s->chanid)) == NULL)\n\t\tfatal(\"%s: session %d: no channel %d\",\n\t\t    __func__, s->self, s->chanid);\n\tdebug(\"%s: session %d channel %d pid %ld\",\n\t    __func__, s->self, s->chanid, (long)s->pid);\n\n\tif (WIFEXITED(status)) {\n\t\tchannel_request_start(ssh, s->chanid, \"exit-status\", 0);\n\t\tpacket_put_int(WEXITSTATUS(status));\n\t\tpacket_send();\n\t} else if (WIFSIGNALED(status)) {\n\t\tchannel_request_start(ssh, s->chanid, \"exit-signal\", 0);\n\t\tpacket_put_cstring(sig2name(WTERMSIG(status)));\n#ifdef WCOREDUMP\n\t\tpacket_put_char(WCOREDUMP(status)? 1 : 0);\n#else /* WCOREDUMP */\n\t\tpacket_put_char(0);\n#endif /* WCOREDUMP */\n\t\tpacket_put_cstring(\"\");\n\t\tpacket_put_cstring(\"\");\n\t\tpacket_send();\n\t} else {\n\t\t/* Some weird exit cause.  Just exit. */\n\t\tpacket_disconnect(\"wait returned status %04x.\", status);\n\t}\n\n\t/* disconnect channel */\n\tdebug(\"%s: release channel %d\", __func__, s->chanid);\n\n\t/*\n\t * Adjust cleanup callback attachment to send close messages when\n\t * the channel gets EOF. The session will be then be closed\n\t * by session_close_by_channel when the childs close their fds.\n\t */\n\tchannel_register_cleanup(ssh, c->self, session_close_by_channel, 1);\n\n\t/*\n\t * emulate a write failure with 'chan_write_failed', nobody will be\n\t * interested in data we write.\n\t * Note that we must not call 'chan_read_failed', since there could\n\t * be some more data waiting in the pipe.\n\t */\n\tif (c->ostate != CHAN_OUTPUT_CLOSED)\n\t\tchan_write_failed(ssh, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: no session for pid %ld\"",
            "__func__",
            "(long)pid"
          ],
          "line": 2456
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_by_pid",
          "args": [
            "pid"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "session_by_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1890-1903",
          "snippet": "static Session *\nsession_by_pid(pid_t pid)\n{\n\tint i;\n\tdebug(\"session_by_pid: pid %ld\", (long)pid);\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->pid == pid)\n\t\t\treturn s;\n\t}\n\terror(\"session_by_pid: unknown pid %ld\", (long)pid);\n\tsession_dump();\n\treturn NULL;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "static int sessions_nalloc = 0;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nstatic Session *\nsession_by_pid(pid_t pid)\n{\n\tint i;\n\tdebug(\"session_by_pid: pid %ld\", (long)pid);\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->pid == pid)\n\t\t\treturn s;\n\t}\n\terror(\"session_by_pid: unknown pid %ld\", (long)pid);\n\tsession_dump();\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_close_by_pid(struct ssh *ssh, pid_t pid, int status)\n{\n\tSession *s = session_by_pid(pid);\n\tif (s == NULL) {\n\t\tdebug(\"%s: no session for pid %ld\", __func__, (long)pid);\n\t\treturn;\n\t}\n\tif (s->chanid != -1)\n\t\tsession_exit_message(ssh, s, status);\n\tif (s->ttyfd != -1)\n\t\tsession_pty_cleanup(s);\n\ts->pid = 0;\n}"
  },
  {
    "function_name": "session_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2420-2449",
    "snippet": "void\nsession_close(struct ssh *ssh, Session *s)\n{\n\tu_int i;\n\n\tverbose(\"Close session: user %s from %.200s port %d id %d\",\n\t    s->pw->pw_name,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    s->self);\n\n\tif (s->ttyfd != -1)\n\t\tsession_pty_cleanup(s);\n\tfree(s->term);\n\tfree(s->display);\n\tfree(s->x11_chanids);\n\tfree(s->auth_display);\n\tfree(s->auth_data);\n\tfree(s->auth_proto);\n\tfree(s->subsys);\n\tif (s->env != NULL) {\n\t\tfor (i = 0; i < s->num_env; i++) {\n\t\t\tfree(s->env[i].name);\n\t\t\tfree(s->env[i].val);\n\t\t}\n\t\tfree(s->env);\n\t}\n\tsession_proctitle(s);\n\tsession_unused(s->self);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "session_unused",
          "args": [
            "s->self"
          ],
          "line": 2448
        },
        "resolved": true,
        "details": {
          "function_name": "session_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1736-1755",
          "snippet": "void\nsession_unused(int id)\n{\n\tdebug3(\"%s: session id %d unused\", __func__, id);\n\tif (id >= options.max_sessions ||\n\t    id >= sessions_nalloc) {\n\t\tfatal(\"%s: insane session id %d (max %d nalloc %d)\",\n\t\t    __func__, id, options.max_sessions, sessions_nalloc);\n\t}\n\tmemset(&sessions[id], 0, sizeof(*sessions));\n\tsessions[id].self = id;\n\tsessions[id].used = 0;\n\tsessions[id].chanid = -1;\n\tsessions[id].ptyfd = -1;\n\tsessions[id].ttyfd = -1;\n\tsessions[id].ptymaster = -1;\n\tsessions[id].x11_chanids = NULL;\n\tsessions[id].next_unused = sessions_first_unused;\n\tsessions_first_unused = id;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "static int sessions_first_unused = -1;",
            "static int sessions_nalloc = 0;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nstatic int sessions_first_unused = -1;\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nvoid\nsession_unused(int id)\n{\n\tdebug3(\"%s: session id %d unused\", __func__, id);\n\tif (id >= options.max_sessions ||\n\t    id >= sessions_nalloc) {\n\t\tfatal(\"%s: insane session id %d (max %d nalloc %d)\",\n\t\t    __func__, id, options.max_sessions, sessions_nalloc);\n\t}\n\tmemset(&sessions[id], 0, sizeof(*sessions));\n\tsessions[id].self = id;\n\tsessions[id].used = 0;\n\tsessions[id].chanid = -1;\n\tsessions[id].ptyfd = -1;\n\tsessions[id].ttyfd = -1;\n\tsessions[id].ptymaster = -1;\n\tsessions[id].x11_chanids = NULL;\n\tsessions[id].next_unused = sessions_first_unused;\n\tsessions_first_unused = id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_proctitle",
          "args": [
            "s"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "session_proctitle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2550-2557",
          "snippet": "void\nsession_proctitle(Session *s)\n{\n\tif (s->pw == NULL)\n\t\terror(\"no user for session %d\", s->self);\n\telse\n\t\tsetproctitle(\"%s@%s\", s->pw->pw_name, session_tty_list());\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_proctitle(Session *s)\n{\n\tif (s->pw == NULL)\n\t\terror(\"no user for session %d\", s->self);\n\telse\n\t\tsetproctitle(\"%s@%s\", s->pw->pw_name, session_tty_list());\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s->env"
          ],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_pty_cleanup",
          "args": [
            "s"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "session_pty_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2294-2298",
          "snippet": "void\nsession_pty_cleanup(Session *s)\n{\n\tPRIVSEP(session_pty_cleanup2(s));\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_pty_cleanup(Session *s)\n{\n\tPRIVSEP(session_pty_cleanup2(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Close session: user %s from %.200s port %d id %d\"",
            "s->pw->pw_name",
            "ssh_remote_ipaddr(ssh)",
            "ssh_remote_port(ssh)",
            "s->self"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_port",
          "args": [
            "ssh"
          ],
          "line": 2428
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "539-544",
          "snippet": "int\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 2427
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_close(struct ssh *ssh, Session *s)\n{\n\tu_int i;\n\n\tverbose(\"Close session: user %s from %.200s port %d id %d\",\n\t    s->pw->pw_name,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    s->self);\n\n\tif (s->ttyfd != -1)\n\t\tsession_pty_cleanup(s);\n\tfree(s->term);\n\tfree(s->display);\n\tfree(s->x11_chanids);\n\tfree(s->auth_display);\n\tfree(s->auth_data);\n\tfree(s->auth_proto);\n\tfree(s->subsys);\n\tif (s->env != NULL) {\n\t\tfor (i = 0; i < s->num_env; i++) {\n\t\t\tfree(s->env[i].name);\n\t\t\tfree(s->env[i].val);\n\t\t}\n\t\tfree(s->env);\n\t}\n\tsession_proctitle(s);\n\tsession_unused(s->self);\n}"
  },
  {
    "function_name": "session_exit_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2369-2418",
    "snippet": "static void\nsession_exit_message(struct ssh *ssh, Session *s, int status)\n{\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, s->chanid)) == NULL)\n\t\tfatal(\"%s: session %d: no channel %d\",\n\t\t    __func__, s->self, s->chanid);\n\tdebug(\"%s: session %d channel %d pid %ld\",\n\t    __func__, s->self, s->chanid, (long)s->pid);\n\n\tif (WIFEXITED(status)) {\n\t\tchannel_request_start(ssh, s->chanid, \"exit-status\", 0);\n\t\tpacket_put_int(WEXITSTATUS(status));\n\t\tpacket_send();\n\t} else if (WIFSIGNALED(status)) {\n\t\tchannel_request_start(ssh, s->chanid, \"exit-signal\", 0);\n\t\tpacket_put_cstring(sig2name(WTERMSIG(status)));\n#ifdef WCOREDUMP\n\t\tpacket_put_char(WCOREDUMP(status)? 1 : 0);\n#else /* WCOREDUMP */\n\t\tpacket_put_char(0);\n#endif /* WCOREDUMP */\n\t\tpacket_put_cstring(\"\");\n\t\tpacket_put_cstring(\"\");\n\t\tpacket_send();\n\t} else {\n\t\t/* Some weird exit cause.  Just exit. */\n\t\tpacket_disconnect(\"wait returned status %04x.\", status);\n\t}\n\n\t/* disconnect channel */\n\tdebug(\"%s: release channel %d\", __func__, s->chanid);\n\n\t/*\n\t * Adjust cleanup callback attachment to send close messages when\n\t * the channel gets EOF. The session will be then be closed\n\t * by session_close_by_channel when the childs close their fds.\n\t */\n\tchannel_register_cleanup(ssh, c->self, session_close_by_channel, 1);\n\n\t/*\n\t * emulate a write failure with 'chan_write_failed', nobody will be\n\t * interested in data we write.\n\t * Note that we must not call 'chan_read_failed', since there could\n\t * be some more data waiting in the pipe.\n\t */\n\tif (c->ostate != CHAN_OUTPUT_CLOSED)\n\t\tchan_write_failed(ssh, c);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "chan_write_failed",
          "args": [
            "ssh",
            "c"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "chan_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "305-322",
          "snippet": "void\nchan_write_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: write failed\", c->self);\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tif (strcmp(c->ctype, \"session\") == 0)\n\t\t\tchan_send_eow2(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_write_failed for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_write_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: write failed\", c->self);\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tif (strcmp(c->ctype, \"session\") == 0)\n\t\t\tchan_send_eow2(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_write_failed for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_register_cleanup",
          "args": [
            "ssh",
            "c->self",
            "session_close_by_channel",
            "1"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "channel_register_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "985-997",
          "snippet": "void\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: release channel %d\"",
            "__func__",
            "s->chanid"
          ],
          "line": 2401
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_disconnect",
          "args": [
            "\"wait returned status %04x.\"",
            "status"
          ],
          "line": 2397
        },
        "resolved": true,
        "details": {
          "function_name": "packet_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "298-308",
          "snippet": "void\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "\"\""
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "\"\""
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_char",
          "args": [
            "0"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_char",
          "args": [
            "WCOREDUMP(status)? 1 : 0"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WCOREDUMP",
          "args": [
            "status"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_cstring",
          "args": [
            "sig2name(WTERMSIG(status))"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig2name",
          "args": [
            "WTERMSIG(status)"
          ],
          "line": 2386
        },
        "resolved": true,
        "details": {
          "function_name": "sig2name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2300-2319",
          "snippet": "static char *\nsig2name(int sig)\n{\n#define SSH_SIG(x) if (sig == SIG ## x) return #x\n\tSSH_SIG(ABRT);\n\tSSH_SIG(ALRM);\n\tSSH_SIG(FPE);\n\tSSH_SIG(HUP);\n\tSSH_SIG(ILL);\n\tSSH_SIG(INT);\n\tSSH_SIG(KILL);\n\tSSH_SIG(PIPE);\n\tSSH_SIG(QUIT);\n\tSSH_SIG(SEGV);\n\tSSH_SIG(TERM);\n\tSSH_SIG(USR1);\n\tSSH_SIG(USR2);\n#undef\tSSH_SIG\n\treturn \"SIG@openssh.com\";\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nsig2name(int sig)\n{\n#define SSH_SIG(x) if (sig == SIG ## x) return #x\n\tSSH_SIG(ABRT);\n\tSSH_SIG(ALRM);\n\tSSH_SIG(FPE);\n\tSSH_SIG(HUP);\n\tSSH_SIG(ILL);\n\tSSH_SIG(INT);\n\tSSH_SIG(KILL);\n\tSSH_SIG(PIPE);\n\tSSH_SIG(QUIT);\n\tSSH_SIG(SEGV);\n\tSSH_SIG(TERM);\n\tSSH_SIG(USR1);\n\tSSH_SIG(USR2);\n#undef\tSSH_SIG\n\treturn \"SIG@openssh.com\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_request_start",
          "args": [
            "ssh",
            "s->chanid",
            "\"exit-signal\"",
            "0"
          ],
          "line": 2385
        },
        "resolved": true,
        "details": {
          "function_name": "channel_request_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "932-952",
          "snippet": "void\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: unknown channel id\", __func__, id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n\t}\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: unknown channel id\", __func__, id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_send",
          "args": [],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_put_int",
          "args": [
            "WEXITSTATUS(status)"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: session %d: no channel %d\"",
            "__func__",
            "s->self",
            "s->chanid"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_lookup",
          "args": [
            "ssh",
            "s->chanid"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "channel_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "279-302",
          "snippet": "Channel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic void\nsession_exit_message(struct ssh *ssh, Session *s, int status)\n{\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, s->chanid)) == NULL)\n\t\tfatal(\"%s: session %d: no channel %d\",\n\t\t    __func__, s->self, s->chanid);\n\tdebug(\"%s: session %d channel %d pid %ld\",\n\t    __func__, s->self, s->chanid, (long)s->pid);\n\n\tif (WIFEXITED(status)) {\n\t\tchannel_request_start(ssh, s->chanid, \"exit-status\", 0);\n\t\tpacket_put_int(WEXITSTATUS(status));\n\t\tpacket_send();\n\t} else if (WIFSIGNALED(status)) {\n\t\tchannel_request_start(ssh, s->chanid, \"exit-signal\", 0);\n\t\tpacket_put_cstring(sig2name(WTERMSIG(status)));\n#ifdef WCOREDUMP\n\t\tpacket_put_char(WCOREDUMP(status)? 1 : 0);\n#else /* WCOREDUMP */\n\t\tpacket_put_char(0);\n#endif /* WCOREDUMP */\n\t\tpacket_put_cstring(\"\");\n\t\tpacket_put_cstring(\"\");\n\t\tpacket_send();\n\t} else {\n\t\t/* Some weird exit cause.  Just exit. */\n\t\tpacket_disconnect(\"wait returned status %04x.\", status);\n\t}\n\n\t/* disconnect channel */\n\tdebug(\"%s: release channel %d\", __func__, s->chanid);\n\n\t/*\n\t * Adjust cleanup callback attachment to send close messages when\n\t * the channel gets EOF. The session will be then be closed\n\t * by session_close_by_channel when the childs close their fds.\n\t */\n\tchannel_register_cleanup(ssh, c->self, session_close_by_channel, 1);\n\n\t/*\n\t * emulate a write failure with 'chan_write_failed', nobody will be\n\t * interested in data we write.\n\t * Note that we must not call 'chan_read_failed', since there could\n\t * be some more data waiting in the pipe.\n\t */\n\tif (c->ostate != CHAN_OUTPUT_CLOSED)\n\t\tchan_write_failed(ssh, c);\n}"
  },
  {
    "function_name": "session_close_single_x11",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2337-2367",
    "snippet": "static void\nsession_close_single_x11(struct ssh *ssh, int id, void *arg)\n{\n\tSession *s;\n\tu_int i;\n\n\tdebug3(\"%s: channel %d\", __func__, id);\n\tchannel_cancel_cleanup(ssh, id);\n\tif ((s = session_by_x11_channel(id)) == NULL)\n\t\tfatal(\"%s: no x11 channel %d\", __func__, id);\n\tfor (i = 0; s->x11_chanids[i] != -1; i++) {\n\t\tdebug(\"%s: session %d: closing channel %d\",\n\t\t    __func__, s->self, s->x11_chanids[i]);\n\t\t/*\n\t\t * The channel \"id\" is already closing, but make sure we\n\t\t * close all of its siblings.\n\t\t */\n\t\tif (s->x11_chanids[i] != id)\n\t\t\tsession_close_x11(ssh, s->x11_chanids[i]);\n\t}\n\tfree(s->x11_chanids);\n\ts->x11_chanids = NULL;\n\tfree(s->display);\n\ts->display = NULL;\n\tfree(s->auth_proto);\n\ts->auth_proto = NULL;\n\tfree(s->auth_data);\n\ts->auth_data = NULL;\n\tfree(s->auth_display);\n\ts->auth_display = NULL;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s->auth_display"
          ],
          "line": 2365
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_close_x11",
          "args": [
            "ssh",
            "s->x11_chanids[i]"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "session_close_x11",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2321-2335",
          "snippet": "static void\nsession_close_x11(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL) {\n\t\tdebug(\"%s: x11 channel %d missing\", __func__, id);\n\t} else {\n\t\t/* Detach X11 listener */\n\t\tdebug(\"%s: detach x11 channel %d\", __func__, id);\n\t\tchannel_cancel_cleanup(ssh, id);\n\t\tif (c->ostate != CHAN_OUTPUT_CLOSED)\n\t\t\tchan_mark_dead(ssh, c);\n\t}\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsession_close_x11(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL) {\n\t\tdebug(\"%s: x11 channel %d missing\", __func__, id);\n\t} else {\n\t\t/* Detach X11 listener */\n\t\tdebug(\"%s: detach x11 channel %d\", __func__, id);\n\t\tchannel_cancel_cleanup(ssh, id);\n\t\tif (c->ostate != CHAN_OUTPUT_CLOSED)\n\t\t\tchan_mark_dead(ssh, c);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: session %d: closing channel %d\"",
            "__func__",
            "s->self",
            "s->x11_chanids[i]"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: no x11 channel %d\"",
            "__func__",
            "id"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_by_x11_channel",
          "args": [
            "id"
          ],
          "line": 2345
        },
        "resolved": true,
        "details": {
          "function_name": "session_by_x11_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1867-1888",
          "snippet": "static Session *\nsession_by_x11_channel(int id)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\n\t\tif (s->x11_chanids == NULL || !s->used)\n\t\t\tcontinue;\n\t\tfor (j = 0; s->x11_chanids[j] != -1; j++) {\n\t\t\tif (s->x11_chanids[j] == id) {\n\t\t\t\tdebug(\"session_by_x11_channel: session %d \"\n\t\t\t\t    \"channel %d\", s->self, id);\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t}\n\tdebug(\"session_by_x11_channel: unknown channel %d\", id);\n\tsession_dump();\n\treturn NULL;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "static int sessions_nalloc = 0;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nstatic Session *\nsession_by_x11_channel(int id)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\n\t\tif (s->x11_chanids == NULL || !s->used)\n\t\t\tcontinue;\n\t\tfor (j = 0; s->x11_chanids[j] != -1; j++) {\n\t\t\tif (s->x11_chanids[j] == id) {\n\t\t\t\tdebug(\"session_by_x11_channel: session %d \"\n\t\t\t\t    \"channel %d\", s->self, id);\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t}\n\tdebug(\"session_by_x11_channel: unknown channel %d\", id);\n\tsession_dump();\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_cancel_cleanup",
          "args": [
            "ssh",
            "id"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "channel_cancel_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "999-1010",
          "snippet": "void\nchannel_cancel_cleanup(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = NULL;\n\tc->detach_close = 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_cancel_cleanup(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = NULL;\n\tc->detach_close = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic void\nsession_close_single_x11(struct ssh *ssh, int id, void *arg)\n{\n\tSession *s;\n\tu_int i;\n\n\tdebug3(\"%s: channel %d\", __func__, id);\n\tchannel_cancel_cleanup(ssh, id);\n\tif ((s = session_by_x11_channel(id)) == NULL)\n\t\tfatal(\"%s: no x11 channel %d\", __func__, id);\n\tfor (i = 0; s->x11_chanids[i] != -1; i++) {\n\t\tdebug(\"%s: session %d: closing channel %d\",\n\t\t    __func__, s->self, s->x11_chanids[i]);\n\t\t/*\n\t\t * The channel \"id\" is already closing, but make sure we\n\t\t * close all of its siblings.\n\t\t */\n\t\tif (s->x11_chanids[i] != id)\n\t\t\tsession_close_x11(ssh, s->x11_chanids[i]);\n\t}\n\tfree(s->x11_chanids);\n\ts->x11_chanids = NULL;\n\tfree(s->display);\n\ts->display = NULL;\n\tfree(s->auth_proto);\n\ts->auth_proto = NULL;\n\tfree(s->auth_data);\n\ts->auth_data = NULL;\n\tfree(s->auth_display);\n\ts->auth_display = NULL;\n}"
  },
  {
    "function_name": "session_close_x11",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2321-2335",
    "snippet": "static void\nsession_close_x11(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL) {\n\t\tdebug(\"%s: x11 channel %d missing\", __func__, id);\n\t} else {\n\t\t/* Detach X11 listener */\n\t\tdebug(\"%s: detach x11 channel %d\", __func__, id);\n\t\tchannel_cancel_cleanup(ssh, id);\n\t\tif (c->ostate != CHAN_OUTPUT_CLOSED)\n\t\t\tchan_mark_dead(ssh, c);\n\t}\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chan_mark_dead",
          "args": [
            "ssh",
            "c"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "chan_mark_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "324-328",
          "snippet": "void\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nvoid\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_cancel_cleanup",
          "args": [
            "ssh",
            "id"
          ],
          "line": 2331
        },
        "resolved": true,
        "details": {
          "function_name": "channel_cancel_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "999-1010",
          "snippet": "void\nchannel_cancel_cleanup(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = NULL;\n\tc->detach_close = 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_cancel_cleanup(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn;\n\t}\n\tc->detach_user = NULL;\n\tc->detach_close = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: detach x11 channel %d\"",
            "__func__",
            "id"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_by_id",
          "args": [
            "ssh",
            "id"
          ],
          "line": 2326
        },
        "resolved": true,
        "details": {
          "function_name": "channel_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "244-259",
          "snippet": "Channel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nChannel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit(\"%s: %d: bad id\", __func__, id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit(\"%s: %d: bad id: channel free\", __func__, id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsession_close_x11(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL) {\n\t\tdebug(\"%s: x11 channel %d missing\", __func__, id);\n\t} else {\n\t\t/* Detach X11 listener */\n\t\tdebug(\"%s: detach x11 channel %d\", __func__, id);\n\t\tchannel_cancel_cleanup(ssh, id);\n\t\tif (c->ostate != CHAN_OUTPUT_CLOSED)\n\t\t\tchan_mark_dead(ssh, c);\n\t}\n}"
  },
  {
    "function_name": "sig2name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2300-2319",
    "snippet": "static char *\nsig2name(int sig)\n{\n#define SSH_SIG(x) if (sig == SIG ## x) return #x\n\tSSH_SIG(ABRT);\n\tSSH_SIG(ALRM);\n\tSSH_SIG(FPE);\n\tSSH_SIG(HUP);\n\tSSH_SIG(ILL);\n\tSSH_SIG(INT);\n\tSSH_SIG(KILL);\n\tSSH_SIG(PIPE);\n\tSSH_SIG(QUIT);\n\tSSH_SIG(SEGV);\n\tSSH_SIG(TERM);\n\tSSH_SIG(USR1);\n\tSSH_SIG(USR2);\n#undef\tSSH_SIG\n\treturn \"SIG@openssh.com\";\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "USR2"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "USR1"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "TERM"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "SEGV"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "QUIT"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "PIPE"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "KILL"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "INT"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "ILL"
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "HUP"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "FPE"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "ALRM"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "ABRT"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nsig2name(int sig)\n{\n#define SSH_SIG(x) if (sig == SIG ## x) return #x\n\tSSH_SIG(ABRT);\n\tSSH_SIG(ALRM);\n\tSSH_SIG(FPE);\n\tSSH_SIG(HUP);\n\tSSH_SIG(ILL);\n\tSSH_SIG(INT);\n\tSSH_SIG(KILL);\n\tSSH_SIG(PIPE);\n\tSSH_SIG(QUIT);\n\tSSH_SIG(SEGV);\n\tSSH_SIG(TERM);\n\tSSH_SIG(USR1);\n\tSSH_SIG(USR2);\n#undef\tSSH_SIG\n\treturn \"SIG@openssh.com\";\n}"
  },
  {
    "function_name": "session_pty_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2294-2298",
    "snippet": "void\nsession_pty_cleanup(Session *s)\n{\n\tPRIVSEP(session_pty_cleanup2(s));\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRIVSEP",
          "args": [
            "session_pty_cleanup2(s)"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "session_pty_cleanup2",
          "args": [
            "s"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "session_pty_cleanup2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2261-2292",
          "snippet": "void\nsession_pty_cleanup2(Session *s)\n{\n\tif (s == NULL) {\n\t\terror(\"%s: no session\", __func__);\n\t\treturn;\n\t}\n\tif (s->ttyfd == -1)\n\t\treturn;\n\n\tdebug(\"%s: session %d release %s\", __func__, s->self, s->tty);\n\n\t/* Record that the user has logged out. */\n\tif (s->pid != 0)\n\t\trecord_logout(s->pid, s->tty, s->pw->pw_name);\n\n\t/* Release the pseudo-tty. */\n\tif (getuid() == 0)\n\t\tpty_release(s->tty);\n\n\t/*\n\t * Close the server side of the socket pairs.  We must do this after\n\t * the pty cleanup, so that another process doesn't get this pty\n\t * while we're still cleaning up.\n\t */\n\tif (s->ptymaster != -1 && close(s->ptymaster) < 0)\n\t\terror(\"close(s->ptymaster/%d): %s\",\n\t\t    s->ptymaster, strerror(errno));\n\n\t/* unlink pty from session */\n\ts->ttyfd = -1;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_pty_cleanup2(Session *s)\n{\n\tif (s == NULL) {\n\t\terror(\"%s: no session\", __func__);\n\t\treturn;\n\t}\n\tif (s->ttyfd == -1)\n\t\treturn;\n\n\tdebug(\"%s: session %d release %s\", __func__, s->self, s->tty);\n\n\t/* Record that the user has logged out. */\n\tif (s->pid != 0)\n\t\trecord_logout(s->pid, s->tty, s->pw->pw_name);\n\n\t/* Release the pseudo-tty. */\n\tif (getuid() == 0)\n\t\tpty_release(s->tty);\n\n\t/*\n\t * Close the server side of the socket pairs.  We must do this after\n\t * the pty cleanup, so that another process doesn't get this pty\n\t * while we're still cleaning up.\n\t */\n\tif (s->ptymaster != -1 && close(s->ptymaster) < 0)\n\t\terror(\"close(s->ptymaster/%d): %s\",\n\t\t    s->ptymaster, strerror(errno));\n\n\t/* unlink pty from session */\n\ts->ttyfd = -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_pty_cleanup(Session *s)\n{\n\tPRIVSEP(session_pty_cleanup2(s));\n}"
  },
  {
    "function_name": "session_pty_cleanup2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2261-2292",
    "snippet": "void\nsession_pty_cleanup2(Session *s)\n{\n\tif (s == NULL) {\n\t\terror(\"%s: no session\", __func__);\n\t\treturn;\n\t}\n\tif (s->ttyfd == -1)\n\t\treturn;\n\n\tdebug(\"%s: session %d release %s\", __func__, s->self, s->tty);\n\n\t/* Record that the user has logged out. */\n\tif (s->pid != 0)\n\t\trecord_logout(s->pid, s->tty, s->pw->pw_name);\n\n\t/* Release the pseudo-tty. */\n\tif (getuid() == 0)\n\t\tpty_release(s->tty);\n\n\t/*\n\t * Close the server side of the socket pairs.  We must do this after\n\t * the pty cleanup, so that another process doesn't get this pty\n\t * while we're still cleaning up.\n\t */\n\tif (s->ptymaster != -1 && close(s->ptymaster) < 0)\n\t\terror(\"close(s->ptymaster/%d): %s\",\n\t\t    s->ptymaster, strerror(errno));\n\n\t/* unlink pty from session */\n\ts->ttyfd = -1;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"close(s->ptymaster/%d): %s\"",
            "s->ptymaster",
            "strerror(errno)"
          ],
          "line": 2287
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s->ptymaster"
          ],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "child_close_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1490-1526",
          "snippet": "static void\nchild_close_fds(struct ssh *ssh)\n{\n\textern int auth_sock;\n\n\tif (auth_sock != -1) {\n\t\tclose(auth_sock);\n\t\tauth_sock = -1;\n\t}\n\n\tif (packet_get_connection_in() == packet_get_connection_out())\n\t\tclose(packet_get_connection_in());\n\telse {\n\t\tclose(packet_get_connection_in());\n\t\tclose(packet_get_connection_out());\n\t}\n\t/*\n\t * Close all descriptors related to channels.  They will still remain\n\t * open in the parent.\n\t */\n\t/* XXX better use close-on-exec? -markus */\n\tchannel_close_all(ssh);\n\n\t/*\n\t * Close any extra file descriptors.  Note that there may still be\n\t * descriptors left by system functions.  They will be closed later.\n\t */\n\tendpwent();\n\n\t/*\n\t * Close any extra open file descriptors so that we don't have them\n\t * hanging around in clients.  Note that we want to do this after\n\t * initgroups, because at least on Solaris 2.3 it leaves file\n\t * descriptors open.\n\t */\n\tclosefrom(STDERR_FILENO + 1);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nchild_close_fds(struct ssh *ssh)\n{\n\textern int auth_sock;\n\n\tif (auth_sock != -1) {\n\t\tclose(auth_sock);\n\t\tauth_sock = -1;\n\t}\n\n\tif (packet_get_connection_in() == packet_get_connection_out())\n\t\tclose(packet_get_connection_in());\n\telse {\n\t\tclose(packet_get_connection_in());\n\t\tclose(packet_get_connection_out());\n\t}\n\t/*\n\t * Close all descriptors related to channels.  They will still remain\n\t * open in the parent.\n\t */\n\t/* XXX better use close-on-exec? -markus */\n\tchannel_close_all(ssh);\n\n\t/*\n\t * Close any extra file descriptors.  Note that there may still be\n\t * descriptors left by system functions.  They will be closed later.\n\t */\n\tendpwent();\n\n\t/*\n\t * Close any extra open file descriptors so that we don't have them\n\t * hanging around in clients.  Note that we want to do this after\n\t * initgroups, because at least on Solaris 2.3 it leaves file\n\t * descriptors open.\n\t */\n\tclosefrom(STDERR_FILENO + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pty_release",
          "args": [
            "s->tty"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "pty_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshpty.c",
          "lines": "85-94",
          "snippet": "void\npty_release(const char *tty)\n{\n#if !defined(__APPLE_PRIVPTY__) && !defined(HAVE_OPENPTY)\n\tif (chown(tty, (uid_t) 0, (gid_t) 0) < 0)\n\t\terror(\"chown %.100s 0 0 failed: %.100s\", tty, strerror(errno));\n\tif (chmod(tty, (mode_t) 0666) < 0)\n\t\terror(\"chmod %.100s 0666 failed: %.100s\", tty, strerror(errno));\n#endif /* !__APPLE_PRIVPTY__ && !HAVE_OPENPTY */\n}",
          "includes": [
            "# include <AvailabilityMacros.h>",
            "# include <pty.h>",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshpty.h\"",
            "#include <unistd.h>",
            "# include <util.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <AvailabilityMacros.h>\n# include <pty.h>\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshpty.h\"\n#include <unistd.h>\n# include <util.h>\n#include <termios.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\npty_release(const char *tty)\n{\n#if !defined(__APPLE_PRIVPTY__) && !defined(HAVE_OPENPTY)\n\tif (chown(tty, (uid_t) 0, (gid_t) 0) < 0)\n\t\terror(\"chown %.100s 0 0 failed: %.100s\", tty, strerror(errno));\n\tif (chmod(tty, (mode_t) 0666) < 0)\n\t\terror(\"chmod %.100s 0666 failed: %.100s\", tty, strerror(errno));\n#endif /* !__APPLE_PRIVPTY__ && !HAVE_OPENPTY */\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_logout",
          "args": [
            "s->pid",
            "s->tty",
            "s->pw->pw_name"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "record_logout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshlogin.c",
          "lines": "162-170",
          "snippet": "void\nrecord_logout(pid_t pid, const char *tty, const char *user)\n{\n\tstruct logininfo *li;\n\n\tli = login_alloc_entry(pid, user, NULL, tty);\n\tlogin_logout(li);\n\tlogin_free_entry(li);\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"loginrec.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshlogin.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"loginrec.h\"\n#include \"ssherr.h\"\n#include \"sshlogin.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nrecord_logout(pid_t pid, const char *tty, const char *user)\n{\n\tstruct logininfo *li;\n\n\tli = login_alloc_entry(pid, user, NULL, tty);\n\tlogin_logout(li);\n\tlogin_free_entry(li);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: session %d release %s\"",
            "__func__",
            "s->self",
            "s->tty"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_pty_cleanup2(Session *s)\n{\n\tif (s == NULL) {\n\t\terror(\"%s: no session\", __func__);\n\t\treturn;\n\t}\n\tif (s->ttyfd == -1)\n\t\treturn;\n\n\tdebug(\"%s: session %d release %s\", __func__, s->self, s->tty);\n\n\t/* Record that the user has logged out. */\n\tif (s->pid != 0)\n\t\trecord_logout(s->pid, s->tty, s->pw->pw_name);\n\n\t/* Release the pseudo-tty. */\n\tif (getuid() == 0)\n\t\tpty_release(s->tty);\n\n\t/*\n\t * Close the server side of the socket pairs.  We must do this after\n\t * the pty cleanup, so that another process doesn't get this pty\n\t * while we're still cleaning up.\n\t */\n\tif (s->ptymaster != -1 && close(s->ptymaster) < 0)\n\t\terror(\"close(s->ptymaster/%d): %s\",\n\t\t    s->ptymaster, strerror(errno));\n\n\t/* unlink pty from session */\n\ts->ttyfd = -1;\n}"
  },
  {
    "function_name": "session_set_fds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2241-2255",
    "snippet": "void\nsession_set_fds(struct ssh *ssh, Session *s,\n    int fdin, int fdout, int fderr, int ignore_fderr, int is_tty)\n{\n\t/*\n\t * now that have a child and a pipe to the child,\n\t * we can activate our channel and register the fd's\n\t */\n\tif (s->chanid == -1)\n\t\tfatal(\"no channel for session %d\", s->self);\n\tchannel_set_fds(ssh, s->chanid,\n\t    fdout, fdin, fderr,\n\t    ignore_fderr ? CHAN_EXTENDED_IGNORE : CHAN_EXTENDED_READ,\n\t    1, is_tty, CHAN_SES_WINDOW_DEFAULT);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_set_fds",
          "args": [
            "ssh",
            "s->chanid",
            "fdout",
            "fdin",
            "fderr",
            "ignore_fderr ? CHAN_EXTENDED_IGNORE : CHAN_EXTENDED_READ",
            "1",
            "is_tty",
            "CHAN_SES_WINDOW_DEFAULT"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "channel_set_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "1028-1049",
          "snippet": "void\nchannel_set_fds(struct ssh *ssh, int id, int rfd, int wfd, int efd,\n    int extusage, int nonblock, int is_tty, u_int window_max)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL || c->type != SSH_CHANNEL_LARVAL)\n\t\tfatal(\"channel_activate for non-larval channel %d.\", id);\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, is_tty);\n\tc->type = SSH_CHANNEL_OPEN;\n\tc->local_window = c->local_window_max = window_max;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_WINDOW_ADJUST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\nvoid\nchannel_set_fds(struct ssh *ssh, int id, int rfd, int wfd, int efd,\n    int extusage, int nonblock, int is_tty, u_int window_max)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL || c->type != SSH_CHANNEL_LARVAL)\n\t\tfatal(\"channel_activate for non-larval channel %d.\", id);\n\tif (!c->have_remote_id)\n\t\tfatal(\":%s: channel %d: no remote id\", __func__, c->self);\n\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, is_tty);\n\tc->type = SSH_CHANNEL_OPEN;\n\tc->local_window = c->local_window_max = window_max;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_WINDOW_ADJUST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: channel %i: %s\", __func__, c->self, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"no channel for session %d\"",
            "s->self"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_set_fds(struct ssh *ssh, Session *s,\n    int fdin, int fdout, int fderr, int ignore_fderr, int is_tty)\n{\n\t/*\n\t * now that have a child and a pipe to the child,\n\t * we can activate our channel and register the fd's\n\t */\n\tif (s->chanid == -1)\n\t\tfatal(\"no channel for session %d\", s->self);\n\tchannel_set_fds(ssh, s->chanid,\n\t    fdout, fdin, fderr,\n\t    ignore_fderr ? CHAN_EXTENDED_IGNORE : CHAN_EXTENDED_READ,\n\t    1, is_tty, CHAN_SES_WINDOW_DEFAULT);\n}"
  },
  {
    "function_name": "session_input_channel_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2197-2239",
    "snippet": "int\nsession_input_channel_req(struct ssh *ssh, Channel *c, const char *rtype)\n{\n\tint success = 0;\n\tSession *s;\n\n\tif ((s = session_by_channel(c->self)) == NULL) {\n\t\tlogit(\"%s: no session %d req %.100s\", __func__, c->self, rtype);\n\t\treturn 0;\n\t}\n\tdebug(\"%s: session %d req %s\", __func__, s->self, rtype);\n\n\t/*\n\t * a session is in LARVAL state until a shell, a command\n\t * or a subsystem is executed\n\t */\n\tif (c->type == SSH_CHANNEL_LARVAL) {\n\t\tif (strcmp(rtype, \"shell\") == 0) {\n\t\t\tsuccess = session_shell_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"exec\") == 0) {\n\t\t\tsuccess = session_exec_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"pty-req\") == 0) {\n\t\t\tsuccess = session_pty_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"x11-req\") == 0) {\n\t\t\tsuccess = session_x11_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"auth-agent-req@openssh.com\") == 0) {\n\t\t\tsuccess = session_auth_agent_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"subsystem\") == 0) {\n\t\t\tsuccess = session_subsystem_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"env\") == 0) {\n\t\t\tsuccess = session_env_req(ssh, s);\n\t\t}\n\t}\n\tif (strcmp(rtype, \"window-change\") == 0) {\n\t\tsuccess = session_window_change_req(ssh, s);\n\t} else if (strcmp(rtype, \"break\") == 0) {\n\t\tsuccess = session_break_req(ssh, s);\n\t} else if (strcmp(rtype, \"signal\") == 0) {\n\t\tsuccess = session_signal_req(ssh, s);\n\t}\n\n\treturn success;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "session_signal_req",
          "args": [
            "ssh",
            "s"
          ],
          "line": 2235
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rtype",
            "\"signal\""
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_break_req",
          "args": [
            "ssh",
            "s"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "session_break_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2059-2069",
          "snippet": "static int\nsession_break_req(struct ssh *ssh, Session *s)\n{\n\n\tpacket_get_int();\t/* ignored */\n\tpacket_check_eom();\n\n\tif (s->ptymaster == -1 || tcsendbreak(s->ptymaster, 0) < 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_break_req(struct ssh *ssh, Session *s)\n{\n\n\tpacket_get_int();\t/* ignored */\n\tpacket_check_eom();\n\n\tif (s->ptymaster == -1 || tcsendbreak(s->ptymaster, 0) < 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_window_change_req",
          "args": [
            "ssh",
            "s"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "session_window_change_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1905-1915",
          "snippet": "static int\nsession_window_change_req(struct ssh *ssh, Session *s)\n{\n\ts->col = packet_get_int();\n\ts->row = packet_get_int();\n\ts->xpixel = packet_get_int();\n\ts->ypixel = packet_get_int();\n\tpacket_check_eom();\n\tpty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);\n\treturn 1;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_window_change_req(struct ssh *ssh, Session *s)\n{\n\ts->col = packet_get_int();\n\ts->row = packet_get_int();\n\ts->xpixel = packet_get_int();\n\ts->ypixel = packet_get_int();\n\tpacket_check_eom();\n\tpty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_env_req",
          "args": [
            "ssh",
            "s"
          ],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "session_env_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2071-2104",
          "snippet": "static int\nsession_env_req(struct ssh *ssh, Session *s)\n{\n\tchar *name, *val;\n\tu_int name_len, val_len, i;\n\n\tname = packet_get_cstring(&name_len);\n\tval = packet_get_cstring(&val_len);\n\tpacket_check_eom();\n\n\t/* Don't set too many environment variables */\n\tif (s->num_env > 128) {\n\t\tdebug2(\"Ignoring env request %s: too many env vars\", name);\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < options.num_accept_env; i++) {\n\t\tif (match_pattern(name, options.accept_env[i])) {\n\t\t\tdebug2(\"Setting env %d: %s=%s\", s->num_env, name, val);\n\t\t\ts->env = xrecallocarray(s->env, s->num_env,\n\t\t\t    s->num_env + 1, sizeof(*s->env));\n\t\t\ts->env[s->num_env].name = name;\n\t\t\ts->env[s->num_env].val = val;\n\t\t\ts->num_env++;\n\t\t\treturn (1);\n\t\t}\n\t}\n\tdebug2(\"Ignoring env request %s: disallowed name\", name);\n\n fail:\n\tfree(name);\n\tfree(val);\n\treturn (0);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\n\nstatic int\nsession_env_req(struct ssh *ssh, Session *s)\n{\n\tchar *name, *val;\n\tu_int name_len, val_len, i;\n\n\tname = packet_get_cstring(&name_len);\n\tval = packet_get_cstring(&val_len);\n\tpacket_check_eom();\n\n\t/* Don't set too many environment variables */\n\tif (s->num_env > 128) {\n\t\tdebug2(\"Ignoring env request %s: too many env vars\", name);\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < options.num_accept_env; i++) {\n\t\tif (match_pattern(name, options.accept_env[i])) {\n\t\t\tdebug2(\"Setting env %d: %s=%s\", s->num_env, name, val);\n\t\t\ts->env = xrecallocarray(s->env, s->num_env,\n\t\t\t    s->num_env + 1, sizeof(*s->env));\n\t\t\ts->env[s->num_env].name = name;\n\t\t\ts->env[s->num_env].val = val;\n\t\t\ts->num_env++;\n\t\t\treturn (1);\n\t\t}\n\t}\n\tdebug2(\"Ignoring env request %s: disallowed name\", name);\n\n fail:\n\tfree(name);\n\tfree(val);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_subsystem_req",
          "args": [
            "ssh",
            "s"
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "session_subsystem_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1968-2006",
          "snippet": "static int\nsession_subsystem_req(struct ssh *ssh, Session *s)\n{\n\tstruct stat st;\n\tu_int len;\n\tint success = 0;\n\tchar *prog, *cmd;\n\tu_int i;\n\n\ts->subsys = packet_get_string(&len);\n\tpacket_check_eom();\n\tdebug2(\"subsystem request for %.100s by user %s\", s->subsys,\n\t    s->pw->pw_name);\n\n\tfor (i = 0; i < options.num_subsystems; i++) {\n\t\tif (strcmp(s->subsys, options.subsystem_name[i]) == 0) {\n\t\t\tprog = options.subsystem_command[i];\n\t\t\tcmd = options.subsystem_args[i];\n\t\t\tif (strcmp(INTERNAL_SFTP_NAME, prog) == 0) {\n\t\t\t\ts->is_subsystem = SUBSYSTEM_INT_SFTP;\n\t\t\t\tdebug(\"subsystem: %s\", prog);\n\t\t\t} else {\n\t\t\t\tif (stat(prog, &st) < 0)\n\t\t\t\t\tdebug(\"subsystem: cannot stat %s: %s\",\n\t\t\t\t\t    prog, strerror(errno));\n\t\t\t\ts->is_subsystem = SUBSYSTEM_EXT;\n\t\t\t\tdebug(\"subsystem: exec() %s\", cmd);\n\t\t\t}\n\t\t\tsuccess = do_exec(ssh, s, cmd) == 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!success)\n\t\tlogit(\"subsystem request for %.100s by user %s failed, \"\n\t\t    \"subsystem not found\", s->subsys, s->pw->pw_name);\n\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SUBSYSTEM_INT_SFTP\t\t2",
            "#define SUBSYSTEM_EXT\t\t\t1"
          ],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SUBSYSTEM_INT_SFTP\t\t2\n#define SUBSYSTEM_EXT\t\t\t1\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\n\nstatic int\nsession_subsystem_req(struct ssh *ssh, Session *s)\n{\n\tstruct stat st;\n\tu_int len;\n\tint success = 0;\n\tchar *prog, *cmd;\n\tu_int i;\n\n\ts->subsys = packet_get_string(&len);\n\tpacket_check_eom();\n\tdebug2(\"subsystem request for %.100s by user %s\", s->subsys,\n\t    s->pw->pw_name);\n\n\tfor (i = 0; i < options.num_subsystems; i++) {\n\t\tif (strcmp(s->subsys, options.subsystem_name[i]) == 0) {\n\t\t\tprog = options.subsystem_command[i];\n\t\t\tcmd = options.subsystem_args[i];\n\t\t\tif (strcmp(INTERNAL_SFTP_NAME, prog) == 0) {\n\t\t\t\ts->is_subsystem = SUBSYSTEM_INT_SFTP;\n\t\t\t\tdebug(\"subsystem: %s\", prog);\n\t\t\t} else {\n\t\t\t\tif (stat(prog, &st) < 0)\n\t\t\t\t\tdebug(\"subsystem: cannot stat %s: %s\",\n\t\t\t\t\t    prog, strerror(errno));\n\t\t\t\ts->is_subsystem = SUBSYSTEM_EXT;\n\t\t\t\tdebug(\"subsystem: exec() %s\", cmd);\n\t\t\t}\n\t\t\tsuccess = do_exec(ssh, s, cmd) == 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!success)\n\t\tlogit(\"subsystem request for %.100s by user %s failed, \"\n\t\t    \"subsystem not found\", s->subsys, s->pw->pw_name);\n\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_auth_agent_req",
          "args": [
            "ssh",
            "s"
          ],
          "line": 2223
        },
        "resolved": true,
        "details": {
          "function_name": "session_auth_agent_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2178-2195",
          "snippet": "static int\nsession_auth_agent_req(struct ssh *ssh, Session *s)\n{\n\tstatic int called = 0;\n\n\tpacket_check_eom();\n\tif (!auth_opts->permit_agent_forwarding_flag ||\n\t    !options.allow_agent_forwarding) {\n\t\tdebug(\"%s: agent forwarding disabled\", __func__);\n\t\treturn 0;\n\t}\n\tif (called) {\n\t\treturn 0;\n\t} else {\n\t\tcalled = 1;\n\t\treturn auth_input_request_forwarding(ssh, s->pw);\n\t}\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "extern ServerOptions options;",
            "extern struct sshauthopt *auth_opts;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\n\nstatic int\nsession_auth_agent_req(struct ssh *ssh, Session *s)\n{\n\tstatic int called = 0;\n\n\tpacket_check_eom();\n\tif (!auth_opts->permit_agent_forwarding_flag ||\n\t    !options.allow_agent_forwarding) {\n\t\tdebug(\"%s: agent forwarding disabled\", __func__);\n\t\treturn 0;\n\t}\n\tif (called) {\n\t\treturn 0;\n\t} else {\n\t\tcalled = 1;\n\t\treturn auth_input_request_forwarding(ssh, s->pw);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_x11_req",
          "args": [
            "ssh",
            "s"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "session_x11_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2008-2038",
          "snippet": "static int\nsession_x11_req(struct ssh *ssh, Session *s)\n{\n\tint success;\n\n\tif (s->auth_proto != NULL || s->auth_data != NULL) {\n\t\terror(\"session_x11_req: session %d: \"\n\t\t    \"x11 forwarding already active\", s->self);\n\t\treturn 0;\n\t}\n\ts->single_connection = packet_get_char();\n\ts->auth_proto = packet_get_string(NULL);\n\ts->auth_data = packet_get_string(NULL);\n\ts->screen = packet_get_int();\n\tpacket_check_eom();\n\n\tif (xauth_valid_string(s->auth_proto) &&\n\t    xauth_valid_string(s->auth_data))\n\t\tsuccess = session_setup_x11fwd(ssh, s);\n\telse {\n\t\tsuccess = 0;\n\t\terror(\"Invalid X11 forwarding data\");\n\t}\n\tif (!success) {\n\t\tfree(s->auth_proto);\n\t\tfree(s->auth_data);\n\t\ts->auth_proto = NULL;\n\t\ts->auth_data = NULL;\n\t}\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_x11_req(struct ssh *ssh, Session *s)\n{\n\tint success;\n\n\tif (s->auth_proto != NULL || s->auth_data != NULL) {\n\t\terror(\"session_x11_req: session %d: \"\n\t\t    \"x11 forwarding already active\", s->self);\n\t\treturn 0;\n\t}\n\ts->single_connection = packet_get_char();\n\ts->auth_proto = packet_get_string(NULL);\n\ts->auth_data = packet_get_string(NULL);\n\ts->screen = packet_get_int();\n\tpacket_check_eom();\n\n\tif (xauth_valid_string(s->auth_proto) &&\n\t    xauth_valid_string(s->auth_data))\n\t\tsuccess = session_setup_x11fwd(ssh, s);\n\telse {\n\t\tsuccess = 0;\n\t\terror(\"Invalid X11 forwarding data\");\n\t}\n\tif (!success) {\n\t\tfree(s->auth_proto);\n\t\tfree(s->auth_data);\n\t\ts->auth_proto = NULL;\n\t\ts->auth_data = NULL;\n\t}\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_pty_req",
          "args": [
            "ssh",
            "s"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "session_pty_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1917-1966",
          "snippet": "static int\nsession_pty_req(struct ssh *ssh, Session *s)\n{\n\tu_int len;\n\n\tif (!auth_opts->permit_pty_flag || !options.permit_tty) {\n\t\tdebug(\"Allocating a pty not permitted for this connection.\");\n\t\treturn 0;\n\t}\n\tif (s->ttyfd != -1) {\n\t\tpacket_disconnect(\"Protocol error: you already have a pty.\");\n\t\treturn 0;\n\t}\n\n\ts->term = packet_get_string(&len);\n\ts->col = packet_get_int();\n\ts->row = packet_get_int();\n\ts->xpixel = packet_get_int();\n\ts->ypixel = packet_get_int();\n\n\tif (strcmp(s->term, \"\") == 0) {\n\t\tfree(s->term);\n\t\ts->term = NULL;\n\t}\n\n\t/* Allocate a pty and open it. */\n\tdebug(\"Allocating pty.\");\n\tif (!PRIVSEP(pty_allocate(&s->ptyfd, &s->ttyfd, s->tty,\n\t    sizeof(s->tty)))) {\n\t\tfree(s->term);\n\t\ts->term = NULL;\n\t\ts->ptyfd = -1;\n\t\ts->ttyfd = -1;\n\t\terror(\"session_pty_req: session %d alloc failed\", s->self);\n\t\treturn 0;\n\t}\n\tdebug(\"session_pty_req: session %d alloc %s\", s->self, s->tty);\n\n\tssh_tty_parse_modes(ssh, s->ttyfd);\n\n\tif (!use_privsep)\n\t\tpty_setowner(s->pw, s->tty);\n\n\t/* Set window size from the packet. */\n\tpty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);\n\n\tpacket_check_eom();\n\tsession_proctitle(s);\n\treturn 1;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "extern ServerOptions options;",
            "extern struct sshauthopt *auth_opts;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\n\nstatic int\nsession_pty_req(struct ssh *ssh, Session *s)\n{\n\tu_int len;\n\n\tif (!auth_opts->permit_pty_flag || !options.permit_tty) {\n\t\tdebug(\"Allocating a pty not permitted for this connection.\");\n\t\treturn 0;\n\t}\n\tif (s->ttyfd != -1) {\n\t\tpacket_disconnect(\"Protocol error: you already have a pty.\");\n\t\treturn 0;\n\t}\n\n\ts->term = packet_get_string(&len);\n\ts->col = packet_get_int();\n\ts->row = packet_get_int();\n\ts->xpixel = packet_get_int();\n\ts->ypixel = packet_get_int();\n\n\tif (strcmp(s->term, \"\") == 0) {\n\t\tfree(s->term);\n\t\ts->term = NULL;\n\t}\n\n\t/* Allocate a pty and open it. */\n\tdebug(\"Allocating pty.\");\n\tif (!PRIVSEP(pty_allocate(&s->ptyfd, &s->ttyfd, s->tty,\n\t    sizeof(s->tty)))) {\n\t\tfree(s->term);\n\t\ts->term = NULL;\n\t\ts->ptyfd = -1;\n\t\ts->ttyfd = -1;\n\t\terror(\"session_pty_req: session %d alloc failed\", s->self);\n\t\treturn 0;\n\t}\n\tdebug(\"session_pty_req: session %d alloc %s\", s->self, s->tty);\n\n\tssh_tty_parse_modes(ssh, s->ttyfd);\n\n\tif (!use_privsep)\n\t\tpty_setowner(s->pw, s->tty);\n\n\t/* Set window size from the packet. */\n\tpty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);\n\n\tpacket_check_eom();\n\tsession_proctitle(s);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_exec_req",
          "args": [
            "ssh",
            "s"
          ],
          "line": 2217
        },
        "resolved": true,
        "details": {
          "function_name": "session_exec_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2047-2057",
          "snippet": "static int\nsession_exec_req(struct ssh *ssh, Session *s)\n{\n\tu_int len, success;\n\n\tchar *command = packet_get_string(&len);\n\tpacket_check_eom();\n\tsuccess = do_exec(ssh, s, command) == 0;\n\tfree(command);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_exec_req(struct ssh *ssh, Session *s)\n{\n\tu_int len, success;\n\n\tchar *command = packet_get_string(&len);\n\tpacket_check_eom();\n\tsuccess = do_exec(ssh, s, command) == 0;\n\tfree(command);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_shell_req",
          "args": [
            "ssh",
            "s"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "session_shell_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2040-2045",
          "snippet": "static int\nsession_shell_req(struct ssh *ssh, Session *s)\n{\n\tpacket_check_eom();\n\treturn do_exec(ssh, s, NULL) == 0;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_shell_req(struct ssh *ssh, Session *s)\n{\n\tpacket_check_eom();\n\treturn do_exec(ssh, s, NULL) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: session %d req %s\"",
            "__func__",
            "s->self",
            "rtype"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s: no session %d req %.100s\"",
            "__func__",
            "c->self",
            "rtype"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_by_channel",
          "args": [
            "c->self"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "session_by_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1850-1865",
          "snippet": "static Session *\nsession_by_channel(int id)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->chanid == id) {\n\t\t\tdebug(\"session_by_channel: session %d channel %d\",\n\t\t\t    i, id);\n\t\t\treturn s;\n\t\t}\n\t}\n\tdebug(\"session_by_channel: unknown channel %d\", id);\n\tsession_dump();\n\treturn NULL;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "static int sessions_nalloc = 0;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nstatic Session *\nsession_by_channel(int id)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->chanid == id) {\n\t\t\tdebug(\"session_by_channel: session %d channel %d\",\n\t\t\t    i, id);\n\t\t\treturn s;\n\t\t}\n\t}\n\tdebug(\"session_by_channel: unknown channel %d\", id);\n\tsession_dump();\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nint\nsession_input_channel_req(struct ssh *ssh, Channel *c, const char *rtype)\n{\n\tint success = 0;\n\tSession *s;\n\n\tif ((s = session_by_channel(c->self)) == NULL) {\n\t\tlogit(\"%s: no session %d req %.100s\", __func__, c->self, rtype);\n\t\treturn 0;\n\t}\n\tdebug(\"%s: session %d req %s\", __func__, s->self, rtype);\n\n\t/*\n\t * a session is in LARVAL state until a shell, a command\n\t * or a subsystem is executed\n\t */\n\tif (c->type == SSH_CHANNEL_LARVAL) {\n\t\tif (strcmp(rtype, \"shell\") == 0) {\n\t\t\tsuccess = session_shell_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"exec\") == 0) {\n\t\t\tsuccess = session_exec_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"pty-req\") == 0) {\n\t\t\tsuccess = session_pty_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"x11-req\") == 0) {\n\t\t\tsuccess = session_x11_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"auth-agent-req@openssh.com\") == 0) {\n\t\t\tsuccess = session_auth_agent_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"subsystem\") == 0) {\n\t\t\tsuccess = session_subsystem_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"env\") == 0) {\n\t\t\tsuccess = session_env_req(ssh, s);\n\t\t}\n\t}\n\tif (strcmp(rtype, \"window-change\") == 0) {\n\t\tsuccess = session_window_change_req(ssh, s);\n\t} else if (strcmp(rtype, \"break\") == 0) {\n\t\tsuccess = session_break_req(ssh, s);\n\t} else if (strcmp(rtype, \"signal\") == 0) {\n\t\tsuccess = session_signal_req(ssh, s);\n\t}\n\n\treturn success;\n}"
  },
  {
    "function_name": "session_auth_agent_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2178-2195",
    "snippet": "static int\nsession_auth_agent_req(struct ssh *ssh, Session *s)\n{\n\tstatic int called = 0;\n\n\tpacket_check_eom();\n\tif (!auth_opts->permit_agent_forwarding_flag ||\n\t    !options.allow_agent_forwarding) {\n\t\tdebug(\"%s: agent forwarding disabled\", __func__);\n\t\treturn 0;\n\t}\n\tif (called) {\n\t\treturn 0;\n\t} else {\n\t\tcalled = 1;\n\t\treturn auth_input_request_forwarding(ssh, s->pw);\n\t}\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "extern ServerOptions options;",
      "extern struct sshauthopt *auth_opts;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "auth_input_request_forwarding",
          "args": [
            "ssh",
            "s->pw"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "auth_input_request_forwarding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "188-247",
          "snippet": "static int\nauth_input_request_forwarding(struct ssh *ssh, struct passwd * pw)\n{\n\tChannel *nc;\n\tint sock = -1;\n\n\tif (auth_sock_name != NULL) {\n\t\terror(\"authentication forwarding requested twice.\");\n\t\treturn 0;\n\t}\n\n\t/* Temporarily drop privileged uid for mkdir/bind. */\n\ttemporarily_use_uid(pw);\n\n\t/* Allocate a buffer for the socket name, and format the name. */\n\tauth_sock_dir = xstrdup(\"/tmp/ssh-XXXXXXXXXX\");\n\n\t/* Create private directory for socket */\n\tif (mkdtemp(auth_sock_dir) == NULL) {\n\t\tpacket_send_debug(\"Agent forwarding disabled: \"\n\t\t    \"mkdtemp() failed: %.100s\", strerror(errno));\n\t\trestore_uid();\n\t\tfree(auth_sock_dir);\n\t\tauth_sock_dir = NULL;\n\t\tgoto authsock_err;\n\t}\n\n\txasprintf(&auth_sock_name, \"%s/agent.%ld\",\n\t    auth_sock_dir, (long) getpid());\n\n\t/* Start a Unix listener on auth_sock_name. */\n\tsock = unix_listener(auth_sock_name, SSH_LISTEN_BACKLOG, 0);\n\n\t/* Restore the privileged uid. */\n\trestore_uid();\n\n\t/* Check for socket/bind/listen failure. */\n\tif (sock < 0)\n\t\tgoto authsock_err;\n\n\t/* Allocate a channel for the authentication agent socket. */\n\tnc = channel_new(ssh, \"auth socket\",\n\t    SSH_CHANNEL_AUTH_SOCKET, sock, sock, -1,\n\t    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,\n\t    0, \"auth socket\", 1);\n\tnc->path = xstrdup(auth_sock_name);\n\treturn 1;\n\n authsock_err:\n\tfree(auth_sock_name);\n\tif (auth_sock_dir != NULL) {\n\t\trmdir(auth_sock_dir);\n\t\tfree(auth_sock_dir);\n\t}\n\tif (sock != -1)\n\t\tclose(sock);\n\tauth_sock_name = NULL;\n\tauth_sock_dir = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *auth_sock_name = NULL;",
            "static char *auth_sock_dir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *auth_sock_name = NULL;\nstatic char *auth_sock_dir = NULL;\n\nstatic int\nauth_input_request_forwarding(struct ssh *ssh, struct passwd * pw)\n{\n\tChannel *nc;\n\tint sock = -1;\n\n\tif (auth_sock_name != NULL) {\n\t\terror(\"authentication forwarding requested twice.\");\n\t\treturn 0;\n\t}\n\n\t/* Temporarily drop privileged uid for mkdir/bind. */\n\ttemporarily_use_uid(pw);\n\n\t/* Allocate a buffer for the socket name, and format the name. */\n\tauth_sock_dir = xstrdup(\"/tmp/ssh-XXXXXXXXXX\");\n\n\t/* Create private directory for socket */\n\tif (mkdtemp(auth_sock_dir) == NULL) {\n\t\tpacket_send_debug(\"Agent forwarding disabled: \"\n\t\t    \"mkdtemp() failed: %.100s\", strerror(errno));\n\t\trestore_uid();\n\t\tfree(auth_sock_dir);\n\t\tauth_sock_dir = NULL;\n\t\tgoto authsock_err;\n\t}\n\n\txasprintf(&auth_sock_name, \"%s/agent.%ld\",\n\t    auth_sock_dir, (long) getpid());\n\n\t/* Start a Unix listener on auth_sock_name. */\n\tsock = unix_listener(auth_sock_name, SSH_LISTEN_BACKLOG, 0);\n\n\t/* Restore the privileged uid. */\n\trestore_uid();\n\n\t/* Check for socket/bind/listen failure. */\n\tif (sock < 0)\n\t\tgoto authsock_err;\n\n\t/* Allocate a channel for the authentication agent socket. */\n\tnc = channel_new(ssh, \"auth socket\",\n\t    SSH_CHANNEL_AUTH_SOCKET, sock, sock, -1,\n\t    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,\n\t    0, \"auth socket\", 1);\n\tnc->path = xstrdup(auth_sock_name);\n\treturn 1;\n\n authsock_err:\n\tfree(auth_sock_name);\n\tif (auth_sock_dir != NULL) {\n\t\trmdir(auth_sock_dir);\n\t\tfree(auth_sock_dir);\n\t}\n\tif (sock != -1)\n\t\tclose(sock);\n\tauth_sock_name = NULL;\n\tauth_sock_dir = NULL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: agent forwarding disabled\"",
            "__func__"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_check_eom",
          "args": [],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\n\nstatic int\nsession_auth_agent_req(struct ssh *ssh, Session *s)\n{\n\tstatic int called = 0;\n\n\tpacket_check_eom();\n\tif (!auth_opts->permit_agent_forwarding_flag ||\n\t    !options.allow_agent_forwarding) {\n\t\tdebug(\"%s: agent forwarding disabled\", __func__);\n\t\treturn 0;\n\t}\n\tif (called) {\n\t\treturn 0;\n\t} else {\n\t\tcalled = 1;\n\t\treturn auth_input_request_forwarding(ssh, s->pw);\n\t}\n}"
  },
  {
    "function_name": "session_signal_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2130-2176",
    "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "signame"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: killpg(%ld, %d): %s\"",
            "__func__",
            "(long)s->pid",
            "sig",
            "strerror(errno)"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_uid",
          "args": [],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "restore_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "141-172",
          "snippet": "void\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "killpg",
          "args": [
            "s->pid",
            "sig"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "temporarily_use_uid",
          "args": [
            "s->pw"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "temporarily_use_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "60-136",
          "snippet": "void\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static uid_t\tuser_groups_uid;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic uid_t\tuser_groups_uid;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: signal %s, killpg(%ld, %d)\"",
            "__func__",
            "signame",
            "(long)s->pid",
            "sig"
          ],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_is_monitor",
          "args": [],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "mm_is_monitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "111-119",
          "snippet": "int\nmm_is_monitor(void)\n{\n\t/*\n\t * m_pid is only set in the privileged part, and\n\t * points to the unprivileged child.\n\t */\n\treturn (pmonitor && pmonitor->m_pid > 0);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct monitor *pmonitor;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern struct monitor *pmonitor;\n\nint\nmm_is_monitor(void)\n{\n\t/*\n\t * m_pid is only set in the privileged part, and\n\t * points to the unprivileged child.\n\t */\n\treturn (pmonitor && pmonitor->m_pid > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "name2sig",
          "args": [
            "signame"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "name2sig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2111-2128",
          "snippet": "static int\nname2sig(char *name)\n{\n#define SSH_SIG(x) if (strcmp(name, #x) == 0) return SIG ## x\n\tSSH_SIG(HUP);\n\tSSH_SIG(INT);\n\tSSH_SIG(KILL);\n\tSSH_SIG(QUIT);\n\tSSH_SIG(TERM);\n\tSSH_SIG(USR1);\n\tSSH_SIG(USR2);\n#undef\tSSH_SIG\n#ifdef SIGINFO\n\tif (strcmp(name, \"INFO@openssh.com\") == 0)\n\t\treturn SIGINFO;\n#endif\n\treturn -1;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nname2sig(char *name)\n{\n#define SSH_SIG(x) if (strcmp(name, #x) == 0) return SIG ## x\n\tSSH_SIG(HUP);\n\tSSH_SIG(INT);\n\tSSH_SIG(KILL);\n\tSSH_SIG(QUIT);\n\tSSH_SIG(TERM);\n\tSSH_SIG(USR1);\n\tSSH_SIG(USR2);\n#undef\tSSH_SIG\n#ifdef SIGINFO\n\tif (strcmp(name, \"INFO@openssh.com\") == 0)\n\t\treturn SIGINFO;\n#endif\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_end",
          "args": [
            "ssh"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2555-2561",
          "snippet": "int\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_cstring",
          "args": [
            "ssh",
            "&signame",
            "NULL"
          ],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2532-2536",
          "snippet": "int\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
  },
  {
    "function_name": "name2sig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2111-2128",
    "snippet": "static int\nname2sig(char *name)\n{\n#define SSH_SIG(x) if (strcmp(name, #x) == 0) return SIG ## x\n\tSSH_SIG(HUP);\n\tSSH_SIG(INT);\n\tSSH_SIG(KILL);\n\tSSH_SIG(QUIT);\n\tSSH_SIG(TERM);\n\tSSH_SIG(USR1);\n\tSSH_SIG(USR2);\n#undef\tSSH_SIG\n#ifdef SIGINFO\n\tif (strcmp(name, \"INFO@openssh.com\") == 0)\n\t\treturn SIGINFO;\n#endif\n\treturn -1;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"INFO@openssh.com\""
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "USR2"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "USR1"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "TERM"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "QUIT"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "KILL"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "INT"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSH_SIG",
          "args": [
            "HUP"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nname2sig(char *name)\n{\n#define SSH_SIG(x) if (strcmp(name, #x) == 0) return SIG ## x\n\tSSH_SIG(HUP);\n\tSSH_SIG(INT);\n\tSSH_SIG(KILL);\n\tSSH_SIG(QUIT);\n\tSSH_SIG(TERM);\n\tSSH_SIG(USR1);\n\tSSH_SIG(USR2);\n#undef\tSSH_SIG\n#ifdef SIGINFO\n\tif (strcmp(name, \"INFO@openssh.com\") == 0)\n\t\treturn SIGINFO;\n#endif\n\treturn -1;\n}"
  },
  {
    "function_name": "session_env_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2071-2104",
    "snippet": "static int\nsession_env_req(struct ssh *ssh, Session *s)\n{\n\tchar *name, *val;\n\tu_int name_len, val_len, i;\n\n\tname = packet_get_cstring(&name_len);\n\tval = packet_get_cstring(&val_len);\n\tpacket_check_eom();\n\n\t/* Don't set too many environment variables */\n\tif (s->num_env > 128) {\n\t\tdebug2(\"Ignoring env request %s: too many env vars\", name);\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < options.num_accept_env; i++) {\n\t\tif (match_pattern(name, options.accept_env[i])) {\n\t\t\tdebug2(\"Setting env %d: %s=%s\", s->num_env, name, val);\n\t\t\ts->env = xrecallocarray(s->env, s->num_env,\n\t\t\t    s->num_env + 1, sizeof(*s->env));\n\t\t\ts->env[s->num_env].name = name;\n\t\t\ts->env[s->num_env].val = val;\n\t\t\ts->num_env++;\n\t\t\treturn (1);\n\t\t}\n\t}\n\tdebug2(\"Ignoring env request %s: disallowed name\", name);\n\n fail:\n\tfree(name);\n\tfree(val);\n\treturn (0);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "val"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"Ignoring env request %s: disallowed name\"",
            "name"
          ],
          "line": 2098
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xrecallocarray",
          "args": [
            "s->env",
            "s->num_env",
            "s->num_env + 1",
            "sizeof(*s->env)"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_pattern",
          "args": [
            "name",
            "options.accept_env[i]"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "56-112",
          "snippet": "int\nmatch_pattern(const char *s, const char *pattern)\n{\n\tfor (;;) {\n\t\t/* If at end of pattern, accept if also at end of string. */\n\t\tif (!*pattern)\n\t\t\treturn !*s;\n\n\t\tif (*pattern == '*') {\n\t\t\t/* Skip the asterisk. */\n\t\t\tpattern++;\n\n\t\t\t/* If at end of pattern, accept immediately. */\n\t\t\tif (!*pattern)\n\t\t\t\treturn 1;\n\n\t\t\t/* If next character in pattern is known, optimize. */\n\t\t\tif (*pattern != '?' && *pattern != '*') {\n\t\t\t\t/*\n\t\t\t\t * Look instances of the next character in\n\t\t\t\t * pattern, and try to match starting from\n\t\t\t\t * those.\n\t\t\t\t */\n\t\t\t\tfor (; *s; s++)\n\t\t\t\t\tif (*s == *pattern &&\n\t\t\t\t\t    match_pattern(s + 1, pattern + 1))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t/* Failed. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Move ahead one character at a time and try to\n\t\t\t * match at each position.\n\t\t\t */\n\t\t\tfor (; *s; s++)\n\t\t\t\tif (match_pattern(s, pattern))\n\t\t\t\t\treturn 1;\n\t\t\t/* Failed. */\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * There must be at least one more character in the string.\n\t\t * If we are at the end, fail.\n\t\t */\n\t\tif (!*s)\n\t\t\treturn 0;\n\n\t\t/* Check if the next character of the string is acceptable. */\n\t\tif (*pattern != '?' && *pattern != *s)\n\t\t\treturn 0;\n\n\t\t/* Move to the next character, both in string and in pattern. */\n\t\ts++;\n\t\tpattern++;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern(const char *s, const char *pattern)\n{\n\tfor (;;) {\n\t\t/* If at end of pattern, accept if also at end of string. */\n\t\tif (!*pattern)\n\t\t\treturn !*s;\n\n\t\tif (*pattern == '*') {\n\t\t\t/* Skip the asterisk. */\n\t\t\tpattern++;\n\n\t\t\t/* If at end of pattern, accept immediately. */\n\t\t\tif (!*pattern)\n\t\t\t\treturn 1;\n\n\t\t\t/* If next character in pattern is known, optimize. */\n\t\t\tif (*pattern != '?' && *pattern != '*') {\n\t\t\t\t/*\n\t\t\t\t * Look instances of the next character in\n\t\t\t\t * pattern, and try to match starting from\n\t\t\t\t * those.\n\t\t\t\t */\n\t\t\t\tfor (; *s; s++)\n\t\t\t\t\tif (*s == *pattern &&\n\t\t\t\t\t    match_pattern(s + 1, pattern + 1))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t/* Failed. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Move ahead one character at a time and try to\n\t\t\t * match at each position.\n\t\t\t */\n\t\t\tfor (; *s; s++)\n\t\t\t\tif (match_pattern(s, pattern))\n\t\t\t\t\treturn 1;\n\t\t\t/* Failed. */\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * There must be at least one more character in the string.\n\t\t * If we are at the end, fail.\n\t\t */\n\t\tif (!*s)\n\t\t\treturn 0;\n\n\t\t/* Check if the next character of the string is acceptable. */\n\t\tif (*pattern != '?' && *pattern != *s)\n\t\t\treturn 0;\n\n\t\t/* Move to the next character, both in string and in pattern. */\n\t\ts++;\n\t\tpattern++;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_check_eom",
          "args": [],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_cstring",
          "args": [
            "&val_len"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_cstring",
          "args": [
            "&name_len"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\n\nstatic int\nsession_env_req(struct ssh *ssh, Session *s)\n{\n\tchar *name, *val;\n\tu_int name_len, val_len, i;\n\n\tname = packet_get_cstring(&name_len);\n\tval = packet_get_cstring(&val_len);\n\tpacket_check_eom();\n\n\t/* Don't set too many environment variables */\n\tif (s->num_env > 128) {\n\t\tdebug2(\"Ignoring env request %s: too many env vars\", name);\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < options.num_accept_env; i++) {\n\t\tif (match_pattern(name, options.accept_env[i])) {\n\t\t\tdebug2(\"Setting env %d: %s=%s\", s->num_env, name, val);\n\t\t\ts->env = xrecallocarray(s->env, s->num_env,\n\t\t\t    s->num_env + 1, sizeof(*s->env));\n\t\t\ts->env[s->num_env].name = name;\n\t\t\ts->env[s->num_env].val = val;\n\t\t\ts->num_env++;\n\t\t\treturn (1);\n\t\t}\n\t}\n\tdebug2(\"Ignoring env request %s: disallowed name\", name);\n\n fail:\n\tfree(name);\n\tfree(val);\n\treturn (0);\n}"
  },
  {
    "function_name": "session_break_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2059-2069",
    "snippet": "static int\nsession_break_req(struct ssh *ssh, Session *s)\n{\n\n\tpacket_get_int();\t/* ignored */\n\tpacket_check_eom();\n\n\tif (s->ptymaster == -1 || tcsendbreak(s->ptymaster, 0) < 0)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tcsendbreak",
          "args": [
            "s->ptymaster",
            "0"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "tcsendbreak",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "195-212",
          "snippet": "int\ntcsendbreak(int fd, int duration)\n{\n# if defined(TIOCSBRK) && defined(TIOCCBRK)\n\tstruct timeval sleepytime;\n\n\tsleepytime.tv_sec = 0;\n\tsleepytime.tv_usec = 400000;\n\tif (ioctl(fd, TIOCSBRK, 0) == -1)\n\t\treturn (-1);\n\t(void)select(0, 0, 0, 0, &sleepytime);\n\tif (ioctl(fd, TIOCCBRK, 0) == -1)\n\t\treturn (-1);\n\treturn (0);\n# else\n\treturn -1;\n# endif\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ntcsendbreak(int fd, int duration)\n{\n# if defined(TIOCSBRK) && defined(TIOCCBRK)\n\tstruct timeval sleepytime;\n\n\tsleepytime.tv_sec = 0;\n\tsleepytime.tv_usec = 400000;\n\tif (ioctl(fd, TIOCSBRK, 0) == -1)\n\t\treturn (-1);\n\t(void)select(0, 0, 0, 0, &sleepytime);\n\tif (ioctl(fd, TIOCCBRK, 0) == -1)\n\t\treturn (-1);\n\treturn (0);\n# else\n\treturn -1;\n# endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_check_eom",
          "args": [],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_int",
          "args": [],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "227-231",
          "snippet": "u_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_break_req(struct ssh *ssh, Session *s)\n{\n\n\tpacket_get_int();\t/* ignored */\n\tpacket_check_eom();\n\n\tif (s->ptymaster == -1 || tcsendbreak(s->ptymaster, 0) < 0)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "session_exec_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2047-2057",
    "snippet": "static int\nsession_exec_req(struct ssh *ssh, Session *s)\n{\n\tu_int len, success;\n\n\tchar *command = packet_get_string(&len);\n\tpacket_check_eom();\n\tsuccess = do_exec(ssh, s, command) == 0;\n\tfree(command);\n\treturn success;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "command"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_exec",
          "args": [
            "ssh",
            "s",
            "command"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "do_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "692-769",
          "snippet": "int\ndo_exec(struct ssh *ssh, Session *s, const char *command)\n{\n\tint ret;\n\tconst char *forced = NULL, *tty = NULL;\n\tchar session_type[1024];\n\n\tif (options.adm_forced_command) {\n\t\toriginal_command = command;\n\t\tcommand = options.adm_forced_command;\n\t\tforced = \"(config)\";\n\t} else if (auth_opts->force_command != NULL) {\n\t\toriginal_command = command;\n\t\tcommand = auth_opts->force_command;\n\t\tforced = \"(key-option)\";\n\t}\n\ts->forced = 0;\n\tif (forced != NULL) {\n\t\ts->forced = 1;\n\t\tif (IS_INTERNAL_SFTP(command)) {\n\t\t\ts->is_subsystem = s->is_subsystem ?\n\t\t\t    SUBSYSTEM_INT_SFTP : SUBSYSTEM_INT_SFTP_ERROR;\n\t\t} else if (s->is_subsystem)\n\t\t\ts->is_subsystem = SUBSYSTEM_EXT;\n\t\tsnprintf(session_type, sizeof(session_type),\n\t\t    \"forced-command %s '%.900s'\", forced, command);\n\t} else if (s->is_subsystem) {\n\t\tsnprintf(session_type, sizeof(session_type),\n\t\t    \"subsystem '%.900s'\", s->subsys);\n\t} else if (command == NULL) {\n\t\tsnprintf(session_type, sizeof(session_type), \"shell\");\n\t} else {\n\t\t/* NB. we don't log unforced commands to preserve privacy */\n\t\tsnprintf(session_type, sizeof(session_type), \"command\");\n\t}\n\n\tif (s->ttyfd != -1) {\n\t\ttty = s->tty;\n\t\tif (strncmp(tty, \"/dev/\", 5) == 0)\n\t\t\ttty += 5;\n\t}\n\n\tverbose(\"Starting session: %s%s%s for %s from %.200s port %d id %d\",\n\t    session_type,\n\t    tty == NULL ? \"\" : \" on \",\n\t    tty == NULL ? \"\" : tty,\n\t    s->pw->pw_name,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    s->self);\n\n#ifdef SSH_AUDIT_EVENTS\n\tif (command != NULL)\n\t\tPRIVSEP(audit_run_command(command));\n\telse if (s->ttyfd == -1) {\n\t\tchar *shell = s->pw->pw_shell;\n\n\t\tif (shell[0] == '\\0')\t/* empty shell means /bin/sh */\n\t\t\tshell =_PATH_BSHELL;\n\t\tPRIVSEP(audit_run_command(shell));\n\t}\n#endif\n\tif (s->ttyfd != -1)\n\t\tret = do_exec_pty(ssh, s, command);\n\telse\n\t\tret = do_exec_no_pty(ssh, s, command);\n\n\toriginal_command = NULL;\n\n\t/*\n\t * Clear loginmsg: it's the child's responsibility to display\n\t * it to the user, otherwise multiple sessions may accumulate\n\t * multiple copies of the login messages.\n\t */\n\tsshbuf_reset(loginmsg);\n\n\treturn ret;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SUBSYSTEM_INT_SFTP_ERROR\t3",
            "#define SUBSYSTEM_INT_SFTP\t\t2",
            "#define SUBSYSTEM_EXT\t\t\t1"
          ],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "extern ServerOptions options;",
            "extern struct sshbuf *loginmsg;",
            "extern struct sshauthopt *auth_opts;",
            "const char *original_command = NULL;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SUBSYSTEM_INT_SFTP_ERROR\t3\n#define SUBSYSTEM_INT_SFTP\t\t2\n#define SUBSYSTEM_EXT\t\t\t1\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern struct sshbuf *loginmsg;\nextern struct sshauthopt *auth_opts;\nconst char *original_command = NULL;\nstatic Session *sessions = NULL;\n\nint\ndo_exec(struct ssh *ssh, Session *s, const char *command)\n{\n\tint ret;\n\tconst char *forced = NULL, *tty = NULL;\n\tchar session_type[1024];\n\n\tif (options.adm_forced_command) {\n\t\toriginal_command = command;\n\t\tcommand = options.adm_forced_command;\n\t\tforced = \"(config)\";\n\t} else if (auth_opts->force_command != NULL) {\n\t\toriginal_command = command;\n\t\tcommand = auth_opts->force_command;\n\t\tforced = \"(key-option)\";\n\t}\n\ts->forced = 0;\n\tif (forced != NULL) {\n\t\ts->forced = 1;\n\t\tif (IS_INTERNAL_SFTP(command)) {\n\t\t\ts->is_subsystem = s->is_subsystem ?\n\t\t\t    SUBSYSTEM_INT_SFTP : SUBSYSTEM_INT_SFTP_ERROR;\n\t\t} else if (s->is_subsystem)\n\t\t\ts->is_subsystem = SUBSYSTEM_EXT;\n\t\tsnprintf(session_type, sizeof(session_type),\n\t\t    \"forced-command %s '%.900s'\", forced, command);\n\t} else if (s->is_subsystem) {\n\t\tsnprintf(session_type, sizeof(session_type),\n\t\t    \"subsystem '%.900s'\", s->subsys);\n\t} else if (command == NULL) {\n\t\tsnprintf(session_type, sizeof(session_type), \"shell\");\n\t} else {\n\t\t/* NB. we don't log unforced commands to preserve privacy */\n\t\tsnprintf(session_type, sizeof(session_type), \"command\");\n\t}\n\n\tif (s->ttyfd != -1) {\n\t\ttty = s->tty;\n\t\tif (strncmp(tty, \"/dev/\", 5) == 0)\n\t\t\ttty += 5;\n\t}\n\n\tverbose(\"Starting session: %s%s%s for %s from %.200s port %d id %d\",\n\t    session_type,\n\t    tty == NULL ? \"\" : \" on \",\n\t    tty == NULL ? \"\" : tty,\n\t    s->pw->pw_name,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    s->self);\n\n#ifdef SSH_AUDIT_EVENTS\n\tif (command != NULL)\n\t\tPRIVSEP(audit_run_command(command));\n\telse if (s->ttyfd == -1) {\n\t\tchar *shell = s->pw->pw_shell;\n\n\t\tif (shell[0] == '\\0')\t/* empty shell means /bin/sh */\n\t\t\tshell =_PATH_BSHELL;\n\t\tPRIVSEP(audit_run_command(shell));\n\t}\n#endif\n\tif (s->ttyfd != -1)\n\t\tret = do_exec_pty(ssh, s, command);\n\telse\n\t\tret = do_exec_no_pty(ssh, s, command);\n\n\toriginal_command = NULL;\n\n\t/*\n\t * Clear loginmsg: it's the child's responsibility to display\n\t * it to the user, otherwise multiple sessions may accumulate\n\t * multiple copies of the login messages.\n\t */\n\tsshbuf_reset(loginmsg);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_check_eom",
          "args": [],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "&len"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_exec_req(struct ssh *ssh, Session *s)\n{\n\tu_int len, success;\n\n\tchar *command = packet_get_string(&len);\n\tpacket_check_eom();\n\tsuccess = do_exec(ssh, s, command) == 0;\n\tfree(command);\n\treturn success;\n}"
  },
  {
    "function_name": "session_shell_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2040-2045",
    "snippet": "static int\nsession_shell_req(struct ssh *ssh, Session *s)\n{\n\tpacket_check_eom();\n\treturn do_exec(ssh, s, NULL) == 0;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_exec",
          "args": [
            "ssh",
            "s",
            "NULL"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "do_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "692-769",
          "snippet": "int\ndo_exec(struct ssh *ssh, Session *s, const char *command)\n{\n\tint ret;\n\tconst char *forced = NULL, *tty = NULL;\n\tchar session_type[1024];\n\n\tif (options.adm_forced_command) {\n\t\toriginal_command = command;\n\t\tcommand = options.adm_forced_command;\n\t\tforced = \"(config)\";\n\t} else if (auth_opts->force_command != NULL) {\n\t\toriginal_command = command;\n\t\tcommand = auth_opts->force_command;\n\t\tforced = \"(key-option)\";\n\t}\n\ts->forced = 0;\n\tif (forced != NULL) {\n\t\ts->forced = 1;\n\t\tif (IS_INTERNAL_SFTP(command)) {\n\t\t\ts->is_subsystem = s->is_subsystem ?\n\t\t\t    SUBSYSTEM_INT_SFTP : SUBSYSTEM_INT_SFTP_ERROR;\n\t\t} else if (s->is_subsystem)\n\t\t\ts->is_subsystem = SUBSYSTEM_EXT;\n\t\tsnprintf(session_type, sizeof(session_type),\n\t\t    \"forced-command %s '%.900s'\", forced, command);\n\t} else if (s->is_subsystem) {\n\t\tsnprintf(session_type, sizeof(session_type),\n\t\t    \"subsystem '%.900s'\", s->subsys);\n\t} else if (command == NULL) {\n\t\tsnprintf(session_type, sizeof(session_type), \"shell\");\n\t} else {\n\t\t/* NB. we don't log unforced commands to preserve privacy */\n\t\tsnprintf(session_type, sizeof(session_type), \"command\");\n\t}\n\n\tif (s->ttyfd != -1) {\n\t\ttty = s->tty;\n\t\tif (strncmp(tty, \"/dev/\", 5) == 0)\n\t\t\ttty += 5;\n\t}\n\n\tverbose(\"Starting session: %s%s%s for %s from %.200s port %d id %d\",\n\t    session_type,\n\t    tty == NULL ? \"\" : \" on \",\n\t    tty == NULL ? \"\" : tty,\n\t    s->pw->pw_name,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    s->self);\n\n#ifdef SSH_AUDIT_EVENTS\n\tif (command != NULL)\n\t\tPRIVSEP(audit_run_command(command));\n\telse if (s->ttyfd == -1) {\n\t\tchar *shell = s->pw->pw_shell;\n\n\t\tif (shell[0] == '\\0')\t/* empty shell means /bin/sh */\n\t\t\tshell =_PATH_BSHELL;\n\t\tPRIVSEP(audit_run_command(shell));\n\t}\n#endif\n\tif (s->ttyfd != -1)\n\t\tret = do_exec_pty(ssh, s, command);\n\telse\n\t\tret = do_exec_no_pty(ssh, s, command);\n\n\toriginal_command = NULL;\n\n\t/*\n\t * Clear loginmsg: it's the child's responsibility to display\n\t * it to the user, otherwise multiple sessions may accumulate\n\t * multiple copies of the login messages.\n\t */\n\tsshbuf_reset(loginmsg);\n\n\treturn ret;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SUBSYSTEM_INT_SFTP_ERROR\t3",
            "#define SUBSYSTEM_INT_SFTP\t\t2",
            "#define SUBSYSTEM_EXT\t\t\t1"
          ],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "extern ServerOptions options;",
            "extern struct sshbuf *loginmsg;",
            "extern struct sshauthopt *auth_opts;",
            "const char *original_command = NULL;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SUBSYSTEM_INT_SFTP_ERROR\t3\n#define SUBSYSTEM_INT_SFTP\t\t2\n#define SUBSYSTEM_EXT\t\t\t1\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern struct sshbuf *loginmsg;\nextern struct sshauthopt *auth_opts;\nconst char *original_command = NULL;\nstatic Session *sessions = NULL;\n\nint\ndo_exec(struct ssh *ssh, Session *s, const char *command)\n{\n\tint ret;\n\tconst char *forced = NULL, *tty = NULL;\n\tchar session_type[1024];\n\n\tif (options.adm_forced_command) {\n\t\toriginal_command = command;\n\t\tcommand = options.adm_forced_command;\n\t\tforced = \"(config)\";\n\t} else if (auth_opts->force_command != NULL) {\n\t\toriginal_command = command;\n\t\tcommand = auth_opts->force_command;\n\t\tforced = \"(key-option)\";\n\t}\n\ts->forced = 0;\n\tif (forced != NULL) {\n\t\ts->forced = 1;\n\t\tif (IS_INTERNAL_SFTP(command)) {\n\t\t\ts->is_subsystem = s->is_subsystem ?\n\t\t\t    SUBSYSTEM_INT_SFTP : SUBSYSTEM_INT_SFTP_ERROR;\n\t\t} else if (s->is_subsystem)\n\t\t\ts->is_subsystem = SUBSYSTEM_EXT;\n\t\tsnprintf(session_type, sizeof(session_type),\n\t\t    \"forced-command %s '%.900s'\", forced, command);\n\t} else if (s->is_subsystem) {\n\t\tsnprintf(session_type, sizeof(session_type),\n\t\t    \"subsystem '%.900s'\", s->subsys);\n\t} else if (command == NULL) {\n\t\tsnprintf(session_type, sizeof(session_type), \"shell\");\n\t} else {\n\t\t/* NB. we don't log unforced commands to preserve privacy */\n\t\tsnprintf(session_type, sizeof(session_type), \"command\");\n\t}\n\n\tif (s->ttyfd != -1) {\n\t\ttty = s->tty;\n\t\tif (strncmp(tty, \"/dev/\", 5) == 0)\n\t\t\ttty += 5;\n\t}\n\n\tverbose(\"Starting session: %s%s%s for %s from %.200s port %d id %d\",\n\t    session_type,\n\t    tty == NULL ? \"\" : \" on \",\n\t    tty == NULL ? \"\" : tty,\n\t    s->pw->pw_name,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    s->self);\n\n#ifdef SSH_AUDIT_EVENTS\n\tif (command != NULL)\n\t\tPRIVSEP(audit_run_command(command));\n\telse if (s->ttyfd == -1) {\n\t\tchar *shell = s->pw->pw_shell;\n\n\t\tif (shell[0] == '\\0')\t/* empty shell means /bin/sh */\n\t\t\tshell =_PATH_BSHELL;\n\t\tPRIVSEP(audit_run_command(shell));\n\t}\n#endif\n\tif (s->ttyfd != -1)\n\t\tret = do_exec_pty(ssh, s, command);\n\telse\n\t\tret = do_exec_no_pty(ssh, s, command);\n\n\toriginal_command = NULL;\n\n\t/*\n\t * Clear loginmsg: it's the child's responsibility to display\n\t * it to the user, otherwise multiple sessions may accumulate\n\t * multiple copies of the login messages.\n\t */\n\tsshbuf_reset(loginmsg);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_check_eom",
          "args": [],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_shell_req(struct ssh *ssh, Session *s)\n{\n\tpacket_check_eom();\n\treturn do_exec(ssh, s, NULL) == 0;\n}"
  },
  {
    "function_name": "session_x11_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "2008-2038",
    "snippet": "static int\nsession_x11_req(struct ssh *ssh, Session *s)\n{\n\tint success;\n\n\tif (s->auth_proto != NULL || s->auth_data != NULL) {\n\t\terror(\"session_x11_req: session %d: \"\n\t\t    \"x11 forwarding already active\", s->self);\n\t\treturn 0;\n\t}\n\ts->single_connection = packet_get_char();\n\ts->auth_proto = packet_get_string(NULL);\n\ts->auth_data = packet_get_string(NULL);\n\ts->screen = packet_get_int();\n\tpacket_check_eom();\n\n\tif (xauth_valid_string(s->auth_proto) &&\n\t    xauth_valid_string(s->auth_data))\n\t\tsuccess = session_setup_x11fwd(ssh, s);\n\telse {\n\t\tsuccess = 0;\n\t\terror(\"Invalid X11 forwarding data\");\n\t}\n\tif (!success) {\n\t\tfree(s->auth_proto);\n\t\tfree(s->auth_data);\n\t\ts->auth_proto = NULL;\n\t\ts->auth_data = NULL;\n\t}\n\treturn success;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s->auth_data"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Invalid X11 forwarding data\""
          ],
          "line": 2029
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_setup_x11fwd",
          "args": [
            "ssh",
            "s"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "session_setup_x11fwd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2559-2633",
          "snippet": "int\nsession_setup_x11fwd(struct ssh *ssh, Session *s)\n{\n\tstruct stat st;\n\tchar display[512], auth_display[512];\n\tchar hostname[NI_MAXHOST];\n\tu_int i;\n\n\tif (!auth_opts->permit_x11_forwarding_flag) {\n\t\tpacket_send_debug(\"X11 forwarding disabled by key options.\");\n\t\treturn 0;\n\t}\n\tif (!options.x11_forwarding) {\n\t\tdebug(\"X11 forwarding disabled in server configuration file.\");\n\t\treturn 0;\n\t}\n\tif (options.xauth_location == NULL ||\n\t    (stat(options.xauth_location, &st) == -1)) {\n\t\tpacket_send_debug(\"No xauth program; cannot forward X11.\");\n\t\treturn 0;\n\t}\n\tif (s->display != NULL) {\n\t\tdebug(\"X11 display already set.\");\n\t\treturn 0;\n\t}\n\tif (x11_create_display_inet(ssh, options.x11_display_offset,\n\t    options.x11_use_localhost, s->single_connection,\n\t    &s->display_number, &s->x11_chanids) == -1) {\n\t\tdebug(\"x11_create_display_inet failed.\");\n\t\treturn 0;\n\t}\n\tfor (i = 0; s->x11_chanids[i] != -1; i++) {\n\t\tchannel_register_cleanup(ssh, s->x11_chanids[i],\n\t\t    session_close_single_x11, 0);\n\t}\n\n\t/* Set up a suitable value for the DISPLAY variable. */\n\tif (gethostname(hostname, sizeof(hostname)) < 0)\n\t\tfatal(\"gethostname: %.100s\", strerror(errno));\n\t/*\n\t * auth_display must be used as the displayname when the\n\t * authorization entry is added with xauth(1).  This will be\n\t * different than the DISPLAY string for localhost displays.\n\t */\n\tif (options.x11_use_localhost) {\n\t\tsnprintf(display, sizeof display, \"localhost:%u.%u\",\n\t\t    s->display_number, s->screen);\n\t\tsnprintf(auth_display, sizeof auth_display, \"unix:%u.%u\",\n\t\t    s->display_number, s->screen);\n\t\ts->display = xstrdup(display);\n\t\ts->auth_display = xstrdup(auth_display);\n\t} else {\n#ifdef IPADDR_IN_DISPLAY\n\t\tstruct hostent *he;\n\t\tstruct in_addr my_addr;\n\n\t\the = gethostbyname(hostname);\n\t\tif (he == NULL) {\n\t\t\terror(\"Can't get IP address for X11 DISPLAY.\");\n\t\t\tpacket_send_debug(\"Can't get IP address for X11 DISPLAY.\");\n\t\t\treturn 0;\n\t\t}\n\t\tmemcpy(&my_addr, he->h_addr_list[0], sizeof(struct in_addr));\n\t\tsnprintf(display, sizeof display, \"%.50s:%u.%u\", inet_ntoa(my_addr),\n\t\t    s->display_number, s->screen);\n#else\n\t\tsnprintf(display, sizeof display, \"%.400s:%u.%u\", hostname,\n\t\t    s->display_number, s->screen);\n#endif\n\t\ts->display = xstrdup(display);\n\t\ts->auth_display = xstrdup(display);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "extern ServerOptions options;",
            "extern struct sshauthopt *auth_opts;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\n\nint\nsession_setup_x11fwd(struct ssh *ssh, Session *s)\n{\n\tstruct stat st;\n\tchar display[512], auth_display[512];\n\tchar hostname[NI_MAXHOST];\n\tu_int i;\n\n\tif (!auth_opts->permit_x11_forwarding_flag) {\n\t\tpacket_send_debug(\"X11 forwarding disabled by key options.\");\n\t\treturn 0;\n\t}\n\tif (!options.x11_forwarding) {\n\t\tdebug(\"X11 forwarding disabled in server configuration file.\");\n\t\treturn 0;\n\t}\n\tif (options.xauth_location == NULL ||\n\t    (stat(options.xauth_location, &st) == -1)) {\n\t\tpacket_send_debug(\"No xauth program; cannot forward X11.\");\n\t\treturn 0;\n\t}\n\tif (s->display != NULL) {\n\t\tdebug(\"X11 display already set.\");\n\t\treturn 0;\n\t}\n\tif (x11_create_display_inet(ssh, options.x11_display_offset,\n\t    options.x11_use_localhost, s->single_connection,\n\t    &s->display_number, &s->x11_chanids) == -1) {\n\t\tdebug(\"x11_create_display_inet failed.\");\n\t\treturn 0;\n\t}\n\tfor (i = 0; s->x11_chanids[i] != -1; i++) {\n\t\tchannel_register_cleanup(ssh, s->x11_chanids[i],\n\t\t    session_close_single_x11, 0);\n\t}\n\n\t/* Set up a suitable value for the DISPLAY variable. */\n\tif (gethostname(hostname, sizeof(hostname)) < 0)\n\t\tfatal(\"gethostname: %.100s\", strerror(errno));\n\t/*\n\t * auth_display must be used as the displayname when the\n\t * authorization entry is added with xauth(1).  This will be\n\t * different than the DISPLAY string for localhost displays.\n\t */\n\tif (options.x11_use_localhost) {\n\t\tsnprintf(display, sizeof display, \"localhost:%u.%u\",\n\t\t    s->display_number, s->screen);\n\t\tsnprintf(auth_display, sizeof auth_display, \"unix:%u.%u\",\n\t\t    s->display_number, s->screen);\n\t\ts->display = xstrdup(display);\n\t\ts->auth_display = xstrdup(auth_display);\n\t} else {\n#ifdef IPADDR_IN_DISPLAY\n\t\tstruct hostent *he;\n\t\tstruct in_addr my_addr;\n\n\t\the = gethostbyname(hostname);\n\t\tif (he == NULL) {\n\t\t\terror(\"Can't get IP address for X11 DISPLAY.\");\n\t\t\tpacket_send_debug(\"Can't get IP address for X11 DISPLAY.\");\n\t\t\treturn 0;\n\t\t}\n\t\tmemcpy(&my_addr, he->h_addr_list[0], sizeof(struct in_addr));\n\t\tsnprintf(display, sizeof display, \"%.50s:%u.%u\", inet_ntoa(my_addr),\n\t\t    s->display_number, s->screen);\n#else\n\t\tsnprintf(display, sizeof display, \"%.400s:%u.%u\", hostname,\n\t\t    s->display_number, s->screen);\n#endif\n\t\ts->display = xstrdup(display);\n\t\ts->auth_display = xstrdup(display);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xauth_valid_string",
          "args": [
            "s->auth_data"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "xauth_valid_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "372-384",
          "snippet": "static int\nxauth_valid_string(const char *s)\n{\n\tsize_t i;\n\n\tfor (i = 0; s[i] != '\\0'; i++) {\n\t\tif (!isalnum((u_char)s[i]) &&\n\t\t    s[i] != '.' && s[i] != ':' && s[i] != '/' &&\n\t\t    s[i] != '-' && s[i] != '_')\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nxauth_valid_string(const char *s)\n{\n\tsize_t i;\n\n\tfor (i = 0; s[i] != '\\0'; i++) {\n\t\tif (!isalnum((u_char)s[i]) &&\n\t\t    s[i] != '.' && s[i] != ':' && s[i] != '/' &&\n\t\t    s[i] != '-' && s[i] != '_')\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_check_eom",
          "args": [],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_int",
          "args": [],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "227-231",
          "snippet": "u_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "NULL"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "NULL"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_char",
          "args": [],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "221-225",
          "snippet": "u_int\npacket_get_char(void)\n{\n\treturn (ssh_packet_get_char(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_char(void)\n{\n\treturn (ssh_packet_get_char(active_state));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_x11_req(struct ssh *ssh, Session *s)\n{\n\tint success;\n\n\tif (s->auth_proto != NULL || s->auth_data != NULL) {\n\t\terror(\"session_x11_req: session %d: \"\n\t\t    \"x11 forwarding already active\", s->self);\n\t\treturn 0;\n\t}\n\ts->single_connection = packet_get_char();\n\ts->auth_proto = packet_get_string(NULL);\n\ts->auth_data = packet_get_string(NULL);\n\ts->screen = packet_get_int();\n\tpacket_check_eom();\n\n\tif (xauth_valid_string(s->auth_proto) &&\n\t    xauth_valid_string(s->auth_data))\n\t\tsuccess = session_setup_x11fwd(ssh, s);\n\telse {\n\t\tsuccess = 0;\n\t\terror(\"Invalid X11 forwarding data\");\n\t}\n\tif (!success) {\n\t\tfree(s->auth_proto);\n\t\tfree(s->auth_data);\n\t\ts->auth_proto = NULL;\n\t\ts->auth_data = NULL;\n\t}\n\treturn success;\n}"
  },
  {
    "function_name": "session_subsystem_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1968-2006",
    "snippet": "static int\nsession_subsystem_req(struct ssh *ssh, Session *s)\n{\n\tstruct stat st;\n\tu_int len;\n\tint success = 0;\n\tchar *prog, *cmd;\n\tu_int i;\n\n\ts->subsys = packet_get_string(&len);\n\tpacket_check_eom();\n\tdebug2(\"subsystem request for %.100s by user %s\", s->subsys,\n\t    s->pw->pw_name);\n\n\tfor (i = 0; i < options.num_subsystems; i++) {\n\t\tif (strcmp(s->subsys, options.subsystem_name[i]) == 0) {\n\t\t\tprog = options.subsystem_command[i];\n\t\t\tcmd = options.subsystem_args[i];\n\t\t\tif (strcmp(INTERNAL_SFTP_NAME, prog) == 0) {\n\t\t\t\ts->is_subsystem = SUBSYSTEM_INT_SFTP;\n\t\t\t\tdebug(\"subsystem: %s\", prog);\n\t\t\t} else {\n\t\t\t\tif (stat(prog, &st) < 0)\n\t\t\t\t\tdebug(\"subsystem: cannot stat %s: %s\",\n\t\t\t\t\t    prog, strerror(errno));\n\t\t\t\ts->is_subsystem = SUBSYSTEM_EXT;\n\t\t\t\tdebug(\"subsystem: exec() %s\", cmd);\n\t\t\t}\n\t\t\tsuccess = do_exec(ssh, s, cmd) == 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!success)\n\t\tlogit(\"subsystem request for %.100s by user %s failed, \"\n\t\t    \"subsystem not found\", s->subsys, s->pw->pw_name);\n\n\treturn success;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SUBSYSTEM_INT_SFTP\t\t2",
      "#define SUBSYSTEM_EXT\t\t\t1"
    ],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"subsystem request for %.100s by user %s failed, \"\n\t\t    \"subsystem not found\"",
            "s->subsys",
            "s->pw->pw_name"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_exec",
          "args": [
            "ssh",
            "s",
            "cmd"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "do_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "692-769",
          "snippet": "int\ndo_exec(struct ssh *ssh, Session *s, const char *command)\n{\n\tint ret;\n\tconst char *forced = NULL, *tty = NULL;\n\tchar session_type[1024];\n\n\tif (options.adm_forced_command) {\n\t\toriginal_command = command;\n\t\tcommand = options.adm_forced_command;\n\t\tforced = \"(config)\";\n\t} else if (auth_opts->force_command != NULL) {\n\t\toriginal_command = command;\n\t\tcommand = auth_opts->force_command;\n\t\tforced = \"(key-option)\";\n\t}\n\ts->forced = 0;\n\tif (forced != NULL) {\n\t\ts->forced = 1;\n\t\tif (IS_INTERNAL_SFTP(command)) {\n\t\t\ts->is_subsystem = s->is_subsystem ?\n\t\t\t    SUBSYSTEM_INT_SFTP : SUBSYSTEM_INT_SFTP_ERROR;\n\t\t} else if (s->is_subsystem)\n\t\t\ts->is_subsystem = SUBSYSTEM_EXT;\n\t\tsnprintf(session_type, sizeof(session_type),\n\t\t    \"forced-command %s '%.900s'\", forced, command);\n\t} else if (s->is_subsystem) {\n\t\tsnprintf(session_type, sizeof(session_type),\n\t\t    \"subsystem '%.900s'\", s->subsys);\n\t} else if (command == NULL) {\n\t\tsnprintf(session_type, sizeof(session_type), \"shell\");\n\t} else {\n\t\t/* NB. we don't log unforced commands to preserve privacy */\n\t\tsnprintf(session_type, sizeof(session_type), \"command\");\n\t}\n\n\tif (s->ttyfd != -1) {\n\t\ttty = s->tty;\n\t\tif (strncmp(tty, \"/dev/\", 5) == 0)\n\t\t\ttty += 5;\n\t}\n\n\tverbose(\"Starting session: %s%s%s for %s from %.200s port %d id %d\",\n\t    session_type,\n\t    tty == NULL ? \"\" : \" on \",\n\t    tty == NULL ? \"\" : tty,\n\t    s->pw->pw_name,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    s->self);\n\n#ifdef SSH_AUDIT_EVENTS\n\tif (command != NULL)\n\t\tPRIVSEP(audit_run_command(command));\n\telse if (s->ttyfd == -1) {\n\t\tchar *shell = s->pw->pw_shell;\n\n\t\tif (shell[0] == '\\0')\t/* empty shell means /bin/sh */\n\t\t\tshell =_PATH_BSHELL;\n\t\tPRIVSEP(audit_run_command(shell));\n\t}\n#endif\n\tif (s->ttyfd != -1)\n\t\tret = do_exec_pty(ssh, s, command);\n\telse\n\t\tret = do_exec_no_pty(ssh, s, command);\n\n\toriginal_command = NULL;\n\n\t/*\n\t * Clear loginmsg: it's the child's responsibility to display\n\t * it to the user, otherwise multiple sessions may accumulate\n\t * multiple copies of the login messages.\n\t */\n\tsshbuf_reset(loginmsg);\n\n\treturn ret;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SUBSYSTEM_INT_SFTP_ERROR\t3",
            "#define SUBSYSTEM_INT_SFTP\t\t2",
            "#define SUBSYSTEM_EXT\t\t\t1"
          ],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "extern ServerOptions options;",
            "extern struct sshbuf *loginmsg;",
            "extern struct sshauthopt *auth_opts;",
            "const char *original_command = NULL;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SUBSYSTEM_INT_SFTP_ERROR\t3\n#define SUBSYSTEM_INT_SFTP\t\t2\n#define SUBSYSTEM_EXT\t\t\t1\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern struct sshbuf *loginmsg;\nextern struct sshauthopt *auth_opts;\nconst char *original_command = NULL;\nstatic Session *sessions = NULL;\n\nint\ndo_exec(struct ssh *ssh, Session *s, const char *command)\n{\n\tint ret;\n\tconst char *forced = NULL, *tty = NULL;\n\tchar session_type[1024];\n\n\tif (options.adm_forced_command) {\n\t\toriginal_command = command;\n\t\tcommand = options.adm_forced_command;\n\t\tforced = \"(config)\";\n\t} else if (auth_opts->force_command != NULL) {\n\t\toriginal_command = command;\n\t\tcommand = auth_opts->force_command;\n\t\tforced = \"(key-option)\";\n\t}\n\ts->forced = 0;\n\tif (forced != NULL) {\n\t\ts->forced = 1;\n\t\tif (IS_INTERNAL_SFTP(command)) {\n\t\t\ts->is_subsystem = s->is_subsystem ?\n\t\t\t    SUBSYSTEM_INT_SFTP : SUBSYSTEM_INT_SFTP_ERROR;\n\t\t} else if (s->is_subsystem)\n\t\t\ts->is_subsystem = SUBSYSTEM_EXT;\n\t\tsnprintf(session_type, sizeof(session_type),\n\t\t    \"forced-command %s '%.900s'\", forced, command);\n\t} else if (s->is_subsystem) {\n\t\tsnprintf(session_type, sizeof(session_type),\n\t\t    \"subsystem '%.900s'\", s->subsys);\n\t} else if (command == NULL) {\n\t\tsnprintf(session_type, sizeof(session_type), \"shell\");\n\t} else {\n\t\t/* NB. we don't log unforced commands to preserve privacy */\n\t\tsnprintf(session_type, sizeof(session_type), \"command\");\n\t}\n\n\tif (s->ttyfd != -1) {\n\t\ttty = s->tty;\n\t\tif (strncmp(tty, \"/dev/\", 5) == 0)\n\t\t\ttty += 5;\n\t}\n\n\tverbose(\"Starting session: %s%s%s for %s from %.200s port %d id %d\",\n\t    session_type,\n\t    tty == NULL ? \"\" : \" on \",\n\t    tty == NULL ? \"\" : tty,\n\t    s->pw->pw_name,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    s->self);\n\n#ifdef SSH_AUDIT_EVENTS\n\tif (command != NULL)\n\t\tPRIVSEP(audit_run_command(command));\n\telse if (s->ttyfd == -1) {\n\t\tchar *shell = s->pw->pw_shell;\n\n\t\tif (shell[0] == '\\0')\t/* empty shell means /bin/sh */\n\t\t\tshell =_PATH_BSHELL;\n\t\tPRIVSEP(audit_run_command(shell));\n\t}\n#endif\n\tif (s->ttyfd != -1)\n\t\tret = do_exec_pty(ssh, s, command);\n\telse\n\t\tret = do_exec_no_pty(ssh, s, command);\n\n\toriginal_command = NULL;\n\n\t/*\n\t * Clear loginmsg: it's the child's responsibility to display\n\t * it to the user, otherwise multiple sessions may accumulate\n\t * multiple copies of the login messages.\n\t */\n\tsshbuf_reset(loginmsg);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"subsystem: exec() %s\"",
            "cmd"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "prog",
            "&st"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "INTERNAL_SFTP_NAME",
            "prog"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"subsystem request for %.100s by user %s\"",
            "s->subsys",
            "s->pw->pw_name"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_check_eom",
          "args": [],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "&len"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SUBSYSTEM_INT_SFTP\t\t2\n#define SUBSYSTEM_EXT\t\t\t1\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\n\nstatic int\nsession_subsystem_req(struct ssh *ssh, Session *s)\n{\n\tstruct stat st;\n\tu_int len;\n\tint success = 0;\n\tchar *prog, *cmd;\n\tu_int i;\n\n\ts->subsys = packet_get_string(&len);\n\tpacket_check_eom();\n\tdebug2(\"subsystem request for %.100s by user %s\", s->subsys,\n\t    s->pw->pw_name);\n\n\tfor (i = 0; i < options.num_subsystems; i++) {\n\t\tif (strcmp(s->subsys, options.subsystem_name[i]) == 0) {\n\t\t\tprog = options.subsystem_command[i];\n\t\t\tcmd = options.subsystem_args[i];\n\t\t\tif (strcmp(INTERNAL_SFTP_NAME, prog) == 0) {\n\t\t\t\ts->is_subsystem = SUBSYSTEM_INT_SFTP;\n\t\t\t\tdebug(\"subsystem: %s\", prog);\n\t\t\t} else {\n\t\t\t\tif (stat(prog, &st) < 0)\n\t\t\t\t\tdebug(\"subsystem: cannot stat %s: %s\",\n\t\t\t\t\t    prog, strerror(errno));\n\t\t\t\ts->is_subsystem = SUBSYSTEM_EXT;\n\t\t\t\tdebug(\"subsystem: exec() %s\", cmd);\n\t\t\t}\n\t\t\tsuccess = do_exec(ssh, s, cmd) == 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!success)\n\t\tlogit(\"subsystem request for %.100s by user %s failed, \"\n\t\t    \"subsystem not found\", s->subsys, s->pw->pw_name);\n\n\treturn success;\n}"
  },
  {
    "function_name": "session_pty_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1917-1966",
    "snippet": "static int\nsession_pty_req(struct ssh *ssh, Session *s)\n{\n\tu_int len;\n\n\tif (!auth_opts->permit_pty_flag || !options.permit_tty) {\n\t\tdebug(\"Allocating a pty not permitted for this connection.\");\n\t\treturn 0;\n\t}\n\tif (s->ttyfd != -1) {\n\t\tpacket_disconnect(\"Protocol error: you already have a pty.\");\n\t\treturn 0;\n\t}\n\n\ts->term = packet_get_string(&len);\n\ts->col = packet_get_int();\n\ts->row = packet_get_int();\n\ts->xpixel = packet_get_int();\n\ts->ypixel = packet_get_int();\n\n\tif (strcmp(s->term, \"\") == 0) {\n\t\tfree(s->term);\n\t\ts->term = NULL;\n\t}\n\n\t/* Allocate a pty and open it. */\n\tdebug(\"Allocating pty.\");\n\tif (!PRIVSEP(pty_allocate(&s->ptyfd, &s->ttyfd, s->tty,\n\t    sizeof(s->tty)))) {\n\t\tfree(s->term);\n\t\ts->term = NULL;\n\t\ts->ptyfd = -1;\n\t\ts->ttyfd = -1;\n\t\terror(\"session_pty_req: session %d alloc failed\", s->self);\n\t\treturn 0;\n\t}\n\tdebug(\"session_pty_req: session %d alloc %s\", s->self, s->tty);\n\n\tssh_tty_parse_modes(ssh, s->ttyfd);\n\n\tif (!use_privsep)\n\t\tpty_setowner(s->pw, s->tty);\n\n\t/* Set window size from the packet. */\n\tpty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);\n\n\tpacket_check_eom();\n\tsession_proctitle(s);\n\treturn 1;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "extern ServerOptions options;",
      "extern struct sshauthopt *auth_opts;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "session_proctitle",
          "args": [
            "s"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "session_proctitle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2550-2557",
          "snippet": "void\nsession_proctitle(Session *s)\n{\n\tif (s->pw == NULL)\n\t\terror(\"no user for session %d\", s->self);\n\telse\n\t\tsetproctitle(\"%s@%s\", s->pw->pw_name, session_tty_list());\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_proctitle(Session *s)\n{\n\tif (s->pw == NULL)\n\t\terror(\"no user for session %d\", s->self);\n\telse\n\t\tsetproctitle(\"%s@%s\", s->pw->pw_name, session_tty_list());\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_check_eom",
          "args": [],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pty_change_window_size",
          "args": [
            "s->ptyfd",
            "s->row",
            "s->col",
            "s->xpixel",
            "s->ypixel"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "pty_change_window_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshpty.c",
          "lines": "150-162",
          "snippet": "void\npty_change_window_size(int ptyfd, u_int row, u_int col,\n\tu_int xpixel, u_int ypixel)\n{\n\tstruct winsize w;\n\n\t/* may truncate u_int -> u_short */\n\tw.ws_row = row;\n\tw.ws_col = col;\n\tw.ws_xpixel = xpixel;\n\tw.ws_ypixel = ypixel;\n\t(void) ioctl(ptyfd, TIOCSWINSZ, &w);\n}",
          "includes": [
            "# include <AvailabilityMacros.h>",
            "# include <pty.h>",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshpty.h\"",
            "#include <unistd.h>",
            "# include <util.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <AvailabilityMacros.h>\n# include <pty.h>\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshpty.h\"\n#include <unistd.h>\n# include <util.h>\n#include <termios.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\npty_change_window_size(int ptyfd, u_int row, u_int col,\n\tu_int xpixel, u_int ypixel)\n{\n\tstruct winsize w;\n\n\t/* may truncate u_int -> u_short */\n\tw.ws_row = row;\n\tw.ws_col = col;\n\tw.ws_xpixel = xpixel;\n\tw.ws_ypixel = ypixel;\n\t(void) ioctl(ptyfd, TIOCSWINSZ, &w);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pty_setowner",
          "args": [
            "s->pw",
            "s->tty"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "pty_setowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshpty.c",
          "lines": "164-215",
          "snippet": "void\npty_setowner(struct passwd *pw, const char *tty)\n{\n\tstruct group *grp;\n\tgid_t gid;\n\tmode_t mode;\n\tstruct stat st;\n\n\t/* Determine the group to make the owner of the tty. */\n\tgrp = getgrnam(\"tty\");\n\tgid = (grp != NULL) ? grp->gr_gid : pw->pw_gid;\n\tmode = (grp != NULL) ? 0620 : 0600;\n\n\t/*\n\t * Change owner and mode of the tty as required.\n\t * Warn but continue if filesystem is read-only and the uids match/\n\t * tty is owned by root.\n\t */\n\tif (stat(tty, &st))\n\t\tfatal(\"stat(%.100s) failed: %.100s\", tty,\n\t\t    strerror(errno));\n\n#ifdef WITH_SELINUX\n\tssh_selinux_setup_pty(pw->pw_name, tty);\n#endif\n\n\tif (st.st_uid != pw->pw_uid || st.st_gid != gid) {\n\t\tif (chown(tty, pw->pw_uid, gid) < 0) {\n\t\t\tif (errno == EROFS &&\n\t\t\t    (st.st_uid == pw->pw_uid || st.st_uid == 0))\n\t\t\t\tdebug(\"chown(%.100s, %u, %u) failed: %.100s\",\n\t\t\t\t    tty, (u_int)pw->pw_uid, (u_int)gid,\n\t\t\t\t    strerror(errno));\n\t\t\telse\n\t\t\t\tfatal(\"chown(%.100s, %u, %u) failed: %.100s\",\n\t\t\t\t    tty, (u_int)pw->pw_uid, (u_int)gid,\n\t\t\t\t    strerror(errno));\n\t\t}\n\t}\n\n\tif ((st.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO)) != mode) {\n\t\tif (chmod(tty, mode) < 0) {\n\t\t\tif (errno == EROFS &&\n\t\t\t    (st.st_mode & (S_IRGRP | S_IROTH)) == 0)\n\t\t\t\tdebug(\"chmod(%.100s, 0%o) failed: %.100s\",\n\t\t\t\t    tty, (u_int)mode, strerror(errno));\n\t\t\telse\n\t\t\t\tfatal(\"chmod(%.100s, 0%o) failed: %.100s\",\n\t\t\t\t    tty, (u_int)mode, strerror(errno));\n\t\t}\n\t}\n}",
          "includes": [
            "# include <AvailabilityMacros.h>",
            "# include <pty.h>",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshpty.h\"",
            "#include <unistd.h>",
            "# include <util.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <AvailabilityMacros.h>\n# include <pty.h>\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshpty.h\"\n#include <unistd.h>\n# include <util.h>\n#include <termios.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\npty_setowner(struct passwd *pw, const char *tty)\n{\n\tstruct group *grp;\n\tgid_t gid;\n\tmode_t mode;\n\tstruct stat st;\n\n\t/* Determine the group to make the owner of the tty. */\n\tgrp = getgrnam(\"tty\");\n\tgid = (grp != NULL) ? grp->gr_gid : pw->pw_gid;\n\tmode = (grp != NULL) ? 0620 : 0600;\n\n\t/*\n\t * Change owner and mode of the tty as required.\n\t * Warn but continue if filesystem is read-only and the uids match/\n\t * tty is owned by root.\n\t */\n\tif (stat(tty, &st))\n\t\tfatal(\"stat(%.100s) failed: %.100s\", tty,\n\t\t    strerror(errno));\n\n#ifdef WITH_SELINUX\n\tssh_selinux_setup_pty(pw->pw_name, tty);\n#endif\n\n\tif (st.st_uid != pw->pw_uid || st.st_gid != gid) {\n\t\tif (chown(tty, pw->pw_uid, gid) < 0) {\n\t\t\tif (errno == EROFS &&\n\t\t\t    (st.st_uid == pw->pw_uid || st.st_uid == 0))\n\t\t\t\tdebug(\"chown(%.100s, %u, %u) failed: %.100s\",\n\t\t\t\t    tty, (u_int)pw->pw_uid, (u_int)gid,\n\t\t\t\t    strerror(errno));\n\t\t\telse\n\t\t\t\tfatal(\"chown(%.100s, %u, %u) failed: %.100s\",\n\t\t\t\t    tty, (u_int)pw->pw_uid, (u_int)gid,\n\t\t\t\t    strerror(errno));\n\t\t}\n\t}\n\n\tif ((st.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO)) != mode) {\n\t\tif (chmod(tty, mode) < 0) {\n\t\t\tif (errno == EROFS &&\n\t\t\t    (st.st_mode & (S_IRGRP | S_IROTH)) == 0)\n\t\t\t\tdebug(\"chmod(%.100s, 0%o) failed: %.100s\",\n\t\t\t\t    tty, (u_int)mode, strerror(errno));\n\t\t\telse\n\t\t\t\tfatal(\"chmod(%.100s, 0%o) failed: %.100s\",\n\t\t\t\t    tty, (u_int)mode, strerror(errno));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_tty_parse_modes",
          "args": [
            "ssh",
            "s->ttyfd"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_tty_parse_modes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ttymodes.c",
          "lines": "342-456",
          "snippet": "void\nssh_tty_parse_modes(struct ssh *ssh, int fd)\n{\n\tstruct termios tio;\n\tstruct sshbuf *buf;\n\tconst u_char *data;\n\tu_char opcode;\n\tu_int baud, u;\n\tint r, failure = 0;\n\tsize_t len;\n\n\tif ((r = sshpkt_get_string_direct(ssh, &data, &len)) != 0)\n\t\tfatal(\"%s: packet error: %s\", __func__, ssh_err(r));\n\tif (len == 0)\n\t\treturn;\n\tif ((buf = sshbuf_from(data, len)) == NULL) {\n\t\terror(\"%s: sshbuf_from failed\", __func__);\n\t\treturn;\n\t}\n\n\t/*\n\t * Get old attributes for the terminal.  We will modify these\n\t * flags. I am hoping that if there are any machine-specific\n\t * modes, they will initially have reasonable values.\n\t */\n\tif (tcgetattr(fd, &tio) == -1) {\n\t\tlogit(\"tcgetattr: %.100s\", strerror(errno));\n\t\tfailure = -1;\n\t}\n\n\twhile (sshbuf_len(buf) > 0) {\n\t\tif ((r = sshbuf_get_u8(buf, &opcode)) != 0)\n\t\t\tfatal(\"%s: packet error: %s\", __func__, ssh_err(r));\n\t\tswitch (opcode) {\n\t\tcase TTY_OP_END:\n\t\t\tgoto set;\n\n\t\tcase TTY_OP_ISPEED:\n\t\t\tif ((r = sshbuf_get_u32(buf, &baud)) != 0)\n\t\t\t\tfatal(\"%s: packet error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (failure != -1 &&\n\t\t\t    cfsetispeed(&tio, baud_to_speed(baud)) == -1)\n\t\t\t\terror(\"cfsetispeed failed for %d\", baud);\n\t\t\tbreak;\n\n\t\tcase TTY_OP_OSPEED:\n\t\t\tif ((r = sshbuf_get_u32(buf, &baud)) != 0)\n\t\t\t\tfatal(\"%s: packet error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (failure != -1 &&\n\t\t\t    cfsetospeed(&tio, baud_to_speed(baud)) == -1)\n\t\t\t\terror(\"cfsetospeed failed for %d\", baud);\n\t\t\tbreak;\n\n#define TTYCHAR(NAME, OP) \\\n\t\tcase OP: \\\n\t\t\tif ((r = sshbuf_get_u32(buf, &u)) != 0) \\\n\t\t\t\tfatal(\"%s: packet error: %s\", __func__, \\\n\t\t\t\t    ssh_err(r)); \\\n\t\t\ttio.c_cc[NAME] = special_char_decode(u); \\\n\t\t\tbreak;\n#define TTYMODE(NAME, FIELD, OP) \\\n\t\tcase OP: \\\n\t\t\tif ((r = sshbuf_get_u32(buf, &u)) != 0) \\\n\t\t\t\tfatal(\"%s: packet error: %s\", __func__, \\\n\t\t\t\t    ssh_err(r)); \\\n\t\t\tif (u) \\\n\t\t\t\ttio.FIELD |= NAME; \\\n\t\t\telse \\\n\t\t\t\ttio.FIELD &= ~NAME; \\\n\t\t\tbreak;\n\n#include \"ttymodes.h\"\n\n#undef TTYCHAR\n#undef TTYMODE\n\n\t\tdefault:\n\t\t\tdebug(\"Ignoring unsupported tty mode opcode %d (0x%x)\",\n\t\t\t    opcode, opcode);\n\t\t\t/*\n\t\t\t * SSH2:\n\t\t\t * Opcodes 1 to 159 are defined to have a uint32\n\t\t\t * argument.\n\t\t\t * Opcodes 160 to 255 are undefined and cause parsing\n\t\t\t * to stop.\n\t\t\t */\n\t\t\tif (opcode > 0 && opcode < 160) {\n\t\t\t\tif ((r = sshbuf_get_u32(buf, NULL)) != 0)\n\t\t\t\t\tfatal(\"%s: packet error: %s\", __func__,\n\t\t\t\t\t    ssh_err(r));\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tlogit(\"%s: unknown opcode %d\", __func__,\n\t\t\t\t    opcode);\n\t\t\t\tgoto set;\n\t\t\t}\n\t\t}\n\t}\n\nset:\n\tlen = sshbuf_len(buf);\n\tsshbuf_free(buf);\n\tif (len > 0) {\n\t\tlogit(\"%s: %zu bytes left\", __func__, len);\n\t\treturn;\t\t/* Don't process bytes passed */\n\t}\n\tif (failure == -1)\n\t\treturn;\t\t/* Packet parsed ok but tcgetattr() failed */\n\n\t/* Set the new modes for the terminal. */\n\tif (tcsetattr(fd, TCSANOW, &tio) == -1)\n\t\tlogit(\"Setting tty modes failed: %.100s\", strerror(errno));\n}",
          "includes": [
            "#include \"ttymodes.h\"",
            "#include \"ttymodes.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"compat.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include <stdarg.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define TTY_OP_OSPEED\t129",
            "#define TTY_OP_ISPEED\t128",
            "#define TTY_OP_END\t\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ttymodes.h\"\n#include \"ttymodes.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"compat.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include <stdarg.h>\n#include <termios.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define TTY_OP_OSPEED\t129\n#define TTY_OP_ISPEED\t128\n#define TTY_OP_END\t\t0\n\nvoid\nssh_tty_parse_modes(struct ssh *ssh, int fd)\n{\n\tstruct termios tio;\n\tstruct sshbuf *buf;\n\tconst u_char *data;\n\tu_char opcode;\n\tu_int baud, u;\n\tint r, failure = 0;\n\tsize_t len;\n\n\tif ((r = sshpkt_get_string_direct(ssh, &data, &len)) != 0)\n\t\tfatal(\"%s: packet error: %s\", __func__, ssh_err(r));\n\tif (len == 0)\n\t\treturn;\n\tif ((buf = sshbuf_from(data, len)) == NULL) {\n\t\terror(\"%s: sshbuf_from failed\", __func__);\n\t\treturn;\n\t}\n\n\t/*\n\t * Get old attributes for the terminal.  We will modify these\n\t * flags. I am hoping that if there are any machine-specific\n\t * modes, they will initially have reasonable values.\n\t */\n\tif (tcgetattr(fd, &tio) == -1) {\n\t\tlogit(\"tcgetattr: %.100s\", strerror(errno));\n\t\tfailure = -1;\n\t}\n\n\twhile (sshbuf_len(buf) > 0) {\n\t\tif ((r = sshbuf_get_u8(buf, &opcode)) != 0)\n\t\t\tfatal(\"%s: packet error: %s\", __func__, ssh_err(r));\n\t\tswitch (opcode) {\n\t\tcase TTY_OP_END:\n\t\t\tgoto set;\n\n\t\tcase TTY_OP_ISPEED:\n\t\t\tif ((r = sshbuf_get_u32(buf, &baud)) != 0)\n\t\t\t\tfatal(\"%s: packet error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (failure != -1 &&\n\t\t\t    cfsetispeed(&tio, baud_to_speed(baud)) == -1)\n\t\t\t\terror(\"cfsetispeed failed for %d\", baud);\n\t\t\tbreak;\n\n\t\tcase TTY_OP_OSPEED:\n\t\t\tif ((r = sshbuf_get_u32(buf, &baud)) != 0)\n\t\t\t\tfatal(\"%s: packet error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (failure != -1 &&\n\t\t\t    cfsetospeed(&tio, baud_to_speed(baud)) == -1)\n\t\t\t\terror(\"cfsetospeed failed for %d\", baud);\n\t\t\tbreak;\n\n#define TTYCHAR(NAME, OP) \\\n\t\tcase OP: \\\n\t\t\tif ((r = sshbuf_get_u32(buf, &u)) != 0) \\\n\t\t\t\tfatal(\"%s: packet error: %s\", __func__, \\\n\t\t\t\t    ssh_err(r)); \\\n\t\t\ttio.c_cc[NAME] = special_char_decode(u); \\\n\t\t\tbreak;\n#define TTYMODE(NAME, FIELD, OP) \\\n\t\tcase OP: \\\n\t\t\tif ((r = sshbuf_get_u32(buf, &u)) != 0) \\\n\t\t\t\tfatal(\"%s: packet error: %s\", __func__, \\\n\t\t\t\t    ssh_err(r)); \\\n\t\t\tif (u) \\\n\t\t\t\ttio.FIELD |= NAME; \\\n\t\t\telse \\\n\t\t\t\ttio.FIELD &= ~NAME; \\\n\t\t\tbreak;\n\n#include \"ttymodes.h\"\n\n#undef TTYCHAR\n#undef TTYMODE\n\n\t\tdefault:\n\t\t\tdebug(\"Ignoring unsupported tty mode opcode %d (0x%x)\",\n\t\t\t    opcode, opcode);\n\t\t\t/*\n\t\t\t * SSH2:\n\t\t\t * Opcodes 1 to 159 are defined to have a uint32\n\t\t\t * argument.\n\t\t\t * Opcodes 160 to 255 are undefined and cause parsing\n\t\t\t * to stop.\n\t\t\t */\n\t\t\tif (opcode > 0 && opcode < 160) {\n\t\t\t\tif ((r = sshbuf_get_u32(buf, NULL)) != 0)\n\t\t\t\t\tfatal(\"%s: packet error: %s\", __func__,\n\t\t\t\t\t    ssh_err(r));\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tlogit(\"%s: unknown opcode %d\", __func__,\n\t\t\t\t    opcode);\n\t\t\t\tgoto set;\n\t\t\t}\n\t\t}\n\t}\n\nset:\n\tlen = sshbuf_len(buf);\n\tsshbuf_free(buf);\n\tif (len > 0) {\n\t\tlogit(\"%s: %zu bytes left\", __func__, len);\n\t\treturn;\t\t/* Don't process bytes passed */\n\t}\n\tif (failure == -1)\n\t\treturn;\t\t/* Packet parsed ok but tcgetattr() failed */\n\n\t/* Set the new modes for the terminal. */\n\tif (tcsetattr(fd, TCSANOW, &tio) == -1)\n\t\tlogit(\"Setting tty modes failed: %.100s\", strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"session_pty_req: session %d alloc %s\"",
            "s->self",
            "s->tty"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"session_pty_req: session %d alloc failed\"",
            "s->self"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s->term"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRIVSEP",
          "args": [
            "pty_allocate(&s->ptyfd, &s->ttyfd, s->tty,\n\t    sizeof(s->tty))"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pty_allocate",
          "args": [
            "&s->ptyfd",
            "&s->ttyfd",
            "s->tty",
            "sizeof(s->tty)"
          ],
          "line": 1944
        },
        "resolved": true,
        "details": {
          "function_name": "pty_allocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshpty.c",
          "lines": "63-81",
          "snippet": "int\npty_allocate(int *ptyfd, int *ttyfd, char *namebuf, size_t namebuflen)\n{\n\t/* openpty(3) exists in OSF/1 and some other os'es */\n\tchar *name;\n\tint i;\n\n\ti = openpty(ptyfd, ttyfd, NULL, NULL, NULL);\n\tif (i < 0) {\n\t\terror(\"openpty: %.100s\", strerror(errno));\n\t\treturn 0;\n\t}\n\tname = ttyname(*ttyfd);\n\tif (!name)\n\t\tfatal(\"openpty returns device for which ttyname fails.\");\n\n\tstrlcpy(namebuf, name, namebuflen);\t/* possible truncation */\n\treturn 1;\n}",
          "includes": [
            "# include <AvailabilityMacros.h>",
            "# include <pty.h>",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshpty.h\"",
            "#include <unistd.h>",
            "# include <util.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <AvailabilityMacros.h>\n# include <pty.h>\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshpty.h\"\n#include <unistd.h>\n# include <util.h>\n#include <termios.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npty_allocate(int *ptyfd, int *ttyfd, char *namebuf, size_t namebuflen)\n{\n\t/* openpty(3) exists in OSF/1 and some other os'es */\n\tchar *name;\n\tint i;\n\n\ti = openpty(ptyfd, ttyfd, NULL, NULL, NULL);\n\tif (i < 0) {\n\t\terror(\"openpty: %.100s\", strerror(errno));\n\t\treturn 0;\n\t}\n\tname = ttyname(*ttyfd);\n\tif (!name)\n\t\tfatal(\"openpty returns device for which ttyname fails.\");\n\n\tstrlcpy(namebuf, name, namebuflen);\t/* possible truncation */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s->term",
            "\"\""
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_int",
          "args": [],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "227-231",
          "snippet": "u_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "&len"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_disconnect",
          "args": [
            "\"Protocol error: you already have a pty.\""
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "packet_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "298-308",
          "snippet": "void\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\n\nstatic int\nsession_pty_req(struct ssh *ssh, Session *s)\n{\n\tu_int len;\n\n\tif (!auth_opts->permit_pty_flag || !options.permit_tty) {\n\t\tdebug(\"Allocating a pty not permitted for this connection.\");\n\t\treturn 0;\n\t}\n\tif (s->ttyfd != -1) {\n\t\tpacket_disconnect(\"Protocol error: you already have a pty.\");\n\t\treturn 0;\n\t}\n\n\ts->term = packet_get_string(&len);\n\ts->col = packet_get_int();\n\ts->row = packet_get_int();\n\ts->xpixel = packet_get_int();\n\ts->ypixel = packet_get_int();\n\n\tif (strcmp(s->term, \"\") == 0) {\n\t\tfree(s->term);\n\t\ts->term = NULL;\n\t}\n\n\t/* Allocate a pty and open it. */\n\tdebug(\"Allocating pty.\");\n\tif (!PRIVSEP(pty_allocate(&s->ptyfd, &s->ttyfd, s->tty,\n\t    sizeof(s->tty)))) {\n\t\tfree(s->term);\n\t\ts->term = NULL;\n\t\ts->ptyfd = -1;\n\t\ts->ttyfd = -1;\n\t\terror(\"session_pty_req: session %d alloc failed\", s->self);\n\t\treturn 0;\n\t}\n\tdebug(\"session_pty_req: session %d alloc %s\", s->self, s->tty);\n\n\tssh_tty_parse_modes(ssh, s->ttyfd);\n\n\tif (!use_privsep)\n\t\tpty_setowner(s->pw, s->tty);\n\n\t/* Set window size from the packet. */\n\tpty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);\n\n\tpacket_check_eom();\n\tsession_proctitle(s);\n\treturn 1;\n}"
  },
  {
    "function_name": "session_window_change_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1905-1915",
    "snippet": "static int\nsession_window_change_req(struct ssh *ssh, Session *s)\n{\n\ts->col = packet_get_int();\n\ts->row = packet_get_int();\n\ts->xpixel = packet_get_int();\n\ts->ypixel = packet_get_int();\n\tpacket_check_eom();\n\tpty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);\n\treturn 1;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pty_change_window_size",
          "args": [
            "s->ptyfd",
            "s->row",
            "s->col",
            "s->xpixel",
            "s->ypixel"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "pty_change_window_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshpty.c",
          "lines": "150-162",
          "snippet": "void\npty_change_window_size(int ptyfd, u_int row, u_int col,\n\tu_int xpixel, u_int ypixel)\n{\n\tstruct winsize w;\n\n\t/* may truncate u_int -> u_short */\n\tw.ws_row = row;\n\tw.ws_col = col;\n\tw.ws_xpixel = xpixel;\n\tw.ws_ypixel = ypixel;\n\t(void) ioctl(ptyfd, TIOCSWINSZ, &w);\n}",
          "includes": [
            "# include <AvailabilityMacros.h>",
            "# include <pty.h>",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshpty.h\"",
            "#include <unistd.h>",
            "# include <util.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <AvailabilityMacros.h>\n# include <pty.h>\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshpty.h\"\n#include <unistd.h>\n# include <util.h>\n#include <termios.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\npty_change_window_size(int ptyfd, u_int row, u_int col,\n\tu_int xpixel, u_int ypixel)\n{\n\tstruct winsize w;\n\n\t/* may truncate u_int -> u_short */\n\tw.ws_row = row;\n\tw.ws_col = col;\n\tw.ws_xpixel = xpixel;\n\tw.ws_ypixel = ypixel;\n\t(void) ioctl(ptyfd, TIOCSWINSZ, &w);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_check_eom",
          "args": [],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_int",
          "args": [],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "packet_get_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "227-231",
          "snippet": "u_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nu_int\npacket_get_int(void)\n{\n\treturn (ssh_packet_get_int(active_state));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_window_change_req(struct ssh *ssh, Session *s)\n{\n\ts->col = packet_get_int();\n\ts->row = packet_get_int();\n\ts->xpixel = packet_get_int();\n\ts->ypixel = packet_get_int();\n\tpacket_check_eom();\n\tpty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);\n\treturn 1;\n}"
  },
  {
    "function_name": "session_by_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1890-1903",
    "snippet": "static Session *\nsession_by_pid(pid_t pid)\n{\n\tint i;\n\tdebug(\"session_by_pid: pid %ld\", (long)pid);\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->pid == pid)\n\t\t\treturn s;\n\t}\n\terror(\"session_by_pid: unknown pid %ld\", (long)pid);\n\tsession_dump();\n\treturn NULL;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "static int sessions_nalloc = 0;",
      "static Session *sessions = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "session_dump",
          "args": [],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "session_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1798-1814",
          "snippet": "static void\nsession_dump(void)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\n\t\tdebug(\"dump: used %d next_unused %d session %d %p \"\n\t\t    \"channel %d pid %ld\",\n\t\t    s->used,\n\t\t    s->next_unused,\n\t\t    s->self,\n\t\t    s,\n\t\t    s->chanid,\n\t\t    (long)s->pid);\n\t}\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "static int sessions_nalloc = 0;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nstatic void\nsession_dump(void)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\n\t\tdebug(\"dump: used %d next_unused %d session %d %p \"\n\t\t    \"channel %d pid %ld\",\n\t\t    s->used,\n\t\t    s->next_unused,\n\t\t    s->self,\n\t\t    s,\n\t\t    s->chanid,\n\t\t    (long)s->pid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"session_by_pid: unknown pid %ld\"",
            "(long)pid"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"session_by_pid: pid %ld\"",
            "(long)pid"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nstatic Session *\nsession_by_pid(pid_t pid)\n{\n\tint i;\n\tdebug(\"session_by_pid: pid %ld\", (long)pid);\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->pid == pid)\n\t\t\treturn s;\n\t}\n\terror(\"session_by_pid: unknown pid %ld\", (long)pid);\n\tsession_dump();\n\treturn NULL;\n}"
  },
  {
    "function_name": "session_by_x11_channel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1867-1888",
    "snippet": "static Session *\nsession_by_x11_channel(int id)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\n\t\tif (s->x11_chanids == NULL || !s->used)\n\t\t\tcontinue;\n\t\tfor (j = 0; s->x11_chanids[j] != -1; j++) {\n\t\t\tif (s->x11_chanids[j] == id) {\n\t\t\t\tdebug(\"session_by_x11_channel: session %d \"\n\t\t\t\t    \"channel %d\", s->self, id);\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t}\n\tdebug(\"session_by_x11_channel: unknown channel %d\", id);\n\tsession_dump();\n\treturn NULL;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "static int sessions_nalloc = 0;",
      "static Session *sessions = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "session_dump",
          "args": [],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "session_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1798-1814",
          "snippet": "static void\nsession_dump(void)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\n\t\tdebug(\"dump: used %d next_unused %d session %d %p \"\n\t\t    \"channel %d pid %ld\",\n\t\t    s->used,\n\t\t    s->next_unused,\n\t\t    s->self,\n\t\t    s,\n\t\t    s->chanid,\n\t\t    (long)s->pid);\n\t}\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "static int sessions_nalloc = 0;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nstatic void\nsession_dump(void)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\n\t\tdebug(\"dump: used %d next_unused %d session %d %p \"\n\t\t    \"channel %d pid %ld\",\n\t\t    s->used,\n\t\t    s->next_unused,\n\t\t    s->self,\n\t\t    s,\n\t\t    s->chanid,\n\t\t    (long)s->pid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"session_by_x11_channel: unknown channel %d\"",
            "id"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nstatic Session *\nsession_by_x11_channel(int id)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\n\t\tif (s->x11_chanids == NULL || !s->used)\n\t\t\tcontinue;\n\t\tfor (j = 0; s->x11_chanids[j] != -1; j++) {\n\t\t\tif (s->x11_chanids[j] == id) {\n\t\t\t\tdebug(\"session_by_x11_channel: session %d \"\n\t\t\t\t    \"channel %d\", s->self, id);\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t}\n\tdebug(\"session_by_x11_channel: unknown channel %d\", id);\n\tsession_dump();\n\treturn NULL;\n}"
  },
  {
    "function_name": "session_by_channel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1850-1865",
    "snippet": "static Session *\nsession_by_channel(int id)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->chanid == id) {\n\t\t\tdebug(\"session_by_channel: session %d channel %d\",\n\t\t\t    i, id);\n\t\t\treturn s;\n\t\t}\n\t}\n\tdebug(\"session_by_channel: unknown channel %d\", id);\n\tsession_dump();\n\treturn NULL;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "static int sessions_nalloc = 0;",
      "static Session *sessions = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "session_dump",
          "args": [],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "session_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1798-1814",
          "snippet": "static void\nsession_dump(void)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\n\t\tdebug(\"dump: used %d next_unused %d session %d %p \"\n\t\t    \"channel %d pid %ld\",\n\t\t    s->used,\n\t\t    s->next_unused,\n\t\t    s->self,\n\t\t    s,\n\t\t    s->chanid,\n\t\t    (long)s->pid);\n\t}\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "static int sessions_nalloc = 0;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nstatic void\nsession_dump(void)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\n\t\tdebug(\"dump: used %d next_unused %d session %d %p \"\n\t\t    \"channel %d pid %ld\",\n\t\t    s->used,\n\t\t    s->next_unused,\n\t\t    s->self,\n\t\t    s,\n\t\t    s->chanid,\n\t\t    (long)s->pid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"session_by_channel: unknown channel %d\"",
            "id"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nstatic Session *\nsession_by_channel(int id)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->chanid == id) {\n\t\t\tdebug(\"session_by_channel: session %d channel %d\",\n\t\t\t    i, id);\n\t\t\treturn s;\n\t\t}\n\t}\n\tdebug(\"session_by_channel: unknown channel %d\", id);\n\tsession_dump();\n\treturn NULL;\n}"
  },
  {
    "function_name": "session_by_tty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1834-1848",
    "snippet": "Session *\nsession_by_tty(char *tty)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->ttyfd != -1 && strcmp(s->tty, tty) == 0) {\n\t\t\tdebug(\"session_by_tty: session %d tty %s\", i, tty);\n\t\t\treturn s;\n\t\t}\n\t}\n\tdebug(\"session_by_tty: unknown tty %.100s\", tty);\n\tsession_dump();\n\treturn NULL;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "static int sessions_nalloc = 0;",
      "static Session *sessions = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "session_dump",
          "args": [],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "session_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1798-1814",
          "snippet": "static void\nsession_dump(void)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\n\t\tdebug(\"dump: used %d next_unused %d session %d %p \"\n\t\t    \"channel %d pid %ld\",\n\t\t    s->used,\n\t\t    s->next_unused,\n\t\t    s->self,\n\t\t    s,\n\t\t    s->chanid,\n\t\t    (long)s->pid);\n\t}\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "static int sessions_nalloc = 0;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nstatic void\nsession_dump(void)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\n\t\tdebug(\"dump: used %d next_unused %d session %d %p \"\n\t\t    \"channel %d pid %ld\",\n\t\t    s->used,\n\t\t    s->next_unused,\n\t\t    s->self,\n\t\t    s,\n\t\t    s->chanid,\n\t\t    (long)s->pid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"session_by_tty: unknown tty %.100s\"",
            "tty"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s->tty",
            "tty"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nSession *\nsession_by_tty(char *tty)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->ttyfd != -1 && strcmp(s->tty, tty) == 0) {\n\t\t\tdebug(\"session_by_tty: session %d tty %s\", i, tty);\n\t\t\treturn s;\n\t\t}\n\t}\n\tdebug(\"session_by_tty: unknown tty %.100s\", tty);\n\tsession_dump();\n\treturn NULL;\n}"
  },
  {
    "function_name": "session_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1816-1832",
    "snippet": "int\nsession_open(Authctxt *authctxt, int chanid)\n{\n\tSession *s = session_new();\n\tdebug(\"session_open: channel %d\", chanid);\n\tif (s == NULL) {\n\t\terror(\"no more sessions\");\n\t\treturn 0;\n\t}\n\ts->authctxt = authctxt;\n\ts->pw = authctxt->pw;\n\tif (s->pw == NULL || !authctxt->valid)\n\t\tfatal(\"no user for session %d\", s->self);\n\tdebug(\"session_open: session %d: link with channel %d\", s->self, chanid);\n\ts->chanid = chanid;\n\treturn 1;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Session *session_new(void);",
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static void do_authenticated2(struct ssh *, Authctxt *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "static Session *sessions = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"session_open: session %d: link with channel %d\"",
            "s->self",
            "chanid"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"no user for session %d\"",
            "s->self"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"no more sessions\""
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_new",
          "args": [],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "session_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1757-1796",
          "snippet": "Session *\nsession_new(void)\n{\n\tSession *s, *tmp;\n\n\tif (sessions_first_unused == -1) {\n\t\tif (sessions_nalloc >= options.max_sessions)\n\t\t\treturn NULL;\n\t\tdebug2(\"%s: allocate (allocated %d max %d)\",\n\t\t    __func__, sessions_nalloc, options.max_sessions);\n\t\ttmp = xrecallocarray(sessions, sessions_nalloc,\n\t\t    sessions_nalloc + 1, sizeof(*sessions));\n\t\tif (tmp == NULL) {\n\t\t\terror(\"%s: cannot allocate %d sessions\",\n\t\t\t    __func__, sessions_nalloc + 1);\n\t\t\treturn NULL;\n\t\t}\n\t\tsessions = tmp;\n\t\tsession_unused(sessions_nalloc++);\n\t}\n\n\tif (sessions_first_unused >= sessions_nalloc ||\n\t    sessions_first_unused < 0) {\n\t\tfatal(\"%s: insane first_unused %d max %d nalloc %d\",\n\t\t    __func__, sessions_first_unused, options.max_sessions,\n\t\t    sessions_nalloc);\n\t}\n\n\ts = &sessions[sessions_first_unused];\n\tif (s->used) {\n\t\tfatal(\"%s: session %d already used\",\n\t\t    __func__, sessions_first_unused);\n\t}\n\tsessions_first_unused = s->next_unused;\n\ts->used = 1;\n\ts->next_unused = -1;\n\tdebug(\"session_new: session %d\", s->self);\n\n\treturn s;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Session *session_new(void);",
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "extern ServerOptions options;",
            "static int sessions_first_unused = -1;",
            "static int sessions_nalloc = 0;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nSession *session_new(void);\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nstatic int sessions_first_unused = -1;\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nSession *\nsession_new(void)\n{\n\tSession *s, *tmp;\n\n\tif (sessions_first_unused == -1) {\n\t\tif (sessions_nalloc >= options.max_sessions)\n\t\t\treturn NULL;\n\t\tdebug2(\"%s: allocate (allocated %d max %d)\",\n\t\t    __func__, sessions_nalloc, options.max_sessions);\n\t\ttmp = xrecallocarray(sessions, sessions_nalloc,\n\t\t    sessions_nalloc + 1, sizeof(*sessions));\n\t\tif (tmp == NULL) {\n\t\t\terror(\"%s: cannot allocate %d sessions\",\n\t\t\t    __func__, sessions_nalloc + 1);\n\t\t\treturn NULL;\n\t\t}\n\t\tsessions = tmp;\n\t\tsession_unused(sessions_nalloc++);\n\t}\n\n\tif (sessions_first_unused >= sessions_nalloc ||\n\t    sessions_first_unused < 0) {\n\t\tfatal(\"%s: insane first_unused %d max %d nalloc %d\",\n\t\t    __func__, sessions_first_unused, options.max_sessions,\n\t\t    sessions_nalloc);\n\t}\n\n\ts = &sessions[sessions_first_unused];\n\tif (s->used) {\n\t\tfatal(\"%s: session %d already used\",\n\t\t    __func__, sessions_first_unused);\n\t}\n\tsessions_first_unused = s->next_unused;\n\ts->used = 1;\n\ts->next_unused = -1;\n\tdebug(\"session_new: session %d\", s->self);\n\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nSession *session_new(void);\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic void do_authenticated2(struct ssh *, Authctxt *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic Session *sessions = NULL;\n\nint\nsession_open(Authctxt *authctxt, int chanid)\n{\n\tSession *s = session_new();\n\tdebug(\"session_open: channel %d\", chanid);\n\tif (s == NULL) {\n\t\terror(\"no more sessions\");\n\t\treturn 0;\n\t}\n\ts->authctxt = authctxt;\n\ts->pw = authctxt->pw;\n\tif (s->pw == NULL || !authctxt->valid)\n\t\tfatal(\"no user for session %d\", s->self);\n\tdebug(\"session_open: session %d: link with channel %d\", s->self, chanid);\n\ts->chanid = chanid;\n\treturn 1;\n}"
  },
  {
    "function_name": "session_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1798-1814",
    "snippet": "static void\nsession_dump(void)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\n\t\tdebug(\"dump: used %d next_unused %d session %d %p \"\n\t\t    \"channel %d pid %ld\",\n\t\t    s->used,\n\t\t    s->next_unused,\n\t\t    s->self,\n\t\t    s,\n\t\t    s->chanid,\n\t\t    (long)s->pid);\n\t}\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "static int sessions_nalloc = 0;",
      "static Session *sessions = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"dump: used %d next_unused %d session %d %p \"\n\t\t    \"channel %d pid %ld\"",
            "s->used",
            "s->next_unused",
            "s->self",
            "s",
            "s->chanid",
            "(long)s->pid"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nstatic void\nsession_dump(void)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\n\t\tdebug(\"dump: used %d next_unused %d session %d %p \"\n\t\t    \"channel %d pid %ld\",\n\t\t    s->used,\n\t\t    s->next_unused,\n\t\t    s->self,\n\t\t    s,\n\t\t    s->chanid,\n\t\t    (long)s->pid);\n\t}\n}"
  },
  {
    "function_name": "session_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1757-1796",
    "snippet": "Session *\nsession_new(void)\n{\n\tSession *s, *tmp;\n\n\tif (sessions_first_unused == -1) {\n\t\tif (sessions_nalloc >= options.max_sessions)\n\t\t\treturn NULL;\n\t\tdebug2(\"%s: allocate (allocated %d max %d)\",\n\t\t    __func__, sessions_nalloc, options.max_sessions);\n\t\ttmp = xrecallocarray(sessions, sessions_nalloc,\n\t\t    sessions_nalloc + 1, sizeof(*sessions));\n\t\tif (tmp == NULL) {\n\t\t\terror(\"%s: cannot allocate %d sessions\",\n\t\t\t    __func__, sessions_nalloc + 1);\n\t\t\treturn NULL;\n\t\t}\n\t\tsessions = tmp;\n\t\tsession_unused(sessions_nalloc++);\n\t}\n\n\tif (sessions_first_unused >= sessions_nalloc ||\n\t    sessions_first_unused < 0) {\n\t\tfatal(\"%s: insane first_unused %d max %d nalloc %d\",\n\t\t    __func__, sessions_first_unused, options.max_sessions,\n\t\t    sessions_nalloc);\n\t}\n\n\ts = &sessions[sessions_first_unused];\n\tif (s->used) {\n\t\tfatal(\"%s: session %d already used\",\n\t\t    __func__, sessions_first_unused);\n\t}\n\tsessions_first_unused = s->next_unused;\n\ts->used = 1;\n\ts->next_unused = -1;\n\tdebug(\"session_new: session %d\", s->self);\n\n\treturn s;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Session *session_new(void);",
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "extern ServerOptions options;",
      "static int sessions_first_unused = -1;",
      "static int sessions_nalloc = 0;",
      "static Session *sessions = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"session_new: session %d\"",
            "s->self"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: session %d already used\"",
            "__func__",
            "sessions_first_unused"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_unused",
          "args": [
            "sessions_nalloc++"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "session_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1736-1755",
          "snippet": "void\nsession_unused(int id)\n{\n\tdebug3(\"%s: session id %d unused\", __func__, id);\n\tif (id >= options.max_sessions ||\n\t    id >= sessions_nalloc) {\n\t\tfatal(\"%s: insane session id %d (max %d nalloc %d)\",\n\t\t    __func__, id, options.max_sessions, sessions_nalloc);\n\t}\n\tmemset(&sessions[id], 0, sizeof(*sessions));\n\tsessions[id].self = id;\n\tsessions[id].used = 0;\n\tsessions[id].chanid = -1;\n\tsessions[id].ptyfd = -1;\n\tsessions[id].ttyfd = -1;\n\tsessions[id].ptymaster = -1;\n\tsessions[id].x11_chanids = NULL;\n\tsessions[id].next_unused = sessions_first_unused;\n\tsessions_first_unused = id;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "static int sessions_first_unused = -1;",
            "static int sessions_nalloc = 0;",
            "static Session *sessions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nstatic int sessions_first_unused = -1;\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nvoid\nsession_unused(int id)\n{\n\tdebug3(\"%s: session id %d unused\", __func__, id);\n\tif (id >= options.max_sessions ||\n\t    id >= sessions_nalloc) {\n\t\tfatal(\"%s: insane session id %d (max %d nalloc %d)\",\n\t\t    __func__, id, options.max_sessions, sessions_nalloc);\n\t}\n\tmemset(&sessions[id], 0, sizeof(*sessions));\n\tsessions[id].self = id;\n\tsessions[id].used = 0;\n\tsessions[id].chanid = -1;\n\tsessions[id].ptyfd = -1;\n\tsessions[id].ttyfd = -1;\n\tsessions[id].ptymaster = -1;\n\tsessions[id].x11_chanids = NULL;\n\tsessions[id].next_unused = sessions_first_unused;\n\tsessions_first_unused = id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: cannot allocate %d sessions\"",
            "__func__",
            "sessions_nalloc + 1"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xrecallocarray",
          "args": [
            "sessions",
            "sessions_nalloc",
            "sessions_nalloc + 1",
            "sizeof(*sessions)"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: allocate (allocated %d max %d)\"",
            "__func__",
            "sessions_nalloc",
            "options.max_sessions"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nSession *session_new(void);\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nstatic int sessions_first_unused = -1;\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nSession *\nsession_new(void)\n{\n\tSession *s, *tmp;\n\n\tif (sessions_first_unused == -1) {\n\t\tif (sessions_nalloc >= options.max_sessions)\n\t\t\treturn NULL;\n\t\tdebug2(\"%s: allocate (allocated %d max %d)\",\n\t\t    __func__, sessions_nalloc, options.max_sessions);\n\t\ttmp = xrecallocarray(sessions, sessions_nalloc,\n\t\t    sessions_nalloc + 1, sizeof(*sessions));\n\t\tif (tmp == NULL) {\n\t\t\terror(\"%s: cannot allocate %d sessions\",\n\t\t\t    __func__, sessions_nalloc + 1);\n\t\t\treturn NULL;\n\t\t}\n\t\tsessions = tmp;\n\t\tsession_unused(sessions_nalloc++);\n\t}\n\n\tif (sessions_first_unused >= sessions_nalloc ||\n\t    sessions_first_unused < 0) {\n\t\tfatal(\"%s: insane first_unused %d max %d nalloc %d\",\n\t\t    __func__, sessions_first_unused, options.max_sessions,\n\t\t    sessions_nalloc);\n\t}\n\n\ts = &sessions[sessions_first_unused];\n\tif (s->used) {\n\t\tfatal(\"%s: session %d already used\",\n\t\t    __func__, sessions_first_unused);\n\t}\n\tsessions_first_unused = s->next_unused;\n\ts->used = 1;\n\ts->next_unused = -1;\n\tdebug(\"session_new: session %d\", s->self);\n\n\treturn s;\n}"
  },
  {
    "function_name": "session_unused",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1736-1755",
    "snippet": "void\nsession_unused(int id)\n{\n\tdebug3(\"%s: session id %d unused\", __func__, id);\n\tif (id >= options.max_sessions ||\n\t    id >= sessions_nalloc) {\n\t\tfatal(\"%s: insane session id %d (max %d nalloc %d)\",\n\t\t    __func__, id, options.max_sessions, sessions_nalloc);\n\t}\n\tmemset(&sessions[id], 0, sizeof(*sessions));\n\tsessions[id].self = id;\n\tsessions[id].used = 0;\n\tsessions[id].chanid = -1;\n\tsessions[id].ptyfd = -1;\n\tsessions[id].ttyfd = -1;\n\tsessions[id].ptymaster = -1;\n\tsessions[id].x11_chanids = NULL;\n\tsessions[id].next_unused = sessions_first_unused;\n\tsessions_first_unused = id;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "static int sessions_first_unused = -1;",
      "static int sessions_nalloc = 0;",
      "static Session *sessions = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sessions[id]",
            "0",
            "sizeof(*sessions)"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: insane session id %d (max %d nalloc %d)\"",
            "__func__",
            "id",
            "options.max_sessions",
            "sessions_nalloc"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: session id %d unused\"",
            "__func__",
            "id"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nstatic int sessions_first_unused = -1;\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\nvoid\nsession_unused(int id)\n{\n\tdebug3(\"%s: session id %d unused\", __func__, id);\n\tif (id >= options.max_sessions ||\n\t    id >= sessions_nalloc) {\n\t\tfatal(\"%s: insane session id %d (max %d nalloc %d)\",\n\t\t    __func__, id, options.max_sessions, sessions_nalloc);\n\t}\n\tmemset(&sessions[id], 0, sizeof(*sessions));\n\tsessions[id].self = id;\n\tsessions[id].used = 0;\n\tsessions[id].chanid = -1;\n\tsessions[id].ptyfd = -1;\n\tsessions[id].ttyfd = -1;\n\tsessions[id].ptymaster = -1;\n\tsessions[id].x11_chanids = NULL;\n\tsessions[id].next_unused = sessions_first_unused;\n\tsessions_first_unused = id;\n}"
  },
  {
    "function_name": "do_child",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1534-1734",
    "snippet": "void\ndo_child(struct ssh *ssh, Session *s, const char *command)\n{\n\textern char **environ;\n\tchar **env;\n\tchar *argv[ARGV_MAX];\n\tconst char *shell, *shell0;\n\tstruct passwd *pw = s->pw;\n\tint r = 0;\n\n\t/* remove hostkey from the child's memory */\n\tdestroy_sensitive_data();\n\tpacket_clear_keys();\n\n\t/* Force a password change */\n\tif (s->authctxt->force_pwchange) {\n\t\tdo_setusercontext(pw);\n\t\tchild_close_fds(ssh);\n\t\tdo_pwchange(s);\n\t\texit(1);\n\t}\n\n\t/*\n\t * Login(1) does this as well, and it needs uid 0 for the \"-h\"\n\t * switch, so we let login(1) to this for us.\n\t */\n#ifdef HAVE_OSF_SIA\n\tsession_setup_sia(pw, s->ttyfd == -1 ? NULL : s->tty);\n\tif (!check_quietlogin(s, command))\n\t\tdo_motd();\n#else /* HAVE_OSF_SIA */\n\t/* When PAM is enabled we rely on it to do the nologin check */\n\tif (!options.use_pam)\n\t\tdo_nologin(pw);\n\tdo_setusercontext(pw);\n\t/*\n\t * PAM session modules in do_setusercontext may have\n\t * generated messages, so if this in an interactive\n\t * login then display them too.\n\t */\n\tif (!check_quietlogin(s, command))\n\t\tdisplay_loginmsg();\n#endif /* HAVE_OSF_SIA */\n\n#ifdef USE_PAM\n\tif (options.use_pam && !is_pam_session_open()) {\n\t\tdebug3(\"PAM session not opened, exiting\");\n\t\tdisplay_loginmsg();\n\t\texit(254);\n\t}\n#endif\n\n\t/*\n\t * Get the shell from the password data.  An empty shell field is\n\t * legal, and means /bin/sh.\n\t */\n\tshell = (pw->pw_shell[0] == '\\0') ? _PATH_BSHELL : pw->pw_shell;\n\n\t/*\n\t * Make sure $SHELL points to the shell from the password file,\n\t * even if shell is overridden from login.conf\n\t */\n\tenv = do_setup_env(ssh, s, shell);\n\n#ifdef HAVE_LOGIN_CAP\n\tshell = login_getcapstr(lc, \"shell\", (char *)shell, (char *)shell);\n#endif\n\n\t/*\n\t * Close the connection descriptors; note that this is the child, and\n\t * the server will still have the socket open, and it is important\n\t * that we do not shutdown it.  Note that the descriptors cannot be\n\t * closed before building the environment, as we call\n\t * ssh_remote_ipaddr there.\n\t */\n\tchild_close_fds(ssh);\n\n\t/*\n\t * Must take new environment into use so that .ssh/rc,\n\t * /etc/ssh/sshrc and xauth are run in the proper environment.\n\t */\n\tenviron = env;\n\n#if defined(KRB5) && defined(USE_AFS)\n\t/*\n\t * At this point, we check to see if AFS is active and if we have\n\t * a valid Kerberos 5 TGT. If so, it seems like a good idea to see\n\t * if we can (and need to) extend the ticket into an AFS token. If\n\t * we don't do this, we run into potential problems if the user's\n\t * home directory is in AFS and it's not world-readable.\n\t */\n\n\tif (options.kerberos_get_afs_token && k_hasafs() &&\n\t    (s->authctxt->krb5_ctx != NULL)) {\n\t\tchar cell[64];\n\n\t\tdebug(\"Getting AFS token\");\n\n\t\tk_setpag();\n\n\t\tif (k_afs_cell_of_file(pw->pw_dir, cell, sizeof(cell)) == 0)\n\t\t\tkrb5_afslog(s->authctxt->krb5_ctx,\n\t\t\t    s->authctxt->krb5_fwd_ccache, cell, NULL);\n\n\t\tkrb5_afslog_home(s->authctxt->krb5_ctx,\n\t\t    s->authctxt->krb5_fwd_ccache, NULL, NULL, pw->pw_dir);\n\t}\n#endif\n\n\t/* Change current directory to the user's home directory. */\n\tif (chdir(pw->pw_dir) < 0) {\n\t\t/* Suppress missing homedir warning for chroot case */\n#ifdef HAVE_LOGIN_CAP\n\t\tr = login_getcapbool(lc, \"requirehome\", 0);\n#endif\n\t\tif (r || !in_chroot) {\n\t\t\tfprintf(stderr, \"Could not chdir to home \"\n\t\t\t    \"directory %s: %s\\n\", pw->pw_dir,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tif (r)\n\t\t\texit(1);\n\t}\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tdo_rc_files(ssh, s, shell);\n\n\t/* restore SIGPIPE for child */\n\tsignal(SIGPIPE, SIG_DFL);\n\n\tif (s->is_subsystem == SUBSYSTEM_INT_SFTP_ERROR) {\n\t\tprintf(\"This service allows sftp connections only.\\n\");\n\t\tfflush(NULL);\n\t\texit(1);\n\t} else if (s->is_subsystem == SUBSYSTEM_INT_SFTP) {\n\t\textern int optind, optreset;\n\t\tint i;\n\t\tchar *p, *args;\n\n\t\tsetproctitle(\"%s@%s\", s->pw->pw_name, INTERNAL_SFTP_NAME);\n\t\targs = xstrdup(command ? command : \"sftp-server\");\n\t\tfor (i = 0, (p = strtok(args, \" \")); p; (p = strtok(NULL, \" \")))\n\t\t\tif (i < ARGV_MAX - 1)\n\t\t\t\targv[i++] = p;\n\t\targv[i] = NULL;\n\t\toptind = optreset = 1;\n\t\t__progname = argv[0];\n#ifdef WITH_SELINUX\n\t\tssh_selinux_change_context(\"sftpd_t\");\n#endif\n\t\texit(sftp_server_main(i, argv, s->pw));\n\t}\n\n\tfflush(NULL);\n\n\t/* Get the last component of the shell name. */\n\tif ((shell0 = strrchr(shell, '/')) != NULL)\n\t\tshell0++;\n\telse\n\t\tshell0 = shell;\n\n\t/*\n\t * If we have no command, execute the shell.  In this case, the shell\n\t * name to be passed in argv[0] is preceded by '-' to indicate that\n\t * this is a login shell.\n\t */\n\tif (!command) {\n\t\tchar argv0[256];\n\n\t\t/* Start the shell.  Set initial character to '-'. */\n\t\targv0[0] = '-';\n\n\t\tif (strlcpy(argv0 + 1, shell0, sizeof(argv0) - 1)\n\t\t    >= sizeof(argv0) - 1) {\n\t\t\terrno = EINVAL;\n\t\t\tperror(shell);\n\t\t\texit(1);\n\t\t}\n\n\t\t/* Execute the shell. */\n\t\targv[0] = argv0;\n\t\targv[1] = NULL;\n\t\texecve(shell, argv, env);\n\n\t\t/* Executing the shell failed. */\n\t\tperror(shell);\n\t\texit(1);\n\t}\n\t/*\n\t * Execute the command using the user's shell.  This uses the -c\n\t * option to execute the command.\n\t */\n\targv[0] = (char *) shell0;\n\targv[1] = \"-c\";\n\targv[2] = (char *) command;\n\targv[3] = NULL;\n\texecve(shell, argv, env);\n\tperror(shell);\n\texit(1);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define ARGV_MAX 10",
      "#define SUBSYSTEM_INT_SFTP_ERROR\t3",
      "#define SUBSYSTEM_INT_SFTP\t\t2"
    ],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "void\tdo_motd(void);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "extern ServerOptions options;",
      "extern char *__progname;",
      "extern void destroy_sensitive_data(void);",
      "static int in_chroot = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "shell"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execve",
          "args": [
            "shell",
            "argv",
            "env"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "shell"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execve",
          "args": [
            "shell",
            "argv",
            "env"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "shell"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "argv0 + 1",
            "shell0",
            "sizeof(argv0) - 1"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "shell",
            "'/'"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "NULL"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "_ssh_compat_fflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "314-326",
          "snippet": "int _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sftp_server_main",
          "args": [
            "i",
            "argv",
            "s->pw"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_main",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1499-1710",
          "snippet": "int\nsftp_server_main(int argc, char **argv, struct passwd *user_pw)\n{\n\tfd_set *rset, *wset;\n\tint i, r, in, out, max, ch, skipargs = 0, log_stderr = 0;\n\tssize_t len, olen, set_size;\n\tSyslogFacility log_facility = SYSLOG_FACILITY_AUTH;\n\tchar *cp, *homedir = NULL, uidstr[32], buf[4*4096];\n\tlong mask;\n\n\textern char *optarg;\n\textern char *__progname;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t__progname = ssh_get_progname(argv[0]);\n\tlog_init(__progname, log_level, log_facility, log_stderr);\n\n\tpw = pwcopy(user_pw);\n\n\twhile (!skipargs && (ch = getopt(argc, argv,\n\t    \"d:f:l:P:p:Q:u:cehR\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'Q':\n\t\t\tif (strcasecmp(optarg, \"requests\") != 0) {\n\t\t\t\tfprintf(stderr, \"Invalid query type\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfor (i = 0; handlers[i].handler != NULL; i++)\n\t\t\t\tprintf(\"%s\\n\", handlers[i].name);\n\t\t\tfor (i = 0; extended_handlers[i].handler != NULL; i++)\n\t\t\t\tprintf(\"%s\\n\", extended_handlers[i].name);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\treadonly = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\t/*\n\t\t\t * Ignore all arguments if we are invoked as a\n\t\t\t * shell using \"sftp-server -c command\"\n\t\t\t */\n\t\t\tskipargs = 1;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tlog_stderr = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlog_level = log_level_number(optarg);\n\t\t\tif (log_level == SYSLOG_LEVEL_NOT_SET)\n\t\t\t\terror(\"Invalid log level \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tlog_facility = log_facility_number(optarg);\n\t\t\tif (log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\t\t\terror(\"Invalid log facility \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tcp = tilde_expand_filename(optarg, user_pw->pw_uid);\n\t\t\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t\t\t    (unsigned long long)pw->pw_uid);\n\t\t\thomedir = percent_expand(cp, \"d\", user_pw->pw_dir,\n\t\t\t    \"u\", user_pw->pw_name, \"U\", uidstr, (char *)NULL);\n\t\t\tfree(cp);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (request_whitelist != NULL)\n\t\t\t\tfatal(\"Permitted requests already set\");\n\t\t\trequest_whitelist = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (request_blacklist != NULL)\n\t\t\t\tfatal(\"Refused requests already set\");\n\t\t\trequest_blacklist = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\terrno = 0;\n\t\t\tmask = strtol(optarg, &cp, 8);\n\t\t\tif (mask < 0 || mask > 0777 || *cp != '\\0' ||\n\t\t\t    cp == optarg || (mask == 0 && errno != 0))\n\t\t\t\tfatal(\"Invalid umask \\\"%s\\\"\", optarg);\n\t\t\t(void)umask((mode_t)mask);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tsftp_server_usage();\n\t\t}\n\t}\n\n\tlog_init(__progname, log_level, log_facility, log_stderr);\n\n\t/*\n\t * On platforms where we can, avoid making /proc/self/{mem,maps}\n\t * available to the user so that sftp access doesn't automatically\n\t * imply arbitrary code execution access that will break\n\t * restricted configurations.\n\t */\n\tplatform_disable_tracing(1);\t/* strict */\n\n\t/* Drop any fine-grained privileges we don't need */\n\tplatform_pledge_sftp_server();\n\n\tif ((cp = getenv(\"SSH_CONNECTION\")) != NULL) {\n\t\tclient_addr = xstrdup(cp);\n\t\tif ((cp = strchr(client_addr, ' ')) == NULL) {\n\t\t\terror(\"Malformed SSH_CONNECTION variable: \\\"%s\\\"\",\n\t\t\t    getenv(\"SSH_CONNECTION\"));\n\t\t\tsftp_server_cleanup_exit(255);\n\t\t}\n\t\t*cp = '\\0';\n\t} else\n\t\tclient_addr = xstrdup(\"UNKNOWN\");\n\n\tlogit(\"session opened for local user %s from [%s]\",\n\t    pw->pw_name, client_addr);\n\n\tin = STDIN_FILENO;\n\tout = STDOUT_FILENO;\n\n#ifdef HAVE_CYGWIN\n\tsetmode(in, O_BINARY);\n\tsetmode(out, O_BINARY);\n#endif\n\n\tmax = 0;\n\tif (in > max)\n\t\tmax = in;\n\tif (out > max)\n\t\tmax = out;\n\n\tif ((iqueue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((oqueue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\trset = xcalloc(howmany(max + 1, NFDBITS), sizeof(fd_mask));\n\twset = xcalloc(howmany(max + 1, NFDBITS), sizeof(fd_mask));\n\n\tif (homedir != NULL) {\n\t\tif (chdir(homedir) != 0) {\n\t\t\terror(\"chdir to \\\"%s\\\" failed: %s\", homedir,\n\t\t\t    strerror(errno));\n\t\t}\n\t}\n\n\tset_size = howmany(max + 1, NFDBITS) * sizeof(fd_mask);\n\tfor (;;) {\n\t\tmemset(rset, 0, set_size);\n\t\tmemset(wset, 0, set_size);\n\n\t\t/*\n\t\t * Ensure that we can read a full buffer and handle\n\t\t * the worst-case length packet it can generate,\n\t\t * otherwise apply backpressure by stopping reads.\n\t\t */\n\t\tif ((r = sshbuf_check_reserve(iqueue, sizeof(buf))) == 0 &&\n\t\t    (r = sshbuf_check_reserve(oqueue,\n\t\t    SFTP_MAX_MSG_LENGTH)) == 0)\n\t\t\tFD_SET(in, rset);\n\t\telse if (r != SSH_ERR_NO_BUFFER_SPACE)\n\t\t\tfatal(\"%s: sshbuf_check_reserve failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n\n\t\tolen = sshbuf_len(oqueue);\n\t\tif (olen > 0)\n\t\t\tFD_SET(out, wset);\n\n\t\tif (select(max+1, rset, wset, NULL, NULL) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\terror(\"select: %s\", strerror(errno));\n\t\t\tsftp_server_cleanup_exit(2);\n\t\t}\n\n\t\t/* copy stdin to iqueue */\n\t\tif (FD_ISSET(in, rset)) {\n\t\t\tlen = read(in, buf, sizeof buf);\n\t\t\tif (len == 0) {\n\t\t\t\tdebug(\"read eof\");\n\t\t\t\tsftp_server_cleanup_exit(0);\n\t\t\t} else if (len < 0) {\n\t\t\t\terror(\"read: %s\", strerror(errno));\n\t\t\t\tsftp_server_cleanup_exit(1);\n\t\t\t} else if ((r = sshbuf_put(iqueue, buf, len)) != 0) {\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t}\n\t\t/* send oqueue to stdout */\n\t\tif (FD_ISSET(out, wset)) {\n\t\t\tlen = write(out, sshbuf_ptr(oqueue), olen);\n\t\t\tif (len < 0) {\n\t\t\t\terror(\"write: %s\", strerror(errno));\n\t\t\t\tsftp_server_cleanup_exit(1);\n\t\t\t} else if ((r = sshbuf_consume(oqueue, len)) != 0) {\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Process requests from client if we can fit the results\n\t\t * into the output buffer, otherwise stop processing input\n\t\t * and let the output queue drain.\n\t\t */\n\t\tr = sshbuf_check_reserve(oqueue, SFTP_MAX_MSG_LENGTH);\n\t\tif (r == 0)\n\t\t\tprocess();\n\t\telse if (r != SSH_ERR_NO_BUFFER_SPACE)\n\t\t\tfatal(\"%s: sshbuf_check_reserve: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LogLevel log_level = SYSLOG_LEVEL_ERROR;",
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;",
            "struct sshbuf *iqueue;",
            "struct sshbuf *oqueue;",
            "static int readonly;",
            "static char *request_whitelist, *request_blacklist;",
            "struct sftp_handler handlers[] = {\n\t/* NB. SSH2_FXP_OPEN does the readonly check in the handler itself */\n\t{ \"open\", NULL, SSH2_FXP_OPEN, process_open, 0 },\n\t{ \"close\", NULL, SSH2_FXP_CLOSE, process_close, 0 },\n\t{ \"read\", NULL, SSH2_FXP_READ, process_read, 0 },\n\t{ \"write\", NULL, SSH2_FXP_WRITE, process_write, 1 },\n\t{ \"lstat\", NULL, SSH2_FXP_LSTAT, process_lstat, 0 },\n\t{ \"fstat\", NULL, SSH2_FXP_FSTAT, process_fstat, 0 },\n\t{ \"setstat\", NULL, SSH2_FXP_SETSTAT, process_setstat, 1 },\n\t{ \"fsetstat\", NULL, SSH2_FXP_FSETSTAT, process_fsetstat, 1 },\n\t{ \"opendir\", NULL, SSH2_FXP_OPENDIR, process_opendir, 0 },\n\t{ \"readdir\", NULL, SSH2_FXP_READDIR, process_readdir, 0 },\n\t{ \"remove\", NULL, SSH2_FXP_REMOVE, process_remove, 1 },\n\t{ \"mkdir\", NULL, SSH2_FXP_MKDIR, process_mkdir, 1 },\n\t{ \"rmdir\", NULL, SSH2_FXP_RMDIR, process_rmdir, 1 },\n\t{ \"realpath\", NULL, SSH2_FXP_REALPATH, process_realpath, 0 },\n\t{ \"stat\", NULL, SSH2_FXP_STAT, process_stat, 0 },\n\t{ \"rename\", NULL, SSH2_FXP_RENAME, process_rename, 1 },\n\t{ \"readlink\", NULL, SSH2_FXP_READLINK, process_readlink, 0 },\n\t{ \"symlink\", NULL, SSH2_FXP_SYMLINK, process_symlink, 1 },\n\t{ NULL, NULL, 0, NULL, 0 }\n};",
            "struct sftp_handler extended_handlers[] = {\n\t{ \"posix-rename\", \"posix-rename@openssh.com\", 0,\n\t   process_extended_posix_rename, 1 },\n\t{ \"statvfs\", \"statvfs@openssh.com\", 0, process_extended_statvfs, 0 },\n\t{ \"fstatvfs\", \"fstatvfs@openssh.com\", 0, process_extended_fstatvfs, 0 },\n\t{ \"hardlink\", \"hardlink@openssh.com\", 0, process_extended_hardlink, 1 },\n\t{ \"fsync\", \"fsync@openssh.com\", 0, process_extended_fsync, 1 },\n\t{ NULL, NULL, 0, NULL, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic LogLevel log_level = SYSLOG_LEVEL_ERROR;\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\nstruct sshbuf *iqueue;\nstruct sshbuf *oqueue;\nstatic int readonly;\nstatic char *request_whitelist, *request_blacklist;\nstruct sftp_handler handlers[] = {\n\t/* NB. SSH2_FXP_OPEN does the readonly check in the handler itself */\n\t{ \"open\", NULL, SSH2_FXP_OPEN, process_open, 0 },\n\t{ \"close\", NULL, SSH2_FXP_CLOSE, process_close, 0 },\n\t{ \"read\", NULL, SSH2_FXP_READ, process_read, 0 },\n\t{ \"write\", NULL, SSH2_FXP_WRITE, process_write, 1 },\n\t{ \"lstat\", NULL, SSH2_FXP_LSTAT, process_lstat, 0 },\n\t{ \"fstat\", NULL, SSH2_FXP_FSTAT, process_fstat, 0 },\n\t{ \"setstat\", NULL, SSH2_FXP_SETSTAT, process_setstat, 1 },\n\t{ \"fsetstat\", NULL, SSH2_FXP_FSETSTAT, process_fsetstat, 1 },\n\t{ \"opendir\", NULL, SSH2_FXP_OPENDIR, process_opendir, 0 },\n\t{ \"readdir\", NULL, SSH2_FXP_READDIR, process_readdir, 0 },\n\t{ \"remove\", NULL, SSH2_FXP_REMOVE, process_remove, 1 },\n\t{ \"mkdir\", NULL, SSH2_FXP_MKDIR, process_mkdir, 1 },\n\t{ \"rmdir\", NULL, SSH2_FXP_RMDIR, process_rmdir, 1 },\n\t{ \"realpath\", NULL, SSH2_FXP_REALPATH, process_realpath, 0 },\n\t{ \"stat\", NULL, SSH2_FXP_STAT, process_stat, 0 },\n\t{ \"rename\", NULL, SSH2_FXP_RENAME, process_rename, 1 },\n\t{ \"readlink\", NULL, SSH2_FXP_READLINK, process_readlink, 0 },\n\t{ \"symlink\", NULL, SSH2_FXP_SYMLINK, process_symlink, 1 },\n\t{ NULL, NULL, 0, NULL, 0 }\n};\nstruct sftp_handler extended_handlers[] = {\n\t{ \"posix-rename\", \"posix-rename@openssh.com\", 0,\n\t   process_extended_posix_rename, 1 },\n\t{ \"statvfs\", \"statvfs@openssh.com\", 0, process_extended_statvfs, 0 },\n\t{ \"fstatvfs\", \"fstatvfs@openssh.com\", 0, process_extended_fstatvfs, 0 },\n\t{ \"hardlink\", \"hardlink@openssh.com\", 0, process_extended_hardlink, 1 },\n\t{ \"fsync\", \"fsync@openssh.com\", 0, process_extended_fsync, 1 },\n\t{ NULL, NULL, 0, NULL, 0 }\n};\n\nint\nsftp_server_main(int argc, char **argv, struct passwd *user_pw)\n{\n\tfd_set *rset, *wset;\n\tint i, r, in, out, max, ch, skipargs = 0, log_stderr = 0;\n\tssize_t len, olen, set_size;\n\tSyslogFacility log_facility = SYSLOG_FACILITY_AUTH;\n\tchar *cp, *homedir = NULL, uidstr[32], buf[4*4096];\n\tlong mask;\n\n\textern char *optarg;\n\textern char *__progname;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t__progname = ssh_get_progname(argv[0]);\n\tlog_init(__progname, log_level, log_facility, log_stderr);\n\n\tpw = pwcopy(user_pw);\n\n\twhile (!skipargs && (ch = getopt(argc, argv,\n\t    \"d:f:l:P:p:Q:u:cehR\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'Q':\n\t\t\tif (strcasecmp(optarg, \"requests\") != 0) {\n\t\t\t\tfprintf(stderr, \"Invalid query type\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfor (i = 0; handlers[i].handler != NULL; i++)\n\t\t\t\tprintf(\"%s\\n\", handlers[i].name);\n\t\t\tfor (i = 0; extended_handlers[i].handler != NULL; i++)\n\t\t\t\tprintf(\"%s\\n\", extended_handlers[i].name);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\treadonly = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\t/*\n\t\t\t * Ignore all arguments if we are invoked as a\n\t\t\t * shell using \"sftp-server -c command\"\n\t\t\t */\n\t\t\tskipargs = 1;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tlog_stderr = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlog_level = log_level_number(optarg);\n\t\t\tif (log_level == SYSLOG_LEVEL_NOT_SET)\n\t\t\t\terror(\"Invalid log level \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tlog_facility = log_facility_number(optarg);\n\t\t\tif (log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\t\t\terror(\"Invalid log facility \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tcp = tilde_expand_filename(optarg, user_pw->pw_uid);\n\t\t\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t\t\t    (unsigned long long)pw->pw_uid);\n\t\t\thomedir = percent_expand(cp, \"d\", user_pw->pw_dir,\n\t\t\t    \"u\", user_pw->pw_name, \"U\", uidstr, (char *)NULL);\n\t\t\tfree(cp);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (request_whitelist != NULL)\n\t\t\t\tfatal(\"Permitted requests already set\");\n\t\t\trequest_whitelist = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (request_blacklist != NULL)\n\t\t\t\tfatal(\"Refused requests already set\");\n\t\t\trequest_blacklist = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\terrno = 0;\n\t\t\tmask = strtol(optarg, &cp, 8);\n\t\t\tif (mask < 0 || mask > 0777 || *cp != '\\0' ||\n\t\t\t    cp == optarg || (mask == 0 && errno != 0))\n\t\t\t\tfatal(\"Invalid umask \\\"%s\\\"\", optarg);\n\t\t\t(void)umask((mode_t)mask);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tsftp_server_usage();\n\t\t}\n\t}\n\n\tlog_init(__progname, log_level, log_facility, log_stderr);\n\n\t/*\n\t * On platforms where we can, avoid making /proc/self/{mem,maps}\n\t * available to the user so that sftp access doesn't automatically\n\t * imply arbitrary code execution access that will break\n\t * restricted configurations.\n\t */\n\tplatform_disable_tracing(1);\t/* strict */\n\n\t/* Drop any fine-grained privileges we don't need */\n\tplatform_pledge_sftp_server();\n\n\tif ((cp = getenv(\"SSH_CONNECTION\")) != NULL) {\n\t\tclient_addr = xstrdup(cp);\n\t\tif ((cp = strchr(client_addr, ' ')) == NULL) {\n\t\t\terror(\"Malformed SSH_CONNECTION variable: \\\"%s\\\"\",\n\t\t\t    getenv(\"SSH_CONNECTION\"));\n\t\t\tsftp_server_cleanup_exit(255);\n\t\t}\n\t\t*cp = '\\0';\n\t} else\n\t\tclient_addr = xstrdup(\"UNKNOWN\");\n\n\tlogit(\"session opened for local user %s from [%s]\",\n\t    pw->pw_name, client_addr);\n\n\tin = STDIN_FILENO;\n\tout = STDOUT_FILENO;\n\n#ifdef HAVE_CYGWIN\n\tsetmode(in, O_BINARY);\n\tsetmode(out, O_BINARY);\n#endif\n\n\tmax = 0;\n\tif (in > max)\n\t\tmax = in;\n\tif (out > max)\n\t\tmax = out;\n\n\tif ((iqueue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((oqueue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\trset = xcalloc(howmany(max + 1, NFDBITS), sizeof(fd_mask));\n\twset = xcalloc(howmany(max + 1, NFDBITS), sizeof(fd_mask));\n\n\tif (homedir != NULL) {\n\t\tif (chdir(homedir) != 0) {\n\t\t\terror(\"chdir to \\\"%s\\\" failed: %s\", homedir,\n\t\t\t    strerror(errno));\n\t\t}\n\t}\n\n\tset_size = howmany(max + 1, NFDBITS) * sizeof(fd_mask);\n\tfor (;;) {\n\t\tmemset(rset, 0, set_size);\n\t\tmemset(wset, 0, set_size);\n\n\t\t/*\n\t\t * Ensure that we can read a full buffer and handle\n\t\t * the worst-case length packet it can generate,\n\t\t * otherwise apply backpressure by stopping reads.\n\t\t */\n\t\tif ((r = sshbuf_check_reserve(iqueue, sizeof(buf))) == 0 &&\n\t\t    (r = sshbuf_check_reserve(oqueue,\n\t\t    SFTP_MAX_MSG_LENGTH)) == 0)\n\t\t\tFD_SET(in, rset);\n\t\telse if (r != SSH_ERR_NO_BUFFER_SPACE)\n\t\t\tfatal(\"%s: sshbuf_check_reserve failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n\n\t\tolen = sshbuf_len(oqueue);\n\t\tif (olen > 0)\n\t\t\tFD_SET(out, wset);\n\n\t\tif (select(max+1, rset, wset, NULL, NULL) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\terror(\"select: %s\", strerror(errno));\n\t\t\tsftp_server_cleanup_exit(2);\n\t\t}\n\n\t\t/* copy stdin to iqueue */\n\t\tif (FD_ISSET(in, rset)) {\n\t\t\tlen = read(in, buf, sizeof buf);\n\t\t\tif (len == 0) {\n\t\t\t\tdebug(\"read eof\");\n\t\t\t\tsftp_server_cleanup_exit(0);\n\t\t\t} else if (len < 0) {\n\t\t\t\terror(\"read: %s\", strerror(errno));\n\t\t\t\tsftp_server_cleanup_exit(1);\n\t\t\t} else if ((r = sshbuf_put(iqueue, buf, len)) != 0) {\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t}\n\t\t/* send oqueue to stdout */\n\t\tif (FD_ISSET(out, wset)) {\n\t\t\tlen = write(out, sshbuf_ptr(oqueue), olen);\n\t\t\tif (len < 0) {\n\t\t\t\terror(\"write: %s\", strerror(errno));\n\t\t\t\tsftp_server_cleanup_exit(1);\n\t\t\t} else if ((r = sshbuf_consume(oqueue, len)) != 0) {\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Process requests from client if we can fit the results\n\t\t * into the output buffer, otherwise stop processing input\n\t\t * and let the output queue drain.\n\t\t */\n\t\tr = sshbuf_check_reserve(oqueue, SFTP_MAX_MSG_LENGTH);\n\t\tif (r == 0)\n\t\t\tprocess();\n\t\telse if (r != SSH_ERR_NO_BUFFER_SPACE)\n\t\t\tfatal(\"%s: sshbuf_check_reserve: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_selinux_change_context",
          "args": [
            "\"sftpd_t\""
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_selinux_change_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-linux.c",
          "lines": "180-222",
          "snippet": "void\nssh_selinux_change_context(const char *newname)\n{\n\tint len, newlen;\n\tchar *oldctx, *newctx, *cx;\n\tvoid (*switchlog) (const char *fmt,...) = logit;\n\n\tif (!ssh_selinux_enabled())\n\t\treturn;\n\n\tif (getcon((security_context_t *)&oldctx) < 0) {\n\t\tlogit(\"%s: getcon failed with %s\", __func__, strerror(errno));\n\t\treturn;\n\t}\n\tif ((cx = index(oldctx, ':')) == NULL || (cx = index(cx + 1, ':')) ==\n\t    NULL) {\n\t\tlogit (\"%s: unparseable context %s\", __func__, oldctx);\n\t\treturn;\n\t}\n\n\t/*\n\t * Check whether we are attempting to switch away from an unconfined\n\t * security context.\n\t */\n\tif (strncmp(cx, SSH_SELINUX_UNCONFINED_TYPE,\n\t    sizeof(SSH_SELINUX_UNCONFINED_TYPE) - 1) == 0)\n\t\tswitchlog = debug3;\n\n\tnewlen = strlen(oldctx) + strlen(newname) + 1;\n\tnewctx = xmalloc(newlen);\n\tlen = cx - oldctx + 1;\n\tmemcpy(newctx, oldctx, len);\n\tstrlcpy(newctx + len, newname, newlen - len);\n\tif ((cx = index(cx + 1, ':')))\n\t\tstrlcat(newctx, cx, newlen);\n\tdebug3(\"%s: setting context from '%s' to '%s'\", __func__,\n\t    oldctx, newctx);\n\tif (setcon(newctx) < 0)\n\t\tswitchlog(\"%s: setcon %s from %s failed with %s\", __func__,\n\t\t    newctx, oldctx, strerror(errno));\n\tfree(oldctx);\n\tfree(newctx);\n}",
          "includes": [
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"port-linux.h\"",
            "#include \"xmalloc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"port-linux.h\"\n#include \"xmalloc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nssh_selinux_change_context(const char *newname)\n{\n\tint len, newlen;\n\tchar *oldctx, *newctx, *cx;\n\tvoid (*switchlog) (const char *fmt,...) = logit;\n\n\tif (!ssh_selinux_enabled())\n\t\treturn;\n\n\tif (getcon((security_context_t *)&oldctx) < 0) {\n\t\tlogit(\"%s: getcon failed with %s\", __func__, strerror(errno));\n\t\treturn;\n\t}\n\tif ((cx = index(oldctx, ':')) == NULL || (cx = index(cx + 1, ':')) ==\n\t    NULL) {\n\t\tlogit (\"%s: unparseable context %s\", __func__, oldctx);\n\t\treturn;\n\t}\n\n\t/*\n\t * Check whether we are attempting to switch away from an unconfined\n\t * security context.\n\t */\n\tif (strncmp(cx, SSH_SELINUX_UNCONFINED_TYPE,\n\t    sizeof(SSH_SELINUX_UNCONFINED_TYPE) - 1) == 0)\n\t\tswitchlog = debug3;\n\n\tnewlen = strlen(oldctx) + strlen(newname) + 1;\n\tnewctx = xmalloc(newlen);\n\tlen = cx - oldctx + 1;\n\tmemcpy(newctx, oldctx, len);\n\tstrlcpy(newctx + len, newname, newlen - len);\n\tif ((cx = index(cx + 1, ':')))\n\t\tstrlcat(newctx, cx, newlen);\n\tdebug3(\"%s: setting context from '%s' to '%s'\", __func__,\n\t    oldctx, newctx);\n\tif (setcon(newctx) < 0)\n\t\tswitchlog(\"%s: setcon %s from %s failed with %s\", __func__,\n\t\t    newctx, oldctx, strerror(errno));\n\tfree(oldctx);\n\tfree(newctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\" \""
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "args",
            "\" \""
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "command ? command : \"sftp-server\""
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setproctitle",
          "args": [
            "\"%s@%s\"",
            "s->pw->pw_name",
            "INTERNAL_SFTP_NAME"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "setproctitle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/setproctitle.c",
          "lines": "122-167",
          "snippet": "void\nsetproctitle(const char *fmt, ...)\n{\n#if SPT_TYPE != SPT_NONE\n\tva_list ap;\n\tchar buf[1024], ptitle[1024];\n\tsize_t len = 0;\n\tint r;\n\textern char *__progname;\n#if SPT_TYPE == SPT_PSTAT\n\tunion pstun pst;\n#endif\n\n#if SPT_TYPE == SPT_REUSEARGV\n\tif (argv_env_len <= 0)\n\t\treturn;\n#endif\n\n\tstrlcpy(buf, __progname, sizeof(buf));\n\n\tr = -1;\n\tva_start(ap, fmt);\n\tif (fmt != NULL) {\n\t\tlen = strlcat(buf, \": \", sizeof(buf));\n\t\tif (len < sizeof(buf))\n\t\t\tr = vsnprintf(buf + len, sizeof(buf) - len , fmt, ap);\n\t}\n\tva_end(ap);\n\tif (r == -1 || (size_t)r >= sizeof(buf) - len)\n\t\treturn;\n\tstrnvis(ptitle, buf, sizeof(ptitle),\n\t    VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL);\n\n#if SPT_TYPE == SPT_PSTAT\n\tpst.pst_command = ptitle;\n\tpstat(PSTAT_SETCMD, pst, strlen(ptitle), 0, 0);\n#elif SPT_TYPE == SPT_REUSEARGV\n/*\tdebug(\"setproctitle: copy \\\"%s\\\" into len %d\",\n\t    buf, argv_env_len); */\n\tlen = strlcpy(argv_start, ptitle, argv_env_len);\n\tfor(; len < argv_env_len; len++)\n\t\targv_start[len] = SPT_PADCHAR;\n#endif\n\n#endif /* SPT_NONE */\n}",
          "includes": [
            "#include <vis.h>",
            "#include <string.h>",
            "#include <sys/pstat.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SPT_REUSEARGV\t2\t/* cover argv with title information */",
            "#define SPT_PSTAT\t1\t/* use pstat(PSTAT_SETCMD, ...) */",
            "#define SPT_NONE\t0\t/* don't use it at all */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vis.h>\n#include <string.h>\n#include <sys/pstat.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\n#define SPT_REUSEARGV\t2\t/* cover argv with title information */\n#define SPT_PSTAT\t1\t/* use pstat(PSTAT_SETCMD, ...) */\n#define SPT_NONE\t0\t/* don't use it at all */\n\nvoid\nsetproctitle(const char *fmt, ...)\n{\n#if SPT_TYPE != SPT_NONE\n\tva_list ap;\n\tchar buf[1024], ptitle[1024];\n\tsize_t len = 0;\n\tint r;\n\textern char *__progname;\n#if SPT_TYPE == SPT_PSTAT\n\tunion pstun pst;\n#endif\n\n#if SPT_TYPE == SPT_REUSEARGV\n\tif (argv_env_len <= 0)\n\t\treturn;\n#endif\n\n\tstrlcpy(buf, __progname, sizeof(buf));\n\n\tr = -1;\n\tva_start(ap, fmt);\n\tif (fmt != NULL) {\n\t\tlen = strlcat(buf, \": \", sizeof(buf));\n\t\tif (len < sizeof(buf))\n\t\t\tr = vsnprintf(buf + len, sizeof(buf) - len , fmt, ap);\n\t}\n\tva_end(ap);\n\tif (r == -1 || (size_t)r >= sizeof(buf) - len)\n\t\treturn;\n\tstrnvis(ptitle, buf, sizeof(ptitle),\n\t    VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL);\n\n#if SPT_TYPE == SPT_PSTAT\n\tpst.pst_command = ptitle;\n\tpstat(PSTAT_SETCMD, pst, strlen(ptitle), 0, 0);\n#elif SPT_TYPE == SPT_REUSEARGV\n/*\tdebug(\"setproctitle: copy \\\"%s\\\" into len %d\",\n\t    buf, argv_env_len); */\n\tlen = strlcpy(argv_start, ptitle, argv_env_len);\n\tfor(; len < argv_env_len; len++)\n\t\targv_start[len] = SPT_PADCHAR;\n#endif\n\n#endif /* SPT_NONE */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"This service allows sftp connections only.\\n\""
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGPIPE",
            "SIG_DFL"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_rc_files",
          "args": [
            "ssh",
            "s",
            "shell"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "do_rc_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1225-1292",
          "snippet": "static void\ndo_rc_files(struct ssh *ssh, Session *s, const char *shell)\n{\n\tFILE *f = NULL;\n\tchar cmd[1024];\n\tint do_xauth;\n\tstruct stat st;\n\n\tdo_xauth =\n\t    s->display != NULL && s->auth_proto != NULL && s->auth_data != NULL;\n\n\t/* ignore _PATH_SSH_USER_RC for subsystems and admin forced commands */\n\tif (!s->is_subsystem && options.adm_forced_command == NULL &&\n\t    auth_opts->permit_user_rc && options.permit_user_rc &&\n\t    stat(_PATH_SSH_USER_RC, &st) >= 0) {\n\t\tsnprintf(cmd, sizeof cmd, \"%s -c '%s %s'\",\n\t\t    shell, _PATH_BSHELL, _PATH_SSH_USER_RC);\n\t\tif (debug_flag)\n\t\t\tfprintf(stderr, \"Running %s\\n\", cmd);\n\t\tf = popen(cmd, \"w\");\n\t\tif (f) {\n\t\t\tif (do_xauth)\n\t\t\t\tfprintf(f, \"%s %s\\n\", s->auth_proto,\n\t\t\t\t    s->auth_data);\n\t\t\tpclose(f);\n\t\t} else\n\t\t\tfprintf(stderr, \"Could not run %s\\n\",\n\t\t\t    _PATH_SSH_USER_RC);\n\t} else if (stat(_PATH_SSH_SYSTEM_RC, &st) >= 0) {\n\t\tif (debug_flag)\n\t\t\tfprintf(stderr, \"Running %s %s\\n\", _PATH_BSHELL,\n\t\t\t    _PATH_SSH_SYSTEM_RC);\n\t\tf = popen(_PATH_BSHELL \" \" _PATH_SSH_SYSTEM_RC, \"w\");\n\t\tif (f) {\n\t\t\tif (do_xauth)\n\t\t\t\tfprintf(f, \"%s %s\\n\", s->auth_proto,\n\t\t\t\t    s->auth_data);\n\t\t\tpclose(f);\n\t\t} else\n\t\t\tfprintf(stderr, \"Could not run %s\\n\",\n\t\t\t    _PATH_SSH_SYSTEM_RC);\n\t} else if (do_xauth && options.xauth_location != NULL) {\n\t\t/* Add authority data to .Xauthority if appropriate. */\n\t\tif (debug_flag) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"Running %.500s remove %.100s\\n\",\n\t\t\t    options.xauth_location, s->auth_display);\n\t\t\tfprintf(stderr,\n\t\t\t    \"%.500s add %.100s %.100s %.100s\\n\",\n\t\t\t    options.xauth_location, s->auth_display,\n\t\t\t    s->auth_proto, s->auth_data);\n\t\t}\n\t\tsnprintf(cmd, sizeof cmd, \"%s -q -\",\n\t\t    options.xauth_location);\n\t\tf = popen(cmd, \"w\");\n\t\tif (f) {\n\t\t\tfprintf(f, \"remove %s\\n\",\n\t\t\t    s->auth_display);\n\t\t\tfprintf(f, \"add %s %s %s\\n\",\n\t\t\t    s->auth_display, s->auth_proto,\n\t\t\t    s->auth_data);\n\t\t\tpclose(f);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Could not run %s\\n\",\n\t\t\t    cmd);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "extern ServerOptions options;",
            "extern int debug_flag;",
            "extern struct sshauthopt *auth_opts;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern int debug_flag;\nextern struct sshauthopt *auth_opts;\n\nstatic void\ndo_rc_files(struct ssh *ssh, Session *s, const char *shell)\n{\n\tFILE *f = NULL;\n\tchar cmd[1024];\n\tint do_xauth;\n\tstruct stat st;\n\n\tdo_xauth =\n\t    s->display != NULL && s->auth_proto != NULL && s->auth_data != NULL;\n\n\t/* ignore _PATH_SSH_USER_RC for subsystems and admin forced commands */\n\tif (!s->is_subsystem && options.adm_forced_command == NULL &&\n\t    auth_opts->permit_user_rc && options.permit_user_rc &&\n\t    stat(_PATH_SSH_USER_RC, &st) >= 0) {\n\t\tsnprintf(cmd, sizeof cmd, \"%s -c '%s %s'\",\n\t\t    shell, _PATH_BSHELL, _PATH_SSH_USER_RC);\n\t\tif (debug_flag)\n\t\t\tfprintf(stderr, \"Running %s\\n\", cmd);\n\t\tf = popen(cmd, \"w\");\n\t\tif (f) {\n\t\t\tif (do_xauth)\n\t\t\t\tfprintf(f, \"%s %s\\n\", s->auth_proto,\n\t\t\t\t    s->auth_data);\n\t\t\tpclose(f);\n\t\t} else\n\t\t\tfprintf(stderr, \"Could not run %s\\n\",\n\t\t\t    _PATH_SSH_USER_RC);\n\t} else if (stat(_PATH_SSH_SYSTEM_RC, &st) >= 0) {\n\t\tif (debug_flag)\n\t\t\tfprintf(stderr, \"Running %s %s\\n\", _PATH_BSHELL,\n\t\t\t    _PATH_SSH_SYSTEM_RC);\n\t\tf = popen(_PATH_BSHELL \" \" _PATH_SSH_SYSTEM_RC, \"w\");\n\t\tif (f) {\n\t\t\tif (do_xauth)\n\t\t\t\tfprintf(f, \"%s %s\\n\", s->auth_proto,\n\t\t\t\t    s->auth_data);\n\t\t\tpclose(f);\n\t\t} else\n\t\t\tfprintf(stderr, \"Could not run %s\\n\",\n\t\t\t    _PATH_SSH_SYSTEM_RC);\n\t} else if (do_xauth && options.xauth_location != NULL) {\n\t\t/* Add authority data to .Xauthority if appropriate. */\n\t\tif (debug_flag) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"Running %.500s remove %.100s\\n\",\n\t\t\t    options.xauth_location, s->auth_display);\n\t\t\tfprintf(stderr,\n\t\t\t    \"%.500s add %.100s %.100s %.100s\\n\",\n\t\t\t    options.xauth_location, s->auth_display,\n\t\t\t    s->auth_proto, s->auth_data);\n\t\t}\n\t\tsnprintf(cmd, sizeof cmd, \"%s -q -\",\n\t\t    options.xauth_location);\n\t\tf = popen(cmd, \"w\");\n\t\tif (f) {\n\t\t\tfprintf(f, \"remove %s\\n\",\n\t\t\t    s->auth_display);\n\t\t\tfprintf(f, \"add %s %s %s\\n\",\n\t\t\t    s->auth_display, s->auth_proto,\n\t\t\t    s->auth_data);\n\t\t\tpclose(f);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Could not run %s\\n\",\n\t\t\t    cmd);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "closefrom",
          "args": [
            "STDERR_FILENO + 1"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not chdir to home \"\n\t\t\t    \"directory %s: %s\\n\"",
            "pw->pw_dir",
            "strerror(errno)"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "login_getcapbool",
          "args": [
            "lc",
            "\"requirehome\"",
            "0"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "pw->pw_dir"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_afslog_home",
          "args": [
            "s->authctxt->krb5_ctx",
            "s->authctxt->krb5_fwd_ccache",
            "NULL",
            "NULL",
            "pw->pw_dir"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_afslog",
          "args": [
            "s->authctxt->krb5_ctx",
            "s->authctxt->krb5_fwd_ccache",
            "cell",
            "NULL"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_afs_cell_of_file",
          "args": [
            "pw->pw_dir",
            "cell",
            "sizeof(cell)"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_setpag",
          "args": [],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Getting AFS token\""
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "k_hasafs",
          "args": [],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "child_close_fds",
          "args": [
            "ssh"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "child_close_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1490-1526",
          "snippet": "static void\nchild_close_fds(struct ssh *ssh)\n{\n\textern int auth_sock;\n\n\tif (auth_sock != -1) {\n\t\tclose(auth_sock);\n\t\tauth_sock = -1;\n\t}\n\n\tif (packet_get_connection_in() == packet_get_connection_out())\n\t\tclose(packet_get_connection_in());\n\telse {\n\t\tclose(packet_get_connection_in());\n\t\tclose(packet_get_connection_out());\n\t}\n\t/*\n\t * Close all descriptors related to channels.  They will still remain\n\t * open in the parent.\n\t */\n\t/* XXX better use close-on-exec? -markus */\n\tchannel_close_all(ssh);\n\n\t/*\n\t * Close any extra file descriptors.  Note that there may still be\n\t * descriptors left by system functions.  They will be closed later.\n\t */\n\tendpwent();\n\n\t/*\n\t * Close any extra open file descriptors so that we don't have them\n\t * hanging around in clients.  Note that we want to do this after\n\t * initgroups, because at least on Solaris 2.3 it leaves file\n\t * descriptors open.\n\t */\n\tclosefrom(STDERR_FILENO + 1);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nchild_close_fds(struct ssh *ssh)\n{\n\textern int auth_sock;\n\n\tif (auth_sock != -1) {\n\t\tclose(auth_sock);\n\t\tauth_sock = -1;\n\t}\n\n\tif (packet_get_connection_in() == packet_get_connection_out())\n\t\tclose(packet_get_connection_in());\n\telse {\n\t\tclose(packet_get_connection_in());\n\t\tclose(packet_get_connection_out());\n\t}\n\t/*\n\t * Close all descriptors related to channels.  They will still remain\n\t * open in the parent.\n\t */\n\t/* XXX better use close-on-exec? -markus */\n\tchannel_close_all(ssh);\n\n\t/*\n\t * Close any extra file descriptors.  Note that there may still be\n\t * descriptors left by system functions.  They will be closed later.\n\t */\n\tendpwent();\n\n\t/*\n\t * Close any extra open file descriptors so that we don't have them\n\t * hanging around in clients.  Note that we want to do this after\n\t * initgroups, because at least on Solaris 2.3 it leaves file\n\t * descriptors open.\n\t */\n\tclosefrom(STDERR_FILENO + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "login_getcapstr",
          "args": [
            "lc",
            "\"shell\"",
            "(char *)shell",
            "(char *)shell"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_setup_env",
          "args": [
            "ssh",
            "s",
            "shell"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "do_setup_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1013-1219",
          "snippet": "static char **\ndo_setup_env(struct ssh *ssh, Session *s, const char *shell)\n{\n\tchar buf[256];\n\tsize_t n;\n\tu_int i, envsize;\n\tchar *ocp, *cp, *value, **env, *laddr;\n\tstruct passwd *pw = s->pw;\n#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)\n\tchar *path = NULL;\n#endif\n\n\t/* Initialize the environment. */\n\tenvsize = 100;\n\tenv = xcalloc(envsize, sizeof(char *));\n\tenv[0] = NULL;\n\n#ifdef HAVE_CYGWIN\n\t/*\n\t * The Windows environment contains some setting which are\n\t * important for a running system. They must not be dropped.\n\t */\n\t{\n\t\tchar **p;\n\n\t\tp = fetch_windows_environment();\n\t\tcopy_environment(p, &env, &envsize);\n\t\tfree_windows_environment(p);\n\t}\n#endif\n\n#ifdef GSSAPI\n\t/* Allow any GSSAPI methods that we've used to alter\n\t * the childs environment as they see fit\n\t */\n\tssh_gssapi_do_child(&env, &envsize);\n#endif\n\n\t/* Set basic environment. */\n\tfor (i = 0; i < s->num_env; i++)\n\t\tchild_set_env(&env, &envsize, s->env[i].name, s->env[i].val);\n\n\tchild_set_env(&env, &envsize, \"USER\", pw->pw_name);\n\tchild_set_env(&env, &envsize, \"LOGNAME\", pw->pw_name);\n#ifdef _AIX\n\tchild_set_env(&env, &envsize, \"LOGIN\", pw->pw_name);\n#endif\n\tchild_set_env(&env, &envsize, \"HOME\", pw->pw_dir);\n#ifdef HAVE_LOGIN_CAP\n\tif (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)\n\t\tchild_set_env(&env, &envsize, \"PATH\", _PATH_STDPATH);\n\telse\n\t\tchild_set_env(&env, &envsize, \"PATH\", getenv(\"PATH\"));\n#else /* HAVE_LOGIN_CAP */\n# ifndef HAVE_CYGWIN\n\t/*\n\t * There's no standard path on Windows. The path contains\n\t * important components pointing to the system directories,\n\t * needed for loading shared libraries. So the path better\n\t * remains intact here.\n\t */\n#  ifdef HAVE_ETC_DEFAULT_LOGIN\n\tread_etc_default_login(&env, &envsize, pw->pw_uid);\n\tpath = child_get_env(env, \"PATH\");\n#  endif /* HAVE_ETC_DEFAULT_LOGIN */\n\tif (path == NULL || *path == '\\0') {\n\t\tchild_set_env(&env, &envsize, \"PATH\",\n\t\t    s->pw->pw_uid == 0 ?  SUPERUSER_PATH : _PATH_STDPATH);\n\t}\n# endif /* HAVE_CYGWIN */\n#endif /* HAVE_LOGIN_CAP */\n\n\tsnprintf(buf, sizeof buf, \"%.200s/%.50s\", _PATH_MAILDIR, pw->pw_name);\n\tchild_set_env(&env, &envsize, \"MAIL\", buf);\n\n\t/* Normal systems set SHELL by default. */\n\tchild_set_env(&env, &envsize, \"SHELL\", shell);\n\n\tif (getenv(\"TZ\"))\n\t\tchild_set_env(&env, &envsize, \"TZ\", getenv(\"TZ\"));\n\tif (s->term)\n\t\tchild_set_env(&env, &envsize, \"TERM\", s->term);\n\tif (s->display)\n\t\tchild_set_env(&env, &envsize, \"DISPLAY\", s->display);\n\n\t/*\n\t * Since we clear KRB5CCNAME at startup, if it's set now then it\n\t * must have been set by a native authentication method (eg AIX or\n\t * SIA), so copy it to the child.\n\t */\n\t{\n\t\tchar *cp;\n\n\t\tif ((cp = getenv(\"KRB5CCNAME\")) != NULL)\n\t\t\tchild_set_env(&env, &envsize, \"KRB5CCNAME\", cp);\n\t}\n\n#ifdef _AIX\n\t{\n\t\tchar *cp;\n\n\t\tif ((cp = getenv(\"AUTHSTATE\")) != NULL)\n\t\t\tchild_set_env(&env, &envsize, \"AUTHSTATE\", cp);\n\t\tread_environment_file(&env, &envsize, \"/etc/environment\",\n\t\t    options.permit_user_env_whitelist);\n\t}\n#endif\n#ifdef KRB5\n\tif (s->authctxt->krb5_ccname)\n\t\tchild_set_env(&env, &envsize, \"KRB5CCNAME\",\n\t\t    s->authctxt->krb5_ccname);\n#endif\n\tif (auth_sock_name != NULL)\n\t\tchild_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,\n\t\t    auth_sock_name);\n\n\n\t/* Set custom environment options from pubkey authentication. */\n\tif (options.permit_user_env) {\n\t\tfor (n = 0 ; n < auth_opts->nenv; n++) {\n\t\t\tocp = xstrdup(auth_opts->env[n]);\n\t\t\tcp = strchr(ocp, '=');\n\t\t\tif (*cp == '=') {\n\t\t\t\t*cp = '\\0';\n\t\t\t\t/* Apply PermitUserEnvironment whitelist */\n\t\t\t\tif (options.permit_user_env_whitelist == NULL ||\n\t\t\t\t    match_pattern_list(ocp,\n\t\t\t\t    options.permit_user_env_whitelist, 0) == 1)\n\t\t\t\t\tchild_set_env(&env, &envsize,\n\t\t\t\t\t    ocp, cp + 1);\n\t\t\t}\n\t\t\tfree(ocp);\n\t\t}\n\t}\n\n\t/* read $HOME/.ssh/environment. */\n\tif (options.permit_user_env) {\n\t\tsnprintf(buf, sizeof buf, \"%.200s/.ssh/environment\",\n\t\t    pw->pw_dir);\n\t\tread_environment_file(&env, &envsize, buf,\n\t\t    options.permit_user_env_whitelist);\n\t}\n\n#ifdef USE_PAM\n\t/*\n\t * Pull in any environment variables that may have\n\t * been set by PAM.\n\t */\n\tif (options.use_pam) {\n\t\tchar **p;\n\n\t\t/*\n\t\t * Don't allow SSH_AUTH_INFO variables posted to PAM to leak\n\t\t * back into the environment.\n\t\t */\n\t\tp = fetch_pam_child_environment();\n\t\tcopy_environment_blacklist(p, &env, &envsize, \"SSH_AUTH_INFO*\");\n\t\tfree_pam_environment(p);\n\n\t\tp = fetch_pam_environment();\n\t\tcopy_environment_blacklist(p, &env, &envsize, \"SSH_AUTH_INFO*\");\n\t\tfree_pam_environment(p);\n\t}\n#endif /* USE_PAM */\n\n\t/* Environment specified by admin */\n\tfor (i = 0; i < options.num_setenv; i++) {\n\t\tcp = xstrdup(options.setenv[i]);\n\t\tif ((value = strchr(cp, '=')) == NULL) {\n\t\t\t/* shouldn't happen; vars are checked in servconf.c */\n\t\t\tfatal(\"Invalid config SetEnv: %s\", options.setenv[i]);\n\t\t}\n\t\t*value++ = '\\0';\n\t\tchild_set_env(&env, &envsize, cp, value);\n\t}\n\n\t/* SSH_CLIENT deprecated */\n\tsnprintf(buf, sizeof buf, \"%.50s %d %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t    ssh_local_port(ssh));\n\tchild_set_env(&env, &envsize, \"SSH_CLIENT\", buf);\n\n\tladdr = get_local_ipaddr(packet_get_connection_in());\n\tsnprintf(buf, sizeof buf, \"%.50s %d %.50s %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t    laddr, ssh_local_port(ssh));\n\tfree(laddr);\n\tchild_set_env(&env, &envsize, \"SSH_CONNECTION\", buf);\n\n\tif (tun_fwd_ifnames != NULL)\n\t\tchild_set_env(&env, &envsize, \"SSH_TUNNEL\", tun_fwd_ifnames);\n\tif (auth_info_file != NULL)\n\t\tchild_set_env(&env, &envsize, \"SSH_USER_AUTH\", auth_info_file);\n\tif (s->ttyfd != -1)\n\t\tchild_set_env(&env, &envsize, \"SSH_TTY\", s->tty);\n\tif (original_command)\n\t\tchild_set_env(&env, &envsize, \"SSH_ORIGINAL_COMMAND\",\n\t\t    original_command);\n\n\tif (debug_flag) {\n\t\t/* dump the environment */\n\t\tfprintf(stderr, \"Environment:\\n\");\n\t\tfor (i = 0; env[i]; i++)\n\t\t\tfprintf(stderr, \"  %.200s\\n\", env[i]);\n\t}\n\treturn env;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "extern ServerOptions options;",
            "extern int debug_flag;",
            "extern struct sshauthopt *auth_opts;",
            "char *tun_fwd_ifnames;",
            "const char *original_command = NULL;",
            "static char *auth_info_file = NULL;",
            "static char *auth_sock_name = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern int debug_flag;\nextern struct sshauthopt *auth_opts;\nchar *tun_fwd_ifnames;\nconst char *original_command = NULL;\nstatic char *auth_info_file = NULL;\nstatic char *auth_sock_name = NULL;\n\nstatic char **\ndo_setup_env(struct ssh *ssh, Session *s, const char *shell)\n{\n\tchar buf[256];\n\tsize_t n;\n\tu_int i, envsize;\n\tchar *ocp, *cp, *value, **env, *laddr;\n\tstruct passwd *pw = s->pw;\n#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)\n\tchar *path = NULL;\n#endif\n\n\t/* Initialize the environment. */\n\tenvsize = 100;\n\tenv = xcalloc(envsize, sizeof(char *));\n\tenv[0] = NULL;\n\n#ifdef HAVE_CYGWIN\n\t/*\n\t * The Windows environment contains some setting which are\n\t * important for a running system. They must not be dropped.\n\t */\n\t{\n\t\tchar **p;\n\n\t\tp = fetch_windows_environment();\n\t\tcopy_environment(p, &env, &envsize);\n\t\tfree_windows_environment(p);\n\t}\n#endif\n\n#ifdef GSSAPI\n\t/* Allow any GSSAPI methods that we've used to alter\n\t * the childs environment as they see fit\n\t */\n\tssh_gssapi_do_child(&env, &envsize);\n#endif\n\n\t/* Set basic environment. */\n\tfor (i = 0; i < s->num_env; i++)\n\t\tchild_set_env(&env, &envsize, s->env[i].name, s->env[i].val);\n\n\tchild_set_env(&env, &envsize, \"USER\", pw->pw_name);\n\tchild_set_env(&env, &envsize, \"LOGNAME\", pw->pw_name);\n#ifdef _AIX\n\tchild_set_env(&env, &envsize, \"LOGIN\", pw->pw_name);\n#endif\n\tchild_set_env(&env, &envsize, \"HOME\", pw->pw_dir);\n#ifdef HAVE_LOGIN_CAP\n\tif (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)\n\t\tchild_set_env(&env, &envsize, \"PATH\", _PATH_STDPATH);\n\telse\n\t\tchild_set_env(&env, &envsize, \"PATH\", getenv(\"PATH\"));\n#else /* HAVE_LOGIN_CAP */\n# ifndef HAVE_CYGWIN\n\t/*\n\t * There's no standard path on Windows. The path contains\n\t * important components pointing to the system directories,\n\t * needed for loading shared libraries. So the path better\n\t * remains intact here.\n\t */\n#  ifdef HAVE_ETC_DEFAULT_LOGIN\n\tread_etc_default_login(&env, &envsize, pw->pw_uid);\n\tpath = child_get_env(env, \"PATH\");\n#  endif /* HAVE_ETC_DEFAULT_LOGIN */\n\tif (path == NULL || *path == '\\0') {\n\t\tchild_set_env(&env, &envsize, \"PATH\",\n\t\t    s->pw->pw_uid == 0 ?  SUPERUSER_PATH : _PATH_STDPATH);\n\t}\n# endif /* HAVE_CYGWIN */\n#endif /* HAVE_LOGIN_CAP */\n\n\tsnprintf(buf, sizeof buf, \"%.200s/%.50s\", _PATH_MAILDIR, pw->pw_name);\n\tchild_set_env(&env, &envsize, \"MAIL\", buf);\n\n\t/* Normal systems set SHELL by default. */\n\tchild_set_env(&env, &envsize, \"SHELL\", shell);\n\n\tif (getenv(\"TZ\"))\n\t\tchild_set_env(&env, &envsize, \"TZ\", getenv(\"TZ\"));\n\tif (s->term)\n\t\tchild_set_env(&env, &envsize, \"TERM\", s->term);\n\tif (s->display)\n\t\tchild_set_env(&env, &envsize, \"DISPLAY\", s->display);\n\n\t/*\n\t * Since we clear KRB5CCNAME at startup, if it's set now then it\n\t * must have been set by a native authentication method (eg AIX or\n\t * SIA), so copy it to the child.\n\t */\n\t{\n\t\tchar *cp;\n\n\t\tif ((cp = getenv(\"KRB5CCNAME\")) != NULL)\n\t\t\tchild_set_env(&env, &envsize, \"KRB5CCNAME\", cp);\n\t}\n\n#ifdef _AIX\n\t{\n\t\tchar *cp;\n\n\t\tif ((cp = getenv(\"AUTHSTATE\")) != NULL)\n\t\t\tchild_set_env(&env, &envsize, \"AUTHSTATE\", cp);\n\t\tread_environment_file(&env, &envsize, \"/etc/environment\",\n\t\t    options.permit_user_env_whitelist);\n\t}\n#endif\n#ifdef KRB5\n\tif (s->authctxt->krb5_ccname)\n\t\tchild_set_env(&env, &envsize, \"KRB5CCNAME\",\n\t\t    s->authctxt->krb5_ccname);\n#endif\n\tif (auth_sock_name != NULL)\n\t\tchild_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,\n\t\t    auth_sock_name);\n\n\n\t/* Set custom environment options from pubkey authentication. */\n\tif (options.permit_user_env) {\n\t\tfor (n = 0 ; n < auth_opts->nenv; n++) {\n\t\t\tocp = xstrdup(auth_opts->env[n]);\n\t\t\tcp = strchr(ocp, '=');\n\t\t\tif (*cp == '=') {\n\t\t\t\t*cp = '\\0';\n\t\t\t\t/* Apply PermitUserEnvironment whitelist */\n\t\t\t\tif (options.permit_user_env_whitelist == NULL ||\n\t\t\t\t    match_pattern_list(ocp,\n\t\t\t\t    options.permit_user_env_whitelist, 0) == 1)\n\t\t\t\t\tchild_set_env(&env, &envsize,\n\t\t\t\t\t    ocp, cp + 1);\n\t\t\t}\n\t\t\tfree(ocp);\n\t\t}\n\t}\n\n\t/* read $HOME/.ssh/environment. */\n\tif (options.permit_user_env) {\n\t\tsnprintf(buf, sizeof buf, \"%.200s/.ssh/environment\",\n\t\t    pw->pw_dir);\n\t\tread_environment_file(&env, &envsize, buf,\n\t\t    options.permit_user_env_whitelist);\n\t}\n\n#ifdef USE_PAM\n\t/*\n\t * Pull in any environment variables that may have\n\t * been set by PAM.\n\t */\n\tif (options.use_pam) {\n\t\tchar **p;\n\n\t\t/*\n\t\t * Don't allow SSH_AUTH_INFO variables posted to PAM to leak\n\t\t * back into the environment.\n\t\t */\n\t\tp = fetch_pam_child_environment();\n\t\tcopy_environment_blacklist(p, &env, &envsize, \"SSH_AUTH_INFO*\");\n\t\tfree_pam_environment(p);\n\n\t\tp = fetch_pam_environment();\n\t\tcopy_environment_blacklist(p, &env, &envsize, \"SSH_AUTH_INFO*\");\n\t\tfree_pam_environment(p);\n\t}\n#endif /* USE_PAM */\n\n\t/* Environment specified by admin */\n\tfor (i = 0; i < options.num_setenv; i++) {\n\t\tcp = xstrdup(options.setenv[i]);\n\t\tif ((value = strchr(cp, '=')) == NULL) {\n\t\t\t/* shouldn't happen; vars are checked in servconf.c */\n\t\t\tfatal(\"Invalid config SetEnv: %s\", options.setenv[i]);\n\t\t}\n\t\t*value++ = '\\0';\n\t\tchild_set_env(&env, &envsize, cp, value);\n\t}\n\n\t/* SSH_CLIENT deprecated */\n\tsnprintf(buf, sizeof buf, \"%.50s %d %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t    ssh_local_port(ssh));\n\tchild_set_env(&env, &envsize, \"SSH_CLIENT\", buf);\n\n\tladdr = get_local_ipaddr(packet_get_connection_in());\n\tsnprintf(buf, sizeof buf, \"%.50s %d %.50s %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t    laddr, ssh_local_port(ssh));\n\tfree(laddr);\n\tchild_set_env(&env, &envsize, \"SSH_CONNECTION\", buf);\n\n\tif (tun_fwd_ifnames != NULL)\n\t\tchild_set_env(&env, &envsize, \"SSH_TUNNEL\", tun_fwd_ifnames);\n\tif (auth_info_file != NULL)\n\t\tchild_set_env(&env, &envsize, \"SSH_USER_AUTH\", auth_info_file);\n\tif (s->ttyfd != -1)\n\t\tchild_set_env(&env, &envsize, \"SSH_TTY\", s->tty);\n\tif (original_command)\n\t\tchild_set_env(&env, &envsize, \"SSH_ORIGINAL_COMMAND\",\n\t\t    original_command);\n\n\tif (debug_flag) {\n\t\t/* dump the environment */\n\t\tfprintf(stderr, \"Environment:\\n\");\n\t\tfor (i = 0; env[i]; i++)\n\t\t\tfprintf(stderr, \"  %.200s\\n\", env[i]);\n\t}\n\treturn env;\n}"
        }
      },
      {
        "call_info": {
          "callee": "display_loginmsg",
          "args": [],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "display_loginmsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "249-260",
          "snippet": "static void\ndisplay_loginmsg(void)\n{\n\tint r;\n\n\tif (sshbuf_len(loginmsg) == 0)\n\t\treturn;\n\tif ((r = sshbuf_put_u8(loginmsg, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tprintf(\"%s\", (char *)sshbuf_ptr(loginmsg));\n\tsshbuf_reset(loginmsg);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct sshbuf *loginmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern struct sshbuf *loginmsg;\n\nstatic void\ndisplay_loginmsg(void)\n{\n\tint r;\n\n\tif (sshbuf_len(loginmsg) == 0)\n\t\treturn;\n\tif ((r = sshbuf_put_u8(loginmsg, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tprintf(\"%s\", (char *)sshbuf_ptr(loginmsg));\n\tsshbuf_reset(loginmsg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pam_session_open",
          "args": [],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "is_pam_session_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "1167-1171",
          "snippet": "int\nis_pam_session_open(void)\n{\n\treturn sshpam_session_open;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nis_pam_session_open(void)\n{\n\treturn sshpam_session_open;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_quietlogin",
          "args": [
            "s",
            "command"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "check_quietlogin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "850-869",
          "snippet": "int\ncheck_quietlogin(Session *s, const char *command)\n{\n\tchar buf[256];\n\tstruct passwd *pw = s->pw;\n\tstruct stat st;\n\n\t/* Return 1 if .hushlogin exists or a command given. */\n\tif (command != NULL)\n\t\treturn 1;\n\tsnprintf(buf, sizeof(buf), \"%.200s/.hushlogin\", pw->pw_dir);\n#ifdef HAVE_LOGIN_CAP\n\tif (login_getcapbool(lc, \"hushlogin\", 0) || stat(buf, &st) >= 0)\n\t\treturn 1;\n#else\n\tif (stat(buf, &st) >= 0)\n\t\treturn 1;\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nint\ncheck_quietlogin(Session *s, const char *command)\n{\n\tchar buf[256];\n\tstruct passwd *pw = s->pw;\n\tstruct stat st;\n\n\t/* Return 1 if .hushlogin exists or a command given. */\n\tif (command != NULL)\n\t\treturn 1;\n\tsnprintf(buf, sizeof(buf), \"%.200s/.hushlogin\", pw->pw_dir);\n#ifdef HAVE_LOGIN_CAP\n\tif (login_getcapbool(lc, \"hushlogin\", 0) || stat(buf, &st) >= 0)\n\t\treturn 1;\n#else\n\tif (stat(buf, &st) >= 0)\n\t\treturn 1;\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_setusercontext",
          "args": [
            "pw"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "do_setusercontext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1382-1463",
          "snippet": "void\ndo_setusercontext(struct passwd *pw)\n{\n\tchar uidstr[32], *chroot_path, *tmp;\n\n\tplatform_setusercontext(pw);\n\n\tif (platform_privileged_uidswap()) {\n#ifdef HAVE_LOGIN_CAP\n\t\tif (setusercontext(lc, pw, pw->pw_uid,\n\t\t    (LOGIN_SETALL & ~(LOGIN_SETPATH|LOGIN_SETUSER))) < 0) {\n\t\t\tperror(\"unable to set user context\");\n\t\t\texit(1);\n\t\t}\n#else\n\t\tif (setlogin(pw->pw_name) < 0)\n\t\t\terror(\"setlogin failed: %s\", strerror(errno));\n\t\tif (setgid(pw->pw_gid) < 0) {\n\t\t\tperror(\"setgid\");\n\t\t\texit(1);\n\t\t}\n\t\t/* Initialize the group list. */\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0) {\n\t\t\tperror(\"initgroups\");\n\t\t\texit(1);\n\t\t}\n\t\tendgrent();\n#endif\n\n\t\tplatform_setusercontext_post_groups(pw);\n\n\t\tif (!in_chroot && options.chroot_directory != NULL &&\n\t\t    strcasecmp(options.chroot_directory, \"none\") != 0) {\n                        tmp = tilde_expand_filename(options.chroot_directory,\n\t\t\t    pw->pw_uid);\n\t\t\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t\t\t    (unsigned long long)pw->pw_uid);\n\t\t\tchroot_path = percent_expand(tmp, \"h\", pw->pw_dir,\n\t\t\t    \"u\", pw->pw_name, \"U\", uidstr, (char *)NULL);\n\t\t\tsafely_chroot(chroot_path, pw->pw_uid);\n\t\t\tfree(tmp);\n\t\t\tfree(chroot_path);\n\t\t\t/* Make sure we don't attempt to chroot again */\n\t\t\tfree(options.chroot_directory);\n\t\t\toptions.chroot_directory = NULL;\n\t\t\tin_chroot = 1;\n\t\t}\n\n#ifdef HAVE_LOGIN_CAP\n\t\tif (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETUSER) < 0) {\n\t\t\tperror(\"unable to set user context (setuser)\");\n\t\t\texit(1);\n\t\t}\n\t\t/* \n\t\t * FreeBSD's setusercontext() will not apply the user's\n\t\t * own umask setting unless running with the user's UID.\n\t\t */\n\t\t(void) setusercontext(lc, pw, pw->pw_uid, LOGIN_SETUMASK);\n#else\n# ifdef USE_LIBIAF\n\t\t/*\n\t\t * In a chroot environment, the set_id() will always fail;\n\t\t * typically because of the lack of necessary authentication\n\t\t * services and runtime such as ./usr/lib/libiaf.so,\n\t\t * ./usr/lib/libpam.so.1, and ./etc/passwd We skip it in the\n\t\t * internal sftp chroot case.  We'll lose auditing and ACLs but\n\t\t * permanently_set_uid will take care of the rest.\n\t\t */\n\t\tif (!in_chroot && set_id(pw->pw_name) != 0)\n\t\t\tfatal(\"set_id(%s) Failed\", pw->pw_name);\n# endif /* USE_LIBIAF */\n\t\t/* Permanently switch to the desired uid. */\n\t\tpermanently_set_uid(pw);\n#endif\n\t} else if (options.chroot_directory != NULL &&\n\t    strcasecmp(options.chroot_directory, \"none\") != 0) {\n\t\tfatal(\"server lacks privileges to chroot to ChrootDirectory\");\n\t}\n\n\tif (getuid() != pw->pw_uid || geteuid() != pw->pw_uid)\n\t\tfatal(\"Failed to set uids to %u.\", (u_int) pw->pw_uid);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "static int in_chroot = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nstatic int in_chroot = 0;\n\nvoid\ndo_setusercontext(struct passwd *pw)\n{\n\tchar uidstr[32], *chroot_path, *tmp;\n\n\tplatform_setusercontext(pw);\n\n\tif (platform_privileged_uidswap()) {\n#ifdef HAVE_LOGIN_CAP\n\t\tif (setusercontext(lc, pw, pw->pw_uid,\n\t\t    (LOGIN_SETALL & ~(LOGIN_SETPATH|LOGIN_SETUSER))) < 0) {\n\t\t\tperror(\"unable to set user context\");\n\t\t\texit(1);\n\t\t}\n#else\n\t\tif (setlogin(pw->pw_name) < 0)\n\t\t\terror(\"setlogin failed: %s\", strerror(errno));\n\t\tif (setgid(pw->pw_gid) < 0) {\n\t\t\tperror(\"setgid\");\n\t\t\texit(1);\n\t\t}\n\t\t/* Initialize the group list. */\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0) {\n\t\t\tperror(\"initgroups\");\n\t\t\texit(1);\n\t\t}\n\t\tendgrent();\n#endif\n\n\t\tplatform_setusercontext_post_groups(pw);\n\n\t\tif (!in_chroot && options.chroot_directory != NULL &&\n\t\t    strcasecmp(options.chroot_directory, \"none\") != 0) {\n                        tmp = tilde_expand_filename(options.chroot_directory,\n\t\t\t    pw->pw_uid);\n\t\t\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t\t\t    (unsigned long long)pw->pw_uid);\n\t\t\tchroot_path = percent_expand(tmp, \"h\", pw->pw_dir,\n\t\t\t    \"u\", pw->pw_name, \"U\", uidstr, (char *)NULL);\n\t\t\tsafely_chroot(chroot_path, pw->pw_uid);\n\t\t\tfree(tmp);\n\t\t\tfree(chroot_path);\n\t\t\t/* Make sure we don't attempt to chroot again */\n\t\t\tfree(options.chroot_directory);\n\t\t\toptions.chroot_directory = NULL;\n\t\t\tin_chroot = 1;\n\t\t}\n\n#ifdef HAVE_LOGIN_CAP\n\t\tif (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETUSER) < 0) {\n\t\t\tperror(\"unable to set user context (setuser)\");\n\t\t\texit(1);\n\t\t}\n\t\t/* \n\t\t * FreeBSD's setusercontext() will not apply the user's\n\t\t * own umask setting unless running with the user's UID.\n\t\t */\n\t\t(void) setusercontext(lc, pw, pw->pw_uid, LOGIN_SETUMASK);\n#else\n# ifdef USE_LIBIAF\n\t\t/*\n\t\t * In a chroot environment, the set_id() will always fail;\n\t\t * typically because of the lack of necessary authentication\n\t\t * services and runtime such as ./usr/lib/libiaf.so,\n\t\t * ./usr/lib/libpam.so.1, and ./etc/passwd We skip it in the\n\t\t * internal sftp chroot case.  We'll lose auditing and ACLs but\n\t\t * permanently_set_uid will take care of the rest.\n\t\t */\n\t\tif (!in_chroot && set_id(pw->pw_name) != 0)\n\t\t\tfatal(\"set_id(%s) Failed\", pw->pw_name);\n# endif /* USE_LIBIAF */\n\t\t/* Permanently switch to the desired uid. */\n\t\tpermanently_set_uid(pw);\n#endif\n\t} else if (options.chroot_directory != NULL &&\n\t    strcasecmp(options.chroot_directory, \"none\") != 0) {\n\t\tfatal(\"server lacks privileges to chroot to ChrootDirectory\");\n\t}\n\n\tif (getuid() != pw->pw_uid || geteuid() != pw->pw_uid)\n\t\tfatal(\"Failed to set uids to %u.\", (u_int) pw->pw_uid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_nologin",
          "args": [
            "pw"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "do_nologin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1294-1324",
          "snippet": "static void\ndo_nologin(struct passwd *pw)\n{\n\tFILE *f = NULL;\n\tchar buf[1024], *nl, *def_nl = _PATH_NOLOGIN;\n\tstruct stat sb;\n\n#ifdef HAVE_LOGIN_CAP\n\tif (login_getcapbool(lc, \"ignorenologin\", 0) || pw->pw_uid == 0)\n\t\treturn;\n\tnl = login_getcapstr(lc, \"nologin\", def_nl, def_nl);\n#else\n\tif (pw->pw_uid == 0)\n\t\treturn;\n\tnl = def_nl;\n#endif\n\tif (stat(nl, &sb) == -1) {\n\t\tif (nl != def_nl)\n\t\t\tfree(nl);\n\t\treturn;\n\t}\n\n\t/* /etc/nologin exists.  Print its contents if we can and exit. */\n\tlogit(\"User %.100s not allowed because %s exists\", pw->pw_name, nl);\n\tif ((f = fopen(nl, \"r\")) != NULL) {\n\t\twhile (fgets(buf, sizeof(buf), f))\n\t\t\tfputs(buf, stderr);\n\t\tfclose(f);\n\t}\n\texit(254);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndo_nologin(struct passwd *pw)\n{\n\tFILE *f = NULL;\n\tchar buf[1024], *nl, *def_nl = _PATH_NOLOGIN;\n\tstruct stat sb;\n\n#ifdef HAVE_LOGIN_CAP\n\tif (login_getcapbool(lc, \"ignorenologin\", 0) || pw->pw_uid == 0)\n\t\treturn;\n\tnl = login_getcapstr(lc, \"nologin\", def_nl, def_nl);\n#else\n\tif (pw->pw_uid == 0)\n\t\treturn;\n\tnl = def_nl;\n#endif\n\tif (stat(nl, &sb) == -1) {\n\t\tif (nl != def_nl)\n\t\t\tfree(nl);\n\t\treturn;\n\t}\n\n\t/* /etc/nologin exists.  Print its contents if we can and exit. */\n\tlogit(\"User %.100s not allowed because %s exists\", pw->pw_name, nl);\n\tif ((f = fopen(nl, \"r\")) != NULL) {\n\t\twhile (fgets(buf, sizeof(buf), f))\n\t\t\tfputs(buf, stderr);\n\t\tfclose(f);\n\t}\n\texit(254);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_motd",
          "args": [],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "do_motd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "825-844",
          "snippet": "void\ndo_motd(void)\n{\n\tFILE *f;\n\tchar buf[256];\n\n\tif (options.print_motd) {\n#ifdef HAVE_LOGIN_CAP\n\t\tf = fopen(login_getcapstr(lc, \"welcome\", \"/etc/motd\",\n\t\t    \"/etc/motd\"), \"r\");\n#else\n\t\tf = fopen(\"/etc/motd\", \"r\");\n#endif\n\t\tif (f) {\n\t\t\twhile (fgets(buf, sizeof(buf), f))\n\t\t\t\tfputs(buf, stdout);\n\t\t\tfclose(f);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tdo_motd(void);",
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tdo_motd(void);\nextern ServerOptions options;\n\nvoid\ndo_motd(void)\n{\n\tFILE *f;\n\tchar buf[256];\n\n\tif (options.print_motd) {\n#ifdef HAVE_LOGIN_CAP\n\t\tf = fopen(login_getcapstr(lc, \"welcome\", \"/etc/motd\",\n\t\t    \"/etc/motd\"), \"r\");\n#else\n\t\tf = fopen(\"/etc/motd\", \"r\");\n#endif\n\t\tif (f) {\n\t\t\twhile (fgets(buf, sizeof(buf), f))\n\t\t\t\tfputs(buf, stdout);\n\t\t\tfclose(f);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_setup_sia",
          "args": [
            "pw",
            "s->ttyfd == -1 ? NULL : s->tty"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "session_setup_sia",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-sia.c",
          "lines": "83-113",
          "snippet": "void\nsession_setup_sia(struct passwd *pw, char *tty)\n{\n\tSIAENTITY *ent = NULL;\n\tconst char *host;\n\n\thost = get_canonical_hostname(options.use_dns);\n\n\tif (sia_ses_init(&ent, saved_argc, saved_argv, host, pw->pw_name,\n\t    tty, 0, NULL) != SIASUCCESS)\n\t\tfatal(\"sia_ses_init failed\");\n\n\tif (sia_make_entity_pwd(pw, ent) != SIASUCCESS) {\n\t\tsia_ses_release(&ent);\n\t\tfatal(\"sia_make_entity_pwd failed\");\n\t}\n\n\tent->authtype = SIA_A_NONE;\n\tif (sia_ses_estab(sia_collect_trm, ent) != SIASUCCESS)\n\t\tfatal(\"Couldn't establish session for %s from %s\",\n\t\t    pw->pw_name, host);\n\n\tif (sia_ses_launch(sia_collect_trm, ent) != SIASUCCESS)\n\t\tfatal(\"Couldn't launch session for %s from %s\",\n\t\t    pw->pw_name, host);\n\n\tsia_ses_release(&ent);\n\n\tsetuid(0);\n\tpermanently_set_uid(pw);\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"log.h\"",
            "#include \"auth-sia.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/resource.h>",
            "#include <setjmp.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <siad.h>",
            "#include <sia.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"log.h\"\n#include \"auth-sia.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/resource.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <pwd.h>\n#include <siad.h>\n#include <sia.h>\n#include \"includes.h\"\n\nvoid\nsession_setup_sia(struct passwd *pw, char *tty)\n{\n\tSIAENTITY *ent = NULL;\n\tconst char *host;\n\n\thost = get_canonical_hostname(options.use_dns);\n\n\tif (sia_ses_init(&ent, saved_argc, saved_argv, host, pw->pw_name,\n\t    tty, 0, NULL) != SIASUCCESS)\n\t\tfatal(\"sia_ses_init failed\");\n\n\tif (sia_make_entity_pwd(pw, ent) != SIASUCCESS) {\n\t\tsia_ses_release(&ent);\n\t\tfatal(\"sia_make_entity_pwd failed\");\n\t}\n\n\tent->authtype = SIA_A_NONE;\n\tif (sia_ses_estab(sia_collect_trm, ent) != SIASUCCESS)\n\t\tfatal(\"Couldn't establish session for %s from %s\",\n\t\t    pw->pw_name, host);\n\n\tif (sia_ses_launch(sia_collect_trm, ent) != SIASUCCESS)\n\t\tfatal(\"Couldn't launch session for %s from %s\",\n\t\t    pw->pw_name, host);\n\n\tsia_ses_release(&ent);\n\n\tsetuid(0);\n\tpermanently_set_uid(pw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_pwchange",
          "args": [
            "s"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "do_pwchange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1465-1488",
          "snippet": "static void\ndo_pwchange(Session *s)\n{\n\tfflush(NULL);\n\tfprintf(stderr, \"WARNING: Your password has expired.\\n\");\n\tif (s->ttyfd != -1) {\n\t\tfprintf(stderr,\n\t\t    \"You must change your password now and login again!\\n\");\n#ifdef WITH_SELINUX\n\t\tsetexeccon(NULL);\n#endif\n#ifdef PASSWD_NEEDS_USERNAME\n\t\texecl(_PATH_PASSWD_PROG, \"passwd\", s->pw->pw_name,\n\t\t    (char *)NULL);\n#else\n\t\texecl(_PATH_PASSWD_PROG, \"passwd\", (char *)NULL);\n#endif\n\t\tperror(\"passwd\");\n\t} else {\n\t\tfprintf(stderr,\n\t\t    \"Password change required but no TTY available.\\n\");\n\t}\n\texit(1);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic void\ndo_pwchange(Session *s)\n{\n\tfflush(NULL);\n\tfprintf(stderr, \"WARNING: Your password has expired.\\n\");\n\tif (s->ttyfd != -1) {\n\t\tfprintf(stderr,\n\t\t    \"You must change your password now and login again!\\n\");\n#ifdef WITH_SELINUX\n\t\tsetexeccon(NULL);\n#endif\n#ifdef PASSWD_NEEDS_USERNAME\n\t\texecl(_PATH_PASSWD_PROG, \"passwd\", s->pw->pw_name,\n\t\t    (char *)NULL);\n#else\n\t\texecl(_PATH_PASSWD_PROG, \"passwd\", (char *)NULL);\n#endif\n\t\tperror(\"passwd\");\n\t} else {\n\t\tfprintf(stderr,\n\t\t    \"Password change required but no TTY available.\\n\");\n\t}\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_clear_keys",
          "args": [],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_sensitive_data",
          "args": [],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_sensitive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshd.c",
          "lines": "469-484",
          "snippet": "void\ndestroy_sensitive_data(void)\n{\n\tu_int i;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tif (sensitive_data.host_keys[i]) {\n\t\t\tsshkey_free(sensitive_data.host_keys[i]);\n\t\t\tsensitive_data.host_keys[i] = NULL;\n\t\t}\n\t\tif (sensitive_data.host_certificates[i]) {\n\t\t\tsshkey_free(sensitive_data.host_certificates[i]);\n\t\t\tsensitive_data.host_certificates[i] = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"version.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh-sandbox.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"dispatch.h\"",
            "#include \"msg.h\"",
            "#include \"authfd.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"canohost.h\"",
            "#include \"atomicio.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <prot.h>",
            "#include <sys/security.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rand.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/dh.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include \"openbsd-compat/sys-tree.h\"",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ServerOptions options;",
            "struct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;",
            "void destroy_sensitive_data(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"version.h\"\n#include \"auth-options.h\"\n#include \"ssh-sandbox.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"msg.h\"\n#include \"authfd.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"canohost.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <prot.h>\n#include <sys/security.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rand.h>\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/sys-tree.h\"\n# include <sys/time.h>\n# include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nServerOptions options;\nstruct {\n\tstruct sshkey\t**host_keys;\t\t/* all private host keys */\n\tstruct sshkey\t**host_pubkeys;\t\t/* all public host keys */\n\tstruct sshkey\t**host_certificates;\t/* all public host certificates */\n\tint\t\thave_ssh2_key;\n} sensitive_data;\nvoid destroy_sensitive_data(void);\n\nvoid\ndestroy_sensitive_data(void)\n{\n\tu_int i;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tif (sensitive_data.host_keys[i]) {\n\t\t\tsshkey_free(sensitive_data.host_keys[i]);\n\t\t\tsensitive_data.host_keys[i] = NULL;\n\t\t}\n\t\tif (sensitive_data.host_certificates[i]) {\n\t\t\tsshkey_free(sensitive_data.host_certificates[i]);\n\t\t\tsensitive_data.host_certificates[i] = NULL;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define ARGV_MAX 10\n#define SUBSYSTEM_INT_SFTP_ERROR\t3\n#define SUBSYSTEM_INT_SFTP\t\t2\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nvoid\tdo_motd(void);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern char *__progname;\nextern void destroy_sensitive_data(void);\nstatic int in_chroot = 0;\n\nvoid\ndo_child(struct ssh *ssh, Session *s, const char *command)\n{\n\textern char **environ;\n\tchar **env;\n\tchar *argv[ARGV_MAX];\n\tconst char *shell, *shell0;\n\tstruct passwd *pw = s->pw;\n\tint r = 0;\n\n\t/* remove hostkey from the child's memory */\n\tdestroy_sensitive_data();\n\tpacket_clear_keys();\n\n\t/* Force a password change */\n\tif (s->authctxt->force_pwchange) {\n\t\tdo_setusercontext(pw);\n\t\tchild_close_fds(ssh);\n\t\tdo_pwchange(s);\n\t\texit(1);\n\t}\n\n\t/*\n\t * Login(1) does this as well, and it needs uid 0 for the \"-h\"\n\t * switch, so we let login(1) to this for us.\n\t */\n#ifdef HAVE_OSF_SIA\n\tsession_setup_sia(pw, s->ttyfd == -1 ? NULL : s->tty);\n\tif (!check_quietlogin(s, command))\n\t\tdo_motd();\n#else /* HAVE_OSF_SIA */\n\t/* When PAM is enabled we rely on it to do the nologin check */\n\tif (!options.use_pam)\n\t\tdo_nologin(pw);\n\tdo_setusercontext(pw);\n\t/*\n\t * PAM session modules in do_setusercontext may have\n\t * generated messages, so if this in an interactive\n\t * login then display them too.\n\t */\n\tif (!check_quietlogin(s, command))\n\t\tdisplay_loginmsg();\n#endif /* HAVE_OSF_SIA */\n\n#ifdef USE_PAM\n\tif (options.use_pam && !is_pam_session_open()) {\n\t\tdebug3(\"PAM session not opened, exiting\");\n\t\tdisplay_loginmsg();\n\t\texit(254);\n\t}\n#endif\n\n\t/*\n\t * Get the shell from the password data.  An empty shell field is\n\t * legal, and means /bin/sh.\n\t */\n\tshell = (pw->pw_shell[0] == '\\0') ? _PATH_BSHELL : pw->pw_shell;\n\n\t/*\n\t * Make sure $SHELL points to the shell from the password file,\n\t * even if shell is overridden from login.conf\n\t */\n\tenv = do_setup_env(ssh, s, shell);\n\n#ifdef HAVE_LOGIN_CAP\n\tshell = login_getcapstr(lc, \"shell\", (char *)shell, (char *)shell);\n#endif\n\n\t/*\n\t * Close the connection descriptors; note that this is the child, and\n\t * the server will still have the socket open, and it is important\n\t * that we do not shutdown it.  Note that the descriptors cannot be\n\t * closed before building the environment, as we call\n\t * ssh_remote_ipaddr there.\n\t */\n\tchild_close_fds(ssh);\n\n\t/*\n\t * Must take new environment into use so that .ssh/rc,\n\t * /etc/ssh/sshrc and xauth are run in the proper environment.\n\t */\n\tenviron = env;\n\n#if defined(KRB5) && defined(USE_AFS)\n\t/*\n\t * At this point, we check to see if AFS is active and if we have\n\t * a valid Kerberos 5 TGT. If so, it seems like a good idea to see\n\t * if we can (and need to) extend the ticket into an AFS token. If\n\t * we don't do this, we run into potential problems if the user's\n\t * home directory is in AFS and it's not world-readable.\n\t */\n\n\tif (options.kerberos_get_afs_token && k_hasafs() &&\n\t    (s->authctxt->krb5_ctx != NULL)) {\n\t\tchar cell[64];\n\n\t\tdebug(\"Getting AFS token\");\n\n\t\tk_setpag();\n\n\t\tif (k_afs_cell_of_file(pw->pw_dir, cell, sizeof(cell)) == 0)\n\t\t\tkrb5_afslog(s->authctxt->krb5_ctx,\n\t\t\t    s->authctxt->krb5_fwd_ccache, cell, NULL);\n\n\t\tkrb5_afslog_home(s->authctxt->krb5_ctx,\n\t\t    s->authctxt->krb5_fwd_ccache, NULL, NULL, pw->pw_dir);\n\t}\n#endif\n\n\t/* Change current directory to the user's home directory. */\n\tif (chdir(pw->pw_dir) < 0) {\n\t\t/* Suppress missing homedir warning for chroot case */\n#ifdef HAVE_LOGIN_CAP\n\t\tr = login_getcapbool(lc, \"requirehome\", 0);\n#endif\n\t\tif (r || !in_chroot) {\n\t\t\tfprintf(stderr, \"Could not chdir to home \"\n\t\t\t    \"directory %s: %s\\n\", pw->pw_dir,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tif (r)\n\t\t\texit(1);\n\t}\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tdo_rc_files(ssh, s, shell);\n\n\t/* restore SIGPIPE for child */\n\tsignal(SIGPIPE, SIG_DFL);\n\n\tif (s->is_subsystem == SUBSYSTEM_INT_SFTP_ERROR) {\n\t\tprintf(\"This service allows sftp connections only.\\n\");\n\t\tfflush(NULL);\n\t\texit(1);\n\t} else if (s->is_subsystem == SUBSYSTEM_INT_SFTP) {\n\t\textern int optind, optreset;\n\t\tint i;\n\t\tchar *p, *args;\n\n\t\tsetproctitle(\"%s@%s\", s->pw->pw_name, INTERNAL_SFTP_NAME);\n\t\targs = xstrdup(command ? command : \"sftp-server\");\n\t\tfor (i = 0, (p = strtok(args, \" \")); p; (p = strtok(NULL, \" \")))\n\t\t\tif (i < ARGV_MAX - 1)\n\t\t\t\targv[i++] = p;\n\t\targv[i] = NULL;\n\t\toptind = optreset = 1;\n\t\t__progname = argv[0];\n#ifdef WITH_SELINUX\n\t\tssh_selinux_change_context(\"sftpd_t\");\n#endif\n\t\texit(sftp_server_main(i, argv, s->pw));\n\t}\n\n\tfflush(NULL);\n\n\t/* Get the last component of the shell name. */\n\tif ((shell0 = strrchr(shell, '/')) != NULL)\n\t\tshell0++;\n\telse\n\t\tshell0 = shell;\n\n\t/*\n\t * If we have no command, execute the shell.  In this case, the shell\n\t * name to be passed in argv[0] is preceded by '-' to indicate that\n\t * this is a login shell.\n\t */\n\tif (!command) {\n\t\tchar argv0[256];\n\n\t\t/* Start the shell.  Set initial character to '-'. */\n\t\targv0[0] = '-';\n\n\t\tif (strlcpy(argv0 + 1, shell0, sizeof(argv0) - 1)\n\t\t    >= sizeof(argv0) - 1) {\n\t\t\terrno = EINVAL;\n\t\t\tperror(shell);\n\t\t\texit(1);\n\t\t}\n\n\t\t/* Execute the shell. */\n\t\targv[0] = argv0;\n\t\targv[1] = NULL;\n\t\texecve(shell, argv, env);\n\n\t\t/* Executing the shell failed. */\n\t\tperror(shell);\n\t\texit(1);\n\t}\n\t/*\n\t * Execute the command using the user's shell.  This uses the -c\n\t * option to execute the command.\n\t */\n\targv[0] = (char *) shell0;\n\targv[1] = \"-c\";\n\targv[2] = (char *) command;\n\targv[3] = NULL;\n\texecve(shell, argv, env);\n\tperror(shell);\n\texit(1);\n}"
  },
  {
    "function_name": "child_close_fds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1490-1526",
    "snippet": "static void\nchild_close_fds(struct ssh *ssh)\n{\n\textern int auth_sock;\n\n\tif (auth_sock != -1) {\n\t\tclose(auth_sock);\n\t\tauth_sock = -1;\n\t}\n\n\tif (packet_get_connection_in() == packet_get_connection_out())\n\t\tclose(packet_get_connection_in());\n\telse {\n\t\tclose(packet_get_connection_in());\n\t\tclose(packet_get_connection_out());\n\t}\n\t/*\n\t * Close all descriptors related to channels.  They will still remain\n\t * open in the parent.\n\t */\n\t/* XXX better use close-on-exec? -markus */\n\tchannel_close_all(ssh);\n\n\t/*\n\t * Close any extra file descriptors.  Note that there may still be\n\t * descriptors left by system functions.  They will be closed later.\n\t */\n\tendpwent();\n\n\t/*\n\t * Close any extra open file descriptors so that we don't have them\n\t * hanging around in clients.  Note that we want to do this after\n\t * initgroups, because at least on Solaris 2.3 it leaves file\n\t * descriptors open.\n\t */\n\tclosefrom(STDERR_FILENO + 1);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closefrom",
          "args": [
            "STDERR_FILENO + 1"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "endpwent",
          "args": [],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_close_all",
          "args": [
            "ssh"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "channel_close_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "656-664",
          "snippet": "void\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "packet_get_connection_out()"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "child_close_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1490-1526",
          "snippet": "static void\nchild_close_fds(struct ssh *ssh)\n{\n\textern int auth_sock;\n\n\tif (auth_sock != -1) {\n\t\tclose(auth_sock);\n\t\tauth_sock = -1;\n\t}\n\n\tif (packet_get_connection_in() == packet_get_connection_out())\n\t\tclose(packet_get_connection_in());\n\telse {\n\t\tclose(packet_get_connection_in());\n\t\tclose(packet_get_connection_out());\n\t}\n\t/*\n\t * Close all descriptors related to channels.  They will still remain\n\t * open in the parent.\n\t */\n\t/* XXX better use close-on-exec? -markus */\n\tchannel_close_all(ssh);\n\n\t/*\n\t * Close any extra file descriptors.  Note that there may still be\n\t * descriptors left by system functions.  They will be closed later.\n\t */\n\tendpwent();\n\n\t/*\n\t * Close any extra open file descriptors so that we don't have them\n\t * hanging around in clients.  Note that we want to do this after\n\t * initgroups, because at least on Solaris 2.3 it leaves file\n\t * descriptors open.\n\t */\n\tclosefrom(STDERR_FILENO + 1);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_connection_out",
          "args": [],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_connection_in",
          "args": [],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_connection_in",
          "args": [],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_connection_out",
          "args": [],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_connection_in",
          "args": [],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nchild_close_fds(struct ssh *ssh)\n{\n\textern int auth_sock;\n\n\tif (auth_sock != -1) {\n\t\tclose(auth_sock);\n\t\tauth_sock = -1;\n\t}\n\n\tif (packet_get_connection_in() == packet_get_connection_out())\n\t\tclose(packet_get_connection_in());\n\telse {\n\t\tclose(packet_get_connection_in());\n\t\tclose(packet_get_connection_out());\n\t}\n\t/*\n\t * Close all descriptors related to channels.  They will still remain\n\t * open in the parent.\n\t */\n\t/* XXX better use close-on-exec? -markus */\n\tchannel_close_all(ssh);\n\n\t/*\n\t * Close any extra file descriptors.  Note that there may still be\n\t * descriptors left by system functions.  They will be closed later.\n\t */\n\tendpwent();\n\n\t/*\n\t * Close any extra open file descriptors so that we don't have them\n\t * hanging around in clients.  Note that we want to do this after\n\t * initgroups, because at least on Solaris 2.3 it leaves file\n\t * descriptors open.\n\t */\n\tclosefrom(STDERR_FILENO + 1);\n}"
  },
  {
    "function_name": "do_pwchange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1465-1488",
    "snippet": "static void\ndo_pwchange(Session *s)\n{\n\tfflush(NULL);\n\tfprintf(stderr, \"WARNING: Your password has expired.\\n\");\n\tif (s->ttyfd != -1) {\n\t\tfprintf(stderr,\n\t\t    \"You must change your password now and login again!\\n\");\n#ifdef WITH_SELINUX\n\t\tsetexeccon(NULL);\n#endif\n#ifdef PASSWD_NEEDS_USERNAME\n\t\texecl(_PATH_PASSWD_PROG, \"passwd\", s->pw->pw_name,\n\t\t    (char *)NULL);\n#else\n\t\texecl(_PATH_PASSWD_PROG, \"passwd\", (char *)NULL);\n#endif\n\t\tperror(\"passwd\");\n\t} else {\n\t\tfprintf(stderr,\n\t\t    \"Password change required but no TTY available.\\n\");\n\t}\n\texit(1);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Password change required but no TTY available.\\n\""
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"passwd\""
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execl",
          "args": [
            "_PATH_PASSWD_PROG",
            "\"passwd\"",
            "(char *)NULL"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execl",
          "args": [
            "_PATH_PASSWD_PROG",
            "\"passwd\"",
            "s->pw->pw_name",
            "(char *)NULL"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setexeccon",
          "args": [
            "NULL"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"You must change your password now and login again!\\n\""
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"WARNING: Your password has expired.\\n\""
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "NULL"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "_ssh_compat_fflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "314-326",
          "snippet": "int _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic void\ndo_pwchange(Session *s)\n{\n\tfflush(NULL);\n\tfprintf(stderr, \"WARNING: Your password has expired.\\n\");\n\tif (s->ttyfd != -1) {\n\t\tfprintf(stderr,\n\t\t    \"You must change your password now and login again!\\n\");\n#ifdef WITH_SELINUX\n\t\tsetexeccon(NULL);\n#endif\n#ifdef PASSWD_NEEDS_USERNAME\n\t\texecl(_PATH_PASSWD_PROG, \"passwd\", s->pw->pw_name,\n\t\t    (char *)NULL);\n#else\n\t\texecl(_PATH_PASSWD_PROG, \"passwd\", (char *)NULL);\n#endif\n\t\tperror(\"passwd\");\n\t} else {\n\t\tfprintf(stderr,\n\t\t    \"Password change required but no TTY available.\\n\");\n\t}\n\texit(1);\n}"
  },
  {
    "function_name": "do_setusercontext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1382-1463",
    "snippet": "void\ndo_setusercontext(struct passwd *pw)\n{\n\tchar uidstr[32], *chroot_path, *tmp;\n\n\tplatform_setusercontext(pw);\n\n\tif (platform_privileged_uidswap()) {\n#ifdef HAVE_LOGIN_CAP\n\t\tif (setusercontext(lc, pw, pw->pw_uid,\n\t\t    (LOGIN_SETALL & ~(LOGIN_SETPATH|LOGIN_SETUSER))) < 0) {\n\t\t\tperror(\"unable to set user context\");\n\t\t\texit(1);\n\t\t}\n#else\n\t\tif (setlogin(pw->pw_name) < 0)\n\t\t\terror(\"setlogin failed: %s\", strerror(errno));\n\t\tif (setgid(pw->pw_gid) < 0) {\n\t\t\tperror(\"setgid\");\n\t\t\texit(1);\n\t\t}\n\t\t/* Initialize the group list. */\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0) {\n\t\t\tperror(\"initgroups\");\n\t\t\texit(1);\n\t\t}\n\t\tendgrent();\n#endif\n\n\t\tplatform_setusercontext_post_groups(pw);\n\n\t\tif (!in_chroot && options.chroot_directory != NULL &&\n\t\t    strcasecmp(options.chroot_directory, \"none\") != 0) {\n                        tmp = tilde_expand_filename(options.chroot_directory,\n\t\t\t    pw->pw_uid);\n\t\t\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t\t\t    (unsigned long long)pw->pw_uid);\n\t\t\tchroot_path = percent_expand(tmp, \"h\", pw->pw_dir,\n\t\t\t    \"u\", pw->pw_name, \"U\", uidstr, (char *)NULL);\n\t\t\tsafely_chroot(chroot_path, pw->pw_uid);\n\t\t\tfree(tmp);\n\t\t\tfree(chroot_path);\n\t\t\t/* Make sure we don't attempt to chroot again */\n\t\t\tfree(options.chroot_directory);\n\t\t\toptions.chroot_directory = NULL;\n\t\t\tin_chroot = 1;\n\t\t}\n\n#ifdef HAVE_LOGIN_CAP\n\t\tif (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETUSER) < 0) {\n\t\t\tperror(\"unable to set user context (setuser)\");\n\t\t\texit(1);\n\t\t}\n\t\t/* \n\t\t * FreeBSD's setusercontext() will not apply the user's\n\t\t * own umask setting unless running with the user's UID.\n\t\t */\n\t\t(void) setusercontext(lc, pw, pw->pw_uid, LOGIN_SETUMASK);\n#else\n# ifdef USE_LIBIAF\n\t\t/*\n\t\t * In a chroot environment, the set_id() will always fail;\n\t\t * typically because of the lack of necessary authentication\n\t\t * services and runtime such as ./usr/lib/libiaf.so,\n\t\t * ./usr/lib/libpam.so.1, and ./etc/passwd We skip it in the\n\t\t * internal sftp chroot case.  We'll lose auditing and ACLs but\n\t\t * permanently_set_uid will take care of the rest.\n\t\t */\n\t\tif (!in_chroot && set_id(pw->pw_name) != 0)\n\t\t\tfatal(\"set_id(%s) Failed\", pw->pw_name);\n# endif /* USE_LIBIAF */\n\t\t/* Permanently switch to the desired uid. */\n\t\tpermanently_set_uid(pw);\n#endif\n\t} else if (options.chroot_directory != NULL &&\n\t    strcasecmp(options.chroot_directory, \"none\") != 0) {\n\t\tfatal(\"server lacks privileges to chroot to ChrootDirectory\");\n\t}\n\n\tif (getuid() != pw->pw_uid || geteuid() != pw->pw_uid)\n\t\tfatal(\"Failed to set uids to %u.\", (u_int) pw->pw_uid);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "static int in_chroot = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Failed to set uids to %u.\"",
            "(u_int) pw->pw_uid"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"server lacks privileges to chroot to ChrootDirectory\""
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "options.chroot_directory",
            "\"none\""
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "permanently_set_uid",
          "args": [
            "pw"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "permanently_set_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "178-236",
          "snippet": "void\npermanently_set_uid(struct passwd *pw)\n{\n#ifndef NO_UID_RESTORATION_TEST\n\tuid_t old_uid = getuid();\n\tgid_t old_gid = getgid();\n#endif\n\n\tif (pw == NULL)\n\t\tfatal(\"permanently_set_uid: no user given\");\n\tif (temporarily_use_uid_effective)\n\t\tfatal(\"permanently_set_uid: temporarily_use_uid effective\");\n\tdebug(\"permanently_set_uid: %u/%u\", (u_int)pw->pw_uid,\n\t    (u_int)pw->pw_gid);\n\n\tif (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) < 0)\n\t\tfatal(\"setresgid %u: %.100s\", (u_int)pw->pw_gid, strerror(errno));\n\n#ifdef __APPLE__\n\t/*\n\t * OS X requires initgroups after setgid to opt back into\n\t * memberd support for >16 supplemental groups.\n\t */\n\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\tfatal(\"initgroups %.100s %u: %.100s\",\n\t\t    pw->pw_name, (u_int)pw->pw_gid, strerror(errno));\n#endif\n\n\tif (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) < 0)\n\t\tfatal(\"setresuid %u: %.100s\", (u_int)pw->pw_uid, strerror(errno));\n\n#ifndef NO_UID_RESTORATION_TEST\n\t/* Try restoration of GID if changed (test clearing of saved gid) */\n\tif (old_gid != pw->pw_gid && pw->pw_uid != 0 &&\n\t    (setgid(old_gid) != -1 || setegid(old_gid) != -1))\n\t\tfatal(\"%s: was able to restore old [e]gid\", __func__);\n#endif\n\n\t/* Verify GID drop was successful */\n\tif (getgid() != pw->pw_gid || getegid() != pw->pw_gid) {\n\t\tfatal(\"%s: egid incorrect gid:%u egid:%u (should be %u)\",\n\t\t    __func__, (u_int)getgid(), (u_int)getegid(),\n\t\t    (u_int)pw->pw_gid);\n\t}\n\n#ifndef NO_UID_RESTORATION_TEST\n\t/* Try restoration of UID if changed (test clearing of saved uid) */\n\tif (old_uid != pw->pw_uid &&\n\t    (setuid(old_uid) != -1 || seteuid(old_uid) != -1))\n\t\tfatal(\"%s: was able to restore old [e]uid\", __func__);\n#endif\n\n\t/* Verify UID drop was successful */\n\tif (getuid() != pw->pw_uid || geteuid() != pw->pw_uid) {\n\t\tfatal(\"%s: euid incorrect uid:%u euid:%u (should be %u)\",\n\t\t    __func__, (u_int)getuid(), (u_int)geteuid(),\n\t\t    (u_int)pw->pw_uid);\n\t}\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttemporarily_use_uid_effective = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\nstatic int\ttemporarily_use_uid_effective = 0;\n\nvoid\npermanently_set_uid(struct passwd *pw)\n{\n#ifndef NO_UID_RESTORATION_TEST\n\tuid_t old_uid = getuid();\n\tgid_t old_gid = getgid();\n#endif\n\n\tif (pw == NULL)\n\t\tfatal(\"permanently_set_uid: no user given\");\n\tif (temporarily_use_uid_effective)\n\t\tfatal(\"permanently_set_uid: temporarily_use_uid effective\");\n\tdebug(\"permanently_set_uid: %u/%u\", (u_int)pw->pw_uid,\n\t    (u_int)pw->pw_gid);\n\n\tif (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) < 0)\n\t\tfatal(\"setresgid %u: %.100s\", (u_int)pw->pw_gid, strerror(errno));\n\n#ifdef __APPLE__\n\t/*\n\t * OS X requires initgroups after setgid to opt back into\n\t * memberd support for >16 supplemental groups.\n\t */\n\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\tfatal(\"initgroups %.100s %u: %.100s\",\n\t\t    pw->pw_name, (u_int)pw->pw_gid, strerror(errno));\n#endif\n\n\tif (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) < 0)\n\t\tfatal(\"setresuid %u: %.100s\", (u_int)pw->pw_uid, strerror(errno));\n\n#ifndef NO_UID_RESTORATION_TEST\n\t/* Try restoration of GID if changed (test clearing of saved gid) */\n\tif (old_gid != pw->pw_gid && pw->pw_uid != 0 &&\n\t    (setgid(old_gid) != -1 || setegid(old_gid) != -1))\n\t\tfatal(\"%s: was able to restore old [e]gid\", __func__);\n#endif\n\n\t/* Verify GID drop was successful */\n\tif (getgid() != pw->pw_gid || getegid() != pw->pw_gid) {\n\t\tfatal(\"%s: egid incorrect gid:%u egid:%u (should be %u)\",\n\t\t    __func__, (u_int)getgid(), (u_int)getegid(),\n\t\t    (u_int)pw->pw_gid);\n\t}\n\n#ifndef NO_UID_RESTORATION_TEST\n\t/* Try restoration of UID if changed (test clearing of saved uid) */\n\tif (old_uid != pw->pw_uid &&\n\t    (setuid(old_uid) != -1 || seteuid(old_uid) != -1))\n\t\tfatal(\"%s: was able to restore old [e]uid\", __func__);\n#endif\n\n\t/* Verify UID drop was successful */\n\tif (getuid() != pw->pw_uid || geteuid() != pw->pw_uid) {\n\t\tfatal(\"%s: euid incorrect uid:%u euid:%u (should be %u)\",\n\t\t    __func__, (u_int)getuid(), (u_int)geteuid(),\n\t\t    (u_int)pw->pw_uid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_id",
          "args": [
            "pw->pw_name"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setusercontext",
          "args": [
            "lc",
            "pw",
            "pw->pw_uid",
            "LOGIN_SETUMASK"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"unable to set user context (setuser)\""
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setusercontext",
          "args": [
            "lc",
            "pw",
            "pw->pw_uid",
            "LOGIN_SETUSER"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "options.chroot_directory"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "safely_chroot",
          "args": [
            "chroot_path",
            "pw->pw_uid"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "safely_chroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1330-1379",
          "snippet": "static void\nsafely_chroot(const char *path, uid_t uid)\n{\n\tconst char *cp;\n\tchar component[PATH_MAX];\n\tstruct stat st;\n\n\tif (*path != '/')\n\t\tfatal(\"chroot path does not begin at root\");\n\tif (strlen(path) >= sizeof(component))\n\t\tfatal(\"chroot path too long\");\n\n\t/*\n\t * Descend the path, checking that each component is a\n\t * root-owned directory with strict permissions.\n\t */\n\tfor (cp = path; cp != NULL;) {\n\t\tif ((cp = strchr(cp, '/')) == NULL)\n\t\t\tstrlcpy(component, path, sizeof(component));\n\t\telse {\n\t\t\tcp++;\n\t\t\tmemcpy(component, path, cp - path);\n\t\t\tcomponent[cp - path] = '\\0';\n\t\t}\n\t\n\t\tdebug3(\"%s: checking '%s'\", __func__, component);\n\n\t\tif (stat(component, &st) != 0)\n\t\t\tfatal(\"%s: stat(\\\"%s\\\"): %s\", __func__,\n\t\t\t    component, strerror(errno));\n\t\tif (st.st_uid != 0 || (st.st_mode & 022) != 0)\n\t\t\tfatal(\"bad ownership or modes for chroot \"\n\t\t\t    \"directory %s\\\"%s\\\"\", \n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\t\tif (!S_ISDIR(st.st_mode))\n\t\t\tfatal(\"chroot path %s\\\"%s\\\" is not a directory\",\n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\n\t}\n\n\tif (chdir(path) == -1)\n\t\tfatal(\"Unable to chdir to chroot path \\\"%s\\\": \"\n\t\t    \"%s\", path, strerror(errno));\n\tif (chroot(path) == -1)\n\t\tfatal(\"chroot(\\\"%s\\\"): %s\", path, strerror(errno));\n\tif (chdir(\"/\") == -1)\n\t\tfatal(\"%s: chdir(/) after chroot: %s\",\n\t\t    __func__, strerror(errno));\n\tverbose(\"Changed root directory to \\\"%s\\\"\", path);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsafely_chroot(const char *path, uid_t uid)\n{\n\tconst char *cp;\n\tchar component[PATH_MAX];\n\tstruct stat st;\n\n\tif (*path != '/')\n\t\tfatal(\"chroot path does not begin at root\");\n\tif (strlen(path) >= sizeof(component))\n\t\tfatal(\"chroot path too long\");\n\n\t/*\n\t * Descend the path, checking that each component is a\n\t * root-owned directory with strict permissions.\n\t */\n\tfor (cp = path; cp != NULL;) {\n\t\tif ((cp = strchr(cp, '/')) == NULL)\n\t\t\tstrlcpy(component, path, sizeof(component));\n\t\telse {\n\t\t\tcp++;\n\t\t\tmemcpy(component, path, cp - path);\n\t\t\tcomponent[cp - path] = '\\0';\n\t\t}\n\t\n\t\tdebug3(\"%s: checking '%s'\", __func__, component);\n\n\t\tif (stat(component, &st) != 0)\n\t\t\tfatal(\"%s: stat(\\\"%s\\\"): %s\", __func__,\n\t\t\t    component, strerror(errno));\n\t\tif (st.st_uid != 0 || (st.st_mode & 022) != 0)\n\t\t\tfatal(\"bad ownership or modes for chroot \"\n\t\t\t    \"directory %s\\\"%s\\\"\", \n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\t\tif (!S_ISDIR(st.st_mode))\n\t\t\tfatal(\"chroot path %s\\\"%s\\\" is not a directory\",\n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\n\t}\n\n\tif (chdir(path) == -1)\n\t\tfatal(\"Unable to chdir to chroot path \\\"%s\\\": \"\n\t\t    \"%s\", path, strerror(errno));\n\tif (chroot(path) == -1)\n\t\tfatal(\"chroot(\\\"%s\\\"): %s\", path, strerror(errno));\n\tif (chdir(\"/\") == -1)\n\t\tfatal(\"%s: chdir(/) after chroot: %s\",\n\t\t    __func__, strerror(errno));\n\tverbose(\"Changed root directory to \\\"%s\\\"\", path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percent_expand",
          "args": [
            "tmp",
            "\"h\"",
            "pw->pw_dir",
            "\"u\"",
            "pw->pw_name",
            "\"U\"",
            "uidstr",
            "(char *)NULL"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "percent_expand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "973-1029",
          "snippet": "char *\npercent_expand(const char *string, ...)\n{\n#define EXPAND_MAX_KEYS\t16\n\tu_int num_keys, i, j;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tchar buf[4096];\n\tva_list ap;\n\n\t/* Gather keys */\n\tva_start(ap, string);\n\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\tif (keys[num_keys].key == NULL)\n\t\t\tbreak;\n\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\tif (keys[num_keys].repl == NULL)\n\t\t\tfatal(\"%s: NULL replacement\", __func__);\n\t}\n\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\tfatal(\"%s: too many keys\", __func__);\n\tva_end(ap);\n\n\t/* Expand string */\n\t*buf = '\\0';\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\tif (*string != '%') {\n append:\n\t\t\tbuf[i++] = *string;\n\t\t\tif (i >= sizeof(buf))\n\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\tbuf[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0')\n\t\t\tfatal(\"%s: invalid format\", __func__);\n\t\tfor (j = 0; j < num_keys; j++) {\n\t\t\tif (strchr(keys[j].key, *string) != NULL) {\n\t\t\t\ti = strlcat(buf, keys[j].repl, sizeof(buf));\n\t\t\t\tif (i >= sizeof(buf))\n\t\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= num_keys)\n\t\t\tfatal(\"%s: unknown key %%%c\", __func__, *string);\n\t}\n\treturn (xstrdup(buf));\n#undef EXPAND_MAX_KEYS\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define EXPAND_MAX_KEYS\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define EXPAND_MAX_KEYS\t16\n\nchar *\npercent_expand(const char *string, ...)\n{\n#define EXPAND_MAX_KEYS\t16\n\tu_int num_keys, i, j;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tchar buf[4096];\n\tva_list ap;\n\n\t/* Gather keys */\n\tva_start(ap, string);\n\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\tif (keys[num_keys].key == NULL)\n\t\t\tbreak;\n\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\tif (keys[num_keys].repl == NULL)\n\t\t\tfatal(\"%s: NULL replacement\", __func__);\n\t}\n\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\tfatal(\"%s: too many keys\", __func__);\n\tva_end(ap);\n\n\t/* Expand string */\n\t*buf = '\\0';\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\tif (*string != '%') {\n append:\n\t\t\tbuf[i++] = *string;\n\t\t\tif (i >= sizeof(buf))\n\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\tbuf[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0')\n\t\t\tfatal(\"%s: invalid format\", __func__);\n\t\tfor (j = 0; j < num_keys; j++) {\n\t\t\tif (strchr(keys[j].key, *string) != NULL) {\n\t\t\t\ti = strlcat(buf, keys[j].repl, sizeof(buf));\n\t\t\t\tif (i >= sizeof(buf))\n\t\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= num_keys)\n\t\t\tfatal(\"%s: unknown key %%%c\", __func__, *string);\n\t}\n\treturn (xstrdup(buf));\n#undef EXPAND_MAX_KEYS\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "uidstr",
            "sizeof(uidstr)",
            "\"%llu\"",
            "(unsigned long long)pw->pw_uid"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tilde_expand_filename",
          "args": [
            "options.chroot_directory",
            "pw->pw_uid"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "tilde_expand_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "926-965",
          "snippet": "char *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "options.chroot_directory",
            "\"none\""
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_setusercontext_post_groups",
          "args": [
            "pw"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "platform_setusercontext_post_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "144-188",
          "snippet": "void\nplatform_setusercontext_post_groups(struct passwd *pw)\n{\n#if !defined(HAVE_LOGIN_CAP) && defined(USE_PAM)\n\t/*\n\t * PAM credentials may take the form of supplementary groups.\n\t * These will have been wiped by the above initgroups() call.\n\t * Reestablish them here.\n\t */\n\tif (options.use_pam) {\n\t\tdo_pam_setcred(use_privsep);\n\t}\n#endif /* USE_PAM */\n\n#if !defined(HAVE_LOGIN_CAP) && (defined(WITH_IRIX_PROJECT) || \\\n    defined(WITH_IRIX_JOBS) || defined(WITH_IRIX_ARRAY))\n\tirix_setusercontext(pw);\n#endif /* defined(WITH_IRIX_PROJECT) || defined(WITH_IRIX_JOBS) || defined(WITH_IRIX_ARRAY) */\n\n#ifdef _AIX\n\taix_usrinfo(pw);\n#endif /* _AIX */\n\n#ifdef HAVE_SETPCRED\n\t/*\n\t * If we have a chroot directory, we set all creds except real\n\t * uid which we will need for chroot.  If we don't have a\n\t * chroot directory, we don't override anything.\n\t */\n\t{\n\t\tchar **creds = NULL, *chroot_creds[] =\n\t\t    { \"REAL_USER=root\", NULL };\n\n\t\tif (options.chroot_directory != NULL &&\n\t\t    strcasecmp(options.chroot_directory, \"none\") != 0)\n\t\t\tcreds = chroot_creds;\n\n\t\tif (setpcred(pw->pw_name, creds) == -1)\n\t\t\tfatal(\"Failed to set process credentials\");\n\t}\n#endif /* HAVE_SETPCRED */\n#ifdef WITH_SELINUX\n\tssh_selinux_setup_exec_context(pw->pw_name);\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int use_privsep;",
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nextern int use_privsep;\nextern ServerOptions options;\n\nvoid\nplatform_setusercontext_post_groups(struct passwd *pw)\n{\n#if !defined(HAVE_LOGIN_CAP) && defined(USE_PAM)\n\t/*\n\t * PAM credentials may take the form of supplementary groups.\n\t * These will have been wiped by the above initgroups() call.\n\t * Reestablish them here.\n\t */\n\tif (options.use_pam) {\n\t\tdo_pam_setcred(use_privsep);\n\t}\n#endif /* USE_PAM */\n\n#if !defined(HAVE_LOGIN_CAP) && (defined(WITH_IRIX_PROJECT) || \\\n    defined(WITH_IRIX_JOBS) || defined(WITH_IRIX_ARRAY))\n\tirix_setusercontext(pw);\n#endif /* defined(WITH_IRIX_PROJECT) || defined(WITH_IRIX_JOBS) || defined(WITH_IRIX_ARRAY) */\n\n#ifdef _AIX\n\taix_usrinfo(pw);\n#endif /* _AIX */\n\n#ifdef HAVE_SETPCRED\n\t/*\n\t * If we have a chroot directory, we set all creds except real\n\t * uid which we will need for chroot.  If we don't have a\n\t * chroot directory, we don't override anything.\n\t */\n\t{\n\t\tchar **creds = NULL, *chroot_creds[] =\n\t\t    { \"REAL_USER=root\", NULL };\n\n\t\tif (options.chroot_directory != NULL &&\n\t\t    strcasecmp(options.chroot_directory, \"none\") != 0)\n\t\t\tcreds = chroot_creds;\n\n\t\tif (setpcred(pw->pw_name, creds) == -1)\n\t\t\tfatal(\"Failed to set process credentials\");\n\t}\n#endif /* HAVE_SETPCRED */\n#ifdef WITH_SELINUX\n\tssh_selinux_setup_exec_context(pw->pw_name);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "endgrent",
          "args": [],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"initgroups\""
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initgroups",
          "args": [
            "pw->pw_name",
            "pw->pw_gid"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"setgid\""
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgid",
          "args": [
            "pw->pw_gid"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"setlogin failed: %s\"",
            "strerror(errno)"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setlogin",
          "args": [
            "pw->pw_name"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "setlogin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "67-70",
          "snippet": "int setlogin(const char *name)\n{\n\treturn (0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint setlogin(const char *name)\n{\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"unable to set user context\""
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setusercontext",
          "args": [
            "lc",
            "pw",
            "pw->pw_uid",
            "(LOGIN_SETALL & ~(LOGIN_SETPATH|LOGIN_SETUSER))"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_privileged_uidswap",
          "args": [],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "platform_privileged_uidswap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "81-90",
          "snippet": "int\nplatform_privileged_uidswap(void)\n{\n#ifdef HAVE_CYGWIN\n\t/* uid 0 is not special on Cygwin so always try */\n\treturn 1;\n#else\n\treturn (getuid() == 0 || geteuid() == 0);\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nplatform_privileged_uidswap(void)\n{\n#ifdef HAVE_CYGWIN\n\t/* uid 0 is not special on Cygwin so always try */\n\treturn 1;\n#else\n\treturn (getuid() == 0 || geteuid() == 0);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nstatic int in_chroot = 0;\n\nvoid\ndo_setusercontext(struct passwd *pw)\n{\n\tchar uidstr[32], *chroot_path, *tmp;\n\n\tplatform_setusercontext(pw);\n\n\tif (platform_privileged_uidswap()) {\n#ifdef HAVE_LOGIN_CAP\n\t\tif (setusercontext(lc, pw, pw->pw_uid,\n\t\t    (LOGIN_SETALL & ~(LOGIN_SETPATH|LOGIN_SETUSER))) < 0) {\n\t\t\tperror(\"unable to set user context\");\n\t\t\texit(1);\n\t\t}\n#else\n\t\tif (setlogin(pw->pw_name) < 0)\n\t\t\terror(\"setlogin failed: %s\", strerror(errno));\n\t\tif (setgid(pw->pw_gid) < 0) {\n\t\t\tperror(\"setgid\");\n\t\t\texit(1);\n\t\t}\n\t\t/* Initialize the group list. */\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0) {\n\t\t\tperror(\"initgroups\");\n\t\t\texit(1);\n\t\t}\n\t\tendgrent();\n#endif\n\n\t\tplatform_setusercontext_post_groups(pw);\n\n\t\tif (!in_chroot && options.chroot_directory != NULL &&\n\t\t    strcasecmp(options.chroot_directory, \"none\") != 0) {\n                        tmp = tilde_expand_filename(options.chroot_directory,\n\t\t\t    pw->pw_uid);\n\t\t\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t\t\t    (unsigned long long)pw->pw_uid);\n\t\t\tchroot_path = percent_expand(tmp, \"h\", pw->pw_dir,\n\t\t\t    \"u\", pw->pw_name, \"U\", uidstr, (char *)NULL);\n\t\t\tsafely_chroot(chroot_path, pw->pw_uid);\n\t\t\tfree(tmp);\n\t\t\tfree(chroot_path);\n\t\t\t/* Make sure we don't attempt to chroot again */\n\t\t\tfree(options.chroot_directory);\n\t\t\toptions.chroot_directory = NULL;\n\t\t\tin_chroot = 1;\n\t\t}\n\n#ifdef HAVE_LOGIN_CAP\n\t\tif (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETUSER) < 0) {\n\t\t\tperror(\"unable to set user context (setuser)\");\n\t\t\texit(1);\n\t\t}\n\t\t/* \n\t\t * FreeBSD's setusercontext() will not apply the user's\n\t\t * own umask setting unless running with the user's UID.\n\t\t */\n\t\t(void) setusercontext(lc, pw, pw->pw_uid, LOGIN_SETUMASK);\n#else\n# ifdef USE_LIBIAF\n\t\t/*\n\t\t * In a chroot environment, the set_id() will always fail;\n\t\t * typically because of the lack of necessary authentication\n\t\t * services and runtime such as ./usr/lib/libiaf.so,\n\t\t * ./usr/lib/libpam.so.1, and ./etc/passwd We skip it in the\n\t\t * internal sftp chroot case.  We'll lose auditing and ACLs but\n\t\t * permanently_set_uid will take care of the rest.\n\t\t */\n\t\tif (!in_chroot && set_id(pw->pw_name) != 0)\n\t\t\tfatal(\"set_id(%s) Failed\", pw->pw_name);\n# endif /* USE_LIBIAF */\n\t\t/* Permanently switch to the desired uid. */\n\t\tpermanently_set_uid(pw);\n#endif\n\t} else if (options.chroot_directory != NULL &&\n\t    strcasecmp(options.chroot_directory, \"none\") != 0) {\n\t\tfatal(\"server lacks privileges to chroot to ChrootDirectory\");\n\t}\n\n\tif (getuid() != pw->pw_uid || geteuid() != pw->pw_uid)\n\t\tfatal(\"Failed to set uids to %u.\", (u_int) pw->pw_uid);\n}"
  },
  {
    "function_name": "safely_chroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1330-1379",
    "snippet": "static void\nsafely_chroot(const char *path, uid_t uid)\n{\n\tconst char *cp;\n\tchar component[PATH_MAX];\n\tstruct stat st;\n\n\tif (*path != '/')\n\t\tfatal(\"chroot path does not begin at root\");\n\tif (strlen(path) >= sizeof(component))\n\t\tfatal(\"chroot path too long\");\n\n\t/*\n\t * Descend the path, checking that each component is a\n\t * root-owned directory with strict permissions.\n\t */\n\tfor (cp = path; cp != NULL;) {\n\t\tif ((cp = strchr(cp, '/')) == NULL)\n\t\t\tstrlcpy(component, path, sizeof(component));\n\t\telse {\n\t\t\tcp++;\n\t\t\tmemcpy(component, path, cp - path);\n\t\t\tcomponent[cp - path] = '\\0';\n\t\t}\n\t\n\t\tdebug3(\"%s: checking '%s'\", __func__, component);\n\n\t\tif (stat(component, &st) != 0)\n\t\t\tfatal(\"%s: stat(\\\"%s\\\"): %s\", __func__,\n\t\t\t    component, strerror(errno));\n\t\tif (st.st_uid != 0 || (st.st_mode & 022) != 0)\n\t\t\tfatal(\"bad ownership or modes for chroot \"\n\t\t\t    \"directory %s\\\"%s\\\"\", \n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\t\tif (!S_ISDIR(st.st_mode))\n\t\t\tfatal(\"chroot path %s\\\"%s\\\" is not a directory\",\n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\n\t}\n\n\tif (chdir(path) == -1)\n\t\tfatal(\"Unable to chdir to chroot path \\\"%s\\\": \"\n\t\t    \"%s\", path, strerror(errno));\n\tif (chroot(path) == -1)\n\t\tfatal(\"chroot(\\\"%s\\\"): %s\", path, strerror(errno));\n\tif (chdir(\"/\") == -1)\n\t\tfatal(\"%s: chdir(/) after chroot: %s\",\n\t\t    __func__, strerror(errno));\n\tverbose(\"Changed root directory to \\\"%s\\\"\", path);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Changed root directory to \\\"%s\\\"\"",
            "path"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: chdir(/) after chroot: %s\"",
            "__func__",
            "strerror(errno)"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chroot",
          "args": [
            "path"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "path"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "component",
            "&st"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: checking '%s'\"",
            "__func__",
            "component"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "component",
            "path",
            "cp - path"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "component",
            "path",
            "sizeof(component)"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cp",
            "'/'"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsafely_chroot(const char *path, uid_t uid)\n{\n\tconst char *cp;\n\tchar component[PATH_MAX];\n\tstruct stat st;\n\n\tif (*path != '/')\n\t\tfatal(\"chroot path does not begin at root\");\n\tif (strlen(path) >= sizeof(component))\n\t\tfatal(\"chroot path too long\");\n\n\t/*\n\t * Descend the path, checking that each component is a\n\t * root-owned directory with strict permissions.\n\t */\n\tfor (cp = path; cp != NULL;) {\n\t\tif ((cp = strchr(cp, '/')) == NULL)\n\t\t\tstrlcpy(component, path, sizeof(component));\n\t\telse {\n\t\t\tcp++;\n\t\t\tmemcpy(component, path, cp - path);\n\t\t\tcomponent[cp - path] = '\\0';\n\t\t}\n\t\n\t\tdebug3(\"%s: checking '%s'\", __func__, component);\n\n\t\tif (stat(component, &st) != 0)\n\t\t\tfatal(\"%s: stat(\\\"%s\\\"): %s\", __func__,\n\t\t\t    component, strerror(errno));\n\t\tif (st.st_uid != 0 || (st.st_mode & 022) != 0)\n\t\t\tfatal(\"bad ownership or modes for chroot \"\n\t\t\t    \"directory %s\\\"%s\\\"\", \n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\t\tif (!S_ISDIR(st.st_mode))\n\t\t\tfatal(\"chroot path %s\\\"%s\\\" is not a directory\",\n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\n\t}\n\n\tif (chdir(path) == -1)\n\t\tfatal(\"Unable to chdir to chroot path \\\"%s\\\": \"\n\t\t    \"%s\", path, strerror(errno));\n\tif (chroot(path) == -1)\n\t\tfatal(\"chroot(\\\"%s\\\"): %s\", path, strerror(errno));\n\tif (chdir(\"/\") == -1)\n\t\tfatal(\"%s: chdir(/) after chroot: %s\",\n\t\t    __func__, strerror(errno));\n\tverbose(\"Changed root directory to \\\"%s\\\"\", path);\n}"
  },
  {
    "function_name": "do_nologin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1294-1324",
    "snippet": "static void\ndo_nologin(struct passwd *pw)\n{\n\tFILE *f = NULL;\n\tchar buf[1024], *nl, *def_nl = _PATH_NOLOGIN;\n\tstruct stat sb;\n\n#ifdef HAVE_LOGIN_CAP\n\tif (login_getcapbool(lc, \"ignorenologin\", 0) || pw->pw_uid == 0)\n\t\treturn;\n\tnl = login_getcapstr(lc, \"nologin\", def_nl, def_nl);\n#else\n\tif (pw->pw_uid == 0)\n\t\treturn;\n\tnl = def_nl;\n#endif\n\tif (stat(nl, &sb) == -1) {\n\t\tif (nl != def_nl)\n\t\t\tfree(nl);\n\t\treturn;\n\t}\n\n\t/* /etc/nologin exists.  Print its contents if we can and exit. */\n\tlogit(\"User %.100s not allowed because %s exists\", pw->pw_name, nl);\n\tif ((f = fopen(nl, \"r\")) != NULL) {\n\t\twhile (fgets(buf, sizeof(buf), f))\n\t\t\tfputs(buf, stderr);\n\t\tfclose(f);\n\t}\n\texit(254);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "254"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "buf",
            "stderr"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "sizeof(buf)",
            "f"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "nl",
            "\"r\""
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"User %.100s not allowed because %s exists\"",
            "pw->pw_name",
            "nl"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "nl"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "nl",
            "&sb"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "login_getcapstr",
          "args": [
            "lc",
            "\"nologin\"",
            "def_nl",
            "def_nl"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "login_getcapbool",
          "args": [
            "lc",
            "\"ignorenologin\"",
            "0"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndo_nologin(struct passwd *pw)\n{\n\tFILE *f = NULL;\n\tchar buf[1024], *nl, *def_nl = _PATH_NOLOGIN;\n\tstruct stat sb;\n\n#ifdef HAVE_LOGIN_CAP\n\tif (login_getcapbool(lc, \"ignorenologin\", 0) || pw->pw_uid == 0)\n\t\treturn;\n\tnl = login_getcapstr(lc, \"nologin\", def_nl, def_nl);\n#else\n\tif (pw->pw_uid == 0)\n\t\treturn;\n\tnl = def_nl;\n#endif\n\tif (stat(nl, &sb) == -1) {\n\t\tif (nl != def_nl)\n\t\t\tfree(nl);\n\t\treturn;\n\t}\n\n\t/* /etc/nologin exists.  Print its contents if we can and exit. */\n\tlogit(\"User %.100s not allowed because %s exists\", pw->pw_name, nl);\n\tif ((f = fopen(nl, \"r\")) != NULL) {\n\t\twhile (fgets(buf, sizeof(buf), f))\n\t\t\tfputs(buf, stderr);\n\t\tfclose(f);\n\t}\n\texit(254);\n}"
  },
  {
    "function_name": "do_rc_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1225-1292",
    "snippet": "static void\ndo_rc_files(struct ssh *ssh, Session *s, const char *shell)\n{\n\tFILE *f = NULL;\n\tchar cmd[1024];\n\tint do_xauth;\n\tstruct stat st;\n\n\tdo_xauth =\n\t    s->display != NULL && s->auth_proto != NULL && s->auth_data != NULL;\n\n\t/* ignore _PATH_SSH_USER_RC for subsystems and admin forced commands */\n\tif (!s->is_subsystem && options.adm_forced_command == NULL &&\n\t    auth_opts->permit_user_rc && options.permit_user_rc &&\n\t    stat(_PATH_SSH_USER_RC, &st) >= 0) {\n\t\tsnprintf(cmd, sizeof cmd, \"%s -c '%s %s'\",\n\t\t    shell, _PATH_BSHELL, _PATH_SSH_USER_RC);\n\t\tif (debug_flag)\n\t\t\tfprintf(stderr, \"Running %s\\n\", cmd);\n\t\tf = popen(cmd, \"w\");\n\t\tif (f) {\n\t\t\tif (do_xauth)\n\t\t\t\tfprintf(f, \"%s %s\\n\", s->auth_proto,\n\t\t\t\t    s->auth_data);\n\t\t\tpclose(f);\n\t\t} else\n\t\t\tfprintf(stderr, \"Could not run %s\\n\",\n\t\t\t    _PATH_SSH_USER_RC);\n\t} else if (stat(_PATH_SSH_SYSTEM_RC, &st) >= 0) {\n\t\tif (debug_flag)\n\t\t\tfprintf(stderr, \"Running %s %s\\n\", _PATH_BSHELL,\n\t\t\t    _PATH_SSH_SYSTEM_RC);\n\t\tf = popen(_PATH_BSHELL \" \" _PATH_SSH_SYSTEM_RC, \"w\");\n\t\tif (f) {\n\t\t\tif (do_xauth)\n\t\t\t\tfprintf(f, \"%s %s\\n\", s->auth_proto,\n\t\t\t\t    s->auth_data);\n\t\t\tpclose(f);\n\t\t} else\n\t\t\tfprintf(stderr, \"Could not run %s\\n\",\n\t\t\t    _PATH_SSH_SYSTEM_RC);\n\t} else if (do_xauth && options.xauth_location != NULL) {\n\t\t/* Add authority data to .Xauthority if appropriate. */\n\t\tif (debug_flag) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"Running %.500s remove %.100s\\n\",\n\t\t\t    options.xauth_location, s->auth_display);\n\t\t\tfprintf(stderr,\n\t\t\t    \"%.500s add %.100s %.100s %.100s\\n\",\n\t\t\t    options.xauth_location, s->auth_display,\n\t\t\t    s->auth_proto, s->auth_data);\n\t\t}\n\t\tsnprintf(cmd, sizeof cmd, \"%s -q -\",\n\t\t    options.xauth_location);\n\t\tf = popen(cmd, \"w\");\n\t\tif (f) {\n\t\t\tfprintf(f, \"remove %s\\n\",\n\t\t\t    s->auth_display);\n\t\t\tfprintf(f, \"add %s %s %s\\n\",\n\t\t\t    s->auth_display, s->auth_proto,\n\t\t\t    s->auth_data);\n\t\t\tpclose(f);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Could not run %s\\n\",\n\t\t\t    cmd);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "extern ServerOptions options;",
      "extern int debug_flag;",
      "extern struct sshauthopt *auth_opts;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not run %s\\n\"",
            "cmd"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "f"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"add %s %s %s\\n\"",
            "s->auth_display",
            "s->auth_proto",
            "s->auth_data"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"remove %s\\n\"",
            "s->auth_display"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "cmd",
            "\"w\""
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cmd",
            "sizeof cmd",
            "\"%s -q -\"",
            "options.xauth_location"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%.500s add %.100s %.100s %.100s\\n\"",
            "options.xauth_location",
            "s->auth_display",
            "s->auth_proto",
            "s->auth_data"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Running %.500s remove %.100s\\n\"",
            "options.xauth_location",
            "s->auth_display"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not run %s\\n\"",
            "_PATH_SSH_SYSTEM_RC"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "f"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%s %s\\n\"",
            "s->auth_proto",
            "s->auth_data"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "_PATH_BSHELL \" \" _PATH_SSH_SYSTEM_RC",
            "\"w\""
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Running %s %s\\n\"",
            "_PATH_BSHELL",
            "_PATH_SSH_SYSTEM_RC"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "_PATH_SSH_SYSTEM_RC",
            "&st"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not run %s\\n\"",
            "_PATH_SSH_USER_RC"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "f"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%s %s\\n\"",
            "s->auth_proto",
            "s->auth_data"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "cmd",
            "\"w\""
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Running %s\\n\"",
            "cmd"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern int debug_flag;\nextern struct sshauthopt *auth_opts;\n\nstatic void\ndo_rc_files(struct ssh *ssh, Session *s, const char *shell)\n{\n\tFILE *f = NULL;\n\tchar cmd[1024];\n\tint do_xauth;\n\tstruct stat st;\n\n\tdo_xauth =\n\t    s->display != NULL && s->auth_proto != NULL && s->auth_data != NULL;\n\n\t/* ignore _PATH_SSH_USER_RC for subsystems and admin forced commands */\n\tif (!s->is_subsystem && options.adm_forced_command == NULL &&\n\t    auth_opts->permit_user_rc && options.permit_user_rc &&\n\t    stat(_PATH_SSH_USER_RC, &st) >= 0) {\n\t\tsnprintf(cmd, sizeof cmd, \"%s -c '%s %s'\",\n\t\t    shell, _PATH_BSHELL, _PATH_SSH_USER_RC);\n\t\tif (debug_flag)\n\t\t\tfprintf(stderr, \"Running %s\\n\", cmd);\n\t\tf = popen(cmd, \"w\");\n\t\tif (f) {\n\t\t\tif (do_xauth)\n\t\t\t\tfprintf(f, \"%s %s\\n\", s->auth_proto,\n\t\t\t\t    s->auth_data);\n\t\t\tpclose(f);\n\t\t} else\n\t\t\tfprintf(stderr, \"Could not run %s\\n\",\n\t\t\t    _PATH_SSH_USER_RC);\n\t} else if (stat(_PATH_SSH_SYSTEM_RC, &st) >= 0) {\n\t\tif (debug_flag)\n\t\t\tfprintf(stderr, \"Running %s %s\\n\", _PATH_BSHELL,\n\t\t\t    _PATH_SSH_SYSTEM_RC);\n\t\tf = popen(_PATH_BSHELL \" \" _PATH_SSH_SYSTEM_RC, \"w\");\n\t\tif (f) {\n\t\t\tif (do_xauth)\n\t\t\t\tfprintf(f, \"%s %s\\n\", s->auth_proto,\n\t\t\t\t    s->auth_data);\n\t\t\tpclose(f);\n\t\t} else\n\t\t\tfprintf(stderr, \"Could not run %s\\n\",\n\t\t\t    _PATH_SSH_SYSTEM_RC);\n\t} else if (do_xauth && options.xauth_location != NULL) {\n\t\t/* Add authority data to .Xauthority if appropriate. */\n\t\tif (debug_flag) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"Running %.500s remove %.100s\\n\",\n\t\t\t    options.xauth_location, s->auth_display);\n\t\t\tfprintf(stderr,\n\t\t\t    \"%.500s add %.100s %.100s %.100s\\n\",\n\t\t\t    options.xauth_location, s->auth_display,\n\t\t\t    s->auth_proto, s->auth_data);\n\t\t}\n\t\tsnprintf(cmd, sizeof cmd, \"%s -q -\",\n\t\t    options.xauth_location);\n\t\tf = popen(cmd, \"w\");\n\t\tif (f) {\n\t\t\tfprintf(f, \"remove %s\\n\",\n\t\t\t    s->auth_display);\n\t\t\tfprintf(f, \"add %s %s %s\\n\",\n\t\t\t    s->auth_display, s->auth_proto,\n\t\t\t    s->auth_data);\n\t\t\tpclose(f);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Could not run %s\\n\",\n\t\t\t    cmd);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "do_setup_env",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1013-1219",
    "snippet": "static char **\ndo_setup_env(struct ssh *ssh, Session *s, const char *shell)\n{\n\tchar buf[256];\n\tsize_t n;\n\tu_int i, envsize;\n\tchar *ocp, *cp, *value, **env, *laddr;\n\tstruct passwd *pw = s->pw;\n#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)\n\tchar *path = NULL;\n#endif\n\n\t/* Initialize the environment. */\n\tenvsize = 100;\n\tenv = xcalloc(envsize, sizeof(char *));\n\tenv[0] = NULL;\n\n#ifdef HAVE_CYGWIN\n\t/*\n\t * The Windows environment contains some setting which are\n\t * important for a running system. They must not be dropped.\n\t */\n\t{\n\t\tchar **p;\n\n\t\tp = fetch_windows_environment();\n\t\tcopy_environment(p, &env, &envsize);\n\t\tfree_windows_environment(p);\n\t}\n#endif\n\n#ifdef GSSAPI\n\t/* Allow any GSSAPI methods that we've used to alter\n\t * the childs environment as they see fit\n\t */\n\tssh_gssapi_do_child(&env, &envsize);\n#endif\n\n\t/* Set basic environment. */\n\tfor (i = 0; i < s->num_env; i++)\n\t\tchild_set_env(&env, &envsize, s->env[i].name, s->env[i].val);\n\n\tchild_set_env(&env, &envsize, \"USER\", pw->pw_name);\n\tchild_set_env(&env, &envsize, \"LOGNAME\", pw->pw_name);\n#ifdef _AIX\n\tchild_set_env(&env, &envsize, \"LOGIN\", pw->pw_name);\n#endif\n\tchild_set_env(&env, &envsize, \"HOME\", pw->pw_dir);\n#ifdef HAVE_LOGIN_CAP\n\tif (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)\n\t\tchild_set_env(&env, &envsize, \"PATH\", _PATH_STDPATH);\n\telse\n\t\tchild_set_env(&env, &envsize, \"PATH\", getenv(\"PATH\"));\n#else /* HAVE_LOGIN_CAP */\n# ifndef HAVE_CYGWIN\n\t/*\n\t * There's no standard path on Windows. The path contains\n\t * important components pointing to the system directories,\n\t * needed for loading shared libraries. So the path better\n\t * remains intact here.\n\t */\n#  ifdef HAVE_ETC_DEFAULT_LOGIN\n\tread_etc_default_login(&env, &envsize, pw->pw_uid);\n\tpath = child_get_env(env, \"PATH\");\n#  endif /* HAVE_ETC_DEFAULT_LOGIN */\n\tif (path == NULL || *path == '\\0') {\n\t\tchild_set_env(&env, &envsize, \"PATH\",\n\t\t    s->pw->pw_uid == 0 ?  SUPERUSER_PATH : _PATH_STDPATH);\n\t}\n# endif /* HAVE_CYGWIN */\n#endif /* HAVE_LOGIN_CAP */\n\n\tsnprintf(buf, sizeof buf, \"%.200s/%.50s\", _PATH_MAILDIR, pw->pw_name);\n\tchild_set_env(&env, &envsize, \"MAIL\", buf);\n\n\t/* Normal systems set SHELL by default. */\n\tchild_set_env(&env, &envsize, \"SHELL\", shell);\n\n\tif (getenv(\"TZ\"))\n\t\tchild_set_env(&env, &envsize, \"TZ\", getenv(\"TZ\"));\n\tif (s->term)\n\t\tchild_set_env(&env, &envsize, \"TERM\", s->term);\n\tif (s->display)\n\t\tchild_set_env(&env, &envsize, \"DISPLAY\", s->display);\n\n\t/*\n\t * Since we clear KRB5CCNAME at startup, if it's set now then it\n\t * must have been set by a native authentication method (eg AIX or\n\t * SIA), so copy it to the child.\n\t */\n\t{\n\t\tchar *cp;\n\n\t\tif ((cp = getenv(\"KRB5CCNAME\")) != NULL)\n\t\t\tchild_set_env(&env, &envsize, \"KRB5CCNAME\", cp);\n\t}\n\n#ifdef _AIX\n\t{\n\t\tchar *cp;\n\n\t\tif ((cp = getenv(\"AUTHSTATE\")) != NULL)\n\t\t\tchild_set_env(&env, &envsize, \"AUTHSTATE\", cp);\n\t\tread_environment_file(&env, &envsize, \"/etc/environment\",\n\t\t    options.permit_user_env_whitelist);\n\t}\n#endif\n#ifdef KRB5\n\tif (s->authctxt->krb5_ccname)\n\t\tchild_set_env(&env, &envsize, \"KRB5CCNAME\",\n\t\t    s->authctxt->krb5_ccname);\n#endif\n\tif (auth_sock_name != NULL)\n\t\tchild_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,\n\t\t    auth_sock_name);\n\n\n\t/* Set custom environment options from pubkey authentication. */\n\tif (options.permit_user_env) {\n\t\tfor (n = 0 ; n < auth_opts->nenv; n++) {\n\t\t\tocp = xstrdup(auth_opts->env[n]);\n\t\t\tcp = strchr(ocp, '=');\n\t\t\tif (*cp == '=') {\n\t\t\t\t*cp = '\\0';\n\t\t\t\t/* Apply PermitUserEnvironment whitelist */\n\t\t\t\tif (options.permit_user_env_whitelist == NULL ||\n\t\t\t\t    match_pattern_list(ocp,\n\t\t\t\t    options.permit_user_env_whitelist, 0) == 1)\n\t\t\t\t\tchild_set_env(&env, &envsize,\n\t\t\t\t\t    ocp, cp + 1);\n\t\t\t}\n\t\t\tfree(ocp);\n\t\t}\n\t}\n\n\t/* read $HOME/.ssh/environment. */\n\tif (options.permit_user_env) {\n\t\tsnprintf(buf, sizeof buf, \"%.200s/.ssh/environment\",\n\t\t    pw->pw_dir);\n\t\tread_environment_file(&env, &envsize, buf,\n\t\t    options.permit_user_env_whitelist);\n\t}\n\n#ifdef USE_PAM\n\t/*\n\t * Pull in any environment variables that may have\n\t * been set by PAM.\n\t */\n\tif (options.use_pam) {\n\t\tchar **p;\n\n\t\t/*\n\t\t * Don't allow SSH_AUTH_INFO variables posted to PAM to leak\n\t\t * back into the environment.\n\t\t */\n\t\tp = fetch_pam_child_environment();\n\t\tcopy_environment_blacklist(p, &env, &envsize, \"SSH_AUTH_INFO*\");\n\t\tfree_pam_environment(p);\n\n\t\tp = fetch_pam_environment();\n\t\tcopy_environment_blacklist(p, &env, &envsize, \"SSH_AUTH_INFO*\");\n\t\tfree_pam_environment(p);\n\t}\n#endif /* USE_PAM */\n\n\t/* Environment specified by admin */\n\tfor (i = 0; i < options.num_setenv; i++) {\n\t\tcp = xstrdup(options.setenv[i]);\n\t\tif ((value = strchr(cp, '=')) == NULL) {\n\t\t\t/* shouldn't happen; vars are checked in servconf.c */\n\t\t\tfatal(\"Invalid config SetEnv: %s\", options.setenv[i]);\n\t\t}\n\t\t*value++ = '\\0';\n\t\tchild_set_env(&env, &envsize, cp, value);\n\t}\n\n\t/* SSH_CLIENT deprecated */\n\tsnprintf(buf, sizeof buf, \"%.50s %d %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t    ssh_local_port(ssh));\n\tchild_set_env(&env, &envsize, \"SSH_CLIENT\", buf);\n\n\tladdr = get_local_ipaddr(packet_get_connection_in());\n\tsnprintf(buf, sizeof buf, \"%.50s %d %.50s %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t    laddr, ssh_local_port(ssh));\n\tfree(laddr);\n\tchild_set_env(&env, &envsize, \"SSH_CONNECTION\", buf);\n\n\tif (tun_fwd_ifnames != NULL)\n\t\tchild_set_env(&env, &envsize, \"SSH_TUNNEL\", tun_fwd_ifnames);\n\tif (auth_info_file != NULL)\n\t\tchild_set_env(&env, &envsize, \"SSH_USER_AUTH\", auth_info_file);\n\tif (s->ttyfd != -1)\n\t\tchild_set_env(&env, &envsize, \"SSH_TTY\", s->tty);\n\tif (original_command)\n\t\tchild_set_env(&env, &envsize, \"SSH_ORIGINAL_COMMAND\",\n\t\t    original_command);\n\n\tif (debug_flag) {\n\t\t/* dump the environment */\n\t\tfprintf(stderr, \"Environment:\\n\");\n\t\tfor (i = 0; env[i]; i++)\n\t\t\tfprintf(stderr, \"  %.200s\\n\", env[i]);\n\t}\n\treturn env;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "extern ServerOptions options;",
      "extern int debug_flag;",
      "extern struct sshauthopt *auth_opts;",
      "char *tun_fwd_ifnames;",
      "const char *original_command = NULL;",
      "static char *auth_info_file = NULL;",
      "static char *auth_sock_name = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  %.200s\\n\"",
            "env[i]"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Environment:\\n\""
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "child_set_env",
          "args": [
            "&env",
            "&envsize",
            "\"SSH_ORIGINAL_COMMAND\"",
            "original_command"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "child_set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1851-1905",
          "snippet": "void\nchild_set_env(char ***envp, u_int *envsizep, const char *name,\n\tconst char *value)\n{\n\tchar **env;\n\tu_int envsize;\n\tu_int i, namelen;\n\n\tif (strchr(name, '=') != NULL) {\n\t\terror(\"Invalid environment variable \\\"%.100s\\\"\", name);\n\t\treturn;\n\t}\n\n\t/*\n\t * If we're passed an uninitialized list, allocate a single null\n\t * entry before continuing.\n\t */\n\tif (*envp == NULL && *envsizep == 0) {\n\t\t*envp = xmalloc(sizeof(char *));\n\t\t*envp[0] = NULL;\n\t\t*envsizep = 1;\n\t}\n\n\t/*\n\t * Find the slot where the value should be stored.  If the variable\n\t * already exists, we reuse the slot; otherwise we append a new slot\n\t * at the end of the array, expanding if necessary.\n\t */\n\tenv = *envp;\n\tnamelen = strlen(name);\n\tfor (i = 0; env[i]; i++)\n\t\tif (strncmp(env[i], name, namelen) == 0 && env[i][namelen] == '=')\n\t\t\tbreak;\n\tif (env[i]) {\n\t\t/* Reuse the slot. */\n\t\tfree(env[i]);\n\t} else {\n\t\t/* New variable.  Expand if necessary. */\n\t\tenvsize = *envsizep;\n\t\tif (i >= envsize - 1) {\n\t\t\tif (envsize >= 1000)\n\t\t\t\tfatal(\"child_set_env: too many env vars\");\n\t\t\tenvsize += 50;\n\t\t\tenv = (*envp) = xreallocarray(env, envsize, sizeof(char *));\n\t\t\t*envsizep = envsize;\n\t\t}\n\t\t/* Need to set the NULL pointer at end of array beyond the new slot. */\n\t\tenv[i + 1] = NULL;\n\t}\n\n\t/* Allocate space and format the variable in the appropriate slot. */\n\t/* XXX xasprintf */\n\tenv[i] = xmalloc(strlen(name) + 1 + strlen(value) + 1);\n\tsnprintf(env[i], strlen(name) + 1 + strlen(value) + 1, \"%s=%s\", name, value);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nchild_set_env(char ***envp, u_int *envsizep, const char *name,\n\tconst char *value)\n{\n\tchar **env;\n\tu_int envsize;\n\tu_int i, namelen;\n\n\tif (strchr(name, '=') != NULL) {\n\t\terror(\"Invalid environment variable \\\"%.100s\\\"\", name);\n\t\treturn;\n\t}\n\n\t/*\n\t * If we're passed an uninitialized list, allocate a single null\n\t * entry before continuing.\n\t */\n\tif (*envp == NULL && *envsizep == 0) {\n\t\t*envp = xmalloc(sizeof(char *));\n\t\t*envp[0] = NULL;\n\t\t*envsizep = 1;\n\t}\n\n\t/*\n\t * Find the slot where the value should be stored.  If the variable\n\t * already exists, we reuse the slot; otherwise we append a new slot\n\t * at the end of the array, expanding if necessary.\n\t */\n\tenv = *envp;\n\tnamelen = strlen(name);\n\tfor (i = 0; env[i]; i++)\n\t\tif (strncmp(env[i], name, namelen) == 0 && env[i][namelen] == '=')\n\t\t\tbreak;\n\tif (env[i]) {\n\t\t/* Reuse the slot. */\n\t\tfree(env[i]);\n\t} else {\n\t\t/* New variable.  Expand if necessary. */\n\t\tenvsize = *envsizep;\n\t\tif (i >= envsize - 1) {\n\t\t\tif (envsize >= 1000)\n\t\t\t\tfatal(\"child_set_env: too many env vars\");\n\t\t\tenvsize += 50;\n\t\t\tenv = (*envp) = xreallocarray(env, envsize, sizeof(char *));\n\t\t\t*envsizep = envsize;\n\t\t}\n\t\t/* Need to set the NULL pointer at end of array beyond the new slot. */\n\t\tenv[i + 1] = NULL;\n\t}\n\n\t/* Allocate space and format the variable in the appropriate slot. */\n\t/* XXX xasprintf */\n\tenv[i] = xmalloc(strlen(name) + 1 + strlen(value) + 1);\n\tsnprintf(env[i], strlen(name) + 1 + strlen(value) + 1, \"%s=%s\", name, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "laddr"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof buf",
            "\"%.50s %d %.50s %d\"",
            "ssh_remote_ipaddr(ssh)",
            "ssh_remote_port(ssh)",
            "laddr",
            "ssh_local_port(ssh)"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_local_port",
          "args": [
            "ssh"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_local_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "560-565",
          "snippet": "int\nssh_local_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->local_port;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_local_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->local_port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_port",
          "args": [
            "ssh"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "539-544",
          "snippet": "int\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_local_ipaddr",
          "args": [
            "packet_get_connection_in()"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "get_local_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "123-131",
          "snippet": "char *\nget_local_ipaddr(int sock)\n{\n\tchar *p;\n\n\tif ((p = get_socket_address(sock, 0, NI_NUMERICHOST)) != NULL)\n\t\treturn p;\n\treturn xstrdup(\"UNKNOWN\");\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nget_local_ipaddr(int sock)\n{\n\tchar *p;\n\n\tif ((p = get_socket_address(sock, 0, NI_NUMERICHOST)) != NULL)\n\t\treturn p;\n\treturn xstrdup(\"UNKNOWN\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_connection_in",
          "args": [],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Invalid config SetEnv: %s\"",
            "options.setenv[i]"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cp",
            "'='"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "options.setenv[i]"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_pam_environment",
          "args": [
            "p"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "free_pam_environment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "1209-1220",
          "snippet": "void\nfree_pam_environment(char **env)\n{\n\tchar **envp;\n\n\tif (env == NULL)\n\t\treturn;\n\n\tfor (envp = env; *envp; envp++)\n\t\tfree(*envp);\n\tfree(env);\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfree_pam_environment(char **env)\n{\n\tchar **envp;\n\n\tif (env == NULL)\n\t\treturn;\n\n\tfor (envp = env; *envp; envp++)\n\t\tfree(*envp);\n\tfree(env);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_environment_blacklist",
          "args": [
            "p",
            "&env",
            "&envsize",
            "\"SSH_AUTH_INFO*\""
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "copy_environment_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "979-1005",
          "snippet": "static void\ncopy_environment_blacklist(char **source, char ***env, u_int *envsize,\n    const char *blacklist)\n{\n\tchar *var_name, *var_val;\n\tint i;\n\n\tif (source == NULL)\n\t\treturn;\n\n\tfor(i = 0; source[i] != NULL; i++) {\n\t\tvar_name = xstrdup(source[i]);\n\t\tif ((var_val = strstr(var_name, \"=\")) == NULL) {\n\t\t\tfree(var_name);\n\t\t\tcontinue;\n\t\t}\n\t\t*var_val++ = '\\0';\n\n\t\tif (blacklist == NULL ||\n\t\t    match_pattern_list(var_name, blacklist, 0) != 1) {\n\t\t\tdebug3(\"Copy environment: %s=%s\", var_name, var_val);\n\t\t\tchild_set_env(env, envsize, var_name, var_val);\n\t\t}\n\n\t\tfree(var_name);\n\t}\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ncopy_environment_blacklist(char **source, char ***env, u_int *envsize,\n    const char *blacklist)\n{\n\tchar *var_name, *var_val;\n\tint i;\n\n\tif (source == NULL)\n\t\treturn;\n\n\tfor(i = 0; source[i] != NULL; i++) {\n\t\tvar_name = xstrdup(source[i]);\n\t\tif ((var_val = strstr(var_name, \"=\")) == NULL) {\n\t\t\tfree(var_name);\n\t\t\tcontinue;\n\t\t}\n\t\t*var_val++ = '\\0';\n\n\t\tif (blacklist == NULL ||\n\t\t    match_pattern_list(var_name, blacklist, 0) != 1) {\n\t\t\tdebug3(\"Copy environment: %s=%s\", var_name, var_val);\n\t\t\tchild_set_env(env, envsize, var_name, var_val);\n\t\t}\n\n\t\tfree(var_name);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_pam_environment",
          "args": [],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_pam_environment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "1203-1207",
          "snippet": "char **\nfetch_pam_environment(void)\n{\n\treturn (pam_getenvlist(sshpam_handle));\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar **\nfetch_pam_environment(void)\n{\n\treturn (pam_getenvlist(sshpam_handle));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_pam_child_environment",
          "args": [],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_pam_child_environment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "1197-1201",
          "snippet": "char **\nfetch_pam_child_environment(void)\n{\n\treturn sshpam_env;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar **\nfetch_pam_child_environment(void)\n{\n\treturn sshpam_env;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_environment_file",
          "args": [
            "&env",
            "&envsize",
            "buf",
            "options.permit_user_env_whitelist"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "read_environment_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "879-921",
          "snippet": "static void\nread_environment_file(char ***env, u_int *envsize,\n\tconst char *filename, const char *whitelist)\n{\n\tFILE *f;\n\tchar *line = NULL, *cp, *value;\n\tsize_t linesize = 0;\n\tu_int lineno = 0;\n\n\tf = fopen(filename, \"r\");\n\tif (!f)\n\t\treturn;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tif (++lineno > 1000)\n\t\t\tfatal(\"Too many lines in environment file %s\", filename);\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (!*cp || *cp == '#' || *cp == '\\n')\n\t\t\tcontinue;\n\n\t\tcp[strcspn(cp, \"\\n\")] = '\\0';\n\n\t\tvalue = strchr(cp, '=');\n\t\tif (value == NULL) {\n\t\t\tfprintf(stderr, \"Bad line %u in %.100s\\n\", lineno,\n\t\t\t    filename);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Replace the equals sign by nul, and advance value to\n\t\t * the value string.\n\t\t */\n\t\t*value = '\\0';\n\t\tvalue++;\n\t\tif (whitelist != NULL &&\n\t\t    match_pattern_list(cp, whitelist, 0) != 1)\n\t\t\tcontinue;\n\t\tchild_set_env(env, envsize, cp, value);\n\t}\n\tfree(line);\n\tfclose(f);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nread_environment_file(char ***env, u_int *envsize,\n\tconst char *filename, const char *whitelist)\n{\n\tFILE *f;\n\tchar *line = NULL, *cp, *value;\n\tsize_t linesize = 0;\n\tu_int lineno = 0;\n\n\tf = fopen(filename, \"r\");\n\tif (!f)\n\t\treturn;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tif (++lineno > 1000)\n\t\t\tfatal(\"Too many lines in environment file %s\", filename);\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (!*cp || *cp == '#' || *cp == '\\n')\n\t\t\tcontinue;\n\n\t\tcp[strcspn(cp, \"\\n\")] = '\\0';\n\n\t\tvalue = strchr(cp, '=');\n\t\tif (value == NULL) {\n\t\t\tfprintf(stderr, \"Bad line %u in %.100s\\n\", lineno,\n\t\t\t    filename);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Replace the equals sign by nul, and advance value to\n\t\t * the value string.\n\t\t */\n\t\t*value = '\\0';\n\t\tvalue++;\n\t\tif (whitelist != NULL &&\n\t\t    match_pattern_list(cp, whitelist, 0) != 1)\n\t\t\tcontinue;\n\t\tchild_set_env(env, envsize, cp, value);\n\t}\n\tfree(line);\n\tfclose(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_pattern_list",
          "args": [
            "ocp",
            "options.permit_user_env_whitelist",
            "0"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "120-171",
          "snippet": "int\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"AUTHSTATE\""
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "pam_getenvlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "254-263",
          "snippet": "static char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "child_get_env",
          "args": [
            "env",
            "\"PATH\""
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "child_get_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "927-938",
          "snippet": "static char *\nchild_get_env(char **env, const char *name)\n{\n\tint i;\n\tsize_t len;\n\n\tlen = strlen(name);\n\tfor (i=0; env[i] != NULL; i++)\n\t\tif (strncmp(name, env[i], len) == 0 && env[i][len] == '=')\n\t\t\treturn(env[i] + len + 1);\n\treturn NULL;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nchild_get_env(char **env, const char *name)\n{\n\tint i;\n\tsize_t len;\n\n\tlen = strlen(name);\n\tfor (i=0; env[i] != NULL; i++)\n\t\tif (strncmp(name, env[i], len) == 0 && env[i][len] == '=')\n\t\t\treturn(env[i] + len + 1);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_etc_default_login",
          "args": [
            "&env",
            "&envsize",
            "pw->pw_uid"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "read_etc_default_login",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "944-976",
          "snippet": "static void\nread_etc_default_login(char ***env, u_int *envsize, uid_t uid)\n{\n\tchar **tmpenv = NULL, *var;\n\tu_int i, tmpenvsize = 0;\n\tu_long mask;\n\n\t/*\n\t * We don't want to copy the whole file to the child's environment,\n\t * so we use a temporary environment and copy the variables we're\n\t * interested in.\n\t */\n\tread_environment_file(&tmpenv, &tmpenvsize, \"/etc/default/login\",\n\t    options.permit_user_env_whitelist);\n\n\tif (tmpenv == NULL)\n\t\treturn;\n\n\tif (uid == 0)\n\t\tvar = child_get_env(tmpenv, \"SUPATH\");\n\telse\n\t\tvar = child_get_env(tmpenv, \"PATH\");\n\tif (var != NULL)\n\t\tchild_set_env(env, envsize, \"PATH\", var);\n\n\tif ((var = child_get_env(tmpenv, \"UMASK\")) != NULL)\n\t\tif (sscanf(var, \"%5lo\", &mask) == 1)\n\t\t\tumask((mode_t)mask);\n\n\tfor (i = 0; tmpenv[i] != NULL; i++)\n\t\tfree(tmpenv[i]);\n\tfree(tmpenv);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic void\nread_etc_default_login(char ***env, u_int *envsize, uid_t uid)\n{\n\tchar **tmpenv = NULL, *var;\n\tu_int i, tmpenvsize = 0;\n\tu_long mask;\n\n\t/*\n\t * We don't want to copy the whole file to the child's environment,\n\t * so we use a temporary environment and copy the variables we're\n\t * interested in.\n\t */\n\tread_environment_file(&tmpenv, &tmpenvsize, \"/etc/default/login\",\n\t    options.permit_user_env_whitelist);\n\n\tif (tmpenv == NULL)\n\t\treturn;\n\n\tif (uid == 0)\n\t\tvar = child_get_env(tmpenv, \"SUPATH\");\n\telse\n\t\tvar = child_get_env(tmpenv, \"PATH\");\n\tif (var != NULL)\n\t\tchild_set_env(env, envsize, \"PATH\", var);\n\n\tif ((var = child_get_env(tmpenv, \"UMASK\")) != NULL)\n\t\tif (sscanf(var, \"%5lo\", &mask) == 1)\n\t\t\tumask((mode_t)mask);\n\n\tfor (i = 0; tmpenv[i] != NULL; i++)\n\t\tfree(tmpenv[i]);\n\tfree(tmpenv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setusercontext",
          "args": [
            "lc",
            "pw",
            "pw->pw_uid",
            "LOGIN_SETPATH"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_do_child",
          "args": [
            "&env",
            "&envsize"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_do_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-serv.c",
          "lines": "344-355",
          "snippet": "void\nssh_gssapi_do_child(char ***envp, u_int *envsizep)\n{\n\n\tif (gssapi_client.store.envvar != NULL &&\n\t    gssapi_client.store.envval != NULL) {\n\t\tdebug(\"Setting %s to %s\", gssapi_client.store.envvar,\n\t\t    gssapi_client.store.envval);\n\t\tchild_set_env(envp, envsizep, gssapi_client.store.envvar,\n\t\t    gssapi_client.store.envval);\n\t}\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_gssapi_do_child(char ***envp, u_int *envsizep)\n{\n\n\tif (gssapi_client.store.envvar != NULL &&\n\t    gssapi_client.store.envval != NULL) {\n\t\tdebug(\"Setting %s to %s\", gssapi_client.store.envvar,\n\t\t    gssapi_client.store.envval);\n\t\tchild_set_env(envp, envsizep, gssapi_client.store.envvar,\n\t\t    gssapi_client.store.envval);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_windows_environment",
          "args": [
            "p"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "free_windows_environment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-cygwin_util.c",
          "lines": "114-118",
          "snippet": "void\nfree_windows_environment(char **p)\n{\n\tfree(p);\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfree_windows_environment(char **p)\n{\n\tfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_environment",
          "args": [
            "p",
            "&env",
            "&envsize"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "copy_environment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1007-1011",
          "snippet": "void\ncopy_environment(char **source, char ***env, u_int *envsize)\n{\n\tcopy_environment_blacklist(source, env, envsize, NULL);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ncopy_environment(char **source, char ***env, u_int *envsize)\n{\n\tcopy_environment_blacklist(source, env, envsize, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_windows_environment",
          "args": [],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_windows_environment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-cygwin_util.c",
          "lines": "97-112",
          "snippet": "char **\nfetch_windows_environment(void)\n{\n\tchar **e, **p;\n\tunsigned int i, idx = 0;\n\n\tp = xcalloc(WENV_SIZ + 1, sizeof(char *));\n\tfor (e = environ; *e != NULL; ++e) {\n\t\tfor (i = 0; i < WENV_SIZ; ++i) {\n\t\t\tif (!strncmp(*e, wenv_arr[i].name, wenv_arr[i].namelen))\n\t\t\t\tp[idx++] = *e;\n\t\t}\n\t}\n\tp[idx] = NULL;\n\treturn p;\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define WENV_SIZ (sizeof (wenv_arr) / sizeof (wenv_arr[0]))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define WENV_SIZ (sizeof (wenv_arr) / sizeof (wenv_arr[0]))\n\nchar **\nfetch_windows_environment(void)\n{\n\tchar **e, **p;\n\tunsigned int i, idx = 0;\n\n\tp = xcalloc(WENV_SIZ + 1, sizeof(char *));\n\tfor (e = environ; *e != NULL; ++e) {\n\t\tfor (i = 0; i < WENV_SIZ; ++i) {\n\t\t\tif (!strncmp(*e, wenv_arr[i].name, wenv_arr[i].namelen))\n\t\t\t\tp[idx++] = *e;\n\t\t}\n\t}\n\tp[idx] = NULL;\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "envsize",
            "sizeof(char *)"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern int debug_flag;\nextern struct sshauthopt *auth_opts;\nchar *tun_fwd_ifnames;\nconst char *original_command = NULL;\nstatic char *auth_info_file = NULL;\nstatic char *auth_sock_name = NULL;\n\nstatic char **\ndo_setup_env(struct ssh *ssh, Session *s, const char *shell)\n{\n\tchar buf[256];\n\tsize_t n;\n\tu_int i, envsize;\n\tchar *ocp, *cp, *value, **env, *laddr;\n\tstruct passwd *pw = s->pw;\n#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)\n\tchar *path = NULL;\n#endif\n\n\t/* Initialize the environment. */\n\tenvsize = 100;\n\tenv = xcalloc(envsize, sizeof(char *));\n\tenv[0] = NULL;\n\n#ifdef HAVE_CYGWIN\n\t/*\n\t * The Windows environment contains some setting which are\n\t * important for a running system. They must not be dropped.\n\t */\n\t{\n\t\tchar **p;\n\n\t\tp = fetch_windows_environment();\n\t\tcopy_environment(p, &env, &envsize);\n\t\tfree_windows_environment(p);\n\t}\n#endif\n\n#ifdef GSSAPI\n\t/* Allow any GSSAPI methods that we've used to alter\n\t * the childs environment as they see fit\n\t */\n\tssh_gssapi_do_child(&env, &envsize);\n#endif\n\n\t/* Set basic environment. */\n\tfor (i = 0; i < s->num_env; i++)\n\t\tchild_set_env(&env, &envsize, s->env[i].name, s->env[i].val);\n\n\tchild_set_env(&env, &envsize, \"USER\", pw->pw_name);\n\tchild_set_env(&env, &envsize, \"LOGNAME\", pw->pw_name);\n#ifdef _AIX\n\tchild_set_env(&env, &envsize, \"LOGIN\", pw->pw_name);\n#endif\n\tchild_set_env(&env, &envsize, \"HOME\", pw->pw_dir);\n#ifdef HAVE_LOGIN_CAP\n\tif (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)\n\t\tchild_set_env(&env, &envsize, \"PATH\", _PATH_STDPATH);\n\telse\n\t\tchild_set_env(&env, &envsize, \"PATH\", getenv(\"PATH\"));\n#else /* HAVE_LOGIN_CAP */\n# ifndef HAVE_CYGWIN\n\t/*\n\t * There's no standard path on Windows. The path contains\n\t * important components pointing to the system directories,\n\t * needed for loading shared libraries. So the path better\n\t * remains intact here.\n\t */\n#  ifdef HAVE_ETC_DEFAULT_LOGIN\n\tread_etc_default_login(&env, &envsize, pw->pw_uid);\n\tpath = child_get_env(env, \"PATH\");\n#  endif /* HAVE_ETC_DEFAULT_LOGIN */\n\tif (path == NULL || *path == '\\0') {\n\t\tchild_set_env(&env, &envsize, \"PATH\",\n\t\t    s->pw->pw_uid == 0 ?  SUPERUSER_PATH : _PATH_STDPATH);\n\t}\n# endif /* HAVE_CYGWIN */\n#endif /* HAVE_LOGIN_CAP */\n\n\tsnprintf(buf, sizeof buf, \"%.200s/%.50s\", _PATH_MAILDIR, pw->pw_name);\n\tchild_set_env(&env, &envsize, \"MAIL\", buf);\n\n\t/* Normal systems set SHELL by default. */\n\tchild_set_env(&env, &envsize, \"SHELL\", shell);\n\n\tif (getenv(\"TZ\"))\n\t\tchild_set_env(&env, &envsize, \"TZ\", getenv(\"TZ\"));\n\tif (s->term)\n\t\tchild_set_env(&env, &envsize, \"TERM\", s->term);\n\tif (s->display)\n\t\tchild_set_env(&env, &envsize, \"DISPLAY\", s->display);\n\n\t/*\n\t * Since we clear KRB5CCNAME at startup, if it's set now then it\n\t * must have been set by a native authentication method (eg AIX or\n\t * SIA), so copy it to the child.\n\t */\n\t{\n\t\tchar *cp;\n\n\t\tif ((cp = getenv(\"KRB5CCNAME\")) != NULL)\n\t\t\tchild_set_env(&env, &envsize, \"KRB5CCNAME\", cp);\n\t}\n\n#ifdef _AIX\n\t{\n\t\tchar *cp;\n\n\t\tif ((cp = getenv(\"AUTHSTATE\")) != NULL)\n\t\t\tchild_set_env(&env, &envsize, \"AUTHSTATE\", cp);\n\t\tread_environment_file(&env, &envsize, \"/etc/environment\",\n\t\t    options.permit_user_env_whitelist);\n\t}\n#endif\n#ifdef KRB5\n\tif (s->authctxt->krb5_ccname)\n\t\tchild_set_env(&env, &envsize, \"KRB5CCNAME\",\n\t\t    s->authctxt->krb5_ccname);\n#endif\n\tif (auth_sock_name != NULL)\n\t\tchild_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,\n\t\t    auth_sock_name);\n\n\n\t/* Set custom environment options from pubkey authentication. */\n\tif (options.permit_user_env) {\n\t\tfor (n = 0 ; n < auth_opts->nenv; n++) {\n\t\t\tocp = xstrdup(auth_opts->env[n]);\n\t\t\tcp = strchr(ocp, '=');\n\t\t\tif (*cp == '=') {\n\t\t\t\t*cp = '\\0';\n\t\t\t\t/* Apply PermitUserEnvironment whitelist */\n\t\t\t\tif (options.permit_user_env_whitelist == NULL ||\n\t\t\t\t    match_pattern_list(ocp,\n\t\t\t\t    options.permit_user_env_whitelist, 0) == 1)\n\t\t\t\t\tchild_set_env(&env, &envsize,\n\t\t\t\t\t    ocp, cp + 1);\n\t\t\t}\n\t\t\tfree(ocp);\n\t\t}\n\t}\n\n\t/* read $HOME/.ssh/environment. */\n\tif (options.permit_user_env) {\n\t\tsnprintf(buf, sizeof buf, \"%.200s/.ssh/environment\",\n\t\t    pw->pw_dir);\n\t\tread_environment_file(&env, &envsize, buf,\n\t\t    options.permit_user_env_whitelist);\n\t}\n\n#ifdef USE_PAM\n\t/*\n\t * Pull in any environment variables that may have\n\t * been set by PAM.\n\t */\n\tif (options.use_pam) {\n\t\tchar **p;\n\n\t\t/*\n\t\t * Don't allow SSH_AUTH_INFO variables posted to PAM to leak\n\t\t * back into the environment.\n\t\t */\n\t\tp = fetch_pam_child_environment();\n\t\tcopy_environment_blacklist(p, &env, &envsize, \"SSH_AUTH_INFO*\");\n\t\tfree_pam_environment(p);\n\n\t\tp = fetch_pam_environment();\n\t\tcopy_environment_blacklist(p, &env, &envsize, \"SSH_AUTH_INFO*\");\n\t\tfree_pam_environment(p);\n\t}\n#endif /* USE_PAM */\n\n\t/* Environment specified by admin */\n\tfor (i = 0; i < options.num_setenv; i++) {\n\t\tcp = xstrdup(options.setenv[i]);\n\t\tif ((value = strchr(cp, '=')) == NULL) {\n\t\t\t/* shouldn't happen; vars are checked in servconf.c */\n\t\t\tfatal(\"Invalid config SetEnv: %s\", options.setenv[i]);\n\t\t}\n\t\t*value++ = '\\0';\n\t\tchild_set_env(&env, &envsize, cp, value);\n\t}\n\n\t/* SSH_CLIENT deprecated */\n\tsnprintf(buf, sizeof buf, \"%.50s %d %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t    ssh_local_port(ssh));\n\tchild_set_env(&env, &envsize, \"SSH_CLIENT\", buf);\n\n\tladdr = get_local_ipaddr(packet_get_connection_in());\n\tsnprintf(buf, sizeof buf, \"%.50s %d %.50s %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t    laddr, ssh_local_port(ssh));\n\tfree(laddr);\n\tchild_set_env(&env, &envsize, \"SSH_CONNECTION\", buf);\n\n\tif (tun_fwd_ifnames != NULL)\n\t\tchild_set_env(&env, &envsize, \"SSH_TUNNEL\", tun_fwd_ifnames);\n\tif (auth_info_file != NULL)\n\t\tchild_set_env(&env, &envsize, \"SSH_USER_AUTH\", auth_info_file);\n\tif (s->ttyfd != -1)\n\t\tchild_set_env(&env, &envsize, \"SSH_TTY\", s->tty);\n\tif (original_command)\n\t\tchild_set_env(&env, &envsize, \"SSH_ORIGINAL_COMMAND\",\n\t\t    original_command);\n\n\tif (debug_flag) {\n\t\t/* dump the environment */\n\t\tfprintf(stderr, \"Environment:\\n\");\n\t\tfor (i = 0; env[i]; i++)\n\t\t\tfprintf(stderr, \"  %.200s\\n\", env[i]);\n\t}\n\treturn env;\n}"
  },
  {
    "function_name": "copy_environment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "1007-1011",
    "snippet": "void\ncopy_environment(char **source, char ***env, u_int *envsize)\n{\n\tcopy_environment_blacklist(source, env, envsize, NULL);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_environment_blacklist",
          "args": [
            "source",
            "env",
            "envsize",
            "NULL"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "copy_environment_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "979-1005",
          "snippet": "static void\ncopy_environment_blacklist(char **source, char ***env, u_int *envsize,\n    const char *blacklist)\n{\n\tchar *var_name, *var_val;\n\tint i;\n\n\tif (source == NULL)\n\t\treturn;\n\n\tfor(i = 0; source[i] != NULL; i++) {\n\t\tvar_name = xstrdup(source[i]);\n\t\tif ((var_val = strstr(var_name, \"=\")) == NULL) {\n\t\t\tfree(var_name);\n\t\t\tcontinue;\n\t\t}\n\t\t*var_val++ = '\\0';\n\n\t\tif (blacklist == NULL ||\n\t\t    match_pattern_list(var_name, blacklist, 0) != 1) {\n\t\t\tdebug3(\"Copy environment: %s=%s\", var_name, var_val);\n\t\t\tchild_set_env(env, envsize, var_name, var_val);\n\t\t}\n\n\t\tfree(var_name);\n\t}\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ncopy_environment_blacklist(char **source, char ***env, u_int *envsize,\n    const char *blacklist)\n{\n\tchar *var_name, *var_val;\n\tint i;\n\n\tif (source == NULL)\n\t\treturn;\n\n\tfor(i = 0; source[i] != NULL; i++) {\n\t\tvar_name = xstrdup(source[i]);\n\t\tif ((var_val = strstr(var_name, \"=\")) == NULL) {\n\t\t\tfree(var_name);\n\t\t\tcontinue;\n\t\t}\n\t\t*var_val++ = '\\0';\n\n\t\tif (blacklist == NULL ||\n\t\t    match_pattern_list(var_name, blacklist, 0) != 1) {\n\t\t\tdebug3(\"Copy environment: %s=%s\", var_name, var_val);\n\t\t\tchild_set_env(env, envsize, var_name, var_val);\n\t\t}\n\n\t\tfree(var_name);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ncopy_environment(char **source, char ***env, u_int *envsize)\n{\n\tcopy_environment_blacklist(source, env, envsize, NULL);\n}"
  },
  {
    "function_name": "copy_environment_blacklist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "979-1005",
    "snippet": "static void\ncopy_environment_blacklist(char **source, char ***env, u_int *envsize,\n    const char *blacklist)\n{\n\tchar *var_name, *var_val;\n\tint i;\n\n\tif (source == NULL)\n\t\treturn;\n\n\tfor(i = 0; source[i] != NULL; i++) {\n\t\tvar_name = xstrdup(source[i]);\n\t\tif ((var_val = strstr(var_name, \"=\")) == NULL) {\n\t\t\tfree(var_name);\n\t\t\tcontinue;\n\t\t}\n\t\t*var_val++ = '\\0';\n\n\t\tif (blacklist == NULL ||\n\t\t    match_pattern_list(var_name, blacklist, 0) != 1) {\n\t\t\tdebug3(\"Copy environment: %s=%s\", var_name, var_val);\n\t\t\tchild_set_env(env, envsize, var_name, var_val);\n\t\t}\n\n\t\tfree(var_name);\n\t}\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "var_name"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "child_set_env",
          "args": [
            "env",
            "envsize",
            "var_name",
            "var_val"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "child_set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1851-1905",
          "snippet": "void\nchild_set_env(char ***envp, u_int *envsizep, const char *name,\n\tconst char *value)\n{\n\tchar **env;\n\tu_int envsize;\n\tu_int i, namelen;\n\n\tif (strchr(name, '=') != NULL) {\n\t\terror(\"Invalid environment variable \\\"%.100s\\\"\", name);\n\t\treturn;\n\t}\n\n\t/*\n\t * If we're passed an uninitialized list, allocate a single null\n\t * entry before continuing.\n\t */\n\tif (*envp == NULL && *envsizep == 0) {\n\t\t*envp = xmalloc(sizeof(char *));\n\t\t*envp[0] = NULL;\n\t\t*envsizep = 1;\n\t}\n\n\t/*\n\t * Find the slot where the value should be stored.  If the variable\n\t * already exists, we reuse the slot; otherwise we append a new slot\n\t * at the end of the array, expanding if necessary.\n\t */\n\tenv = *envp;\n\tnamelen = strlen(name);\n\tfor (i = 0; env[i]; i++)\n\t\tif (strncmp(env[i], name, namelen) == 0 && env[i][namelen] == '=')\n\t\t\tbreak;\n\tif (env[i]) {\n\t\t/* Reuse the slot. */\n\t\tfree(env[i]);\n\t} else {\n\t\t/* New variable.  Expand if necessary. */\n\t\tenvsize = *envsizep;\n\t\tif (i >= envsize - 1) {\n\t\t\tif (envsize >= 1000)\n\t\t\t\tfatal(\"child_set_env: too many env vars\");\n\t\t\tenvsize += 50;\n\t\t\tenv = (*envp) = xreallocarray(env, envsize, sizeof(char *));\n\t\t\t*envsizep = envsize;\n\t\t}\n\t\t/* Need to set the NULL pointer at end of array beyond the new slot. */\n\t\tenv[i + 1] = NULL;\n\t}\n\n\t/* Allocate space and format the variable in the appropriate slot. */\n\t/* XXX xasprintf */\n\tenv[i] = xmalloc(strlen(name) + 1 + strlen(value) + 1);\n\tsnprintf(env[i], strlen(name) + 1 + strlen(value) + 1, \"%s=%s\", name, value);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nchild_set_env(char ***envp, u_int *envsizep, const char *name,\n\tconst char *value)\n{\n\tchar **env;\n\tu_int envsize;\n\tu_int i, namelen;\n\n\tif (strchr(name, '=') != NULL) {\n\t\terror(\"Invalid environment variable \\\"%.100s\\\"\", name);\n\t\treturn;\n\t}\n\n\t/*\n\t * If we're passed an uninitialized list, allocate a single null\n\t * entry before continuing.\n\t */\n\tif (*envp == NULL && *envsizep == 0) {\n\t\t*envp = xmalloc(sizeof(char *));\n\t\t*envp[0] = NULL;\n\t\t*envsizep = 1;\n\t}\n\n\t/*\n\t * Find the slot where the value should be stored.  If the variable\n\t * already exists, we reuse the slot; otherwise we append a new slot\n\t * at the end of the array, expanding if necessary.\n\t */\n\tenv = *envp;\n\tnamelen = strlen(name);\n\tfor (i = 0; env[i]; i++)\n\t\tif (strncmp(env[i], name, namelen) == 0 && env[i][namelen] == '=')\n\t\t\tbreak;\n\tif (env[i]) {\n\t\t/* Reuse the slot. */\n\t\tfree(env[i]);\n\t} else {\n\t\t/* New variable.  Expand if necessary. */\n\t\tenvsize = *envsizep;\n\t\tif (i >= envsize - 1) {\n\t\t\tif (envsize >= 1000)\n\t\t\t\tfatal(\"child_set_env: too many env vars\");\n\t\t\tenvsize += 50;\n\t\t\tenv = (*envp) = xreallocarray(env, envsize, sizeof(char *));\n\t\t\t*envsizep = envsize;\n\t\t}\n\t\t/* Need to set the NULL pointer at end of array beyond the new slot. */\n\t\tenv[i + 1] = NULL;\n\t}\n\n\t/* Allocate space and format the variable in the appropriate slot. */\n\t/* XXX xasprintf */\n\tenv[i] = xmalloc(strlen(name) + 1 + strlen(value) + 1);\n\tsnprintf(env[i], strlen(name) + 1 + strlen(value) + 1, \"%s=%s\", name, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Copy environment: %s=%s\"",
            "var_name",
            "var_val"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_pattern_list",
          "args": [
            "var_name",
            "blacklist",
            "0"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "120-171",
          "snippet": "int\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "var_name",
            "\"=\""
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "source[i]"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ncopy_environment_blacklist(char **source, char ***env, u_int *envsize,\n    const char *blacklist)\n{\n\tchar *var_name, *var_val;\n\tint i;\n\n\tif (source == NULL)\n\t\treturn;\n\n\tfor(i = 0; source[i] != NULL; i++) {\n\t\tvar_name = xstrdup(source[i]);\n\t\tif ((var_val = strstr(var_name, \"=\")) == NULL) {\n\t\t\tfree(var_name);\n\t\t\tcontinue;\n\t\t}\n\t\t*var_val++ = '\\0';\n\n\t\tif (blacklist == NULL ||\n\t\t    match_pattern_list(var_name, blacklist, 0) != 1) {\n\t\t\tdebug3(\"Copy environment: %s=%s\", var_name, var_val);\n\t\t\tchild_set_env(env, envsize, var_name, var_val);\n\t\t}\n\n\t\tfree(var_name);\n\t}\n}"
  },
  {
    "function_name": "read_etc_default_login",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "944-976",
    "snippet": "static void\nread_etc_default_login(char ***env, u_int *envsize, uid_t uid)\n{\n\tchar **tmpenv = NULL, *var;\n\tu_int i, tmpenvsize = 0;\n\tu_long mask;\n\n\t/*\n\t * We don't want to copy the whole file to the child's environment,\n\t * so we use a temporary environment and copy the variables we're\n\t * interested in.\n\t */\n\tread_environment_file(&tmpenv, &tmpenvsize, \"/etc/default/login\",\n\t    options.permit_user_env_whitelist);\n\n\tif (tmpenv == NULL)\n\t\treturn;\n\n\tif (uid == 0)\n\t\tvar = child_get_env(tmpenv, \"SUPATH\");\n\telse\n\t\tvar = child_get_env(tmpenv, \"PATH\");\n\tif (var != NULL)\n\t\tchild_set_env(env, envsize, \"PATH\", var);\n\n\tif ((var = child_get_env(tmpenv, \"UMASK\")) != NULL)\n\t\tif (sscanf(var, \"%5lo\", &mask) == 1)\n\t\t\tumask((mode_t)mask);\n\n\tfor (i = 0; tmpenv[i] != NULL; i++)\n\t\tfree(tmpenv[i]);\n\tfree(tmpenv);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmpenv"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "(mode_t)mask"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "var",
            "\"%5lo\"",
            "&mask"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "child_get_env",
          "args": [
            "tmpenv",
            "\"UMASK\""
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "child_get_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "927-938",
          "snippet": "static char *\nchild_get_env(char **env, const char *name)\n{\n\tint i;\n\tsize_t len;\n\n\tlen = strlen(name);\n\tfor (i=0; env[i] != NULL; i++)\n\t\tif (strncmp(name, env[i], len) == 0 && env[i][len] == '=')\n\t\t\treturn(env[i] + len + 1);\n\treturn NULL;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nchild_get_env(char **env, const char *name)\n{\n\tint i;\n\tsize_t len;\n\n\tlen = strlen(name);\n\tfor (i=0; env[i] != NULL; i++)\n\t\tif (strncmp(name, env[i], len) == 0 && env[i][len] == '=')\n\t\t\treturn(env[i] + len + 1);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "child_set_env",
          "args": [
            "env",
            "envsize",
            "\"PATH\"",
            "var"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "child_set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1851-1905",
          "snippet": "void\nchild_set_env(char ***envp, u_int *envsizep, const char *name,\n\tconst char *value)\n{\n\tchar **env;\n\tu_int envsize;\n\tu_int i, namelen;\n\n\tif (strchr(name, '=') != NULL) {\n\t\terror(\"Invalid environment variable \\\"%.100s\\\"\", name);\n\t\treturn;\n\t}\n\n\t/*\n\t * If we're passed an uninitialized list, allocate a single null\n\t * entry before continuing.\n\t */\n\tif (*envp == NULL && *envsizep == 0) {\n\t\t*envp = xmalloc(sizeof(char *));\n\t\t*envp[0] = NULL;\n\t\t*envsizep = 1;\n\t}\n\n\t/*\n\t * Find the slot where the value should be stored.  If the variable\n\t * already exists, we reuse the slot; otherwise we append a new slot\n\t * at the end of the array, expanding if necessary.\n\t */\n\tenv = *envp;\n\tnamelen = strlen(name);\n\tfor (i = 0; env[i]; i++)\n\t\tif (strncmp(env[i], name, namelen) == 0 && env[i][namelen] == '=')\n\t\t\tbreak;\n\tif (env[i]) {\n\t\t/* Reuse the slot. */\n\t\tfree(env[i]);\n\t} else {\n\t\t/* New variable.  Expand if necessary. */\n\t\tenvsize = *envsizep;\n\t\tif (i >= envsize - 1) {\n\t\t\tif (envsize >= 1000)\n\t\t\t\tfatal(\"child_set_env: too many env vars\");\n\t\t\tenvsize += 50;\n\t\t\tenv = (*envp) = xreallocarray(env, envsize, sizeof(char *));\n\t\t\t*envsizep = envsize;\n\t\t}\n\t\t/* Need to set the NULL pointer at end of array beyond the new slot. */\n\t\tenv[i + 1] = NULL;\n\t}\n\n\t/* Allocate space and format the variable in the appropriate slot. */\n\t/* XXX xasprintf */\n\tenv[i] = xmalloc(strlen(name) + 1 + strlen(value) + 1);\n\tsnprintf(env[i], strlen(name) + 1 + strlen(value) + 1, \"%s=%s\", name, value);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nchild_set_env(char ***envp, u_int *envsizep, const char *name,\n\tconst char *value)\n{\n\tchar **env;\n\tu_int envsize;\n\tu_int i, namelen;\n\n\tif (strchr(name, '=') != NULL) {\n\t\terror(\"Invalid environment variable \\\"%.100s\\\"\", name);\n\t\treturn;\n\t}\n\n\t/*\n\t * If we're passed an uninitialized list, allocate a single null\n\t * entry before continuing.\n\t */\n\tif (*envp == NULL && *envsizep == 0) {\n\t\t*envp = xmalloc(sizeof(char *));\n\t\t*envp[0] = NULL;\n\t\t*envsizep = 1;\n\t}\n\n\t/*\n\t * Find the slot where the value should be stored.  If the variable\n\t * already exists, we reuse the slot; otherwise we append a new slot\n\t * at the end of the array, expanding if necessary.\n\t */\n\tenv = *envp;\n\tnamelen = strlen(name);\n\tfor (i = 0; env[i]; i++)\n\t\tif (strncmp(env[i], name, namelen) == 0 && env[i][namelen] == '=')\n\t\t\tbreak;\n\tif (env[i]) {\n\t\t/* Reuse the slot. */\n\t\tfree(env[i]);\n\t} else {\n\t\t/* New variable.  Expand if necessary. */\n\t\tenvsize = *envsizep;\n\t\tif (i >= envsize - 1) {\n\t\t\tif (envsize >= 1000)\n\t\t\t\tfatal(\"child_set_env: too many env vars\");\n\t\t\tenvsize += 50;\n\t\t\tenv = (*envp) = xreallocarray(env, envsize, sizeof(char *));\n\t\t\t*envsizep = envsize;\n\t\t}\n\t\t/* Need to set the NULL pointer at end of array beyond the new slot. */\n\t\tenv[i + 1] = NULL;\n\t}\n\n\t/* Allocate space and format the variable in the appropriate slot. */\n\t/* XXX xasprintf */\n\tenv[i] = xmalloc(strlen(name) + 1 + strlen(value) + 1);\n\tsnprintf(env[i], strlen(name) + 1 + strlen(value) + 1, \"%s=%s\", name, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_environment_file",
          "args": [
            "&tmpenv",
            "&tmpenvsize",
            "\"/etc/default/login\"",
            "options.permit_user_env_whitelist"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "read_environment_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "879-921",
          "snippet": "static void\nread_environment_file(char ***env, u_int *envsize,\n\tconst char *filename, const char *whitelist)\n{\n\tFILE *f;\n\tchar *line = NULL, *cp, *value;\n\tsize_t linesize = 0;\n\tu_int lineno = 0;\n\n\tf = fopen(filename, \"r\");\n\tif (!f)\n\t\treturn;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tif (++lineno > 1000)\n\t\t\tfatal(\"Too many lines in environment file %s\", filename);\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (!*cp || *cp == '#' || *cp == '\\n')\n\t\t\tcontinue;\n\n\t\tcp[strcspn(cp, \"\\n\")] = '\\0';\n\n\t\tvalue = strchr(cp, '=');\n\t\tif (value == NULL) {\n\t\t\tfprintf(stderr, \"Bad line %u in %.100s\\n\", lineno,\n\t\t\t    filename);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Replace the equals sign by nul, and advance value to\n\t\t * the value string.\n\t\t */\n\t\t*value = '\\0';\n\t\tvalue++;\n\t\tif (whitelist != NULL &&\n\t\t    match_pattern_list(cp, whitelist, 0) != 1)\n\t\t\tcontinue;\n\t\tchild_set_env(env, envsize, cp, value);\n\t}\n\tfree(line);\n\tfclose(f);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nread_environment_file(char ***env, u_int *envsize,\n\tconst char *filename, const char *whitelist)\n{\n\tFILE *f;\n\tchar *line = NULL, *cp, *value;\n\tsize_t linesize = 0;\n\tu_int lineno = 0;\n\n\tf = fopen(filename, \"r\");\n\tif (!f)\n\t\treturn;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tif (++lineno > 1000)\n\t\t\tfatal(\"Too many lines in environment file %s\", filename);\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (!*cp || *cp == '#' || *cp == '\\n')\n\t\t\tcontinue;\n\n\t\tcp[strcspn(cp, \"\\n\")] = '\\0';\n\n\t\tvalue = strchr(cp, '=');\n\t\tif (value == NULL) {\n\t\t\tfprintf(stderr, \"Bad line %u in %.100s\\n\", lineno,\n\t\t\t    filename);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Replace the equals sign by nul, and advance value to\n\t\t * the value string.\n\t\t */\n\t\t*value = '\\0';\n\t\tvalue++;\n\t\tif (whitelist != NULL &&\n\t\t    match_pattern_list(cp, whitelist, 0) != 1)\n\t\t\tcontinue;\n\t\tchild_set_env(env, envsize, cp, value);\n\t}\n\tfree(line);\n\tfclose(f);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic void\nread_etc_default_login(char ***env, u_int *envsize, uid_t uid)\n{\n\tchar **tmpenv = NULL, *var;\n\tu_int i, tmpenvsize = 0;\n\tu_long mask;\n\n\t/*\n\t * We don't want to copy the whole file to the child's environment,\n\t * so we use a temporary environment and copy the variables we're\n\t * interested in.\n\t */\n\tread_environment_file(&tmpenv, &tmpenvsize, \"/etc/default/login\",\n\t    options.permit_user_env_whitelist);\n\n\tif (tmpenv == NULL)\n\t\treturn;\n\n\tif (uid == 0)\n\t\tvar = child_get_env(tmpenv, \"SUPATH\");\n\telse\n\t\tvar = child_get_env(tmpenv, \"PATH\");\n\tif (var != NULL)\n\t\tchild_set_env(env, envsize, \"PATH\", var);\n\n\tif ((var = child_get_env(tmpenv, \"UMASK\")) != NULL)\n\t\tif (sscanf(var, \"%5lo\", &mask) == 1)\n\t\t\tumask((mode_t)mask);\n\n\tfor (i = 0; tmpenv[i] != NULL; i++)\n\t\tfree(tmpenv[i]);\n\tfree(tmpenv);\n}"
  },
  {
    "function_name": "child_get_env",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "927-938",
    "snippet": "static char *\nchild_get_env(char **env, const char *name)\n{\n\tint i;\n\tsize_t len;\n\n\tlen = strlen(name);\n\tfor (i=0; env[i] != NULL; i++)\n\t\tif (strncmp(name, env[i], len) == 0 && env[i][len] == '=')\n\t\t\treturn(env[i] + len + 1);\n\treturn NULL;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "env[i]",
            "len"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nchild_get_env(char **env, const char *name)\n{\n\tint i;\n\tsize_t len;\n\n\tlen = strlen(name);\n\tfor (i=0; env[i] != NULL; i++)\n\t\tif (strncmp(name, env[i], len) == 0 && env[i][len] == '=')\n\t\t\treturn(env[i] + len + 1);\n\treturn NULL;\n}"
  },
  {
    "function_name": "read_environment_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "879-921",
    "snippet": "static void\nread_environment_file(char ***env, u_int *envsize,\n\tconst char *filename, const char *whitelist)\n{\n\tFILE *f;\n\tchar *line = NULL, *cp, *value;\n\tsize_t linesize = 0;\n\tu_int lineno = 0;\n\n\tf = fopen(filename, \"r\");\n\tif (!f)\n\t\treturn;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tif (++lineno > 1000)\n\t\t\tfatal(\"Too many lines in environment file %s\", filename);\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (!*cp || *cp == '#' || *cp == '\\n')\n\t\t\tcontinue;\n\n\t\tcp[strcspn(cp, \"\\n\")] = '\\0';\n\n\t\tvalue = strchr(cp, '=');\n\t\tif (value == NULL) {\n\t\t\tfprintf(stderr, \"Bad line %u in %.100s\\n\", lineno,\n\t\t\t    filename);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Replace the equals sign by nul, and advance value to\n\t\t * the value string.\n\t\t */\n\t\t*value = '\\0';\n\t\tvalue++;\n\t\tif (whitelist != NULL &&\n\t\t    match_pattern_list(cp, whitelist, 0) != 1)\n\t\t\tcontinue;\n\t\tchild_set_env(env, envsize, cp, value);\n\t}\n\tfree(line);\n\tfclose(f);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "child_set_env",
          "args": [
            "env",
            "envsize",
            "cp",
            "value"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "child_set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1851-1905",
          "snippet": "void\nchild_set_env(char ***envp, u_int *envsizep, const char *name,\n\tconst char *value)\n{\n\tchar **env;\n\tu_int envsize;\n\tu_int i, namelen;\n\n\tif (strchr(name, '=') != NULL) {\n\t\terror(\"Invalid environment variable \\\"%.100s\\\"\", name);\n\t\treturn;\n\t}\n\n\t/*\n\t * If we're passed an uninitialized list, allocate a single null\n\t * entry before continuing.\n\t */\n\tif (*envp == NULL && *envsizep == 0) {\n\t\t*envp = xmalloc(sizeof(char *));\n\t\t*envp[0] = NULL;\n\t\t*envsizep = 1;\n\t}\n\n\t/*\n\t * Find the slot where the value should be stored.  If the variable\n\t * already exists, we reuse the slot; otherwise we append a new slot\n\t * at the end of the array, expanding if necessary.\n\t */\n\tenv = *envp;\n\tnamelen = strlen(name);\n\tfor (i = 0; env[i]; i++)\n\t\tif (strncmp(env[i], name, namelen) == 0 && env[i][namelen] == '=')\n\t\t\tbreak;\n\tif (env[i]) {\n\t\t/* Reuse the slot. */\n\t\tfree(env[i]);\n\t} else {\n\t\t/* New variable.  Expand if necessary. */\n\t\tenvsize = *envsizep;\n\t\tif (i >= envsize - 1) {\n\t\t\tif (envsize >= 1000)\n\t\t\t\tfatal(\"child_set_env: too many env vars\");\n\t\t\tenvsize += 50;\n\t\t\tenv = (*envp) = xreallocarray(env, envsize, sizeof(char *));\n\t\t\t*envsizep = envsize;\n\t\t}\n\t\t/* Need to set the NULL pointer at end of array beyond the new slot. */\n\t\tenv[i + 1] = NULL;\n\t}\n\n\t/* Allocate space and format the variable in the appropriate slot. */\n\t/* XXX xasprintf */\n\tenv[i] = xmalloc(strlen(name) + 1 + strlen(value) + 1);\n\tsnprintf(env[i], strlen(name) + 1 + strlen(value) + 1, \"%s=%s\", name, value);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nchild_set_env(char ***envp, u_int *envsizep, const char *name,\n\tconst char *value)\n{\n\tchar **env;\n\tu_int envsize;\n\tu_int i, namelen;\n\n\tif (strchr(name, '=') != NULL) {\n\t\terror(\"Invalid environment variable \\\"%.100s\\\"\", name);\n\t\treturn;\n\t}\n\n\t/*\n\t * If we're passed an uninitialized list, allocate a single null\n\t * entry before continuing.\n\t */\n\tif (*envp == NULL && *envsizep == 0) {\n\t\t*envp = xmalloc(sizeof(char *));\n\t\t*envp[0] = NULL;\n\t\t*envsizep = 1;\n\t}\n\n\t/*\n\t * Find the slot where the value should be stored.  If the variable\n\t * already exists, we reuse the slot; otherwise we append a new slot\n\t * at the end of the array, expanding if necessary.\n\t */\n\tenv = *envp;\n\tnamelen = strlen(name);\n\tfor (i = 0; env[i]; i++)\n\t\tif (strncmp(env[i], name, namelen) == 0 && env[i][namelen] == '=')\n\t\t\tbreak;\n\tif (env[i]) {\n\t\t/* Reuse the slot. */\n\t\tfree(env[i]);\n\t} else {\n\t\t/* New variable.  Expand if necessary. */\n\t\tenvsize = *envsizep;\n\t\tif (i >= envsize - 1) {\n\t\t\tif (envsize >= 1000)\n\t\t\t\tfatal(\"child_set_env: too many env vars\");\n\t\t\tenvsize += 50;\n\t\t\tenv = (*envp) = xreallocarray(env, envsize, sizeof(char *));\n\t\t\t*envsizep = envsize;\n\t\t}\n\t\t/* Need to set the NULL pointer at end of array beyond the new slot. */\n\t\tenv[i + 1] = NULL;\n\t}\n\n\t/* Allocate space and format the variable in the appropriate slot. */\n\t/* XXX xasprintf */\n\tenv[i] = xmalloc(strlen(name) + 1 + strlen(value) + 1);\n\tsnprintf(env[i], strlen(name) + 1 + strlen(value) + 1, \"%s=%s\", name, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_pattern_list",
          "args": [
            "cp",
            "whitelist",
            "0"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "120-171",
          "snippet": "int\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Bad line %u in %.100s\\n\"",
            "lineno",
            "filename"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cp",
            "'='"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "cp",
            "\"\\n\""
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Too many lines in environment file %s\"",
            "filename"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&linesize",
            "f"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-getline.c",
          "lines": "92-96",
          "snippet": "ssize_t\ngetline(char **buf, size_t *bufsiz, FILE *fp)\n{\n\treturn getdelim(buf, bufsiz, '\\n', fp);\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"file.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"file.h\"\n#include \"includes.h\"\n\nssize_t\ngetline(char **buf, size_t *bufsiz, FILE *fp)\n{\n\treturn getdelim(buf, bufsiz, '\\n', fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "filename",
            "\"r\""
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nread_environment_file(char ***env, u_int *envsize,\n\tconst char *filename, const char *whitelist)\n{\n\tFILE *f;\n\tchar *line = NULL, *cp, *value;\n\tsize_t linesize = 0;\n\tu_int lineno = 0;\n\n\tf = fopen(filename, \"r\");\n\tif (!f)\n\t\treturn;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tif (++lineno > 1000)\n\t\t\tfatal(\"Too many lines in environment file %s\", filename);\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (!*cp || *cp == '#' || *cp == '\\n')\n\t\t\tcontinue;\n\n\t\tcp[strcspn(cp, \"\\n\")] = '\\0';\n\n\t\tvalue = strchr(cp, '=');\n\t\tif (value == NULL) {\n\t\t\tfprintf(stderr, \"Bad line %u in %.100s\\n\", lineno,\n\t\t\t    filename);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Replace the equals sign by nul, and advance value to\n\t\t * the value string.\n\t\t */\n\t\t*value = '\\0';\n\t\tvalue++;\n\t\tif (whitelist != NULL &&\n\t\t    match_pattern_list(cp, whitelist, 0) != 1)\n\t\t\tcontinue;\n\t\tchild_set_env(env, envsize, cp, value);\n\t}\n\tfree(line);\n\tfclose(f);\n}"
  },
  {
    "function_name": "check_quietlogin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "850-869",
    "snippet": "int\ncheck_quietlogin(Session *s, const char *command)\n{\n\tchar buf[256];\n\tstruct passwd *pw = s->pw;\n\tstruct stat st;\n\n\t/* Return 1 if .hushlogin exists or a command given. */\n\tif (command != NULL)\n\t\treturn 1;\n\tsnprintf(buf, sizeof(buf), \"%.200s/.hushlogin\", pw->pw_dir);\n#ifdef HAVE_LOGIN_CAP\n\tif (login_getcapbool(lc, \"hushlogin\", 0) || stat(buf, &st) >= 0)\n\t\treturn 1;\n#else\n\tif (stat(buf, &st) >= 0)\n\t\treturn 1;\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "buf",
            "&st"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "login_getcapbool",
          "args": [
            "lc",
            "\"hushlogin\"",
            "0"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%.200s/.hushlogin\"",
            "pw->pw_dir"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nint\ncheck_quietlogin(Session *s, const char *command)\n{\n\tchar buf[256];\n\tstruct passwd *pw = s->pw;\n\tstruct stat st;\n\n\t/* Return 1 if .hushlogin exists or a command given. */\n\tif (command != NULL)\n\t\treturn 1;\n\tsnprintf(buf, sizeof(buf), \"%.200s/.hushlogin\", pw->pw_dir);\n#ifdef HAVE_LOGIN_CAP\n\tif (login_getcapbool(lc, \"hushlogin\", 0) || stat(buf, &st) >= 0)\n\t\treturn 1;\n#else\n\tif (stat(buf, &st) >= 0)\n\t\treturn 1;\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "do_motd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "825-844",
    "snippet": "void\ndo_motd(void)\n{\n\tFILE *f;\n\tchar buf[256];\n\n\tif (options.print_motd) {\n#ifdef HAVE_LOGIN_CAP\n\t\tf = fopen(login_getcapstr(lc, \"welcome\", \"/etc/motd\",\n\t\t    \"/etc/motd\"), \"r\");\n#else\n\t\tf = fopen(\"/etc/motd\", \"r\");\n#endif\n\t\tif (f) {\n\t\t\twhile (fgets(buf, sizeof(buf), f))\n\t\t\t\tfputs(buf, stdout);\n\t\t\tfclose(f);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tdo_motd(void);",
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "buf",
            "stdout"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "sizeof(buf)",
            "f"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/etc/motd\"",
            "\"r\""
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "login_getcapstr(lc, \"welcome\", \"/etc/motd\",\n\t\t    \"/etc/motd\")",
            "\"r\""
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "login_getcapstr",
          "args": [
            "lc",
            "\"welcome\"",
            "\"/etc/motd\"",
            "\"/etc/motd\""
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tdo_motd(void);\nextern ServerOptions options;\n\nvoid\ndo_motd(void)\n{\n\tFILE *f;\n\tchar buf[256];\n\n\tif (options.print_motd) {\n#ifdef HAVE_LOGIN_CAP\n\t\tf = fopen(login_getcapstr(lc, \"welcome\", \"/etc/motd\",\n\t\t    \"/etc/motd\"), \"r\");\n#else\n\t\tf = fopen(\"/etc/motd\", \"r\");\n#endif\n\t\tif (f) {\n\t\t\twhile (fgets(buf, sizeof(buf), f))\n\t\t\t\tfputs(buf, stdout);\n\t\t\tfclose(f);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "do_login",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "772-820",
    "snippet": "void\ndo_login(struct ssh *ssh, Session *s, const char *command)\n{\n\tsocklen_t fromlen;\n\tstruct sockaddr_storage from;\n\tstruct passwd * pw = s->pw;\n\tpid_t pid = getpid();\n\n\t/*\n\t * Get IP address of client. If the connection is not a socket, let\n\t * the address be 0.0.0.0.\n\t */\n\tmemset(&from, 0, sizeof(from));\n\tfromlen = sizeof(from);\n\tif (packet_connection_is_on_socket()) {\n\t\tif (getpeername(packet_get_connection_in(),\n\t\t    (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\tdebug(\"getpeername: %.100s\", strerror(errno));\n\t\t\tcleanup_exit(255);\n\t\t}\n\t}\n\n\t/* Record that there was a login on that tty from the remote host. */\n\tif (!use_privsep)\n\t\trecord_login(pid, s->tty, pw->pw_name, pw->pw_uid,\n\t\t    session_get_remote_name_or_ip(ssh, utmp_len,\n\t\t    options.use_dns),\n\t\t    (struct sockaddr *)&from, fromlen);\n\n#ifdef USE_PAM\n\t/*\n\t * If password change is needed, do it now.\n\t * This needs to occur before the ~/.hushlogin check.\n\t */\n\tif (options.use_pam && !use_privsep && s->authctxt->force_pwchange) {\n\t\tdisplay_loginmsg();\n\t\tdo_pam_chauthtok();\n\t\ts->authctxt->force_pwchange = 0;\n\t\t/* XXX - signal [net] parent to enable forwardings */\n\t}\n#endif\n\n\tif (check_quietlogin(s, command))\n\t\treturn;\n\n\tdisplay_loginmsg();\n\n\tdo_motd();\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "void\tdo_motd(void);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "extern ServerOptions options;",
      "extern u_int utmp_len;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_motd",
          "args": [],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "do_motd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "825-844",
          "snippet": "void\ndo_motd(void)\n{\n\tFILE *f;\n\tchar buf[256];\n\n\tif (options.print_motd) {\n#ifdef HAVE_LOGIN_CAP\n\t\tf = fopen(login_getcapstr(lc, \"welcome\", \"/etc/motd\",\n\t\t    \"/etc/motd\"), \"r\");\n#else\n\t\tf = fopen(\"/etc/motd\", \"r\");\n#endif\n\t\tif (f) {\n\t\t\twhile (fgets(buf, sizeof(buf), f))\n\t\t\t\tfputs(buf, stdout);\n\t\t\tfclose(f);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tdo_motd(void);",
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tdo_motd(void);\nextern ServerOptions options;\n\nvoid\ndo_motd(void)\n{\n\tFILE *f;\n\tchar buf[256];\n\n\tif (options.print_motd) {\n#ifdef HAVE_LOGIN_CAP\n\t\tf = fopen(login_getcapstr(lc, \"welcome\", \"/etc/motd\",\n\t\t    \"/etc/motd\"), \"r\");\n#else\n\t\tf = fopen(\"/etc/motd\", \"r\");\n#endif\n\t\tif (f) {\n\t\t\twhile (fgets(buf, sizeof(buf), f))\n\t\t\t\tfputs(buf, stdout);\n\t\t\tfclose(f);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "display_loginmsg",
          "args": [],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "display_loginmsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "249-260",
          "snippet": "static void\ndisplay_loginmsg(void)\n{\n\tint r;\n\n\tif (sshbuf_len(loginmsg) == 0)\n\t\treturn;\n\tif ((r = sshbuf_put_u8(loginmsg, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tprintf(\"%s\", (char *)sshbuf_ptr(loginmsg));\n\tsshbuf_reset(loginmsg);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct sshbuf *loginmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern struct sshbuf *loginmsg;\n\nstatic void\ndisplay_loginmsg(void)\n{\n\tint r;\n\n\tif (sshbuf_len(loginmsg) == 0)\n\t\treturn;\n\tif ((r = sshbuf_put_u8(loginmsg, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tprintf(\"%s\", (char *)sshbuf_ptr(loginmsg));\n\tsshbuf_reset(loginmsg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_quietlogin",
          "args": [
            "s",
            "command"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "check_quietlogin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "850-869",
          "snippet": "int\ncheck_quietlogin(Session *s, const char *command)\n{\n\tchar buf[256];\n\tstruct passwd *pw = s->pw;\n\tstruct stat st;\n\n\t/* Return 1 if .hushlogin exists or a command given. */\n\tif (command != NULL)\n\t\treturn 1;\n\tsnprintf(buf, sizeof(buf), \"%.200s/.hushlogin\", pw->pw_dir);\n#ifdef HAVE_LOGIN_CAP\n\tif (login_getcapbool(lc, \"hushlogin\", 0) || stat(buf, &st) >= 0)\n\t\treturn 1;\n#else\n\tif (stat(buf, &st) >= 0)\n\t\treturn 1;\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nint\ncheck_quietlogin(Session *s, const char *command)\n{\n\tchar buf[256];\n\tstruct passwd *pw = s->pw;\n\tstruct stat st;\n\n\t/* Return 1 if .hushlogin exists or a command given. */\n\tif (command != NULL)\n\t\treturn 1;\n\tsnprintf(buf, sizeof(buf), \"%.200s/.hushlogin\", pw->pw_dir);\n#ifdef HAVE_LOGIN_CAP\n\tif (login_getcapbool(lc, \"hushlogin\", 0) || stat(buf, &st) >= 0)\n\t\treturn 1;\n#else\n\tif (stat(buf, &st) >= 0)\n\t\treturn 1;\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_pam_chauthtok",
          "args": [],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "do_pam_chauthtok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "1126-1141",
          "snippet": "void\ndo_pam_chauthtok(void)\n{\n\tif (use_privsep)\n\t\tfatal(\"Password expired (unable to change with privsep)\");\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&tty_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: failed to set PAM_CONV: %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\tdebug(\"PAM: changing password\");\n\tsshpam_err = pam_chauthtok(sshpam_handle, PAM_CHANGE_EXPIRED_AUTHTOK);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: pam_chauthtok(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndo_pam_chauthtok(void)\n{\n\tif (use_privsep)\n\t\tfatal(\"Password expired (unable to change with privsep)\");\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&tty_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: failed to set PAM_CONV: %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\tdebug(\"PAM: changing password\");\n\tsshpam_err = pam_chauthtok(sshpam_handle, PAM_CHANGE_EXPIRED_AUTHTOK);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: pam_chauthtok(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n}"
        }
      },
      {
        "call_info": {
          "callee": "record_login",
          "args": [
            "pid",
            "s->tty",
            "pw->pw_name",
            "pw->pw_uid",
            "session_get_remote_name_or_ip(ssh, utmp_len,\n\t\t    options.use_dns)",
            "(struct sockaddr *)&from",
            "fromlen"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "record_login",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshlogin.c",
          "lines": "132-145",
          "snippet": "void\nrecord_login(pid_t pid, const char *tty, const char *user, uid_t uid,\n    const char *host, struct sockaddr *addr, socklen_t addrlen)\n{\n\tstruct logininfo *li;\n\n\t/* save previous login details before writing new */\n\tstore_lastlog_message(user, uid);\n\n\tli = login_alloc_entry(pid, user, host, tty);\n\tlogin_set_addr(li, addr, addrlen);\n\tlogin_login(li);\n\tlogin_free_entry(li);\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"loginrec.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshlogin.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"loginrec.h\"\n#include \"ssherr.h\"\n#include \"sshlogin.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nrecord_login(pid_t pid, const char *tty, const char *user, uid_t uid,\n    const char *host, struct sockaddr *addr, socklen_t addrlen)\n{\n\tstruct logininfo *li;\n\n\t/* save previous login details before writing new */\n\tstore_lastlog_message(user, uid);\n\n\tli = login_alloc_entry(pid, user, host, tty);\n\tlogin_set_addr(li, addr, addrlen);\n\tlogin_login(li);\n\tlogin_free_entry(li);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_get_remote_name_or_ip",
          "args": [
            "ssh",
            "utmp_len",
            "options.use_dns"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "session_get_remote_name_or_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2703-2713",
          "snippet": "const char *\nsession_get_remote_name_or_ip(struct ssh *ssh, u_int utmp_size, int use_dns)\n{\n\tconst char *remote = \"\";\n\n\tif (utmp_size > 0)\n\t\tremote = auth_get_canonical_hostname(ssh, use_dns);\n\tif (utmp_size == 0 || strlen(remote) > utmp_size)\n\t\tremote = ssh_remote_ipaddr(ssh);\n\treturn remote;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsession_get_remote_name_or_ip(struct ssh *ssh, u_int utmp_size, int use_dns)\n{\n\tconst char *remote = \"\";\n\n\tif (utmp_size > 0)\n\t\tremote = auth_get_canonical_hostname(ssh, use_dns);\n\tif (utmp_size == 0 || strlen(remote) > utmp_size)\n\t\tremote = ssh_remote_ipaddr(ssh);\n\treturn remote;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_exit",
          "args": [
            "255"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"getpeername: %.100s\"",
            "strerror(errno)"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpeername",
          "args": [
            "packet_get_connection_in()",
            "(struct sockaddr *)&from",
            "&fromlen"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_connection_in",
          "args": [],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_connection_is_on_socket",
          "args": [],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&from",
            "0",
            "sizeof(from)"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nvoid\tdo_motd(void);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern u_int utmp_len;\n\nvoid\ndo_login(struct ssh *ssh, Session *s, const char *command)\n{\n\tsocklen_t fromlen;\n\tstruct sockaddr_storage from;\n\tstruct passwd * pw = s->pw;\n\tpid_t pid = getpid();\n\n\t/*\n\t * Get IP address of client. If the connection is not a socket, let\n\t * the address be 0.0.0.0.\n\t */\n\tmemset(&from, 0, sizeof(from));\n\tfromlen = sizeof(from);\n\tif (packet_connection_is_on_socket()) {\n\t\tif (getpeername(packet_get_connection_in(),\n\t\t    (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\tdebug(\"getpeername: %.100s\", strerror(errno));\n\t\t\tcleanup_exit(255);\n\t\t}\n\t}\n\n\t/* Record that there was a login on that tty from the remote host. */\n\tif (!use_privsep)\n\t\trecord_login(pid, s->tty, pw->pw_name, pw->pw_uid,\n\t\t    session_get_remote_name_or_ip(ssh, utmp_len,\n\t\t    options.use_dns),\n\t\t    (struct sockaddr *)&from, fromlen);\n\n#ifdef USE_PAM\n\t/*\n\t * If password change is needed, do it now.\n\t * This needs to occur before the ~/.hushlogin check.\n\t */\n\tif (options.use_pam && !use_privsep && s->authctxt->force_pwchange) {\n\t\tdisplay_loginmsg();\n\t\tdo_pam_chauthtok();\n\t\ts->authctxt->force_pwchange = 0;\n\t\t/* XXX - signal [net] parent to enable forwardings */\n\t}\n#endif\n\n\tif (check_quietlogin(s, command))\n\t\treturn;\n\n\tdisplay_loginmsg();\n\n\tdo_motd();\n}"
  },
  {
    "function_name": "do_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "692-769",
    "snippet": "int\ndo_exec(struct ssh *ssh, Session *s, const char *command)\n{\n\tint ret;\n\tconst char *forced = NULL, *tty = NULL;\n\tchar session_type[1024];\n\n\tif (options.adm_forced_command) {\n\t\toriginal_command = command;\n\t\tcommand = options.adm_forced_command;\n\t\tforced = \"(config)\";\n\t} else if (auth_opts->force_command != NULL) {\n\t\toriginal_command = command;\n\t\tcommand = auth_opts->force_command;\n\t\tforced = \"(key-option)\";\n\t}\n\ts->forced = 0;\n\tif (forced != NULL) {\n\t\ts->forced = 1;\n\t\tif (IS_INTERNAL_SFTP(command)) {\n\t\t\ts->is_subsystem = s->is_subsystem ?\n\t\t\t    SUBSYSTEM_INT_SFTP : SUBSYSTEM_INT_SFTP_ERROR;\n\t\t} else if (s->is_subsystem)\n\t\t\ts->is_subsystem = SUBSYSTEM_EXT;\n\t\tsnprintf(session_type, sizeof(session_type),\n\t\t    \"forced-command %s '%.900s'\", forced, command);\n\t} else if (s->is_subsystem) {\n\t\tsnprintf(session_type, sizeof(session_type),\n\t\t    \"subsystem '%.900s'\", s->subsys);\n\t} else if (command == NULL) {\n\t\tsnprintf(session_type, sizeof(session_type), \"shell\");\n\t} else {\n\t\t/* NB. we don't log unforced commands to preserve privacy */\n\t\tsnprintf(session_type, sizeof(session_type), \"command\");\n\t}\n\n\tif (s->ttyfd != -1) {\n\t\ttty = s->tty;\n\t\tif (strncmp(tty, \"/dev/\", 5) == 0)\n\t\t\ttty += 5;\n\t}\n\n\tverbose(\"Starting session: %s%s%s for %s from %.200s port %d id %d\",\n\t    session_type,\n\t    tty == NULL ? \"\" : \" on \",\n\t    tty == NULL ? \"\" : tty,\n\t    s->pw->pw_name,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    s->self);\n\n#ifdef SSH_AUDIT_EVENTS\n\tif (command != NULL)\n\t\tPRIVSEP(audit_run_command(command));\n\telse if (s->ttyfd == -1) {\n\t\tchar *shell = s->pw->pw_shell;\n\n\t\tif (shell[0] == '\\0')\t/* empty shell means /bin/sh */\n\t\t\tshell =_PATH_BSHELL;\n\t\tPRIVSEP(audit_run_command(shell));\n\t}\n#endif\n\tif (s->ttyfd != -1)\n\t\tret = do_exec_pty(ssh, s, command);\n\telse\n\t\tret = do_exec_no_pty(ssh, s, command);\n\n\toriginal_command = NULL;\n\n\t/*\n\t * Clear loginmsg: it's the child's responsibility to display\n\t * it to the user, otherwise multiple sessions may accumulate\n\t * multiple copies of the login messages.\n\t */\n\tsshbuf_reset(loginmsg);\n\n\treturn ret;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SUBSYSTEM_INT_SFTP_ERROR\t3",
      "#define SUBSYSTEM_INT_SFTP\t\t2",
      "#define SUBSYSTEM_EXT\t\t\t1"
    ],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "extern ServerOptions options;",
      "extern struct sshbuf *loginmsg;",
      "extern struct sshauthopt *auth_opts;",
      "const char *original_command = NULL;",
      "static Session *sessions = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "loginmsg"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_exec_no_pty",
          "args": [
            "ssh",
            "s",
            "command"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "do_exec_no_pty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "392-555",
          "snippet": "int\ndo_exec_no_pty(struct ssh *ssh, Session *s, const char *command)\n{\n\tpid_t pid;\n#ifdef USE_PIPES\n\tint pin[2], pout[2], perr[2];\n\n\tif (s == NULL)\n\t\tfatal(\"do_exec_no_pty: no session\");\n\n\t/* Allocate pipes for communicating with the program. */\n\tif (pipe(pin) < 0) {\n\t\terror(\"%s: pipe in: %.100s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pipe(pout) < 0) {\n\t\terror(\"%s: pipe out: %.100s\", __func__, strerror(errno));\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\treturn -1;\n\t}\n\tif (pipe(perr) < 0) {\n\t\terror(\"%s: pipe err: %.100s\", __func__,\n\t\t    strerror(errno));\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tclose(pout[1]);\n\t\treturn -1;\n\t}\n#else\n\tint inout[2], err[2];\n\n\tif (s == NULL)\n\t\tfatal(\"do_exec_no_pty: no session\");\n\n\t/* Uses socket pairs to communicate with the program. */\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) < 0) {\n\t\terror(\"%s: socketpair #1: %.100s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, err) < 0) {\n\t\terror(\"%s: socketpair #2: %.100s\", __func__,\n\t\t    strerror(errno));\n\t\tclose(inout[0]);\n\t\tclose(inout[1]);\n\t\treturn -1;\n\t}\n#endif\n\n\tsession_proctitle(s);\n\n\t/* Fork the child. */\n\tswitch ((pid = fork())) {\n\tcase -1:\n\t\terror(\"%s: fork: %.100s\", __func__, strerror(errno));\n#ifdef USE_PIPES\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tclose(pout[1]);\n\t\tclose(perr[0]);\n\t\tclose(perr[1]);\n#else\n\t\tclose(inout[0]);\n\t\tclose(inout[1]);\n\t\tclose(err[0]);\n\t\tclose(err[1]);\n#endif\n\t\treturn -1;\n\tcase 0:\n\t\tis_child = 1;\n\n\t\t/*\n\t\t * Create a new session and process group since the 4.4BSD\n\t\t * setlogin() affects the entire process group.\n\t\t */\n\t\tif (setsid() < 0)\n\t\t\terror(\"setsid failed: %.100s\", strerror(errno));\n\n#ifdef USE_PIPES\n\t\t/*\n\t\t * Redirect stdin.  We close the parent side of the socket\n\t\t * pair, and make the child side the standard input.\n\t\t */\n\t\tclose(pin[1]);\n\t\tif (dup2(pin[0], 0) < 0)\n\t\t\tperror(\"dup2 stdin\");\n\t\tclose(pin[0]);\n\n\t\t/* Redirect stdout. */\n\t\tclose(pout[0]);\n\t\tif (dup2(pout[1], 1) < 0)\n\t\t\tperror(\"dup2 stdout\");\n\t\tclose(pout[1]);\n\n\t\t/* Redirect stderr. */\n\t\tclose(perr[0]);\n\t\tif (dup2(perr[1], 2) < 0)\n\t\t\tperror(\"dup2 stderr\");\n\t\tclose(perr[1]);\n#else\n\t\t/*\n\t\t * Redirect stdin, stdout, and stderr.  Stdin and stdout will\n\t\t * use the same socket, as some programs (particularly rdist)\n\t\t * seem to depend on it.\n\t\t */\n\t\tclose(inout[1]);\n\t\tclose(err[1]);\n\t\tif (dup2(inout[0], 0) < 0)\t/* stdin */\n\t\t\tperror(\"dup2 stdin\");\n\t\tif (dup2(inout[0], 1) < 0)\t/* stdout (same as stdin) */\n\t\t\tperror(\"dup2 stdout\");\n\t\tclose(inout[0]);\n\t\tif (dup2(err[0], 2) < 0)\t/* stderr */\n\t\t\tperror(\"dup2 stderr\");\n\t\tclose(err[0]);\n#endif\n\n\t\t/* Do processing for the child (exec command etc). */\n\t\tdo_child(ssh, s, command);\n\t\t/* NOTREACHED */\n\tdefault:\n\t\tbreak;\n\t}\n\n#ifdef HAVE_CYGWIN\n\tcygwin_set_impersonation_token(INVALID_HANDLE_VALUE);\n#endif\n\n\ts->pid = pid;\n\t/* Set interactive/non-interactive mode. */\n\tpacket_set_interactive(s->display != NULL,\n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\n\t/*\n\t * Clear loginmsg, since it's the child's responsibility to display\n\t * it to the user, otherwise multiple sessions may accumulate\n\t * multiple copies of the login messages.\n\t */\n\tsshbuf_reset(loginmsg);\n\n#ifdef USE_PIPES\n\t/* We are the parent.  Close the child sides of the pipes. */\n\tclose(pin[0]);\n\tclose(pout[1]);\n\tclose(perr[1]);\n\n\tsession_set_fds(ssh, s, pin[1], pout[0], perr[0],\n\t    s->is_subsystem, 0);\n#else\n\t/* We are the parent.  Close the child sides of the socket pairs. */\n\tclose(inout[0]);\n\tclose(err[0]);\n\n\t/*\n\t * Enter the interactive session.  Note: server_loop must be able to\n\t * handle the case that fdin and fdout are the same.\n\t */\n\tsession_set_fds(s, inout[1], inout[1], err[1],\n\t    s->is_subsystem, 0);\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define USE_PIPES 1"
          ],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "extern ServerOptions options;",
            "extern struct sshbuf *loginmsg;",
            "static Session *sessions = NULL;",
            "static int is_child = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define USE_PIPES 1\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern struct sshbuf *loginmsg;\nstatic Session *sessions = NULL;\nstatic int is_child = 0;\n\nint\ndo_exec_no_pty(struct ssh *ssh, Session *s, const char *command)\n{\n\tpid_t pid;\n#ifdef USE_PIPES\n\tint pin[2], pout[2], perr[2];\n\n\tif (s == NULL)\n\t\tfatal(\"do_exec_no_pty: no session\");\n\n\t/* Allocate pipes for communicating with the program. */\n\tif (pipe(pin) < 0) {\n\t\terror(\"%s: pipe in: %.100s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pipe(pout) < 0) {\n\t\terror(\"%s: pipe out: %.100s\", __func__, strerror(errno));\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\treturn -1;\n\t}\n\tif (pipe(perr) < 0) {\n\t\terror(\"%s: pipe err: %.100s\", __func__,\n\t\t    strerror(errno));\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tclose(pout[1]);\n\t\treturn -1;\n\t}\n#else\n\tint inout[2], err[2];\n\n\tif (s == NULL)\n\t\tfatal(\"do_exec_no_pty: no session\");\n\n\t/* Uses socket pairs to communicate with the program. */\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) < 0) {\n\t\terror(\"%s: socketpair #1: %.100s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, err) < 0) {\n\t\terror(\"%s: socketpair #2: %.100s\", __func__,\n\t\t    strerror(errno));\n\t\tclose(inout[0]);\n\t\tclose(inout[1]);\n\t\treturn -1;\n\t}\n#endif\n\n\tsession_proctitle(s);\n\n\t/* Fork the child. */\n\tswitch ((pid = fork())) {\n\tcase -1:\n\t\terror(\"%s: fork: %.100s\", __func__, strerror(errno));\n#ifdef USE_PIPES\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tclose(pout[1]);\n\t\tclose(perr[0]);\n\t\tclose(perr[1]);\n#else\n\t\tclose(inout[0]);\n\t\tclose(inout[1]);\n\t\tclose(err[0]);\n\t\tclose(err[1]);\n#endif\n\t\treturn -1;\n\tcase 0:\n\t\tis_child = 1;\n\n\t\t/*\n\t\t * Create a new session and process group since the 4.4BSD\n\t\t * setlogin() affects the entire process group.\n\t\t */\n\t\tif (setsid() < 0)\n\t\t\terror(\"setsid failed: %.100s\", strerror(errno));\n\n#ifdef USE_PIPES\n\t\t/*\n\t\t * Redirect stdin.  We close the parent side of the socket\n\t\t * pair, and make the child side the standard input.\n\t\t */\n\t\tclose(pin[1]);\n\t\tif (dup2(pin[0], 0) < 0)\n\t\t\tperror(\"dup2 stdin\");\n\t\tclose(pin[0]);\n\n\t\t/* Redirect stdout. */\n\t\tclose(pout[0]);\n\t\tif (dup2(pout[1], 1) < 0)\n\t\t\tperror(\"dup2 stdout\");\n\t\tclose(pout[1]);\n\n\t\t/* Redirect stderr. */\n\t\tclose(perr[0]);\n\t\tif (dup2(perr[1], 2) < 0)\n\t\t\tperror(\"dup2 stderr\");\n\t\tclose(perr[1]);\n#else\n\t\t/*\n\t\t * Redirect stdin, stdout, and stderr.  Stdin and stdout will\n\t\t * use the same socket, as some programs (particularly rdist)\n\t\t * seem to depend on it.\n\t\t */\n\t\tclose(inout[1]);\n\t\tclose(err[1]);\n\t\tif (dup2(inout[0], 0) < 0)\t/* stdin */\n\t\t\tperror(\"dup2 stdin\");\n\t\tif (dup2(inout[0], 1) < 0)\t/* stdout (same as stdin) */\n\t\t\tperror(\"dup2 stdout\");\n\t\tclose(inout[0]);\n\t\tif (dup2(err[0], 2) < 0)\t/* stderr */\n\t\t\tperror(\"dup2 stderr\");\n\t\tclose(err[0]);\n#endif\n\n\t\t/* Do processing for the child (exec command etc). */\n\t\tdo_child(ssh, s, command);\n\t\t/* NOTREACHED */\n\tdefault:\n\t\tbreak;\n\t}\n\n#ifdef HAVE_CYGWIN\n\tcygwin_set_impersonation_token(INVALID_HANDLE_VALUE);\n#endif\n\n\ts->pid = pid;\n\t/* Set interactive/non-interactive mode. */\n\tpacket_set_interactive(s->display != NULL,\n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\n\t/*\n\t * Clear loginmsg, since it's the child's responsibility to display\n\t * it to the user, otherwise multiple sessions may accumulate\n\t * multiple copies of the login messages.\n\t */\n\tsshbuf_reset(loginmsg);\n\n#ifdef USE_PIPES\n\t/* We are the parent.  Close the child sides of the pipes. */\n\tclose(pin[0]);\n\tclose(pout[1]);\n\tclose(perr[1]);\n\n\tsession_set_fds(ssh, s, pin[1], pout[0], perr[0],\n\t    s->is_subsystem, 0);\n#else\n\t/* We are the parent.  Close the child sides of the socket pairs. */\n\tclose(inout[0]);\n\tclose(err[0]);\n\n\t/*\n\t * Enter the interactive session.  Note: server_loop must be able to\n\t * handle the case that fdin and fdout are the same.\n\t */\n\tsession_set_fds(s, inout[1], inout[1], err[1],\n\t    s->is_subsystem, 0);\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_exec_pty",
          "args": [
            "ssh",
            "s",
            "command"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "do_exec_pty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "563-657",
          "snippet": "int\ndo_exec_pty(struct ssh *ssh, Session *s, const char *command)\n{\n\tint fdout, ptyfd, ttyfd, ptymaster;\n\tpid_t pid;\n\n\tif (s == NULL)\n\t\tfatal(\"do_exec_pty: no session\");\n\tptyfd = s->ptyfd;\n\tttyfd = s->ttyfd;\n\n\t/*\n\t * Create another descriptor of the pty master side for use as the\n\t * standard input.  We could use the original descriptor, but this\n\t * simplifies code in server_loop.  The descriptor is bidirectional.\n\t * Do this before forking (and cleanup in the child) so as to\n\t * detect and gracefully fail out-of-fd conditions.\n\t */\n\tif ((fdout = dup(ptyfd)) < 0) {\n\t\terror(\"%s: dup #1: %s\", __func__, strerror(errno));\n\t\tclose(ttyfd);\n\t\tclose(ptyfd);\n\t\treturn -1;\n\t}\n\t/* we keep a reference to the pty master */\n\tif ((ptymaster = dup(ptyfd)) < 0) {\n\t\terror(\"%s: dup #2: %s\", __func__, strerror(errno));\n\t\tclose(ttyfd);\n\t\tclose(ptyfd);\n\t\tclose(fdout);\n\t\treturn -1;\n\t}\n\n\t/* Fork the child. */\n\tswitch ((pid = fork())) {\n\tcase -1:\n\t\terror(\"%s: fork: %.100s\", __func__, strerror(errno));\n\t\tclose(fdout);\n\t\tclose(ptymaster);\n\t\tclose(ttyfd);\n\t\tclose(ptyfd);\n\t\treturn -1;\n\tcase 0:\n\t\tis_child = 1;\n\n\t\tclose(fdout);\n\t\tclose(ptymaster);\n\n\t\t/* Close the master side of the pseudo tty. */\n\t\tclose(ptyfd);\n\n\t\t/* Make the pseudo tty our controlling tty. */\n\t\tpty_make_controlling_tty(&ttyfd, s->tty);\n\n\t\t/* Redirect stdin/stdout/stderr from the pseudo tty. */\n\t\tif (dup2(ttyfd, 0) < 0)\n\t\t\terror(\"dup2 stdin: %s\", strerror(errno));\n\t\tif (dup2(ttyfd, 1) < 0)\n\t\t\terror(\"dup2 stdout: %s\", strerror(errno));\n\t\tif (dup2(ttyfd, 2) < 0)\n\t\t\terror(\"dup2 stderr: %s\", strerror(errno));\n\n\t\t/* Close the extra descriptor for the pseudo tty. */\n\t\tclose(ttyfd);\n\n\t\t/* record login, etc. similar to login(1) */\n#ifndef HAVE_OSF_SIA\n\t\tdo_login(ssh, s, command);\n#endif\n\t\t/*\n\t\t * Do common processing for the child, such as execing\n\t\t * the command.\n\t\t */\n\t\tdo_child(ssh, s, command);\n\t\t/* NOTREACHED */\n\tdefault:\n\t\tbreak;\n\t}\n\n#ifdef HAVE_CYGWIN\n\tcygwin_set_impersonation_token(INVALID_HANDLE_VALUE);\n#endif\n\n\ts->pid = pid;\n\n\t/* Parent.  Close the slave side of the pseudo tty. */\n\tclose(ttyfd);\n\n\t/* Enter interactive session. */\n\ts->ptymaster = ptymaster;\n\tpacket_set_interactive(1, \n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\tsession_set_fds(ssh, s, ptyfd, fdout, -1, 1, 1);\n\treturn 0;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "extern ServerOptions options;",
            "static int is_child = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nstatic int is_child = 0;\n\nint\ndo_exec_pty(struct ssh *ssh, Session *s, const char *command)\n{\n\tint fdout, ptyfd, ttyfd, ptymaster;\n\tpid_t pid;\n\n\tif (s == NULL)\n\t\tfatal(\"do_exec_pty: no session\");\n\tptyfd = s->ptyfd;\n\tttyfd = s->ttyfd;\n\n\t/*\n\t * Create another descriptor of the pty master side for use as the\n\t * standard input.  We could use the original descriptor, but this\n\t * simplifies code in server_loop.  The descriptor is bidirectional.\n\t * Do this before forking (and cleanup in the child) so as to\n\t * detect and gracefully fail out-of-fd conditions.\n\t */\n\tif ((fdout = dup(ptyfd)) < 0) {\n\t\terror(\"%s: dup #1: %s\", __func__, strerror(errno));\n\t\tclose(ttyfd);\n\t\tclose(ptyfd);\n\t\treturn -1;\n\t}\n\t/* we keep a reference to the pty master */\n\tif ((ptymaster = dup(ptyfd)) < 0) {\n\t\terror(\"%s: dup #2: %s\", __func__, strerror(errno));\n\t\tclose(ttyfd);\n\t\tclose(ptyfd);\n\t\tclose(fdout);\n\t\treturn -1;\n\t}\n\n\t/* Fork the child. */\n\tswitch ((pid = fork())) {\n\tcase -1:\n\t\terror(\"%s: fork: %.100s\", __func__, strerror(errno));\n\t\tclose(fdout);\n\t\tclose(ptymaster);\n\t\tclose(ttyfd);\n\t\tclose(ptyfd);\n\t\treturn -1;\n\tcase 0:\n\t\tis_child = 1;\n\n\t\tclose(fdout);\n\t\tclose(ptymaster);\n\n\t\t/* Close the master side of the pseudo tty. */\n\t\tclose(ptyfd);\n\n\t\t/* Make the pseudo tty our controlling tty. */\n\t\tpty_make_controlling_tty(&ttyfd, s->tty);\n\n\t\t/* Redirect stdin/stdout/stderr from the pseudo tty. */\n\t\tif (dup2(ttyfd, 0) < 0)\n\t\t\terror(\"dup2 stdin: %s\", strerror(errno));\n\t\tif (dup2(ttyfd, 1) < 0)\n\t\t\terror(\"dup2 stdout: %s\", strerror(errno));\n\t\tif (dup2(ttyfd, 2) < 0)\n\t\t\terror(\"dup2 stderr: %s\", strerror(errno));\n\n\t\t/* Close the extra descriptor for the pseudo tty. */\n\t\tclose(ttyfd);\n\n\t\t/* record login, etc. similar to login(1) */\n#ifndef HAVE_OSF_SIA\n\t\tdo_login(ssh, s, command);\n#endif\n\t\t/*\n\t\t * Do common processing for the child, such as execing\n\t\t * the command.\n\t\t */\n\t\tdo_child(ssh, s, command);\n\t\t/* NOTREACHED */\n\tdefault:\n\t\tbreak;\n\t}\n\n#ifdef HAVE_CYGWIN\n\tcygwin_set_impersonation_token(INVALID_HANDLE_VALUE);\n#endif\n\n\ts->pid = pid;\n\n\t/* Parent.  Close the slave side of the pseudo tty. */\n\tclose(ttyfd);\n\n\t/* Enter interactive session. */\n\ts->ptymaster = ptymaster;\n\tpacket_set_interactive(1, \n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\tsession_set_fds(ssh, s, ptyfd, fdout, -1, 1, 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRIVSEP",
          "args": [
            "audit_run_command(shell)"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_run_command",
          "args": [
            "shell"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "audit_run_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit.c",
          "lines": "177-182",
          "snippet": "void\naudit_run_command(const char *command)\n{\n\tdebug(\"audit run command euid %d user %s command '%.200s'\", geteuid(),\n\t    audit_username(), command);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"log.h\"",
            "#include \"audit.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"audit.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\naudit_run_command(const char *command)\n{\n\tdebug(\"audit run command euid %d user %s command '%.200s'\", geteuid(),\n\t    audit_username(), command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRIVSEP",
          "args": [
            "audit_run_command(command)"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Starting session: %s%s%s for %s from %.200s port %d id %d\"",
            "session_type",
            "tty == NULL ? \"\" : \" on \"",
            "tty == NULL ? \"\" : tty",
            "s->pw->pw_name",
            "ssh_remote_ipaddr(ssh)",
            "ssh_remote_port(ssh)",
            "s->self"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_port",
          "args": [
            "ssh"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "539-544",
          "snippet": "int\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "tty",
            "\"/dev/\"",
            "5"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "session_type",
            "sizeof(session_type)",
            "\"command\""
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_INTERNAL_SFTP",
          "args": [
            "command"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SUBSYSTEM_INT_SFTP_ERROR\t3\n#define SUBSYSTEM_INT_SFTP\t\t2\n#define SUBSYSTEM_EXT\t\t\t1\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern struct sshbuf *loginmsg;\nextern struct sshauthopt *auth_opts;\nconst char *original_command = NULL;\nstatic Session *sessions = NULL;\n\nint\ndo_exec(struct ssh *ssh, Session *s, const char *command)\n{\n\tint ret;\n\tconst char *forced = NULL, *tty = NULL;\n\tchar session_type[1024];\n\n\tif (options.adm_forced_command) {\n\t\toriginal_command = command;\n\t\tcommand = options.adm_forced_command;\n\t\tforced = \"(config)\";\n\t} else if (auth_opts->force_command != NULL) {\n\t\toriginal_command = command;\n\t\tcommand = auth_opts->force_command;\n\t\tforced = \"(key-option)\";\n\t}\n\ts->forced = 0;\n\tif (forced != NULL) {\n\t\ts->forced = 1;\n\t\tif (IS_INTERNAL_SFTP(command)) {\n\t\t\ts->is_subsystem = s->is_subsystem ?\n\t\t\t    SUBSYSTEM_INT_SFTP : SUBSYSTEM_INT_SFTP_ERROR;\n\t\t} else if (s->is_subsystem)\n\t\t\ts->is_subsystem = SUBSYSTEM_EXT;\n\t\tsnprintf(session_type, sizeof(session_type),\n\t\t    \"forced-command %s '%.900s'\", forced, command);\n\t} else if (s->is_subsystem) {\n\t\tsnprintf(session_type, sizeof(session_type),\n\t\t    \"subsystem '%.900s'\", s->subsys);\n\t} else if (command == NULL) {\n\t\tsnprintf(session_type, sizeof(session_type), \"shell\");\n\t} else {\n\t\t/* NB. we don't log unforced commands to preserve privacy */\n\t\tsnprintf(session_type, sizeof(session_type), \"command\");\n\t}\n\n\tif (s->ttyfd != -1) {\n\t\ttty = s->tty;\n\t\tif (strncmp(tty, \"/dev/\", 5) == 0)\n\t\t\ttty += 5;\n\t}\n\n\tverbose(\"Starting session: %s%s%s for %s from %.200s port %d id %d\",\n\t    session_type,\n\t    tty == NULL ? \"\" : \" on \",\n\t    tty == NULL ? \"\" : tty,\n\t    s->pw->pw_name,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    s->self);\n\n#ifdef SSH_AUDIT_EVENTS\n\tif (command != NULL)\n\t\tPRIVSEP(audit_run_command(command));\n\telse if (s->ttyfd == -1) {\n\t\tchar *shell = s->pw->pw_shell;\n\n\t\tif (shell[0] == '\\0')\t/* empty shell means /bin/sh */\n\t\t\tshell =_PATH_BSHELL;\n\t\tPRIVSEP(audit_run_command(shell));\n\t}\n#endif\n\tif (s->ttyfd != -1)\n\t\tret = do_exec_pty(ssh, s, command);\n\telse\n\t\tret = do_exec_no_pty(ssh, s, command);\n\n\toriginal_command = NULL;\n\n\t/*\n\t * Clear loginmsg: it's the child's responsibility to display\n\t * it to the user, otherwise multiple sessions may accumulate\n\t * multiple copies of the login messages.\n\t */\n\tsshbuf_reset(loginmsg);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "do_pre_login",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "660-685",
    "snippet": "static void\ndo_pre_login(Session *s)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tsocklen_t fromlen;\n\tstruct sockaddr_storage from;\n\tpid_t pid = getpid();\n\n\t/*\n\t * Get IP address of client. If the connection is not a socket, let\n\t * the address be 0.0.0.0.\n\t */\n\tmemset(&from, 0, sizeof(from));\n\tfromlen = sizeof(from);\n\tif (packet_connection_is_on_socket()) {\n\t\tif (getpeername(packet_get_connection_in(),\n\t\t    (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\tdebug(\"getpeername: %.100s\", strerror(errno));\n\t\t\tcleanup_exit(255);\n\t\t}\n\t}\n\n\trecord_utmp_only(pid, s->tty, s->pw->pw_name,\n\t    session_get_remote_name_or_ip(ssh, utmp_len, options.use_dns),\n\t    (struct sockaddr *)&from, fromlen);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "extern ServerOptions options;",
      "extern u_int utmp_len;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "record_utmp_only",
          "args": [
            "pid",
            "s->tty",
            "s->pw->pw_name",
            "session_get_remote_name_or_ip(ssh, utmp_len, options.use_dns)",
            "(struct sockaddr *)&from",
            "fromlen"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "record_utmp_only",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshlogin.c",
          "lines": "148-158",
          "snippet": "void\nrecord_utmp_only(pid_t pid, const char *ttyname, const char *user,\n\t\t const char *host, struct sockaddr *addr, socklen_t addrlen)\n{\n\tstruct logininfo *li;\n\n\tli = login_alloc_entry(pid, user, host, ttyname);\n\tlogin_set_addr(li, addr, addrlen);\n\tlogin_utmp_only(li);\n\tlogin_free_entry(li);\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"loginrec.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshlogin.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"loginrec.h\"\n#include \"ssherr.h\"\n#include \"sshlogin.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nrecord_utmp_only(pid_t pid, const char *ttyname, const char *user,\n\t\t const char *host, struct sockaddr *addr, socklen_t addrlen)\n{\n\tstruct logininfo *li;\n\n\tli = login_alloc_entry(pid, user, host, ttyname);\n\tlogin_set_addr(li, addr, addrlen);\n\tlogin_utmp_only(li);\n\tlogin_free_entry(li);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_get_remote_name_or_ip",
          "args": [
            "ssh",
            "utmp_len",
            "options.use_dns"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "session_get_remote_name_or_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2703-2713",
          "snippet": "const char *\nsession_get_remote_name_or_ip(struct ssh *ssh, u_int utmp_size, int use_dns)\n{\n\tconst char *remote = \"\";\n\n\tif (utmp_size > 0)\n\t\tremote = auth_get_canonical_hostname(ssh, use_dns);\n\tif (utmp_size == 0 || strlen(remote) > utmp_size)\n\t\tremote = ssh_remote_ipaddr(ssh);\n\treturn remote;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsession_get_remote_name_or_ip(struct ssh *ssh, u_int utmp_size, int use_dns)\n{\n\tconst char *remote = \"\";\n\n\tif (utmp_size > 0)\n\t\tremote = auth_get_canonical_hostname(ssh, use_dns);\n\tif (utmp_size == 0 || strlen(remote) > utmp_size)\n\t\tremote = ssh_remote_ipaddr(ssh);\n\treturn remote;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_exit",
          "args": [
            "255"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"getpeername: %.100s\"",
            "strerror(errno)"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpeername",
          "args": [
            "packet_get_connection_in()",
            "(struct sockaddr *)&from",
            "&fromlen"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_connection_in",
          "args": [],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_connection_is_on_socket",
          "args": [],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&from",
            "0",
            "sizeof(from)"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern u_int utmp_len;\n\nstatic void\ndo_pre_login(Session *s)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tsocklen_t fromlen;\n\tstruct sockaddr_storage from;\n\tpid_t pid = getpid();\n\n\t/*\n\t * Get IP address of client. If the connection is not a socket, let\n\t * the address be 0.0.0.0.\n\t */\n\tmemset(&from, 0, sizeof(from));\n\tfromlen = sizeof(from);\n\tif (packet_connection_is_on_socket()) {\n\t\tif (getpeername(packet_get_connection_in(),\n\t\t    (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\tdebug(\"getpeername: %.100s\", strerror(errno));\n\t\t\tcleanup_exit(255);\n\t\t}\n\t}\n\n\trecord_utmp_only(pid, s->tty, s->pw->pw_name,\n\t    session_get_remote_name_or_ip(ssh, utmp_len, options.use_dns),\n\t    (struct sockaddr *)&from, fromlen);\n}"
  },
  {
    "function_name": "do_exec_pty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "563-657",
    "snippet": "int\ndo_exec_pty(struct ssh *ssh, Session *s, const char *command)\n{\n\tint fdout, ptyfd, ttyfd, ptymaster;\n\tpid_t pid;\n\n\tif (s == NULL)\n\t\tfatal(\"do_exec_pty: no session\");\n\tptyfd = s->ptyfd;\n\tttyfd = s->ttyfd;\n\n\t/*\n\t * Create another descriptor of the pty master side for use as the\n\t * standard input.  We could use the original descriptor, but this\n\t * simplifies code in server_loop.  The descriptor is bidirectional.\n\t * Do this before forking (and cleanup in the child) so as to\n\t * detect and gracefully fail out-of-fd conditions.\n\t */\n\tif ((fdout = dup(ptyfd)) < 0) {\n\t\terror(\"%s: dup #1: %s\", __func__, strerror(errno));\n\t\tclose(ttyfd);\n\t\tclose(ptyfd);\n\t\treturn -1;\n\t}\n\t/* we keep a reference to the pty master */\n\tif ((ptymaster = dup(ptyfd)) < 0) {\n\t\terror(\"%s: dup #2: %s\", __func__, strerror(errno));\n\t\tclose(ttyfd);\n\t\tclose(ptyfd);\n\t\tclose(fdout);\n\t\treturn -1;\n\t}\n\n\t/* Fork the child. */\n\tswitch ((pid = fork())) {\n\tcase -1:\n\t\terror(\"%s: fork: %.100s\", __func__, strerror(errno));\n\t\tclose(fdout);\n\t\tclose(ptymaster);\n\t\tclose(ttyfd);\n\t\tclose(ptyfd);\n\t\treturn -1;\n\tcase 0:\n\t\tis_child = 1;\n\n\t\tclose(fdout);\n\t\tclose(ptymaster);\n\n\t\t/* Close the master side of the pseudo tty. */\n\t\tclose(ptyfd);\n\n\t\t/* Make the pseudo tty our controlling tty. */\n\t\tpty_make_controlling_tty(&ttyfd, s->tty);\n\n\t\t/* Redirect stdin/stdout/stderr from the pseudo tty. */\n\t\tif (dup2(ttyfd, 0) < 0)\n\t\t\terror(\"dup2 stdin: %s\", strerror(errno));\n\t\tif (dup2(ttyfd, 1) < 0)\n\t\t\terror(\"dup2 stdout: %s\", strerror(errno));\n\t\tif (dup2(ttyfd, 2) < 0)\n\t\t\terror(\"dup2 stderr: %s\", strerror(errno));\n\n\t\t/* Close the extra descriptor for the pseudo tty. */\n\t\tclose(ttyfd);\n\n\t\t/* record login, etc. similar to login(1) */\n#ifndef HAVE_OSF_SIA\n\t\tdo_login(ssh, s, command);\n#endif\n\t\t/*\n\t\t * Do common processing for the child, such as execing\n\t\t * the command.\n\t\t */\n\t\tdo_child(ssh, s, command);\n\t\t/* NOTREACHED */\n\tdefault:\n\t\tbreak;\n\t}\n\n#ifdef HAVE_CYGWIN\n\tcygwin_set_impersonation_token(INVALID_HANDLE_VALUE);\n#endif\n\n\ts->pid = pid;\n\n\t/* Parent.  Close the slave side of the pseudo tty. */\n\tclose(ttyfd);\n\n\t/* Enter interactive session. */\n\ts->ptymaster = ptymaster;\n\tpacket_set_interactive(1, \n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\tsession_set_fds(ssh, s, ptyfd, fdout, -1, 1, 1);\n\treturn 0;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "extern ServerOptions options;",
      "static int is_child = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "session_set_fds",
          "args": [
            "ssh",
            "s",
            "ptyfd",
            "fdout",
            "-1",
            "1",
            "1"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "session_set_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2241-2255",
          "snippet": "void\nsession_set_fds(struct ssh *ssh, Session *s,\n    int fdin, int fdout, int fderr, int ignore_fderr, int is_tty)\n{\n\t/*\n\t * now that have a child and a pipe to the child,\n\t * we can activate our channel and register the fd's\n\t */\n\tif (s->chanid == -1)\n\t\tfatal(\"no channel for session %d\", s->self);\n\tchannel_set_fds(ssh, s->chanid,\n\t    fdout, fdin, fderr,\n\t    ignore_fderr ? CHAN_EXTENDED_IGNORE : CHAN_EXTENDED_READ,\n\t    1, is_tty, CHAN_SES_WINDOW_DEFAULT);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_set_fds(struct ssh *ssh, Session *s,\n    int fdin, int fdout, int fderr, int ignore_fderr, int is_tty)\n{\n\t/*\n\t * now that have a child and a pipe to the child,\n\t * we can activate our channel and register the fd's\n\t */\n\tif (s->chanid == -1)\n\t\tfatal(\"no channel for session %d\", s->self);\n\tchannel_set_fds(ssh, s->chanid,\n\t    fdout, fdin, fderr,\n\t    ignore_fderr ? CHAN_EXTENDED_IGNORE : CHAN_EXTENDED_READ,\n\t    1, is_tty, CHAN_SES_WINDOW_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_set_interactive",
          "args": [
            "1",
            "options.ip_qos_interactive",
            "options.ip_qos_bulk"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ttyfd"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "child_close_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1490-1526",
          "snippet": "static void\nchild_close_fds(struct ssh *ssh)\n{\n\textern int auth_sock;\n\n\tif (auth_sock != -1) {\n\t\tclose(auth_sock);\n\t\tauth_sock = -1;\n\t}\n\n\tif (packet_get_connection_in() == packet_get_connection_out())\n\t\tclose(packet_get_connection_in());\n\telse {\n\t\tclose(packet_get_connection_in());\n\t\tclose(packet_get_connection_out());\n\t}\n\t/*\n\t * Close all descriptors related to channels.  They will still remain\n\t * open in the parent.\n\t */\n\t/* XXX better use close-on-exec? -markus */\n\tchannel_close_all(ssh);\n\n\t/*\n\t * Close any extra file descriptors.  Note that there may still be\n\t * descriptors left by system functions.  They will be closed later.\n\t */\n\tendpwent();\n\n\t/*\n\t * Close any extra open file descriptors so that we don't have them\n\t * hanging around in clients.  Note that we want to do this after\n\t * initgroups, because at least on Solaris 2.3 it leaves file\n\t * descriptors open.\n\t */\n\tclosefrom(STDERR_FILENO + 1);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nchild_close_fds(struct ssh *ssh)\n{\n\textern int auth_sock;\n\n\tif (auth_sock != -1) {\n\t\tclose(auth_sock);\n\t\tauth_sock = -1;\n\t}\n\n\tif (packet_get_connection_in() == packet_get_connection_out())\n\t\tclose(packet_get_connection_in());\n\telse {\n\t\tclose(packet_get_connection_in());\n\t\tclose(packet_get_connection_out());\n\t}\n\t/*\n\t * Close all descriptors related to channels.  They will still remain\n\t * open in the parent.\n\t */\n\t/* XXX better use close-on-exec? -markus */\n\tchannel_close_all(ssh);\n\n\t/*\n\t * Close any extra file descriptors.  Note that there may still be\n\t * descriptors left by system functions.  They will be closed later.\n\t */\n\tendpwent();\n\n\t/*\n\t * Close any extra open file descriptors so that we don't have them\n\t * hanging around in clients.  Note that we want to do this after\n\t * initgroups, because at least on Solaris 2.3 it leaves file\n\t * descriptors open.\n\t */\n\tclosefrom(STDERR_FILENO + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cygwin_set_impersonation_token",
          "args": [
            "INVALID_HANDLE_VALUE"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_child",
          "args": [
            "ssh",
            "s",
            "command"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "do_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1534-1734",
          "snippet": "void\ndo_child(struct ssh *ssh, Session *s, const char *command)\n{\n\textern char **environ;\n\tchar **env;\n\tchar *argv[ARGV_MAX];\n\tconst char *shell, *shell0;\n\tstruct passwd *pw = s->pw;\n\tint r = 0;\n\n\t/* remove hostkey from the child's memory */\n\tdestroy_sensitive_data();\n\tpacket_clear_keys();\n\n\t/* Force a password change */\n\tif (s->authctxt->force_pwchange) {\n\t\tdo_setusercontext(pw);\n\t\tchild_close_fds(ssh);\n\t\tdo_pwchange(s);\n\t\texit(1);\n\t}\n\n\t/*\n\t * Login(1) does this as well, and it needs uid 0 for the \"-h\"\n\t * switch, so we let login(1) to this for us.\n\t */\n#ifdef HAVE_OSF_SIA\n\tsession_setup_sia(pw, s->ttyfd == -1 ? NULL : s->tty);\n\tif (!check_quietlogin(s, command))\n\t\tdo_motd();\n#else /* HAVE_OSF_SIA */\n\t/* When PAM is enabled we rely on it to do the nologin check */\n\tif (!options.use_pam)\n\t\tdo_nologin(pw);\n\tdo_setusercontext(pw);\n\t/*\n\t * PAM session modules in do_setusercontext may have\n\t * generated messages, so if this in an interactive\n\t * login then display them too.\n\t */\n\tif (!check_quietlogin(s, command))\n\t\tdisplay_loginmsg();\n#endif /* HAVE_OSF_SIA */\n\n#ifdef USE_PAM\n\tif (options.use_pam && !is_pam_session_open()) {\n\t\tdebug3(\"PAM session not opened, exiting\");\n\t\tdisplay_loginmsg();\n\t\texit(254);\n\t}\n#endif\n\n\t/*\n\t * Get the shell from the password data.  An empty shell field is\n\t * legal, and means /bin/sh.\n\t */\n\tshell = (pw->pw_shell[0] == '\\0') ? _PATH_BSHELL : pw->pw_shell;\n\n\t/*\n\t * Make sure $SHELL points to the shell from the password file,\n\t * even if shell is overridden from login.conf\n\t */\n\tenv = do_setup_env(ssh, s, shell);\n\n#ifdef HAVE_LOGIN_CAP\n\tshell = login_getcapstr(lc, \"shell\", (char *)shell, (char *)shell);\n#endif\n\n\t/*\n\t * Close the connection descriptors; note that this is the child, and\n\t * the server will still have the socket open, and it is important\n\t * that we do not shutdown it.  Note that the descriptors cannot be\n\t * closed before building the environment, as we call\n\t * ssh_remote_ipaddr there.\n\t */\n\tchild_close_fds(ssh);\n\n\t/*\n\t * Must take new environment into use so that .ssh/rc,\n\t * /etc/ssh/sshrc and xauth are run in the proper environment.\n\t */\n\tenviron = env;\n\n#if defined(KRB5) && defined(USE_AFS)\n\t/*\n\t * At this point, we check to see if AFS is active and if we have\n\t * a valid Kerberos 5 TGT. If so, it seems like a good idea to see\n\t * if we can (and need to) extend the ticket into an AFS token. If\n\t * we don't do this, we run into potential problems if the user's\n\t * home directory is in AFS and it's not world-readable.\n\t */\n\n\tif (options.kerberos_get_afs_token && k_hasafs() &&\n\t    (s->authctxt->krb5_ctx != NULL)) {\n\t\tchar cell[64];\n\n\t\tdebug(\"Getting AFS token\");\n\n\t\tk_setpag();\n\n\t\tif (k_afs_cell_of_file(pw->pw_dir, cell, sizeof(cell)) == 0)\n\t\t\tkrb5_afslog(s->authctxt->krb5_ctx,\n\t\t\t    s->authctxt->krb5_fwd_ccache, cell, NULL);\n\n\t\tkrb5_afslog_home(s->authctxt->krb5_ctx,\n\t\t    s->authctxt->krb5_fwd_ccache, NULL, NULL, pw->pw_dir);\n\t}\n#endif\n\n\t/* Change current directory to the user's home directory. */\n\tif (chdir(pw->pw_dir) < 0) {\n\t\t/* Suppress missing homedir warning for chroot case */\n#ifdef HAVE_LOGIN_CAP\n\t\tr = login_getcapbool(lc, \"requirehome\", 0);\n#endif\n\t\tif (r || !in_chroot) {\n\t\t\tfprintf(stderr, \"Could not chdir to home \"\n\t\t\t    \"directory %s: %s\\n\", pw->pw_dir,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tif (r)\n\t\t\texit(1);\n\t}\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tdo_rc_files(ssh, s, shell);\n\n\t/* restore SIGPIPE for child */\n\tsignal(SIGPIPE, SIG_DFL);\n\n\tif (s->is_subsystem == SUBSYSTEM_INT_SFTP_ERROR) {\n\t\tprintf(\"This service allows sftp connections only.\\n\");\n\t\tfflush(NULL);\n\t\texit(1);\n\t} else if (s->is_subsystem == SUBSYSTEM_INT_SFTP) {\n\t\textern int optind, optreset;\n\t\tint i;\n\t\tchar *p, *args;\n\n\t\tsetproctitle(\"%s@%s\", s->pw->pw_name, INTERNAL_SFTP_NAME);\n\t\targs = xstrdup(command ? command : \"sftp-server\");\n\t\tfor (i = 0, (p = strtok(args, \" \")); p; (p = strtok(NULL, \" \")))\n\t\t\tif (i < ARGV_MAX - 1)\n\t\t\t\targv[i++] = p;\n\t\targv[i] = NULL;\n\t\toptind = optreset = 1;\n\t\t__progname = argv[0];\n#ifdef WITH_SELINUX\n\t\tssh_selinux_change_context(\"sftpd_t\");\n#endif\n\t\texit(sftp_server_main(i, argv, s->pw));\n\t}\n\n\tfflush(NULL);\n\n\t/* Get the last component of the shell name. */\n\tif ((shell0 = strrchr(shell, '/')) != NULL)\n\t\tshell0++;\n\telse\n\t\tshell0 = shell;\n\n\t/*\n\t * If we have no command, execute the shell.  In this case, the shell\n\t * name to be passed in argv[0] is preceded by '-' to indicate that\n\t * this is a login shell.\n\t */\n\tif (!command) {\n\t\tchar argv0[256];\n\n\t\t/* Start the shell.  Set initial character to '-'. */\n\t\targv0[0] = '-';\n\n\t\tif (strlcpy(argv0 + 1, shell0, sizeof(argv0) - 1)\n\t\t    >= sizeof(argv0) - 1) {\n\t\t\terrno = EINVAL;\n\t\t\tperror(shell);\n\t\t\texit(1);\n\t\t}\n\n\t\t/* Execute the shell. */\n\t\targv[0] = argv0;\n\t\targv[1] = NULL;\n\t\texecve(shell, argv, env);\n\n\t\t/* Executing the shell failed. */\n\t\tperror(shell);\n\t\texit(1);\n\t}\n\t/*\n\t * Execute the command using the user's shell.  This uses the -c\n\t * option to execute the command.\n\t */\n\targv[0] = (char *) shell0;\n\targv[1] = \"-c\";\n\targv[2] = (char *) command;\n\targv[3] = NULL;\n\texecve(shell, argv, env);\n\tperror(shell);\n\texit(1);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define ARGV_MAX 10",
            "#define SUBSYSTEM_INT_SFTP_ERROR\t3",
            "#define SUBSYSTEM_INT_SFTP\t\t2"
          ],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "void\tdo_motd(void);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "extern ServerOptions options;",
            "extern char *__progname;",
            "extern void destroy_sensitive_data(void);",
            "static int in_chroot = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define ARGV_MAX 10\n#define SUBSYSTEM_INT_SFTP_ERROR\t3\n#define SUBSYSTEM_INT_SFTP\t\t2\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nvoid\tdo_motd(void);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern char *__progname;\nextern void destroy_sensitive_data(void);\nstatic int in_chroot = 0;\n\nvoid\ndo_child(struct ssh *ssh, Session *s, const char *command)\n{\n\textern char **environ;\n\tchar **env;\n\tchar *argv[ARGV_MAX];\n\tconst char *shell, *shell0;\n\tstruct passwd *pw = s->pw;\n\tint r = 0;\n\n\t/* remove hostkey from the child's memory */\n\tdestroy_sensitive_data();\n\tpacket_clear_keys();\n\n\t/* Force a password change */\n\tif (s->authctxt->force_pwchange) {\n\t\tdo_setusercontext(pw);\n\t\tchild_close_fds(ssh);\n\t\tdo_pwchange(s);\n\t\texit(1);\n\t}\n\n\t/*\n\t * Login(1) does this as well, and it needs uid 0 for the \"-h\"\n\t * switch, so we let login(1) to this for us.\n\t */\n#ifdef HAVE_OSF_SIA\n\tsession_setup_sia(pw, s->ttyfd == -1 ? NULL : s->tty);\n\tif (!check_quietlogin(s, command))\n\t\tdo_motd();\n#else /* HAVE_OSF_SIA */\n\t/* When PAM is enabled we rely on it to do the nologin check */\n\tif (!options.use_pam)\n\t\tdo_nologin(pw);\n\tdo_setusercontext(pw);\n\t/*\n\t * PAM session modules in do_setusercontext may have\n\t * generated messages, so if this in an interactive\n\t * login then display them too.\n\t */\n\tif (!check_quietlogin(s, command))\n\t\tdisplay_loginmsg();\n#endif /* HAVE_OSF_SIA */\n\n#ifdef USE_PAM\n\tif (options.use_pam && !is_pam_session_open()) {\n\t\tdebug3(\"PAM session not opened, exiting\");\n\t\tdisplay_loginmsg();\n\t\texit(254);\n\t}\n#endif\n\n\t/*\n\t * Get the shell from the password data.  An empty shell field is\n\t * legal, and means /bin/sh.\n\t */\n\tshell = (pw->pw_shell[0] == '\\0') ? _PATH_BSHELL : pw->pw_shell;\n\n\t/*\n\t * Make sure $SHELL points to the shell from the password file,\n\t * even if shell is overridden from login.conf\n\t */\n\tenv = do_setup_env(ssh, s, shell);\n\n#ifdef HAVE_LOGIN_CAP\n\tshell = login_getcapstr(lc, \"shell\", (char *)shell, (char *)shell);\n#endif\n\n\t/*\n\t * Close the connection descriptors; note that this is the child, and\n\t * the server will still have the socket open, and it is important\n\t * that we do not shutdown it.  Note that the descriptors cannot be\n\t * closed before building the environment, as we call\n\t * ssh_remote_ipaddr there.\n\t */\n\tchild_close_fds(ssh);\n\n\t/*\n\t * Must take new environment into use so that .ssh/rc,\n\t * /etc/ssh/sshrc and xauth are run in the proper environment.\n\t */\n\tenviron = env;\n\n#if defined(KRB5) && defined(USE_AFS)\n\t/*\n\t * At this point, we check to see if AFS is active and if we have\n\t * a valid Kerberos 5 TGT. If so, it seems like a good idea to see\n\t * if we can (and need to) extend the ticket into an AFS token. If\n\t * we don't do this, we run into potential problems if the user's\n\t * home directory is in AFS and it's not world-readable.\n\t */\n\n\tif (options.kerberos_get_afs_token && k_hasafs() &&\n\t    (s->authctxt->krb5_ctx != NULL)) {\n\t\tchar cell[64];\n\n\t\tdebug(\"Getting AFS token\");\n\n\t\tk_setpag();\n\n\t\tif (k_afs_cell_of_file(pw->pw_dir, cell, sizeof(cell)) == 0)\n\t\t\tkrb5_afslog(s->authctxt->krb5_ctx,\n\t\t\t    s->authctxt->krb5_fwd_ccache, cell, NULL);\n\n\t\tkrb5_afslog_home(s->authctxt->krb5_ctx,\n\t\t    s->authctxt->krb5_fwd_ccache, NULL, NULL, pw->pw_dir);\n\t}\n#endif\n\n\t/* Change current directory to the user's home directory. */\n\tif (chdir(pw->pw_dir) < 0) {\n\t\t/* Suppress missing homedir warning for chroot case */\n#ifdef HAVE_LOGIN_CAP\n\t\tr = login_getcapbool(lc, \"requirehome\", 0);\n#endif\n\t\tif (r || !in_chroot) {\n\t\t\tfprintf(stderr, \"Could not chdir to home \"\n\t\t\t    \"directory %s: %s\\n\", pw->pw_dir,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tif (r)\n\t\t\texit(1);\n\t}\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tdo_rc_files(ssh, s, shell);\n\n\t/* restore SIGPIPE for child */\n\tsignal(SIGPIPE, SIG_DFL);\n\n\tif (s->is_subsystem == SUBSYSTEM_INT_SFTP_ERROR) {\n\t\tprintf(\"This service allows sftp connections only.\\n\");\n\t\tfflush(NULL);\n\t\texit(1);\n\t} else if (s->is_subsystem == SUBSYSTEM_INT_SFTP) {\n\t\textern int optind, optreset;\n\t\tint i;\n\t\tchar *p, *args;\n\n\t\tsetproctitle(\"%s@%s\", s->pw->pw_name, INTERNAL_SFTP_NAME);\n\t\targs = xstrdup(command ? command : \"sftp-server\");\n\t\tfor (i = 0, (p = strtok(args, \" \")); p; (p = strtok(NULL, \" \")))\n\t\t\tif (i < ARGV_MAX - 1)\n\t\t\t\targv[i++] = p;\n\t\targv[i] = NULL;\n\t\toptind = optreset = 1;\n\t\t__progname = argv[0];\n#ifdef WITH_SELINUX\n\t\tssh_selinux_change_context(\"sftpd_t\");\n#endif\n\t\texit(sftp_server_main(i, argv, s->pw));\n\t}\n\n\tfflush(NULL);\n\n\t/* Get the last component of the shell name. */\n\tif ((shell0 = strrchr(shell, '/')) != NULL)\n\t\tshell0++;\n\telse\n\t\tshell0 = shell;\n\n\t/*\n\t * If we have no command, execute the shell.  In this case, the shell\n\t * name to be passed in argv[0] is preceded by '-' to indicate that\n\t * this is a login shell.\n\t */\n\tif (!command) {\n\t\tchar argv0[256];\n\n\t\t/* Start the shell.  Set initial character to '-'. */\n\t\targv0[0] = '-';\n\n\t\tif (strlcpy(argv0 + 1, shell0, sizeof(argv0) - 1)\n\t\t    >= sizeof(argv0) - 1) {\n\t\t\terrno = EINVAL;\n\t\t\tperror(shell);\n\t\t\texit(1);\n\t\t}\n\n\t\t/* Execute the shell. */\n\t\targv[0] = argv0;\n\t\targv[1] = NULL;\n\t\texecve(shell, argv, env);\n\n\t\t/* Executing the shell failed. */\n\t\tperror(shell);\n\t\texit(1);\n\t}\n\t/*\n\t * Execute the command using the user's shell.  This uses the -c\n\t * option to execute the command.\n\t */\n\targv[0] = (char *) shell0;\n\targv[1] = \"-c\";\n\targv[2] = (char *) command;\n\targv[3] = NULL;\n\texecve(shell, argv, env);\n\tperror(shell);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_login",
          "args": [
            "ssh",
            "s",
            "command"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "do_login",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "772-820",
          "snippet": "void\ndo_login(struct ssh *ssh, Session *s, const char *command)\n{\n\tsocklen_t fromlen;\n\tstruct sockaddr_storage from;\n\tstruct passwd * pw = s->pw;\n\tpid_t pid = getpid();\n\n\t/*\n\t * Get IP address of client. If the connection is not a socket, let\n\t * the address be 0.0.0.0.\n\t */\n\tmemset(&from, 0, sizeof(from));\n\tfromlen = sizeof(from);\n\tif (packet_connection_is_on_socket()) {\n\t\tif (getpeername(packet_get_connection_in(),\n\t\t    (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\tdebug(\"getpeername: %.100s\", strerror(errno));\n\t\t\tcleanup_exit(255);\n\t\t}\n\t}\n\n\t/* Record that there was a login on that tty from the remote host. */\n\tif (!use_privsep)\n\t\trecord_login(pid, s->tty, pw->pw_name, pw->pw_uid,\n\t\t    session_get_remote_name_or_ip(ssh, utmp_len,\n\t\t    options.use_dns),\n\t\t    (struct sockaddr *)&from, fromlen);\n\n#ifdef USE_PAM\n\t/*\n\t * If password change is needed, do it now.\n\t * This needs to occur before the ~/.hushlogin check.\n\t */\n\tif (options.use_pam && !use_privsep && s->authctxt->force_pwchange) {\n\t\tdisplay_loginmsg();\n\t\tdo_pam_chauthtok();\n\t\ts->authctxt->force_pwchange = 0;\n\t\t/* XXX - signal [net] parent to enable forwardings */\n\t}\n#endif\n\n\tif (check_quietlogin(s, command))\n\t\treturn;\n\n\tdisplay_loginmsg();\n\n\tdo_motd();\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "void\tdo_motd(void);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "extern ServerOptions options;",
            "extern u_int utmp_len;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nvoid\tdo_motd(void);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern u_int utmp_len;\n\nvoid\ndo_login(struct ssh *ssh, Session *s, const char *command)\n{\n\tsocklen_t fromlen;\n\tstruct sockaddr_storage from;\n\tstruct passwd * pw = s->pw;\n\tpid_t pid = getpid();\n\n\t/*\n\t * Get IP address of client. If the connection is not a socket, let\n\t * the address be 0.0.0.0.\n\t */\n\tmemset(&from, 0, sizeof(from));\n\tfromlen = sizeof(from);\n\tif (packet_connection_is_on_socket()) {\n\t\tif (getpeername(packet_get_connection_in(),\n\t\t    (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\tdebug(\"getpeername: %.100s\", strerror(errno));\n\t\t\tcleanup_exit(255);\n\t\t}\n\t}\n\n\t/* Record that there was a login on that tty from the remote host. */\n\tif (!use_privsep)\n\t\trecord_login(pid, s->tty, pw->pw_name, pw->pw_uid,\n\t\t    session_get_remote_name_or_ip(ssh, utmp_len,\n\t\t    options.use_dns),\n\t\t    (struct sockaddr *)&from, fromlen);\n\n#ifdef USE_PAM\n\t/*\n\t * If password change is needed, do it now.\n\t * This needs to occur before the ~/.hushlogin check.\n\t */\n\tif (options.use_pam && !use_privsep && s->authctxt->force_pwchange) {\n\t\tdisplay_loginmsg();\n\t\tdo_pam_chauthtok();\n\t\ts->authctxt->force_pwchange = 0;\n\t\t/* XXX - signal [net] parent to enable forwardings */\n\t}\n#endif\n\n\tif (check_quietlogin(s, command))\n\t\treturn;\n\n\tdisplay_loginmsg();\n\n\tdo_motd();\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"dup2 stderr: %s\"",
            "strerror(errno)"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "ttyfd",
            "2"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "ttyfd",
            "1"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "ttyfd",
            "0"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pty_make_controlling_tty",
          "args": [
            "&ttyfd",
            "s->tty"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "pty_make_controlling_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshpty.c",
          "lines": "98-146",
          "snippet": "void\npty_make_controlling_tty(int *ttyfd, const char *tty)\n{\n\tint fd;\n\n\t/* First disconnect from the old controlling tty. */\n#ifdef TIOCNOTTY\n\tfd = open(_PATH_TTY, O_RDWR | O_NOCTTY);\n\tif (fd >= 0) {\n\t\t(void) ioctl(fd, TIOCNOTTY, NULL);\n\t\tclose(fd);\n\t}\n#endif /* TIOCNOTTY */\n\tif (setsid() < 0)\n\t\terror(\"setsid: %.100s\", strerror(errno));\n\n\t/*\n\t * Verify that we are successfully disconnected from the controlling\n\t * tty.\n\t */\n\tfd = open(_PATH_TTY, O_RDWR | O_NOCTTY);\n\tif (fd >= 0) {\n\t\terror(\"Failed to disconnect from controlling tty.\");\n\t\tclose(fd);\n\t}\n\t/* Make it our controlling tty. */\n#ifdef TIOCSCTTY\n\tdebug(\"Setting controlling tty using TIOCSCTTY.\");\n\tif (ioctl(*ttyfd, TIOCSCTTY, NULL) < 0)\n\t\terror(\"ioctl(TIOCSCTTY): %.100s\", strerror(errno));\n#endif /* TIOCSCTTY */\n#ifdef NEED_SETPGRP\n\tif (setpgrp(0,0) < 0)\n\t\terror(\"SETPGRP %s\",strerror(errno));\n#endif /* NEED_SETPGRP */\n\tfd = open(tty, O_RDWR);\n\tif (fd < 0)\n\t\terror(\"%.100s: %.100s\", tty, strerror(errno));\n\telse\n\t\tclose(fd);\n\n\t/* Verify that we now have a controlling tty. */\n\tfd = open(_PATH_TTY, O_WRONLY);\n\tif (fd < 0)\n\t\terror(\"open /dev/tty failed - could not set controlling tty: %.100s\",\n\t\t    strerror(errno));\n\telse\n\t\tclose(fd);\n}",
          "includes": [
            "# include <AvailabilityMacros.h>",
            "# include <pty.h>",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshpty.h\"",
            "#include <unistd.h>",
            "# include <util.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define O_NOCTTY 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <AvailabilityMacros.h>\n# include <pty.h>\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshpty.h\"\n#include <unistd.h>\n# include <util.h>\n#include <termios.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define O_NOCTTY 0\n\nvoid\npty_make_controlling_tty(int *ttyfd, const char *tty)\n{\n\tint fd;\n\n\t/* First disconnect from the old controlling tty. */\n#ifdef TIOCNOTTY\n\tfd = open(_PATH_TTY, O_RDWR | O_NOCTTY);\n\tif (fd >= 0) {\n\t\t(void) ioctl(fd, TIOCNOTTY, NULL);\n\t\tclose(fd);\n\t}\n#endif /* TIOCNOTTY */\n\tif (setsid() < 0)\n\t\terror(\"setsid: %.100s\", strerror(errno));\n\n\t/*\n\t * Verify that we are successfully disconnected from the controlling\n\t * tty.\n\t */\n\tfd = open(_PATH_TTY, O_RDWR | O_NOCTTY);\n\tif (fd >= 0) {\n\t\terror(\"Failed to disconnect from controlling tty.\");\n\t\tclose(fd);\n\t}\n\t/* Make it our controlling tty. */\n#ifdef TIOCSCTTY\n\tdebug(\"Setting controlling tty using TIOCSCTTY.\");\n\tif (ioctl(*ttyfd, TIOCSCTTY, NULL) < 0)\n\t\terror(\"ioctl(TIOCSCTTY): %.100s\", strerror(errno));\n#endif /* TIOCSCTTY */\n#ifdef NEED_SETPGRP\n\tif (setpgrp(0,0) < 0)\n\t\terror(\"SETPGRP %s\",strerror(errno));\n#endif /* NEED_SETPGRP */\n\tfd = open(tty, O_RDWR);\n\tif (fd < 0)\n\t\terror(\"%.100s: %.100s\", tty, strerror(errno));\n\telse\n\t\tclose(fd);\n\n\t/* Verify that we now have a controlling tty. */\n\tfd = open(_PATH_TTY, O_WRONLY);\n\tif (fd < 0)\n\t\terror(\"open /dev/tty failed - could not set controlling tty: %.100s\",\n\t\t    strerror(errno));\n\telse\n\t\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "69-78",
          "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup",
          "args": [
            "ptyfd"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"do_exec_pty: no session\""
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nstatic int is_child = 0;\n\nint\ndo_exec_pty(struct ssh *ssh, Session *s, const char *command)\n{\n\tint fdout, ptyfd, ttyfd, ptymaster;\n\tpid_t pid;\n\n\tif (s == NULL)\n\t\tfatal(\"do_exec_pty: no session\");\n\tptyfd = s->ptyfd;\n\tttyfd = s->ttyfd;\n\n\t/*\n\t * Create another descriptor of the pty master side for use as the\n\t * standard input.  We could use the original descriptor, but this\n\t * simplifies code in server_loop.  The descriptor is bidirectional.\n\t * Do this before forking (and cleanup in the child) so as to\n\t * detect and gracefully fail out-of-fd conditions.\n\t */\n\tif ((fdout = dup(ptyfd)) < 0) {\n\t\terror(\"%s: dup #1: %s\", __func__, strerror(errno));\n\t\tclose(ttyfd);\n\t\tclose(ptyfd);\n\t\treturn -1;\n\t}\n\t/* we keep a reference to the pty master */\n\tif ((ptymaster = dup(ptyfd)) < 0) {\n\t\terror(\"%s: dup #2: %s\", __func__, strerror(errno));\n\t\tclose(ttyfd);\n\t\tclose(ptyfd);\n\t\tclose(fdout);\n\t\treturn -1;\n\t}\n\n\t/* Fork the child. */\n\tswitch ((pid = fork())) {\n\tcase -1:\n\t\terror(\"%s: fork: %.100s\", __func__, strerror(errno));\n\t\tclose(fdout);\n\t\tclose(ptymaster);\n\t\tclose(ttyfd);\n\t\tclose(ptyfd);\n\t\treturn -1;\n\tcase 0:\n\t\tis_child = 1;\n\n\t\tclose(fdout);\n\t\tclose(ptymaster);\n\n\t\t/* Close the master side of the pseudo tty. */\n\t\tclose(ptyfd);\n\n\t\t/* Make the pseudo tty our controlling tty. */\n\t\tpty_make_controlling_tty(&ttyfd, s->tty);\n\n\t\t/* Redirect stdin/stdout/stderr from the pseudo tty. */\n\t\tif (dup2(ttyfd, 0) < 0)\n\t\t\terror(\"dup2 stdin: %s\", strerror(errno));\n\t\tif (dup2(ttyfd, 1) < 0)\n\t\t\terror(\"dup2 stdout: %s\", strerror(errno));\n\t\tif (dup2(ttyfd, 2) < 0)\n\t\t\terror(\"dup2 stderr: %s\", strerror(errno));\n\n\t\t/* Close the extra descriptor for the pseudo tty. */\n\t\tclose(ttyfd);\n\n\t\t/* record login, etc. similar to login(1) */\n#ifndef HAVE_OSF_SIA\n\t\tdo_login(ssh, s, command);\n#endif\n\t\t/*\n\t\t * Do common processing for the child, such as execing\n\t\t * the command.\n\t\t */\n\t\tdo_child(ssh, s, command);\n\t\t/* NOTREACHED */\n\tdefault:\n\t\tbreak;\n\t}\n\n#ifdef HAVE_CYGWIN\n\tcygwin_set_impersonation_token(INVALID_HANDLE_VALUE);\n#endif\n\n\ts->pid = pid;\n\n\t/* Parent.  Close the slave side of the pseudo tty. */\n\tclose(ttyfd);\n\n\t/* Enter interactive session. */\n\ts->ptymaster = ptymaster;\n\tpacket_set_interactive(1, \n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\tsession_set_fds(ssh, s, ptyfd, fdout, -1, 1, 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "do_exec_no_pty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "392-555",
    "snippet": "int\ndo_exec_no_pty(struct ssh *ssh, Session *s, const char *command)\n{\n\tpid_t pid;\n#ifdef USE_PIPES\n\tint pin[2], pout[2], perr[2];\n\n\tif (s == NULL)\n\t\tfatal(\"do_exec_no_pty: no session\");\n\n\t/* Allocate pipes for communicating with the program. */\n\tif (pipe(pin) < 0) {\n\t\terror(\"%s: pipe in: %.100s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pipe(pout) < 0) {\n\t\terror(\"%s: pipe out: %.100s\", __func__, strerror(errno));\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\treturn -1;\n\t}\n\tif (pipe(perr) < 0) {\n\t\terror(\"%s: pipe err: %.100s\", __func__,\n\t\t    strerror(errno));\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tclose(pout[1]);\n\t\treturn -1;\n\t}\n#else\n\tint inout[2], err[2];\n\n\tif (s == NULL)\n\t\tfatal(\"do_exec_no_pty: no session\");\n\n\t/* Uses socket pairs to communicate with the program. */\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) < 0) {\n\t\terror(\"%s: socketpair #1: %.100s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, err) < 0) {\n\t\terror(\"%s: socketpair #2: %.100s\", __func__,\n\t\t    strerror(errno));\n\t\tclose(inout[0]);\n\t\tclose(inout[1]);\n\t\treturn -1;\n\t}\n#endif\n\n\tsession_proctitle(s);\n\n\t/* Fork the child. */\n\tswitch ((pid = fork())) {\n\tcase -1:\n\t\terror(\"%s: fork: %.100s\", __func__, strerror(errno));\n#ifdef USE_PIPES\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tclose(pout[1]);\n\t\tclose(perr[0]);\n\t\tclose(perr[1]);\n#else\n\t\tclose(inout[0]);\n\t\tclose(inout[1]);\n\t\tclose(err[0]);\n\t\tclose(err[1]);\n#endif\n\t\treturn -1;\n\tcase 0:\n\t\tis_child = 1;\n\n\t\t/*\n\t\t * Create a new session and process group since the 4.4BSD\n\t\t * setlogin() affects the entire process group.\n\t\t */\n\t\tif (setsid() < 0)\n\t\t\terror(\"setsid failed: %.100s\", strerror(errno));\n\n#ifdef USE_PIPES\n\t\t/*\n\t\t * Redirect stdin.  We close the parent side of the socket\n\t\t * pair, and make the child side the standard input.\n\t\t */\n\t\tclose(pin[1]);\n\t\tif (dup2(pin[0], 0) < 0)\n\t\t\tperror(\"dup2 stdin\");\n\t\tclose(pin[0]);\n\n\t\t/* Redirect stdout. */\n\t\tclose(pout[0]);\n\t\tif (dup2(pout[1], 1) < 0)\n\t\t\tperror(\"dup2 stdout\");\n\t\tclose(pout[1]);\n\n\t\t/* Redirect stderr. */\n\t\tclose(perr[0]);\n\t\tif (dup2(perr[1], 2) < 0)\n\t\t\tperror(\"dup2 stderr\");\n\t\tclose(perr[1]);\n#else\n\t\t/*\n\t\t * Redirect stdin, stdout, and stderr.  Stdin and stdout will\n\t\t * use the same socket, as some programs (particularly rdist)\n\t\t * seem to depend on it.\n\t\t */\n\t\tclose(inout[1]);\n\t\tclose(err[1]);\n\t\tif (dup2(inout[0], 0) < 0)\t/* stdin */\n\t\t\tperror(\"dup2 stdin\");\n\t\tif (dup2(inout[0], 1) < 0)\t/* stdout (same as stdin) */\n\t\t\tperror(\"dup2 stdout\");\n\t\tclose(inout[0]);\n\t\tif (dup2(err[0], 2) < 0)\t/* stderr */\n\t\t\tperror(\"dup2 stderr\");\n\t\tclose(err[0]);\n#endif\n\n\t\t/* Do processing for the child (exec command etc). */\n\t\tdo_child(ssh, s, command);\n\t\t/* NOTREACHED */\n\tdefault:\n\t\tbreak;\n\t}\n\n#ifdef HAVE_CYGWIN\n\tcygwin_set_impersonation_token(INVALID_HANDLE_VALUE);\n#endif\n\n\ts->pid = pid;\n\t/* Set interactive/non-interactive mode. */\n\tpacket_set_interactive(s->display != NULL,\n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\n\t/*\n\t * Clear loginmsg, since it's the child's responsibility to display\n\t * it to the user, otherwise multiple sessions may accumulate\n\t * multiple copies of the login messages.\n\t */\n\tsshbuf_reset(loginmsg);\n\n#ifdef USE_PIPES\n\t/* We are the parent.  Close the child sides of the pipes. */\n\tclose(pin[0]);\n\tclose(pout[1]);\n\tclose(perr[1]);\n\n\tsession_set_fds(ssh, s, pin[1], pout[0], perr[0],\n\t    s->is_subsystem, 0);\n#else\n\t/* We are the parent.  Close the child sides of the socket pairs. */\n\tclose(inout[0]);\n\tclose(err[0]);\n\n\t/*\n\t * Enter the interactive session.  Note: server_loop must be able to\n\t * handle the case that fdin and fdout are the same.\n\t */\n\tsession_set_fds(s, inout[1], inout[1], err[1],\n\t    s->is_subsystem, 0);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define USE_PIPES 1"
    ],
    "globals_used": [
      "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
      "void\tsession_pty_cleanup(Session *);",
      "void\tsession_proctitle(Session *);",
      "int\tsession_setup_x11fwd(struct ssh *, Session *);",
      "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
      "int\tdo_exec(struct ssh *, Session *, const char *);",
      "void\tdo_login(struct ssh *, Session *, const char *);",
      "void\tdo_child(struct ssh *, Session *, const char *);",
      "int\tcheck_quietlogin(Session *, const char *);",
      "static int session_pty_req(struct ssh *, Session *);",
      "extern ServerOptions options;",
      "extern struct sshbuf *loginmsg;",
      "static Session *sessions = NULL;",
      "static int is_child = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "session_set_fds",
          "args": [
            "s",
            "inout[1]",
            "inout[1]",
            "err[1]",
            "s->is_subsystem",
            "0"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "err[0]"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "child_close_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1490-1526",
          "snippet": "static void\nchild_close_fds(struct ssh *ssh)\n{\n\textern int auth_sock;\n\n\tif (auth_sock != -1) {\n\t\tclose(auth_sock);\n\t\tauth_sock = -1;\n\t}\n\n\tif (packet_get_connection_in() == packet_get_connection_out())\n\t\tclose(packet_get_connection_in());\n\telse {\n\t\tclose(packet_get_connection_in());\n\t\tclose(packet_get_connection_out());\n\t}\n\t/*\n\t * Close all descriptors related to channels.  They will still remain\n\t * open in the parent.\n\t */\n\t/* XXX better use close-on-exec? -markus */\n\tchannel_close_all(ssh);\n\n\t/*\n\t * Close any extra file descriptors.  Note that there may still be\n\t * descriptors left by system functions.  They will be closed later.\n\t */\n\tendpwent();\n\n\t/*\n\t * Close any extra open file descriptors so that we don't have them\n\t * hanging around in clients.  Note that we want to do this after\n\t * initgroups, because at least on Solaris 2.3 it leaves file\n\t * descriptors open.\n\t */\n\tclosefrom(STDERR_FILENO + 1);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nchild_close_fds(struct ssh *ssh)\n{\n\textern int auth_sock;\n\n\tif (auth_sock != -1) {\n\t\tclose(auth_sock);\n\t\tauth_sock = -1;\n\t}\n\n\tif (packet_get_connection_in() == packet_get_connection_out())\n\t\tclose(packet_get_connection_in());\n\telse {\n\t\tclose(packet_get_connection_in());\n\t\tclose(packet_get_connection_out());\n\t}\n\t/*\n\t * Close all descriptors related to channels.  They will still remain\n\t * open in the parent.\n\t */\n\t/* XXX better use close-on-exec? -markus */\n\tchannel_close_all(ssh);\n\n\t/*\n\t * Close any extra file descriptors.  Note that there may still be\n\t * descriptors left by system functions.  They will be closed later.\n\t */\n\tendpwent();\n\n\t/*\n\t * Close any extra open file descriptors so that we don't have them\n\t * hanging around in clients.  Note that we want to do this after\n\t * initgroups, because at least on Solaris 2.3 it leaves file\n\t * descriptors open.\n\t */\n\tclosefrom(STDERR_FILENO + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_set_fds",
          "args": [
            "ssh",
            "s",
            "pin[1]",
            "pout[0]",
            "perr[0]",
            "s->is_subsystem",
            "0"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "session_set_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2241-2255",
          "snippet": "void\nsession_set_fds(struct ssh *ssh, Session *s,\n    int fdin, int fdout, int fderr, int ignore_fderr, int is_tty)\n{\n\t/*\n\t * now that have a child and a pipe to the child,\n\t * we can activate our channel and register the fd's\n\t */\n\tif (s->chanid == -1)\n\t\tfatal(\"no channel for session %d\", s->self);\n\tchannel_set_fds(ssh, s->chanid,\n\t    fdout, fdin, fderr,\n\t    ignore_fderr ? CHAN_EXTENDED_IGNORE : CHAN_EXTENDED_READ,\n\t    1, is_tty, CHAN_SES_WINDOW_DEFAULT);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_set_fds(struct ssh *ssh, Session *s,\n    int fdin, int fdout, int fderr, int ignore_fderr, int is_tty)\n{\n\t/*\n\t * now that have a child and a pipe to the child,\n\t * we can activate our channel and register the fd's\n\t */\n\tif (s->chanid == -1)\n\t\tfatal(\"no channel for session %d\", s->self);\n\tchannel_set_fds(ssh, s->chanid,\n\t    fdout, fdin, fderr,\n\t    ignore_fderr ? CHAN_EXTENDED_IGNORE : CHAN_EXTENDED_READ,\n\t    1, is_tty, CHAN_SES_WINDOW_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "loginmsg"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_set_interactive",
          "args": [
            "s->display != NULL",
            "options.ip_qos_interactive",
            "options.ip_qos_bulk"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cygwin_set_impersonation_token",
          "args": [
            "INVALID_HANDLE_VALUE"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_child",
          "args": [
            "ssh",
            "s",
            "command"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "do_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1534-1734",
          "snippet": "void\ndo_child(struct ssh *ssh, Session *s, const char *command)\n{\n\textern char **environ;\n\tchar **env;\n\tchar *argv[ARGV_MAX];\n\tconst char *shell, *shell0;\n\tstruct passwd *pw = s->pw;\n\tint r = 0;\n\n\t/* remove hostkey from the child's memory */\n\tdestroy_sensitive_data();\n\tpacket_clear_keys();\n\n\t/* Force a password change */\n\tif (s->authctxt->force_pwchange) {\n\t\tdo_setusercontext(pw);\n\t\tchild_close_fds(ssh);\n\t\tdo_pwchange(s);\n\t\texit(1);\n\t}\n\n\t/*\n\t * Login(1) does this as well, and it needs uid 0 for the \"-h\"\n\t * switch, so we let login(1) to this for us.\n\t */\n#ifdef HAVE_OSF_SIA\n\tsession_setup_sia(pw, s->ttyfd == -1 ? NULL : s->tty);\n\tif (!check_quietlogin(s, command))\n\t\tdo_motd();\n#else /* HAVE_OSF_SIA */\n\t/* When PAM is enabled we rely on it to do the nologin check */\n\tif (!options.use_pam)\n\t\tdo_nologin(pw);\n\tdo_setusercontext(pw);\n\t/*\n\t * PAM session modules in do_setusercontext may have\n\t * generated messages, so if this in an interactive\n\t * login then display them too.\n\t */\n\tif (!check_quietlogin(s, command))\n\t\tdisplay_loginmsg();\n#endif /* HAVE_OSF_SIA */\n\n#ifdef USE_PAM\n\tif (options.use_pam && !is_pam_session_open()) {\n\t\tdebug3(\"PAM session not opened, exiting\");\n\t\tdisplay_loginmsg();\n\t\texit(254);\n\t}\n#endif\n\n\t/*\n\t * Get the shell from the password data.  An empty shell field is\n\t * legal, and means /bin/sh.\n\t */\n\tshell = (pw->pw_shell[0] == '\\0') ? _PATH_BSHELL : pw->pw_shell;\n\n\t/*\n\t * Make sure $SHELL points to the shell from the password file,\n\t * even if shell is overridden from login.conf\n\t */\n\tenv = do_setup_env(ssh, s, shell);\n\n#ifdef HAVE_LOGIN_CAP\n\tshell = login_getcapstr(lc, \"shell\", (char *)shell, (char *)shell);\n#endif\n\n\t/*\n\t * Close the connection descriptors; note that this is the child, and\n\t * the server will still have the socket open, and it is important\n\t * that we do not shutdown it.  Note that the descriptors cannot be\n\t * closed before building the environment, as we call\n\t * ssh_remote_ipaddr there.\n\t */\n\tchild_close_fds(ssh);\n\n\t/*\n\t * Must take new environment into use so that .ssh/rc,\n\t * /etc/ssh/sshrc and xauth are run in the proper environment.\n\t */\n\tenviron = env;\n\n#if defined(KRB5) && defined(USE_AFS)\n\t/*\n\t * At this point, we check to see if AFS is active and if we have\n\t * a valid Kerberos 5 TGT. If so, it seems like a good idea to see\n\t * if we can (and need to) extend the ticket into an AFS token. If\n\t * we don't do this, we run into potential problems if the user's\n\t * home directory is in AFS and it's not world-readable.\n\t */\n\n\tif (options.kerberos_get_afs_token && k_hasafs() &&\n\t    (s->authctxt->krb5_ctx != NULL)) {\n\t\tchar cell[64];\n\n\t\tdebug(\"Getting AFS token\");\n\n\t\tk_setpag();\n\n\t\tif (k_afs_cell_of_file(pw->pw_dir, cell, sizeof(cell)) == 0)\n\t\t\tkrb5_afslog(s->authctxt->krb5_ctx,\n\t\t\t    s->authctxt->krb5_fwd_ccache, cell, NULL);\n\n\t\tkrb5_afslog_home(s->authctxt->krb5_ctx,\n\t\t    s->authctxt->krb5_fwd_ccache, NULL, NULL, pw->pw_dir);\n\t}\n#endif\n\n\t/* Change current directory to the user's home directory. */\n\tif (chdir(pw->pw_dir) < 0) {\n\t\t/* Suppress missing homedir warning for chroot case */\n#ifdef HAVE_LOGIN_CAP\n\t\tr = login_getcapbool(lc, \"requirehome\", 0);\n#endif\n\t\tif (r || !in_chroot) {\n\t\t\tfprintf(stderr, \"Could not chdir to home \"\n\t\t\t    \"directory %s: %s\\n\", pw->pw_dir,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tif (r)\n\t\t\texit(1);\n\t}\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tdo_rc_files(ssh, s, shell);\n\n\t/* restore SIGPIPE for child */\n\tsignal(SIGPIPE, SIG_DFL);\n\n\tif (s->is_subsystem == SUBSYSTEM_INT_SFTP_ERROR) {\n\t\tprintf(\"This service allows sftp connections only.\\n\");\n\t\tfflush(NULL);\n\t\texit(1);\n\t} else if (s->is_subsystem == SUBSYSTEM_INT_SFTP) {\n\t\textern int optind, optreset;\n\t\tint i;\n\t\tchar *p, *args;\n\n\t\tsetproctitle(\"%s@%s\", s->pw->pw_name, INTERNAL_SFTP_NAME);\n\t\targs = xstrdup(command ? command : \"sftp-server\");\n\t\tfor (i = 0, (p = strtok(args, \" \")); p; (p = strtok(NULL, \" \")))\n\t\t\tif (i < ARGV_MAX - 1)\n\t\t\t\targv[i++] = p;\n\t\targv[i] = NULL;\n\t\toptind = optreset = 1;\n\t\t__progname = argv[0];\n#ifdef WITH_SELINUX\n\t\tssh_selinux_change_context(\"sftpd_t\");\n#endif\n\t\texit(sftp_server_main(i, argv, s->pw));\n\t}\n\n\tfflush(NULL);\n\n\t/* Get the last component of the shell name. */\n\tif ((shell0 = strrchr(shell, '/')) != NULL)\n\t\tshell0++;\n\telse\n\t\tshell0 = shell;\n\n\t/*\n\t * If we have no command, execute the shell.  In this case, the shell\n\t * name to be passed in argv[0] is preceded by '-' to indicate that\n\t * this is a login shell.\n\t */\n\tif (!command) {\n\t\tchar argv0[256];\n\n\t\t/* Start the shell.  Set initial character to '-'. */\n\t\targv0[0] = '-';\n\n\t\tif (strlcpy(argv0 + 1, shell0, sizeof(argv0) - 1)\n\t\t    >= sizeof(argv0) - 1) {\n\t\t\terrno = EINVAL;\n\t\t\tperror(shell);\n\t\t\texit(1);\n\t\t}\n\n\t\t/* Execute the shell. */\n\t\targv[0] = argv0;\n\t\targv[1] = NULL;\n\t\texecve(shell, argv, env);\n\n\t\t/* Executing the shell failed. */\n\t\tperror(shell);\n\t\texit(1);\n\t}\n\t/*\n\t * Execute the command using the user's shell.  This uses the -c\n\t * option to execute the command.\n\t */\n\targv[0] = (char *) shell0;\n\targv[1] = \"-c\";\n\targv[2] = (char *) command;\n\targv[3] = NULL;\n\texecve(shell, argv, env);\n\tperror(shell);\n\texit(1);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define ARGV_MAX 10",
            "#define SUBSYSTEM_INT_SFTP_ERROR\t3",
            "#define SUBSYSTEM_INT_SFTP\t\t2"
          ],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "void\tdo_motd(void);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);",
            "extern ServerOptions options;",
            "extern char *__progname;",
            "extern void destroy_sensitive_data(void);",
            "static int in_chroot = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define ARGV_MAX 10\n#define SUBSYSTEM_INT_SFTP_ERROR\t3\n#define SUBSYSTEM_INT_SFTP\t\t2\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nvoid\tdo_motd(void);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern char *__progname;\nextern void destroy_sensitive_data(void);\nstatic int in_chroot = 0;\n\nvoid\ndo_child(struct ssh *ssh, Session *s, const char *command)\n{\n\textern char **environ;\n\tchar **env;\n\tchar *argv[ARGV_MAX];\n\tconst char *shell, *shell0;\n\tstruct passwd *pw = s->pw;\n\tint r = 0;\n\n\t/* remove hostkey from the child's memory */\n\tdestroy_sensitive_data();\n\tpacket_clear_keys();\n\n\t/* Force a password change */\n\tif (s->authctxt->force_pwchange) {\n\t\tdo_setusercontext(pw);\n\t\tchild_close_fds(ssh);\n\t\tdo_pwchange(s);\n\t\texit(1);\n\t}\n\n\t/*\n\t * Login(1) does this as well, and it needs uid 0 for the \"-h\"\n\t * switch, so we let login(1) to this for us.\n\t */\n#ifdef HAVE_OSF_SIA\n\tsession_setup_sia(pw, s->ttyfd == -1 ? NULL : s->tty);\n\tif (!check_quietlogin(s, command))\n\t\tdo_motd();\n#else /* HAVE_OSF_SIA */\n\t/* When PAM is enabled we rely on it to do the nologin check */\n\tif (!options.use_pam)\n\t\tdo_nologin(pw);\n\tdo_setusercontext(pw);\n\t/*\n\t * PAM session modules in do_setusercontext may have\n\t * generated messages, so if this in an interactive\n\t * login then display them too.\n\t */\n\tif (!check_quietlogin(s, command))\n\t\tdisplay_loginmsg();\n#endif /* HAVE_OSF_SIA */\n\n#ifdef USE_PAM\n\tif (options.use_pam && !is_pam_session_open()) {\n\t\tdebug3(\"PAM session not opened, exiting\");\n\t\tdisplay_loginmsg();\n\t\texit(254);\n\t}\n#endif\n\n\t/*\n\t * Get the shell from the password data.  An empty shell field is\n\t * legal, and means /bin/sh.\n\t */\n\tshell = (pw->pw_shell[0] == '\\0') ? _PATH_BSHELL : pw->pw_shell;\n\n\t/*\n\t * Make sure $SHELL points to the shell from the password file,\n\t * even if shell is overridden from login.conf\n\t */\n\tenv = do_setup_env(ssh, s, shell);\n\n#ifdef HAVE_LOGIN_CAP\n\tshell = login_getcapstr(lc, \"shell\", (char *)shell, (char *)shell);\n#endif\n\n\t/*\n\t * Close the connection descriptors; note that this is the child, and\n\t * the server will still have the socket open, and it is important\n\t * that we do not shutdown it.  Note that the descriptors cannot be\n\t * closed before building the environment, as we call\n\t * ssh_remote_ipaddr there.\n\t */\n\tchild_close_fds(ssh);\n\n\t/*\n\t * Must take new environment into use so that .ssh/rc,\n\t * /etc/ssh/sshrc and xauth are run in the proper environment.\n\t */\n\tenviron = env;\n\n#if defined(KRB5) && defined(USE_AFS)\n\t/*\n\t * At this point, we check to see if AFS is active and if we have\n\t * a valid Kerberos 5 TGT. If so, it seems like a good idea to see\n\t * if we can (and need to) extend the ticket into an AFS token. If\n\t * we don't do this, we run into potential problems if the user's\n\t * home directory is in AFS and it's not world-readable.\n\t */\n\n\tif (options.kerberos_get_afs_token && k_hasafs() &&\n\t    (s->authctxt->krb5_ctx != NULL)) {\n\t\tchar cell[64];\n\n\t\tdebug(\"Getting AFS token\");\n\n\t\tk_setpag();\n\n\t\tif (k_afs_cell_of_file(pw->pw_dir, cell, sizeof(cell)) == 0)\n\t\t\tkrb5_afslog(s->authctxt->krb5_ctx,\n\t\t\t    s->authctxt->krb5_fwd_ccache, cell, NULL);\n\n\t\tkrb5_afslog_home(s->authctxt->krb5_ctx,\n\t\t    s->authctxt->krb5_fwd_ccache, NULL, NULL, pw->pw_dir);\n\t}\n#endif\n\n\t/* Change current directory to the user's home directory. */\n\tif (chdir(pw->pw_dir) < 0) {\n\t\t/* Suppress missing homedir warning for chroot case */\n#ifdef HAVE_LOGIN_CAP\n\t\tr = login_getcapbool(lc, \"requirehome\", 0);\n#endif\n\t\tif (r || !in_chroot) {\n\t\t\tfprintf(stderr, \"Could not chdir to home \"\n\t\t\t    \"directory %s: %s\\n\", pw->pw_dir,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tif (r)\n\t\t\texit(1);\n\t}\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tdo_rc_files(ssh, s, shell);\n\n\t/* restore SIGPIPE for child */\n\tsignal(SIGPIPE, SIG_DFL);\n\n\tif (s->is_subsystem == SUBSYSTEM_INT_SFTP_ERROR) {\n\t\tprintf(\"This service allows sftp connections only.\\n\");\n\t\tfflush(NULL);\n\t\texit(1);\n\t} else if (s->is_subsystem == SUBSYSTEM_INT_SFTP) {\n\t\textern int optind, optreset;\n\t\tint i;\n\t\tchar *p, *args;\n\n\t\tsetproctitle(\"%s@%s\", s->pw->pw_name, INTERNAL_SFTP_NAME);\n\t\targs = xstrdup(command ? command : \"sftp-server\");\n\t\tfor (i = 0, (p = strtok(args, \" \")); p; (p = strtok(NULL, \" \")))\n\t\t\tif (i < ARGV_MAX - 1)\n\t\t\t\targv[i++] = p;\n\t\targv[i] = NULL;\n\t\toptind = optreset = 1;\n\t\t__progname = argv[0];\n#ifdef WITH_SELINUX\n\t\tssh_selinux_change_context(\"sftpd_t\");\n#endif\n\t\texit(sftp_server_main(i, argv, s->pw));\n\t}\n\n\tfflush(NULL);\n\n\t/* Get the last component of the shell name. */\n\tif ((shell0 = strrchr(shell, '/')) != NULL)\n\t\tshell0++;\n\telse\n\t\tshell0 = shell;\n\n\t/*\n\t * If we have no command, execute the shell.  In this case, the shell\n\t * name to be passed in argv[0] is preceded by '-' to indicate that\n\t * this is a login shell.\n\t */\n\tif (!command) {\n\t\tchar argv0[256];\n\n\t\t/* Start the shell.  Set initial character to '-'. */\n\t\targv0[0] = '-';\n\n\t\tif (strlcpy(argv0 + 1, shell0, sizeof(argv0) - 1)\n\t\t    >= sizeof(argv0) - 1) {\n\t\t\terrno = EINVAL;\n\t\t\tperror(shell);\n\t\t\texit(1);\n\t\t}\n\n\t\t/* Execute the shell. */\n\t\targv[0] = argv0;\n\t\targv[1] = NULL;\n\t\texecve(shell, argv, env);\n\n\t\t/* Executing the shell failed. */\n\t\tperror(shell);\n\t\texit(1);\n\t}\n\t/*\n\t * Execute the command using the user's shell.  This uses the -c\n\t * option to execute the command.\n\t */\n\targv[0] = (char *) shell0;\n\targv[1] = \"-c\";\n\targv[2] = (char *) command;\n\targv[3] = NULL;\n\texecve(shell, argv, env);\n\tperror(shell);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"dup2 stderr\""
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "err[0]",
            "2"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"dup2 stdout\""
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "inout[0]",
            "1"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"dup2 stdin\""
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "inout[0]",
            "0"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"dup2 stderr\""
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "perr[1]",
            "2"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"dup2 stdout\""
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "pout[1]",
            "1"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"dup2 stdin\""
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "pin[0]",
            "0"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"setsid failed: %.100s\"",
            "strerror(errno)"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "69-78",
          "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "session_proctitle",
          "args": [
            "s"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "session_proctitle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2550-2557",
          "snippet": "void\nsession_proctitle(Session *s)\n{\n\tif (s->pw == NULL)\n\t\terror(\"no user for session %d\", s->self);\n\telse\n\t\tsetproctitle(\"%s@%s\", s->pw->pw_name, session_tty_list());\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nvoid\nsession_proctitle(Session *s)\n{\n\tif (s->pw == NULL)\n\t\terror(\"no user for session %d\", s->self);\n\telse\n\t\tsetproctitle(\"%s@%s\", s->pw->pw_name, session_tty_list());\n}"
        }
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0",
            "err"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0",
            "inout"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"do_exec_no_pty: no session\""
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "perr"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pout"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pin"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define USE_PIPES 1\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\nextern ServerOptions options;\nextern struct sshbuf *loginmsg;\nstatic Session *sessions = NULL;\nstatic int is_child = 0;\n\nint\ndo_exec_no_pty(struct ssh *ssh, Session *s, const char *command)\n{\n\tpid_t pid;\n#ifdef USE_PIPES\n\tint pin[2], pout[2], perr[2];\n\n\tif (s == NULL)\n\t\tfatal(\"do_exec_no_pty: no session\");\n\n\t/* Allocate pipes for communicating with the program. */\n\tif (pipe(pin) < 0) {\n\t\terror(\"%s: pipe in: %.100s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pipe(pout) < 0) {\n\t\terror(\"%s: pipe out: %.100s\", __func__, strerror(errno));\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\treturn -1;\n\t}\n\tif (pipe(perr) < 0) {\n\t\terror(\"%s: pipe err: %.100s\", __func__,\n\t\t    strerror(errno));\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tclose(pout[1]);\n\t\treturn -1;\n\t}\n#else\n\tint inout[2], err[2];\n\n\tif (s == NULL)\n\t\tfatal(\"do_exec_no_pty: no session\");\n\n\t/* Uses socket pairs to communicate with the program. */\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) < 0) {\n\t\terror(\"%s: socketpair #1: %.100s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, err) < 0) {\n\t\terror(\"%s: socketpair #2: %.100s\", __func__,\n\t\t    strerror(errno));\n\t\tclose(inout[0]);\n\t\tclose(inout[1]);\n\t\treturn -1;\n\t}\n#endif\n\n\tsession_proctitle(s);\n\n\t/* Fork the child. */\n\tswitch ((pid = fork())) {\n\tcase -1:\n\t\terror(\"%s: fork: %.100s\", __func__, strerror(errno));\n#ifdef USE_PIPES\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tclose(pout[1]);\n\t\tclose(perr[0]);\n\t\tclose(perr[1]);\n#else\n\t\tclose(inout[0]);\n\t\tclose(inout[1]);\n\t\tclose(err[0]);\n\t\tclose(err[1]);\n#endif\n\t\treturn -1;\n\tcase 0:\n\t\tis_child = 1;\n\n\t\t/*\n\t\t * Create a new session and process group since the 4.4BSD\n\t\t * setlogin() affects the entire process group.\n\t\t */\n\t\tif (setsid() < 0)\n\t\t\terror(\"setsid failed: %.100s\", strerror(errno));\n\n#ifdef USE_PIPES\n\t\t/*\n\t\t * Redirect stdin.  We close the parent side of the socket\n\t\t * pair, and make the child side the standard input.\n\t\t */\n\t\tclose(pin[1]);\n\t\tif (dup2(pin[0], 0) < 0)\n\t\t\tperror(\"dup2 stdin\");\n\t\tclose(pin[0]);\n\n\t\t/* Redirect stdout. */\n\t\tclose(pout[0]);\n\t\tif (dup2(pout[1], 1) < 0)\n\t\t\tperror(\"dup2 stdout\");\n\t\tclose(pout[1]);\n\n\t\t/* Redirect stderr. */\n\t\tclose(perr[0]);\n\t\tif (dup2(perr[1], 2) < 0)\n\t\t\tperror(\"dup2 stderr\");\n\t\tclose(perr[1]);\n#else\n\t\t/*\n\t\t * Redirect stdin, stdout, and stderr.  Stdin and stdout will\n\t\t * use the same socket, as some programs (particularly rdist)\n\t\t * seem to depend on it.\n\t\t */\n\t\tclose(inout[1]);\n\t\tclose(err[1]);\n\t\tif (dup2(inout[0], 0) < 0)\t/* stdin */\n\t\t\tperror(\"dup2 stdin\");\n\t\tif (dup2(inout[0], 1) < 0)\t/* stdout (same as stdin) */\n\t\t\tperror(\"dup2 stdout\");\n\t\tclose(inout[0]);\n\t\tif (dup2(err[0], 2) < 0)\t/* stderr */\n\t\t\tperror(\"dup2 stderr\");\n\t\tclose(err[0]);\n#endif\n\n\t\t/* Do processing for the child (exec command etc). */\n\t\tdo_child(ssh, s, command);\n\t\t/* NOTREACHED */\n\tdefault:\n\t\tbreak;\n\t}\n\n#ifdef HAVE_CYGWIN\n\tcygwin_set_impersonation_token(INVALID_HANDLE_VALUE);\n#endif\n\n\ts->pid = pid;\n\t/* Set interactive/non-interactive mode. */\n\tpacket_set_interactive(s->display != NULL,\n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\n\t/*\n\t * Clear loginmsg, since it's the child's responsibility to display\n\t * it to the user, otherwise multiple sessions may accumulate\n\t * multiple copies of the login messages.\n\t */\n\tsshbuf_reset(loginmsg);\n\n#ifdef USE_PIPES\n\t/* We are the parent.  Close the child sides of the pipes. */\n\tclose(pin[0]);\n\tclose(pout[1]);\n\tclose(perr[1]);\n\n\tsession_set_fds(ssh, s, pin[1], pout[0], perr[0],\n\t    s->is_subsystem, 0);\n#else\n\t/* We are the parent.  Close the child sides of the socket pairs. */\n\tclose(inout[0]);\n\tclose(err[0]);\n\n\t/*\n\t * Enter the interactive session.  Note: server_loop must be able to\n\t * handle the case that fdin and fdout are the same.\n\t */\n\tsession_set_fds(s, inout[1], inout[1], err[1],\n\t    s->is_subsystem, 0);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "xauth_valid_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "372-384",
    "snippet": "static int\nxauth_valid_string(const char *s)\n{\n\tsize_t i;\n\n\tfor (i = 0; s[i] != '\\0'; i++) {\n\t\tif (!isalnum((u_char)s[i]) &&\n\t\t    s[i] != '.' && s[i] != ':' && s[i] != '/' &&\n\t\t    s[i] != '-' && s[i] != '_')\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "(u_char)s[i]"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nxauth_valid_string(const char *s)\n{\n\tsize_t i;\n\n\tfor (i = 0; s[i] != '\\0'; i++) {\n\t\tif (!isalnum((u_char)s[i]) &&\n\t\t    s[i] != '.' && s[i] != ':' && s[i] != '/' &&\n\t\t    s[i] != '-' && s[i] != '_')\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "do_authenticated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "337-369",
    "snippet": "void\ndo_authenticated(struct ssh *ssh, Authctxt *authctxt)\n{\n\tsetproctitle(\"%s\", authctxt->pw->pw_name);\n\n\tauth_log_authopts(\"active\", auth_opts, 0);\n\n\t/* setup the channel layer */\n\t/* XXX - streamlocal? */\n\tset_fwdpermit_from_authopts(ssh, auth_opts);\n\n\tif (!auth_opts->permit_port_forwarding_flag ||\n\t    options.disable_forwarding) {\n\t\tchannel_disable_admin(ssh, FORWARD_LOCAL);\n\t\tchannel_disable_admin(ssh, FORWARD_REMOTE);\n\t} else {\n\t\tif ((options.allow_tcp_forwarding & FORWARD_LOCAL) == 0)\n\t\t\tchannel_disable_admin(ssh, FORWARD_LOCAL);\n\t\telse\n\t\t\tchannel_permit_all(ssh, FORWARD_LOCAL);\n\t\tif ((options.allow_tcp_forwarding & FORWARD_REMOTE) == 0)\n\t\t\tchannel_disable_admin(ssh, FORWARD_REMOTE);\n\t\telse\n\t\t\tchannel_permit_all(ssh, FORWARD_REMOTE);\n\t}\n\tauth_debug_send();\n\n\tprepare_auth_info_file(authctxt->pw, authctxt->session_info);\n\n\tdo_authenticated2(ssh, authctxt);\n\n\tdo_cleanup(ssh, authctxt);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void do_authenticated2(struct ssh *, Authctxt *);",
      "extern ServerOptions options;",
      "extern struct sshauthopt *auth_opts;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_cleanup",
          "args": [
            "ssh",
            "authctxt"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "do_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2641-2699",
          "snippet": "void\ndo_cleanup(struct ssh *ssh, Authctxt *authctxt)\n{\n\tstatic int called = 0;\n\n\tdebug(\"do_cleanup\");\n\n\t/* no cleanup if we're in the child for login shell */\n\tif (is_child)\n\t\treturn;\n\n\t/* avoid double cleanup */\n\tif (called)\n\t\treturn;\n\tcalled = 1;\n\n\tif (authctxt == NULL)\n\t\treturn;\n\n#ifdef USE_PAM\n\tif (options.use_pam) {\n\t\tsshpam_cleanup();\n\t\tsshpam_thread_cleanup();\n\t}\n#endif\n\n\tif (!authctxt->authenticated)\n\t\treturn;\n\n#ifdef KRB5\n\tif (options.kerberos_ticket_cleanup &&\n\t    authctxt->krb5_ctx)\n\t\tkrb5_cleanup_proc(authctxt);\n#endif\n\n#ifdef GSSAPI\n\tif (options.gss_cleanup_creds)\n\t\tssh_gssapi_cleanup_creds();\n#endif\n\n\t/* remove agent socket */\n\tauth_sock_cleanup_proc(authctxt->pw);\n\n\t/* remove userauth info */\n\tif (auth_info_file != NULL) {\n\t\ttemporarily_use_uid(authctxt->pw);\n\t\tunlink(auth_info_file);\n\t\trestore_uid();\n\t\tfree(auth_info_file);\n\t\tauth_info_file = NULL;\n\t}\n\n\t/*\n\t * Cleanup ptys/utmp only if privsep is disabled,\n\t * or if running in monitor.\n\t */\n\tif (!use_privsep || mm_is_monitor())\n\t\tsession_destroy_all(ssh, session_pty_cleanup2);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void do_authenticated2(struct ssh *, Authctxt *);",
            "extern ServerOptions options;",
            "static int is_child = 0;",
            "static char *auth_info_file = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void do_authenticated2(struct ssh *, Authctxt *);\nextern ServerOptions options;\nstatic int is_child = 0;\nstatic char *auth_info_file = NULL;\n\nvoid\ndo_cleanup(struct ssh *ssh, Authctxt *authctxt)\n{\n\tstatic int called = 0;\n\n\tdebug(\"do_cleanup\");\n\n\t/* no cleanup if we're in the child for login shell */\n\tif (is_child)\n\t\treturn;\n\n\t/* avoid double cleanup */\n\tif (called)\n\t\treturn;\n\tcalled = 1;\n\n\tif (authctxt == NULL)\n\t\treturn;\n\n#ifdef USE_PAM\n\tif (options.use_pam) {\n\t\tsshpam_cleanup();\n\t\tsshpam_thread_cleanup();\n\t}\n#endif\n\n\tif (!authctxt->authenticated)\n\t\treturn;\n\n#ifdef KRB5\n\tif (options.kerberos_ticket_cleanup &&\n\t    authctxt->krb5_ctx)\n\t\tkrb5_cleanup_proc(authctxt);\n#endif\n\n#ifdef GSSAPI\n\tif (options.gss_cleanup_creds)\n\t\tssh_gssapi_cleanup_creds();\n#endif\n\n\t/* remove agent socket */\n\tauth_sock_cleanup_proc(authctxt->pw);\n\n\t/* remove userauth info */\n\tif (auth_info_file != NULL) {\n\t\ttemporarily_use_uid(authctxt->pw);\n\t\tunlink(auth_info_file);\n\t\trestore_uid();\n\t\tfree(auth_info_file);\n\t\tauth_info_file = NULL;\n\t}\n\n\t/*\n\t * Cleanup ptys/utmp only if privsep is disabled,\n\t * or if running in monitor.\n\t */\n\tif (!use_privsep || mm_is_monitor())\n\t\tsession_destroy_all(ssh, session_pty_cleanup2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_authenticated2",
          "args": [
            "ssh",
            "authctxt"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "do_authenticated2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2635-2639",
          "snippet": "static void\ndo_authenticated2(struct ssh *ssh, Authctxt *authctxt)\n{\n\tserver_loop2(ssh, authctxt);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void do_authenticated2(struct ssh *, Authctxt *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void do_authenticated2(struct ssh *, Authctxt *);\n\nstatic void\ndo_authenticated2(struct ssh *ssh, Authctxt *authctxt)\n{\n\tserver_loop2(ssh, authctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_auth_info_file",
          "args": [
            "authctxt->pw",
            "authctxt->session_info"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_auth_info_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "262-294",
          "snippet": "static void\nprepare_auth_info_file(struct passwd *pw, struct sshbuf *info)\n{\n\tint fd = -1, success = 0;\n\n\tif (!options.expose_userauth_info || info == NULL)\n\t\treturn;\n\n\ttemporarily_use_uid(pw);\n\tauth_info_file = xstrdup(\"/tmp/sshauth.XXXXXXXXXXXXXXX\");\n\tif ((fd = mkstemp(auth_info_file)) == -1) {\n\t\terror(\"%s: mkstemp: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(info),\n\t    sshbuf_len(info)) != sshbuf_len(info)) {\n\t\terror(\"%s: write: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tif (close(fd) != 0) {\n\t\terror(\"%s: close: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tsuccess = 1;\n out:\n\tif (!success) {\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\t\tfree(auth_info_file);\n\t\tauth_info_file = NULL;\n\t}\n\trestore_uid();\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "static char *auth_info_file = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nstatic char *auth_info_file = NULL;\n\nstatic void\nprepare_auth_info_file(struct passwd *pw, struct sshbuf *info)\n{\n\tint fd = -1, success = 0;\n\n\tif (!options.expose_userauth_info || info == NULL)\n\t\treturn;\n\n\ttemporarily_use_uid(pw);\n\tauth_info_file = xstrdup(\"/tmp/sshauth.XXXXXXXXXXXXXXX\");\n\tif ((fd = mkstemp(auth_info_file)) == -1) {\n\t\terror(\"%s: mkstemp: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(info),\n\t    sshbuf_len(info)) != sshbuf_len(info)) {\n\t\terror(\"%s: write: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tif (close(fd) != 0) {\n\t\terror(\"%s: close: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tsuccess = 1;\n out:\n\tif (!success) {\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\t\tfree(auth_info_file);\n\t\tauth_info_file = NULL;\n\t}\n\trestore_uid();\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_debug_send",
          "args": [],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "auth_debug_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "690-706",
          "snippet": "void\nauth_debug_send(void)\n{\n\tstruct ssh *ssh = active_state;\t\t/* XXX */\n\tchar *msg;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\twhile (sshbuf_len(auth_debug) != 0) {\n\t\tif ((r = sshbuf_get_cstring(auth_debug, &msg, NULL)) != 0)\n\t\t\tfatal(\"%s: sshbuf_get_cstring: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tssh_packet_send_debug(ssh, \"%s\", msg);\n\t\tfree(msg);\n\t}\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sshbuf *auth_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *auth_debug;\n\nvoid\nauth_debug_send(void)\n{\n\tstruct ssh *ssh = active_state;\t\t/* XXX */\n\tchar *msg;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\twhile (sshbuf_len(auth_debug) != 0) {\n\t\tif ((r = sshbuf_get_cstring(auth_debug, &msg, NULL)) != 0)\n\t\t\tfatal(\"%s: sshbuf_get_cstring: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tssh_packet_send_debug(ssh, \"%s\", msg);\n\t\tfree(msg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_permit_all",
          "args": [
            "ssh",
            "FORWARD_REMOTE"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "channel_permit_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4039-4046",
          "snippet": "void\nchannel_permit_all(struct ssh *ssh, int where)\n{\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tif (pset->num_permitted_user == 0)\n\t\tpset->all_permitted = 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_permit_all(struct ssh *ssh, int where)\n{\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tif (pset->num_permitted_user == 0)\n\t\tpset->all_permitted = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_disable_admin",
          "args": [
            "ssh",
            "FORWARD_REMOTE"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "channel_disable_admin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4073-4079",
          "snippet": "void\nchannel_disable_admin(struct ssh *ssh, int where)\n{\n\tchannel_clear_permission(ssh, FORWARD_ADM, where);\n\tpermission_set_add(ssh, FORWARD_ADM, where,\n\t    NULL, 0, NULL, NULL, 0, NULL);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_disable_admin(struct ssh *ssh, int where)\n{\n\tchannel_clear_permission(ssh, FORWARD_ADM, where);\n\tpermission_set_add(ssh, FORWARD_ADM, where,\n\t    NULL, 0, NULL, NULL, 0, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fwdpermit_from_authopts",
          "args": [
            "ssh",
            "auth_opts"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "set_fwdpermit_from_authopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "296-335",
          "snippet": "static void\nset_fwdpermit_from_authopts(struct ssh *ssh, const struct sshauthopt *opts)\n{\n\tchar *tmp, *cp, *host;\n\tint port;\n\tsize_t i;\n\n\tif ((options.allow_tcp_forwarding & FORWARD_LOCAL) != 0) {\n\t\tchannel_clear_permission(ssh, FORWARD_USER, FORWARD_LOCAL);\n\t\tfor (i = 0; i < auth_opts->npermitopen; i++) {\n\t\t\ttmp = cp = xstrdup(auth_opts->permitopen[i]);\n\t\t\t/* This shouldn't fail as it has already been checked */\n\t\t\tif ((host = hpdelim(&cp)) == NULL)\n\t\t\t\tfatal(\"%s: internal error: hpdelim\", __func__);\n\t\t\thost = cleanhostname(host);\n\t\t\tif (cp == NULL || (port = permitopen_port(cp)) < 0)\n\t\t\t\tfatal(\"%s: internal error: permitopen port\",\n\t\t\t\t    __func__);\n\t\t\tchannel_add_permission(ssh,\n\t\t\t    FORWARD_USER, FORWARD_LOCAL, host, port);\n\t\t\tfree(tmp);\n\t\t}\n\t}\n\tif ((options.allow_tcp_forwarding & FORWARD_REMOTE) != 0) {\n\t\tchannel_clear_permission(ssh, FORWARD_USER, FORWARD_REMOTE);\n\t\tfor (i = 0; i < auth_opts->npermitlisten; i++) {\n\t\t\ttmp = cp = xstrdup(auth_opts->permitlisten[i]);\n\t\t\t/* This shouldn't fail as it has already been checked */\n\t\t\tif ((host = hpdelim(&cp)) == NULL)\n\t\t\t\tfatal(\"%s: internal error: hpdelim\", __func__);\n\t\t\thost = cleanhostname(host);\n\t\t\tif (cp == NULL || (port = permitopen_port(cp)) < 0)\n\t\t\t\tfatal(\"%s: internal error: permitlisten port\",\n\t\t\t\t    __func__);\n\t\t\tchannel_add_permission(ssh,\n\t\t\t    FORWARD_USER, FORWARD_REMOTE, host, port);\n\t\t\tfree(tmp);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "extern struct sshauthopt *auth_opts;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\n\nstatic void\nset_fwdpermit_from_authopts(struct ssh *ssh, const struct sshauthopt *opts)\n{\n\tchar *tmp, *cp, *host;\n\tint port;\n\tsize_t i;\n\n\tif ((options.allow_tcp_forwarding & FORWARD_LOCAL) != 0) {\n\t\tchannel_clear_permission(ssh, FORWARD_USER, FORWARD_LOCAL);\n\t\tfor (i = 0; i < auth_opts->npermitopen; i++) {\n\t\t\ttmp = cp = xstrdup(auth_opts->permitopen[i]);\n\t\t\t/* This shouldn't fail as it has already been checked */\n\t\t\tif ((host = hpdelim(&cp)) == NULL)\n\t\t\t\tfatal(\"%s: internal error: hpdelim\", __func__);\n\t\t\thost = cleanhostname(host);\n\t\t\tif (cp == NULL || (port = permitopen_port(cp)) < 0)\n\t\t\t\tfatal(\"%s: internal error: permitopen port\",\n\t\t\t\t    __func__);\n\t\t\tchannel_add_permission(ssh,\n\t\t\t    FORWARD_USER, FORWARD_LOCAL, host, port);\n\t\t\tfree(tmp);\n\t\t}\n\t}\n\tif ((options.allow_tcp_forwarding & FORWARD_REMOTE) != 0) {\n\t\tchannel_clear_permission(ssh, FORWARD_USER, FORWARD_REMOTE);\n\t\tfor (i = 0; i < auth_opts->npermitlisten; i++) {\n\t\t\ttmp = cp = xstrdup(auth_opts->permitlisten[i]);\n\t\t\t/* This shouldn't fail as it has already been checked */\n\t\t\tif ((host = hpdelim(&cp)) == NULL)\n\t\t\t\tfatal(\"%s: internal error: hpdelim\", __func__);\n\t\t\thost = cleanhostname(host);\n\t\t\tif (cp == NULL || (port = permitopen_port(cp)) < 0)\n\t\t\t\tfatal(\"%s: internal error: permitlisten port\",\n\t\t\t\t    __func__);\n\t\t\tchannel_add_permission(ssh,\n\t\t\t    FORWARD_USER, FORWARD_REMOTE, host, port);\n\t\t\tfree(tmp);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_log_authopts",
          "args": [
            "\"active\"",
            "auth_opts",
            "0"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "auth_log_authopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "1009-1074",
          "snippet": "void\nauth_log_authopts(const char *loc, const struct sshauthopt *opts, int do_remote)\n{\n\tint do_env = options.permit_user_env && opts->nenv > 0;\n\tint do_permitopen = opts->npermitopen > 0 &&\n\t    (options.allow_tcp_forwarding & FORWARD_LOCAL) != 0;\n\tint do_permitlisten = opts->npermitlisten > 0 &&\n\t    (options.allow_tcp_forwarding & FORWARD_REMOTE) != 0;\n\tsize_t i;\n\tchar msg[1024], buf[64];\n\n\tsnprintf(buf, sizeof(buf), \"%d\", opts->force_tun_device);\n\t/* Try to keep this alphabetically sorted */\n\tsnprintf(msg, sizeof(msg), \"key options:%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n\t    opts->permit_agent_forwarding_flag ? \" agent-forwarding\" : \"\",\n\t    opts->force_command == NULL ? \"\" : \" command\",\n\t    do_env ?  \" environment\" : \"\",\n\t    opts->valid_before == 0 ? \"\" : \"expires\",\n\t    do_permitopen ?  \" permitopen\" : \"\",\n\t    do_permitlisten ?  \" permitlisten\" : \"\",\n\t    opts->permit_port_forwarding_flag ? \" port-forwarding\" : \"\",\n\t    opts->cert_principals == NULL ? \"\" : \" principals\",\n\t    opts->permit_pty_flag ? \" pty\" : \"\",\n\t    opts->force_tun_device == -1 ? \"\" : \" tun=\",\n\t    opts->force_tun_device == -1 ? \"\" : buf,\n\t    opts->permit_user_rc ? \" user-rc\" : \"\",\n\t    opts->permit_x11_forwarding_flag ? \" x11-forwarding\" : \"\");\n\n\tdebug(\"%s: %s\", loc, msg);\n\tif (do_remote)\n\t\tauth_debug_add(\"%s: %s\", loc, msg);\n\n\tif (options.permit_user_env) {\n\t\tfor (i = 0; i < opts->nenv; i++) {\n\t\t\tdebug(\"%s: environment: %s\", loc, opts->env[i]);\n\t\t\tif (do_remote) {\n\t\t\t\tauth_debug_add(\"%s: environment: %s\",\n\t\t\t\t    loc, opts->env[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Go into a little more details for the local logs. */\n\tif (opts->valid_before != 0) {\n\t\tformat_absolute_time(opts->valid_before, buf, sizeof(buf));\n\t\tdebug(\"%s: expires at %s\", loc, buf);\n\t}\n\tif (opts->cert_principals != NULL) {\n\t\tdebug(\"%s: authorized principals: \\\"%s\\\"\",\n\t\t    loc, opts->cert_principals);\n\t}\n\tif (opts->force_command != NULL)\n\t\tdebug(\"%s: forced command: \\\"%s\\\"\", loc, opts->force_command);\n\tif (do_permitopen) {\n\t\tfor (i = 0; i < opts->npermitopen; i++) {\n\t\t\tdebug(\"%s: permitted open: %s\",\n\t\t\t    loc, opts->permitopen[i]);\n\t\t}\n\t}\n\tif (do_permitlisten) {\n\t\tfor (i = 0; i < opts->npermitlisten; i++) {\n\t\t\tdebug(\"%s: permitted listen: %s\",\n\t\t\t    loc, opts->permitlisten[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nvoid\nauth_log_authopts(const char *loc, const struct sshauthopt *opts, int do_remote)\n{\n\tint do_env = options.permit_user_env && opts->nenv > 0;\n\tint do_permitopen = opts->npermitopen > 0 &&\n\t    (options.allow_tcp_forwarding & FORWARD_LOCAL) != 0;\n\tint do_permitlisten = opts->npermitlisten > 0 &&\n\t    (options.allow_tcp_forwarding & FORWARD_REMOTE) != 0;\n\tsize_t i;\n\tchar msg[1024], buf[64];\n\n\tsnprintf(buf, sizeof(buf), \"%d\", opts->force_tun_device);\n\t/* Try to keep this alphabetically sorted */\n\tsnprintf(msg, sizeof(msg), \"key options:%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n\t    opts->permit_agent_forwarding_flag ? \" agent-forwarding\" : \"\",\n\t    opts->force_command == NULL ? \"\" : \" command\",\n\t    do_env ?  \" environment\" : \"\",\n\t    opts->valid_before == 0 ? \"\" : \"expires\",\n\t    do_permitopen ?  \" permitopen\" : \"\",\n\t    do_permitlisten ?  \" permitlisten\" : \"\",\n\t    opts->permit_port_forwarding_flag ? \" port-forwarding\" : \"\",\n\t    opts->cert_principals == NULL ? \"\" : \" principals\",\n\t    opts->permit_pty_flag ? \" pty\" : \"\",\n\t    opts->force_tun_device == -1 ? \"\" : \" tun=\",\n\t    opts->force_tun_device == -1 ? \"\" : buf,\n\t    opts->permit_user_rc ? \" user-rc\" : \"\",\n\t    opts->permit_x11_forwarding_flag ? \" x11-forwarding\" : \"\");\n\n\tdebug(\"%s: %s\", loc, msg);\n\tif (do_remote)\n\t\tauth_debug_add(\"%s: %s\", loc, msg);\n\n\tif (options.permit_user_env) {\n\t\tfor (i = 0; i < opts->nenv; i++) {\n\t\t\tdebug(\"%s: environment: %s\", loc, opts->env[i]);\n\t\t\tif (do_remote) {\n\t\t\t\tauth_debug_add(\"%s: environment: %s\",\n\t\t\t\t    loc, opts->env[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Go into a little more details for the local logs. */\n\tif (opts->valid_before != 0) {\n\t\tformat_absolute_time(opts->valid_before, buf, sizeof(buf));\n\t\tdebug(\"%s: expires at %s\", loc, buf);\n\t}\n\tif (opts->cert_principals != NULL) {\n\t\tdebug(\"%s: authorized principals: \\\"%s\\\"\",\n\t\t    loc, opts->cert_principals);\n\t}\n\tif (opts->force_command != NULL)\n\t\tdebug(\"%s: forced command: \\\"%s\\\"\", loc, opts->force_command);\n\tif (do_permitopen) {\n\t\tfor (i = 0; i < opts->npermitopen; i++) {\n\t\t\tdebug(\"%s: permitted open: %s\",\n\t\t\t    loc, opts->permitopen[i]);\n\t\t}\n\t}\n\tif (do_permitlisten) {\n\t\tfor (i = 0; i < opts->npermitlisten; i++) {\n\t\t\tdebug(\"%s: permitted listen: %s\",\n\t\t\t    loc, opts->permitlisten[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setproctitle",
          "args": [
            "\"%s\"",
            "authctxt->pw->pw_name"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "setproctitle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/setproctitle.c",
          "lines": "122-167",
          "snippet": "void\nsetproctitle(const char *fmt, ...)\n{\n#if SPT_TYPE != SPT_NONE\n\tva_list ap;\n\tchar buf[1024], ptitle[1024];\n\tsize_t len = 0;\n\tint r;\n\textern char *__progname;\n#if SPT_TYPE == SPT_PSTAT\n\tunion pstun pst;\n#endif\n\n#if SPT_TYPE == SPT_REUSEARGV\n\tif (argv_env_len <= 0)\n\t\treturn;\n#endif\n\n\tstrlcpy(buf, __progname, sizeof(buf));\n\n\tr = -1;\n\tva_start(ap, fmt);\n\tif (fmt != NULL) {\n\t\tlen = strlcat(buf, \": \", sizeof(buf));\n\t\tif (len < sizeof(buf))\n\t\t\tr = vsnprintf(buf + len, sizeof(buf) - len , fmt, ap);\n\t}\n\tva_end(ap);\n\tif (r == -1 || (size_t)r >= sizeof(buf) - len)\n\t\treturn;\n\tstrnvis(ptitle, buf, sizeof(ptitle),\n\t    VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL);\n\n#if SPT_TYPE == SPT_PSTAT\n\tpst.pst_command = ptitle;\n\tpstat(PSTAT_SETCMD, pst, strlen(ptitle), 0, 0);\n#elif SPT_TYPE == SPT_REUSEARGV\n/*\tdebug(\"setproctitle: copy \\\"%s\\\" into len %d\",\n\t    buf, argv_env_len); */\n\tlen = strlcpy(argv_start, ptitle, argv_env_len);\n\tfor(; len < argv_env_len; len++)\n\t\targv_start[len] = SPT_PADCHAR;\n#endif\n\n#endif /* SPT_NONE */\n}",
          "includes": [
            "#include <vis.h>",
            "#include <string.h>",
            "#include <sys/pstat.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SPT_REUSEARGV\t2\t/* cover argv with title information */",
            "#define SPT_PSTAT\t1\t/* use pstat(PSTAT_SETCMD, ...) */",
            "#define SPT_NONE\t0\t/* don't use it at all */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vis.h>\n#include <string.h>\n#include <sys/pstat.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\n#define SPT_REUSEARGV\t2\t/* cover argv with title information */\n#define SPT_PSTAT\t1\t/* use pstat(PSTAT_SETCMD, ...) */\n#define SPT_NONE\t0\t/* don't use it at all */\n\nvoid\nsetproctitle(const char *fmt, ...)\n{\n#if SPT_TYPE != SPT_NONE\n\tva_list ap;\n\tchar buf[1024], ptitle[1024];\n\tsize_t len = 0;\n\tint r;\n\textern char *__progname;\n#if SPT_TYPE == SPT_PSTAT\n\tunion pstun pst;\n#endif\n\n#if SPT_TYPE == SPT_REUSEARGV\n\tif (argv_env_len <= 0)\n\t\treturn;\n#endif\n\n\tstrlcpy(buf, __progname, sizeof(buf));\n\n\tr = -1;\n\tva_start(ap, fmt);\n\tif (fmt != NULL) {\n\t\tlen = strlcat(buf, \": \", sizeof(buf));\n\t\tif (len < sizeof(buf))\n\t\t\tr = vsnprintf(buf + len, sizeof(buf) - len , fmt, ap);\n\t}\n\tva_end(ap);\n\tif (r == -1 || (size_t)r >= sizeof(buf) - len)\n\t\treturn;\n\tstrnvis(ptitle, buf, sizeof(ptitle),\n\t    VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL);\n\n#if SPT_TYPE == SPT_PSTAT\n\tpst.pst_command = ptitle;\n\tpstat(PSTAT_SETCMD, pst, strlen(ptitle), 0, 0);\n#elif SPT_TYPE == SPT_REUSEARGV\n/*\tdebug(\"setproctitle: copy \\\"%s\\\" into len %d\",\n\t    buf, argv_env_len); */\n\tlen = strlcpy(argv_start, ptitle, argv_env_len);\n\tfor(; len < argv_env_len; len++)\n\t\targv_start[len] = SPT_PADCHAR;\n#endif\n\n#endif /* SPT_NONE */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void do_authenticated2(struct ssh *, Authctxt *);\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\n\nvoid\ndo_authenticated(struct ssh *ssh, Authctxt *authctxt)\n{\n\tsetproctitle(\"%s\", authctxt->pw->pw_name);\n\n\tauth_log_authopts(\"active\", auth_opts, 0);\n\n\t/* setup the channel layer */\n\t/* XXX - streamlocal? */\n\tset_fwdpermit_from_authopts(ssh, auth_opts);\n\n\tif (!auth_opts->permit_port_forwarding_flag ||\n\t    options.disable_forwarding) {\n\t\tchannel_disable_admin(ssh, FORWARD_LOCAL);\n\t\tchannel_disable_admin(ssh, FORWARD_REMOTE);\n\t} else {\n\t\tif ((options.allow_tcp_forwarding & FORWARD_LOCAL) == 0)\n\t\t\tchannel_disable_admin(ssh, FORWARD_LOCAL);\n\t\telse\n\t\t\tchannel_permit_all(ssh, FORWARD_LOCAL);\n\t\tif ((options.allow_tcp_forwarding & FORWARD_REMOTE) == 0)\n\t\t\tchannel_disable_admin(ssh, FORWARD_REMOTE);\n\t\telse\n\t\t\tchannel_permit_all(ssh, FORWARD_REMOTE);\n\t}\n\tauth_debug_send();\n\n\tprepare_auth_info_file(authctxt->pw, authctxt->session_info);\n\n\tdo_authenticated2(ssh, authctxt);\n\n\tdo_cleanup(ssh, authctxt);\n}"
  },
  {
    "function_name": "set_fwdpermit_from_authopts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "296-335",
    "snippet": "static void\nset_fwdpermit_from_authopts(struct ssh *ssh, const struct sshauthopt *opts)\n{\n\tchar *tmp, *cp, *host;\n\tint port;\n\tsize_t i;\n\n\tif ((options.allow_tcp_forwarding & FORWARD_LOCAL) != 0) {\n\t\tchannel_clear_permission(ssh, FORWARD_USER, FORWARD_LOCAL);\n\t\tfor (i = 0; i < auth_opts->npermitopen; i++) {\n\t\t\ttmp = cp = xstrdup(auth_opts->permitopen[i]);\n\t\t\t/* This shouldn't fail as it has already been checked */\n\t\t\tif ((host = hpdelim(&cp)) == NULL)\n\t\t\t\tfatal(\"%s: internal error: hpdelim\", __func__);\n\t\t\thost = cleanhostname(host);\n\t\t\tif (cp == NULL || (port = permitopen_port(cp)) < 0)\n\t\t\t\tfatal(\"%s: internal error: permitopen port\",\n\t\t\t\t    __func__);\n\t\t\tchannel_add_permission(ssh,\n\t\t\t    FORWARD_USER, FORWARD_LOCAL, host, port);\n\t\t\tfree(tmp);\n\t\t}\n\t}\n\tif ((options.allow_tcp_forwarding & FORWARD_REMOTE) != 0) {\n\t\tchannel_clear_permission(ssh, FORWARD_USER, FORWARD_REMOTE);\n\t\tfor (i = 0; i < auth_opts->npermitlisten; i++) {\n\t\t\ttmp = cp = xstrdup(auth_opts->permitlisten[i]);\n\t\t\t/* This shouldn't fail as it has already been checked */\n\t\t\tif ((host = hpdelim(&cp)) == NULL)\n\t\t\t\tfatal(\"%s: internal error: hpdelim\", __func__);\n\t\t\thost = cleanhostname(host);\n\t\t\tif (cp == NULL || (port = permitopen_port(cp)) < 0)\n\t\t\t\tfatal(\"%s: internal error: permitlisten port\",\n\t\t\t\t    __func__);\n\t\t\tchannel_add_permission(ssh,\n\t\t\t    FORWARD_USER, FORWARD_REMOTE, host, port);\n\t\t\tfree(tmp);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "extern struct sshauthopt *auth_opts;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_add_permission",
          "args": [
            "ssh",
            "FORWARD_USER",
            "FORWARD_REMOTE",
            "host",
            "port"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "channel_add_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4051-4068",
          "snippet": "void\nchannel_add_permission(struct ssh *ssh, int who, int where,\n    char *host, int port)\n{\n\tint local = where == FORWARD_LOCAL;\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tdebug(\"allow %s forwarding to host %s port %d\",\n\t    fwd_ident(who, where), host, port);\n\t/*\n\t * Remote forwards set listen_host/port, local forwards set\n\t * host/port_to_connect.\n\t */\n\tpermission_set_add(ssh, who, where,\n\t    local ? host : 0, local ? port : 0,\n\t    local ? NULL : host, NULL, local ? 0 : port, NULL);\n\tpset->all_permitted = 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *channel_rfwd_bind_host(const char *listen_host);",
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_add_permission(struct ssh *ssh, int who, int where,\n    char *host, int port)\n{\n\tint local = where == FORWARD_LOCAL;\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tdebug(\"allow %s forwarding to host %s port %d\",\n\t    fwd_ident(who, where), host, port);\n\t/*\n\t * Remote forwards set listen_host/port, local forwards set\n\t * host/port_to_connect.\n\t */\n\tpermission_set_add(ssh, who, where,\n\t    local ? host : 0, local ? port : 0,\n\t    local ? NULL : host, NULL, local ? 0 : port, NULL);\n\tpset->all_permitted = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: internal error: permitlisten port\"",
            "__func__"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "permitopen_port",
          "args": [
            "cp"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "permitopen_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4124-4134",
          "snippet": "int\npermitopen_port(const char *p)\n{\n\tint port;\n\n\tif (strcmp(p, \"*\") == 0)\n\t\treturn FWD_PERMIT_ANY_PORT;\n\tif ((port = a2port(p)) > 0)\n\t\treturn port;\n\treturn -1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FWD_PERMIT_ANY_PORT\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define FWD_PERMIT_ANY_PORT\t0\n\nint\npermitopen_port(const char *p)\n{\n\tint port;\n\n\tif (strcmp(p, \"*\") == 0)\n\t\treturn FWD_PERMIT_ANY_PORT;\n\tif ((port = a2port(p)) > 0)\n\t\treturn port;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanhostname",
          "args": [
            "host"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "cleanhostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "535-543",
          "snippet": "char *\ncleanhostname(char *host)\n{\n\tif (*host == '[' && host[strlen(host) - 1] == ']') {\n\t\thost[strlen(host) - 1] = '\\0';\n\t\treturn (host + 1);\n\t} else\n\t\treturn host;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ncleanhostname(char *host)\n{\n\tif (*host == '[' && host[strlen(host) - 1] == ']') {\n\t\thost[strlen(host) - 1] = '\\0';\n\t\treturn (host + 1);\n\t} else\n\t\treturn host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpdelim",
          "args": [
            "&cp"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "hpdelim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "529-533",
          "snippet": "char *\nhpdelim(char **cp)\n{\n\treturn hpdelim2(cp, NULL);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nhpdelim(char **cp)\n{\n\treturn hpdelim2(cp, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "auth_opts->permitlisten[i]"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_clear_permission",
          "args": [
            "ssh",
            "FORWARD_USER",
            "FORWARD_REMOTE"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "channel_clear_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "4084-4093",
          "snippet": "void\nchannel_clear_permission(struct ssh *ssh, int who, int where)\n{\n\tstruct permission **permp;\n\tu_int *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\t*permp = xrecallocarray(*permp, *npermp, 0, sizeof(**permp));\n\t*npermp = 0;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\n\nvoid\nchannel_clear_permission(struct ssh *ssh, int who, int where)\n{\n\tstruct permission **permp;\n\tu_int *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\t*permp = xrecallocarray(*permp, *npermp, 0, sizeof(**permp));\n\t*npermp = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\n\nstatic void\nset_fwdpermit_from_authopts(struct ssh *ssh, const struct sshauthopt *opts)\n{\n\tchar *tmp, *cp, *host;\n\tint port;\n\tsize_t i;\n\n\tif ((options.allow_tcp_forwarding & FORWARD_LOCAL) != 0) {\n\t\tchannel_clear_permission(ssh, FORWARD_USER, FORWARD_LOCAL);\n\t\tfor (i = 0; i < auth_opts->npermitopen; i++) {\n\t\t\ttmp = cp = xstrdup(auth_opts->permitopen[i]);\n\t\t\t/* This shouldn't fail as it has already been checked */\n\t\t\tif ((host = hpdelim(&cp)) == NULL)\n\t\t\t\tfatal(\"%s: internal error: hpdelim\", __func__);\n\t\t\thost = cleanhostname(host);\n\t\t\tif (cp == NULL || (port = permitopen_port(cp)) < 0)\n\t\t\t\tfatal(\"%s: internal error: permitopen port\",\n\t\t\t\t    __func__);\n\t\t\tchannel_add_permission(ssh,\n\t\t\t    FORWARD_USER, FORWARD_LOCAL, host, port);\n\t\t\tfree(tmp);\n\t\t}\n\t}\n\tif ((options.allow_tcp_forwarding & FORWARD_REMOTE) != 0) {\n\t\tchannel_clear_permission(ssh, FORWARD_USER, FORWARD_REMOTE);\n\t\tfor (i = 0; i < auth_opts->npermitlisten; i++) {\n\t\t\ttmp = cp = xstrdup(auth_opts->permitlisten[i]);\n\t\t\t/* This shouldn't fail as it has already been checked */\n\t\t\tif ((host = hpdelim(&cp)) == NULL)\n\t\t\t\tfatal(\"%s: internal error: hpdelim\", __func__);\n\t\t\thost = cleanhostname(host);\n\t\t\tif (cp == NULL || (port = permitopen_port(cp)) < 0)\n\t\t\t\tfatal(\"%s: internal error: permitlisten port\",\n\t\t\t\t    __func__);\n\t\t\tchannel_add_permission(ssh,\n\t\t\t    FORWARD_USER, FORWARD_REMOTE, host, port);\n\t\t\tfree(tmp);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "prepare_auth_info_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "262-294",
    "snippet": "static void\nprepare_auth_info_file(struct passwd *pw, struct sshbuf *info)\n{\n\tint fd = -1, success = 0;\n\n\tif (!options.expose_userauth_info || info == NULL)\n\t\treturn;\n\n\ttemporarily_use_uid(pw);\n\tauth_info_file = xstrdup(\"/tmp/sshauth.XXXXXXXXXXXXXXX\");\n\tif ((fd = mkstemp(auth_info_file)) == -1) {\n\t\terror(\"%s: mkstemp: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(info),\n\t    sshbuf_len(info)) != sshbuf_len(info)) {\n\t\terror(\"%s: write: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tif (close(fd) != 0) {\n\t\terror(\"%s: close: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tsuccess = 1;\n out:\n\tif (!success) {\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\t\tfree(auth_info_file);\n\t\tauth_info_file = NULL;\n\t}\n\trestore_uid();\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "static char *auth_info_file = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "restore_uid",
          "args": [],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "restore_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "141-172",
          "snippet": "void\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "auth_info_file"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "child_close_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1490-1526",
          "snippet": "static void\nchild_close_fds(struct ssh *ssh)\n{\n\textern int auth_sock;\n\n\tif (auth_sock != -1) {\n\t\tclose(auth_sock);\n\t\tauth_sock = -1;\n\t}\n\n\tif (packet_get_connection_in() == packet_get_connection_out())\n\t\tclose(packet_get_connection_in());\n\telse {\n\t\tclose(packet_get_connection_in());\n\t\tclose(packet_get_connection_out());\n\t}\n\t/*\n\t * Close all descriptors related to channels.  They will still remain\n\t * open in the parent.\n\t */\n\t/* XXX better use close-on-exec? -markus */\n\tchannel_close_all(ssh);\n\n\t/*\n\t * Close any extra file descriptors.  Note that there may still be\n\t * descriptors left by system functions.  They will be closed later.\n\t */\n\tendpwent();\n\n\t/*\n\t * Close any extra open file descriptors so that we don't have them\n\t * hanging around in clients.  Note that we want to do this after\n\t * initgroups, because at least on Solaris 2.3 it leaves file\n\t * descriptors open.\n\t */\n\tclosefrom(STDERR_FILENO + 1);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nchild_close_fds(struct ssh *ssh)\n{\n\textern int auth_sock;\n\n\tif (auth_sock != -1) {\n\t\tclose(auth_sock);\n\t\tauth_sock = -1;\n\t}\n\n\tif (packet_get_connection_in() == packet_get_connection_out())\n\t\tclose(packet_get_connection_in());\n\telse {\n\t\tclose(packet_get_connection_in());\n\t\tclose(packet_get_connection_out());\n\t}\n\t/*\n\t * Close all descriptors related to channels.  They will still remain\n\t * open in the parent.\n\t */\n\t/* XXX better use close-on-exec? -markus */\n\tchannel_close_all(ssh);\n\n\t/*\n\t * Close any extra file descriptors.  Note that there may still be\n\t * descriptors left by system functions.  They will be closed later.\n\t */\n\tendpwent();\n\n\t/*\n\t * Close any extra open file descriptors so that we don't have them\n\t * hanging around in clients.  Note that we want to do this after\n\t * initgroups, because at least on Solaris 2.3 it leaves file\n\t * descriptors open.\n\t */\n\tclosefrom(STDERR_FILENO + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: close: %s\"",
            "__func__",
            "strerror(errno)"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "info"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "vwrite",
            "fd",
            "sshbuf_mutable_ptr(info)",
            "sshbuf_len(info)"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_mutable_ptr",
          "args": [
            "info"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_mutable_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "276-282",
          "snippet": "u_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "auth_info_file"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "mkstemp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
          "lines": "120-124",
          "snippet": "int\nmkstemp(char *path)\n{\n\treturn(mktemp_internal(path, 0, MKTEMP_FILE));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MKTEMP_FILE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MKTEMP_FILE\t1\n\nint\nmkstemp(char *path)\n{\n\treturn(mktemp_internal(path, 0, MKTEMP_FILE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "\"/tmp/sshauth.XXXXXXXXXXXXXXX\""
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "temporarily_use_uid",
          "args": [
            "pw"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "temporarily_use_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "60-136",
          "snippet": "void\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static uid_t\tuser_groups_uid;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic uid_t\tuser_groups_uid;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nstatic char *auth_info_file = NULL;\n\nstatic void\nprepare_auth_info_file(struct passwd *pw, struct sshbuf *info)\n{\n\tint fd = -1, success = 0;\n\n\tif (!options.expose_userauth_info || info == NULL)\n\t\treturn;\n\n\ttemporarily_use_uid(pw);\n\tauth_info_file = xstrdup(\"/tmp/sshauth.XXXXXXXXXXXXXXX\");\n\tif ((fd = mkstemp(auth_info_file)) == -1) {\n\t\terror(\"%s: mkstemp: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(info),\n\t    sshbuf_len(info)) != sshbuf_len(info)) {\n\t\terror(\"%s: write: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tif (close(fd) != 0) {\n\t\terror(\"%s: close: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tsuccess = 1;\n out:\n\tif (!success) {\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\t\tfree(auth_info_file);\n\t\tauth_info_file = NULL;\n\t}\n\trestore_uid();\n}"
  },
  {
    "function_name": "display_loginmsg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "249-260",
    "snippet": "static void\ndisplay_loginmsg(void)\n{\n\tint r;\n\n\tif (sshbuf_len(loginmsg) == 0)\n\t\treturn;\n\tif ((r = sshbuf_put_u8(loginmsg, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tprintf(\"%s\", (char *)sshbuf_ptr(loginmsg));\n\tsshbuf_reset(loginmsg);\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct sshbuf *loginmsg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "loginmsg"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\"",
            "(char *)sshbuf_ptr(loginmsg)"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "loginmsg"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "loginmsg",
            "0"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "loginmsg"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern struct sshbuf *loginmsg;\n\nstatic void\ndisplay_loginmsg(void)\n{\n\tint r;\n\n\tif (sshbuf_len(loginmsg) == 0)\n\t\treturn;\n\tif ((r = sshbuf_put_u8(loginmsg, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tprintf(\"%s\", (char *)sshbuf_ptr(loginmsg));\n\tsshbuf_reset(loginmsg);\n}"
  },
  {
    "function_name": "auth_input_request_forwarding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "188-247",
    "snippet": "static int\nauth_input_request_forwarding(struct ssh *ssh, struct passwd * pw)\n{\n\tChannel *nc;\n\tint sock = -1;\n\n\tif (auth_sock_name != NULL) {\n\t\terror(\"authentication forwarding requested twice.\");\n\t\treturn 0;\n\t}\n\n\t/* Temporarily drop privileged uid for mkdir/bind. */\n\ttemporarily_use_uid(pw);\n\n\t/* Allocate a buffer for the socket name, and format the name. */\n\tauth_sock_dir = xstrdup(\"/tmp/ssh-XXXXXXXXXX\");\n\n\t/* Create private directory for socket */\n\tif (mkdtemp(auth_sock_dir) == NULL) {\n\t\tpacket_send_debug(\"Agent forwarding disabled: \"\n\t\t    \"mkdtemp() failed: %.100s\", strerror(errno));\n\t\trestore_uid();\n\t\tfree(auth_sock_dir);\n\t\tauth_sock_dir = NULL;\n\t\tgoto authsock_err;\n\t}\n\n\txasprintf(&auth_sock_name, \"%s/agent.%ld\",\n\t    auth_sock_dir, (long) getpid());\n\n\t/* Start a Unix listener on auth_sock_name. */\n\tsock = unix_listener(auth_sock_name, SSH_LISTEN_BACKLOG, 0);\n\n\t/* Restore the privileged uid. */\n\trestore_uid();\n\n\t/* Check for socket/bind/listen failure. */\n\tif (sock < 0)\n\t\tgoto authsock_err;\n\n\t/* Allocate a channel for the authentication agent socket. */\n\tnc = channel_new(ssh, \"auth socket\",\n\t    SSH_CHANNEL_AUTH_SOCKET, sock, sock, -1,\n\t    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,\n\t    0, \"auth socket\", 1);\n\tnc->path = xstrdup(auth_sock_name);\n\treturn 1;\n\n authsock_err:\n\tfree(auth_sock_name);\n\tif (auth_sock_dir != NULL) {\n\t\trmdir(auth_sock_dir);\n\t\tfree(auth_sock_dir);\n\t}\n\tif (sock != -1)\n\t\tclose(sock);\n\tauth_sock_name = NULL;\n\tauth_sock_dir = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *auth_sock_name = NULL;",
      "static char *auth_sock_dir = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "child_close_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "1490-1526",
          "snippet": "static void\nchild_close_fds(struct ssh *ssh)\n{\n\textern int auth_sock;\n\n\tif (auth_sock != -1) {\n\t\tclose(auth_sock);\n\t\tauth_sock = -1;\n\t}\n\n\tif (packet_get_connection_in() == packet_get_connection_out())\n\t\tclose(packet_get_connection_in());\n\telse {\n\t\tclose(packet_get_connection_in());\n\t\tclose(packet_get_connection_out());\n\t}\n\t/*\n\t * Close all descriptors related to channels.  They will still remain\n\t * open in the parent.\n\t */\n\t/* XXX better use close-on-exec? -markus */\n\tchannel_close_all(ssh);\n\n\t/*\n\t * Close any extra file descriptors.  Note that there may still be\n\t * descriptors left by system functions.  They will be closed later.\n\t */\n\tendpwent();\n\n\t/*\n\t * Close any extra open file descriptors so that we don't have them\n\t * hanging around in clients.  Note that we want to do this after\n\t * initgroups, because at least on Solaris 2.3 it leaves file\n\t * descriptors open.\n\t */\n\tclosefrom(STDERR_FILENO + 1);\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nchild_close_fds(struct ssh *ssh)\n{\n\textern int auth_sock;\n\n\tif (auth_sock != -1) {\n\t\tclose(auth_sock);\n\t\tauth_sock = -1;\n\t}\n\n\tif (packet_get_connection_in() == packet_get_connection_out())\n\t\tclose(packet_get_connection_in());\n\telse {\n\t\tclose(packet_get_connection_in());\n\t\tclose(packet_get_connection_out());\n\t}\n\t/*\n\t * Close all descriptors related to channels.  They will still remain\n\t * open in the parent.\n\t */\n\t/* XXX better use close-on-exec? -markus */\n\tchannel_close_all(ssh);\n\n\t/*\n\t * Close any extra file descriptors.  Note that there may still be\n\t * descriptors left by system functions.  They will be closed later.\n\t */\n\tendpwent();\n\n\t/*\n\t * Close any extra open file descriptors so that we don't have them\n\t * hanging around in clients.  Note that we want to do this after\n\t * initgroups, because at least on Solaris 2.3 it leaves file\n\t * descriptors open.\n\t */\n\tclosefrom(STDERR_FILENO + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "auth_sock_dir"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "auth_sock_dir"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "process_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1128-1143",
          "snippet": "static void\nprocess_rmdir(u_int32_t id)\n{\n\tchar *name;\n\tint r, status;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: rmdir\", id);\n\tlogit(\"rmdir name \\\"%s\\\"\", name);\n\tr = rmdir(name);\n\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\tsend_status(id, status);\n\tfree(name);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct sshbuf *iqueue;",
            "static void process_open(u_int32_t id);",
            "static void process_close(u_int32_t id);",
            "static void process_read(u_int32_t id);",
            "static void process_write(u_int32_t id);",
            "static void process_stat(u_int32_t id);",
            "static void process_lstat(u_int32_t id);",
            "static void process_fstat(u_int32_t id);",
            "static void process_setstat(u_int32_t id);",
            "static void process_fsetstat(u_int32_t id);",
            "static void process_opendir(u_int32_t id);",
            "static void process_readdir(u_int32_t id);",
            "static void process_remove(u_int32_t id);",
            "static void process_mkdir(u_int32_t id);",
            "static void process_rmdir(u_int32_t id);",
            "static void process_realpath(u_int32_t id);",
            "static void process_rename(u_int32_t id);",
            "static void process_readlink(u_int32_t id);",
            "static void process_symlink(u_int32_t id);",
            "static void process_extended_posix_rename(u_int32_t id);",
            "static void process_extended_statvfs(u_int32_t id);",
            "static void process_extended_fstatvfs(u_int32_t id);",
            "static void process_extended_hardlink(u_int32_t id);",
            "static void process_extended_fsync(u_int32_t id);",
            "static void process_extended(u_int32_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *iqueue;\nstatic void process_open(u_int32_t id);\nstatic void process_close(u_int32_t id);\nstatic void process_read(u_int32_t id);\nstatic void process_write(u_int32_t id);\nstatic void process_stat(u_int32_t id);\nstatic void process_lstat(u_int32_t id);\nstatic void process_fstat(u_int32_t id);\nstatic void process_setstat(u_int32_t id);\nstatic void process_fsetstat(u_int32_t id);\nstatic void process_opendir(u_int32_t id);\nstatic void process_readdir(u_int32_t id);\nstatic void process_remove(u_int32_t id);\nstatic void process_mkdir(u_int32_t id);\nstatic void process_rmdir(u_int32_t id);\nstatic void process_realpath(u_int32_t id);\nstatic void process_rename(u_int32_t id);\nstatic void process_readlink(u_int32_t id);\nstatic void process_symlink(u_int32_t id);\nstatic void process_extended_posix_rename(u_int32_t id);\nstatic void process_extended_statvfs(u_int32_t id);\nstatic void process_extended_fstatvfs(u_int32_t id);\nstatic void process_extended_hardlink(u_int32_t id);\nstatic void process_extended_fsync(u_int32_t id);\nstatic void process_extended(u_int32_t id);\n\nstatic void\nprocess_rmdir(u_int32_t id)\n{\n\tchar *name;\n\tint r, status;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: rmdir\", id);\n\tlogit(\"rmdir name \\\"%s\\\"\", name);\n\tr = rmdir(name);\n\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\tsend_status(id, status);\n\tfree(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "auth_sock_name"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_new",
          "args": [
            "ssh",
            "\"auth socket\"",
            "SSH_CHANNEL_AUTH_SOCKET",
            "sock",
            "sock",
            "-1",
            "CHAN_X11_WINDOW_DEFAULT",
            "CHAN_X11_PACKET_DEFAULT",
            "0",
            "\"auth socket\"",
            "1"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "channel_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "354-405",
          "snippet": "Channel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);",
            "static int rdynamic_connect_finish(struct ssh *, Channel *);",
            "static void channel_handler_init(struct ssh_channels *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\nstatic void channel_handler_init(struct ssh_channels *sc);\n\nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found;\n\tChannel *c;\n\n\t/* Try to find a free slot where to put the new channel. */\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t/* Found a free slot. */\n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t/*\n\t\t * There are no free slots. Take last+1 slot and expand\n\t\t * the array.\n\t\t */\n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal(\"%s: internal error: channels_alloc %d too big\",\n\t\t\t    __func__, sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t/* Initialize and return new channel. */\n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t/* prevent call to channel_post handler */\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new [%s]\", found, remote_name);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_uid",
          "args": [],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "restore_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "141-172",
          "snippet": "void\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unix_listener",
          "args": [
            "auth_sock_name",
            "SSH_LISTEN_BACKLOG",
            "0"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "unix_listener",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1487-1532",
          "snippet": "int\nunix_listener(const char *path, int backlog, int unlink_first)\n{\n\tstruct sockaddr_un sunaddr;\n\tint saved_errno, sock;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tif (strlcpy(sunaddr.sun_path, path,\n\t    sizeof(sunaddr.sun_path)) >= sizeof(sunaddr.sun_path)) {\n\t\terror(\"%s: path \\\"%s\\\" too long for Unix domain socket\",\n\t\t    __func__, path);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\tsock = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (sock < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: socket: %.100s\", __func__, strerror(errno));\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (unlink_first == 1) {\n\t\tif (unlink(path) != 0 && errno != ENOENT)\n\t\t\terror(\"unlink(%s): %.100s\", path, strerror(errno));\n\t}\n\tif (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: cannot bind to path %s: %s\",\n\t\t    __func__, path, strerror(errno));\n\t\tclose(sock);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (listen(sock, backlog) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: cannot listen on path %s: %s\",\n\t\t    __func__, path, strerror(errno));\n\t\tclose(sock);\n\t\tunlink(path);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\treturn sock;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunix_listener(const char *path, int backlog, int unlink_first)\n{\n\tstruct sockaddr_un sunaddr;\n\tint saved_errno, sock;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tif (strlcpy(sunaddr.sun_path, path,\n\t    sizeof(sunaddr.sun_path)) >= sizeof(sunaddr.sun_path)) {\n\t\terror(\"%s: path \\\"%s\\\" too long for Unix domain socket\",\n\t\t    __func__, path);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\tsock = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (sock < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: socket: %.100s\", __func__, strerror(errno));\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (unlink_first == 1) {\n\t\tif (unlink(path) != 0 && errno != ENOENT)\n\t\t\terror(\"unlink(%s): %.100s\", path, strerror(errno));\n\t}\n\tif (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: cannot bind to path %s: %s\",\n\t\t    __func__, path, strerror(errno));\n\t\tclose(sock);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (listen(sock, backlog) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: cannot listen on path %s: %s\",\n\t\t    __func__, path, strerror(errno));\n\t\tclose(sock);\n\t\tunlink(path);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\treturn sock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&auth_sock_name",
            "\"%s/agent.%ld\"",
            "auth_sock_dir",
            "(long) getpid()"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_send_debug",
          "args": [
            "\"Agent forwarding disabled: \"\n\t\t    \"mkdtemp() failed: %.100s\"",
            "strerror(errno)"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "packet_send_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "310-320",
          "snippet": "void\npacket_send_debug(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_send_debug(active_state, \"%s\", buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_send_debug(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_send_debug(active_state, \"%s\", buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdtemp",
          "args": [
            "auth_sock_dir"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "mkdtemp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
          "lines": "132-139",
          "snippet": "char *\nmkdtemp(char *path)\n{\n\tint error;\n\n\terror = mktemp_internal(path, 0, MKTEMP_DIR);\n\treturn(error ? NULL : path);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MKTEMP_DIR\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MKTEMP_DIR\t2\n\nchar *\nmkdtemp(char *path)\n{\n\tint error;\n\n\terror = mktemp_internal(path, 0, MKTEMP_DIR);\n\treturn(error ? NULL : path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "temporarily_use_uid",
          "args": [
            "pw"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "temporarily_use_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "60-136",
          "snippet": "void\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static uid_t\tuser_groups_uid;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic uid_t\tuser_groups_uid;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"authentication forwarding requested twice.\""
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *auth_sock_name = NULL;\nstatic char *auth_sock_dir = NULL;\n\nstatic int\nauth_input_request_forwarding(struct ssh *ssh, struct passwd * pw)\n{\n\tChannel *nc;\n\tint sock = -1;\n\n\tif (auth_sock_name != NULL) {\n\t\terror(\"authentication forwarding requested twice.\");\n\t\treturn 0;\n\t}\n\n\t/* Temporarily drop privileged uid for mkdir/bind. */\n\ttemporarily_use_uid(pw);\n\n\t/* Allocate a buffer for the socket name, and format the name. */\n\tauth_sock_dir = xstrdup(\"/tmp/ssh-XXXXXXXXXX\");\n\n\t/* Create private directory for socket */\n\tif (mkdtemp(auth_sock_dir) == NULL) {\n\t\tpacket_send_debug(\"Agent forwarding disabled: \"\n\t\t    \"mkdtemp() failed: %.100s\", strerror(errno));\n\t\trestore_uid();\n\t\tfree(auth_sock_dir);\n\t\tauth_sock_dir = NULL;\n\t\tgoto authsock_err;\n\t}\n\n\txasprintf(&auth_sock_name, \"%s/agent.%ld\",\n\t    auth_sock_dir, (long) getpid());\n\n\t/* Start a Unix listener on auth_sock_name. */\n\tsock = unix_listener(auth_sock_name, SSH_LISTEN_BACKLOG, 0);\n\n\t/* Restore the privileged uid. */\n\trestore_uid();\n\n\t/* Check for socket/bind/listen failure. */\n\tif (sock < 0)\n\t\tgoto authsock_err;\n\n\t/* Allocate a channel for the authentication agent socket. */\n\tnc = channel_new(ssh, \"auth socket\",\n\t    SSH_CHANNEL_AUTH_SOCKET, sock, sock, -1,\n\t    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,\n\t    0, \"auth socket\", 1);\n\tnc->path = xstrdup(auth_sock_name);\n\treturn 1;\n\n authsock_err:\n\tfree(auth_sock_name);\n\tif (auth_sock_dir != NULL) {\n\t\trmdir(auth_sock_dir);\n\t\tfree(auth_sock_dir);\n\t}\n\tif (sock != -1)\n\t\tclose(sock);\n\tauth_sock_name = NULL;\n\tauth_sock_dir = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "auth_sock_cleanup_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
    "lines": "176-186",
    "snippet": "static void\nauth_sock_cleanup_proc(struct passwd *pw)\n{\n\tif (auth_sock_name != NULL) {\n\t\ttemporarily_use_uid(pw);\n\t\tunlink(auth_sock_name);\n\t\trmdir(auth_sock_dir);\n\t\tauth_sock_name = NULL;\n\t\trestore_uid();\n\t}\n}",
    "includes": [
      "#include <selinux/selinux.h>",
      "#include <kafs.h>",
      "#include \"atomicio.h\"",
      "#include \"sftp.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"kex.h\"",
      "#include \"session.h\"",
      "#include \"canohost.h\"",
      "#include \"serverloop.h\"",
      "#include \"sshlogin.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"authfd.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"cipher.h\"",
      "#include \"sshkey.h\"",
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"uidswap.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"packet.h\"",
      "#include \"sshpty.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <netdb.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "# include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *auth_sock_name = NULL;",
      "static char *auth_sock_dir = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "restore_uid",
          "args": [],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "restore_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "141-172",
          "snippet": "void\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "auth_sock_dir"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "process_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1128-1143",
          "snippet": "static void\nprocess_rmdir(u_int32_t id)\n{\n\tchar *name;\n\tint r, status;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: rmdir\", id);\n\tlogit(\"rmdir name \\\"%s\\\"\", name);\n\tr = rmdir(name);\n\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\tsend_status(id, status);\n\tfree(name);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct sshbuf *iqueue;",
            "static void process_open(u_int32_t id);",
            "static void process_close(u_int32_t id);",
            "static void process_read(u_int32_t id);",
            "static void process_write(u_int32_t id);",
            "static void process_stat(u_int32_t id);",
            "static void process_lstat(u_int32_t id);",
            "static void process_fstat(u_int32_t id);",
            "static void process_setstat(u_int32_t id);",
            "static void process_fsetstat(u_int32_t id);",
            "static void process_opendir(u_int32_t id);",
            "static void process_readdir(u_int32_t id);",
            "static void process_remove(u_int32_t id);",
            "static void process_mkdir(u_int32_t id);",
            "static void process_rmdir(u_int32_t id);",
            "static void process_realpath(u_int32_t id);",
            "static void process_rename(u_int32_t id);",
            "static void process_readlink(u_int32_t id);",
            "static void process_symlink(u_int32_t id);",
            "static void process_extended_posix_rename(u_int32_t id);",
            "static void process_extended_statvfs(u_int32_t id);",
            "static void process_extended_fstatvfs(u_int32_t id);",
            "static void process_extended_hardlink(u_int32_t id);",
            "static void process_extended_fsync(u_int32_t id);",
            "static void process_extended(u_int32_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *iqueue;\nstatic void process_open(u_int32_t id);\nstatic void process_close(u_int32_t id);\nstatic void process_read(u_int32_t id);\nstatic void process_write(u_int32_t id);\nstatic void process_stat(u_int32_t id);\nstatic void process_lstat(u_int32_t id);\nstatic void process_fstat(u_int32_t id);\nstatic void process_setstat(u_int32_t id);\nstatic void process_fsetstat(u_int32_t id);\nstatic void process_opendir(u_int32_t id);\nstatic void process_readdir(u_int32_t id);\nstatic void process_remove(u_int32_t id);\nstatic void process_mkdir(u_int32_t id);\nstatic void process_rmdir(u_int32_t id);\nstatic void process_realpath(u_int32_t id);\nstatic void process_rename(u_int32_t id);\nstatic void process_readlink(u_int32_t id);\nstatic void process_symlink(u_int32_t id);\nstatic void process_extended_posix_rename(u_int32_t id);\nstatic void process_extended_statvfs(u_int32_t id);\nstatic void process_extended_fstatvfs(u_int32_t id);\nstatic void process_extended_hardlink(u_int32_t id);\nstatic void process_extended_fsync(u_int32_t id);\nstatic void process_extended(u_int32_t id);\n\nstatic void\nprocess_rmdir(u_int32_t id)\n{\n\tchar *name;\n\tint r, status;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: rmdir\", id);\n\tlogit(\"rmdir name \\\"%s\\\"\", name);\n\tr = rmdir(name);\n\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\tsend_status(id, status);\n\tfree(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "auth_sock_name"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "temporarily_use_uid",
          "args": [
            "pw"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "temporarily_use_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "60-136",
          "snippet": "void\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static uid_t\tuser_groups_uid;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic uid_t\tuser_groups_uid;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *auth_sock_name = NULL;\nstatic char *auth_sock_dir = NULL;\n\nstatic void\nauth_sock_cleanup_proc(struct passwd *pw)\n{\n\tif (auth_sock_name != NULL) {\n\t\ttemporarily_use_uid(pw);\n\t\tunlink(auth_sock_name);\n\t\trmdir(auth_sock_dir);\n\t\tauth_sock_name = NULL;\n\t\trestore_uid();\n\t}\n}"
  }
]