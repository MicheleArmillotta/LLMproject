[
  {
    "function_name": "xmssmt_sign_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "970-1105",
    "snippet": "int xmssmt_sign_open(unsigned char *msg, unsigned long long *msglen, const unsigned char *sig_msg, unsigned long long sig_msg_len, const unsigned char *pk, const xmssmt_params *params)\n{\n  unsigned int n = params->n;\n\n  unsigned int tree_h = params->xmss_par.h;\n  unsigned int idx_len = params->index_len;\n  uint64_t idx_tree;\n  uint32_t idx_leaf;\n\n  unsigned long long i, m_len;\n  unsigned long long idx=0;\n  unsigned char wots_pk[params->xmss_par.wots_par.keysize];\n  unsigned char pkhash[n];\n  unsigned char root[n];\n  unsigned char msg_h[n];\n  unsigned char hash_key[3*n];\n\n  unsigned char pub_seed[n];\n  memcpy(pub_seed, pk+n, n);\n\n  // Init addresses\n  uint32_t ots_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t ltree_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t node_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n  // Extract index\n  for (i = 0; i < idx_len; i++) {\n    idx |= ((unsigned long long)sig_msg[i]) << (8*(idx_len - 1 - i));\n  }\n  printf(\"verify:: idx = %llu\\n\", idx);\n  sig_msg += idx_len;\n  sig_msg_len -= idx_len;\n  \n  // Generate hash key (R || root || idx)\n  memcpy(hash_key, sig_msg,n);\n  memcpy(hash_key+n, pk, n);\n  to_byte(hash_key+2*n, idx, n);\n\n  sig_msg += n;\n  sig_msg_len -= n;\n  \n\n  // hash message (recall, R is now on pole position at sig_msg\n  unsigned long long tmp_sig_len = (params->d * params->xmss_par.wots_par.keysize) + (params->h * n);\n  m_len = sig_msg_len - tmp_sig_len;\n  h_msg(msg_h, sig_msg + tmp_sig_len, m_len, hash_key, 3*n, n);\n\n  \n  //-----------------------\n  // Verify signature\n  //-----------------------\n\n  // Prepare Address\n  idx_tree = idx >> tree_h;\n  idx_leaf = (idx & ((1 << tree_h)-1));\n  setLayerADRS(ots_addr, 0);\n  setTreeADRS(ots_addr, idx_tree);\n  setType(ots_addr, 0);\n\n  memcpy(ltree_addr, ots_addr, 12);\n  setType(ltree_addr, 1);\n\n  memcpy(node_addr, ltree_addr, 12);\n  setType(node_addr, 2);\n  \n  setOTSADRS(ots_addr, idx_leaf);\n\n  // Check WOTS signature\n  wots_pkFromSig(wots_pk, sig_msg, msg_h, &(params->xmss_par.wots_par), pub_seed, ots_addr);\n\n  sig_msg += params->xmss_par.wots_par.keysize;\n  sig_msg_len -= params->xmss_par.wots_par.keysize;\n\n  // Compute Ltree\n  setLtreeADRS(ltree_addr, idx_leaf);\n  l_tree(pkhash, wots_pk, &(params->xmss_par), pub_seed, ltree_addr);\n\n  // Compute root\n  validate_authpath(root, pkhash, idx_leaf, sig_msg, &(params->xmss_par), pub_seed, node_addr);\n\n  sig_msg += tree_h*n;\n  sig_msg_len -= tree_h*n;\n\n  for (i = 1; i < params->d; i++) {\n    // Prepare Address\n    idx_leaf = (idx_tree & ((1 << tree_h)-1));\n    idx_tree = idx_tree >> tree_h;\n\n    setLayerADRS(ots_addr, i);\n    setTreeADRS(ots_addr, idx_tree);\n    setType(ots_addr, 0);\n\n    memcpy(ltree_addr, ots_addr, 12);\n    setType(ltree_addr, 1);\n\n    memcpy(node_addr, ltree_addr, 12);\n    setType(node_addr, 2);\n\n    setOTSADRS(ots_addr, idx_leaf);\n\n    // Check WOTS signature\n    wots_pkFromSig(wots_pk, sig_msg, root, &(params->xmss_par.wots_par), pub_seed, ots_addr);\n\n    sig_msg += params->xmss_par.wots_par.keysize;\n    sig_msg_len -= params->xmss_par.wots_par.keysize;\n\n    // Compute Ltree\n    setLtreeADRS(ltree_addr, idx_leaf);\n    l_tree(pkhash, wots_pk, &(params->xmss_par), pub_seed, ltree_addr);\n\n    // Compute root\n    validate_authpath(root, pkhash, idx_leaf, sig_msg, &(params->xmss_par), pub_seed, node_addr);\n\n    sig_msg += tree_h*n;\n    sig_msg_len -= tree_h*n;\n\n  }\n\n  for (i = 0; i < n; i++)\n    if (root[i] != pk[i])\n      goto fail;\n\n  *msglen = sig_msg_len;\n  for (i = 0; i < *msglen; i++)\n    msg[i] = sig_msg[i];\n\n  return 0;\n\n\nfail:\n  *msglen = sig_msg_len;\n  for (i = 0; i < *msglen; i++)\n    msg[i] = 0;\n  *msglen = -1;\n  return -1;\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "validate_authpath",
          "args": [
            "root",
            "pkhash",
            "idx_leaf",
            "sig_msg",
            "&(params->xmss_par)",
            "pub_seed",
            "node_addr"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "validate_authpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "296-339",
          "snippet": "static void validate_authpath(unsigned char *root, const unsigned char *leaf, unsigned long leafidx, const unsigned char *authpath, const xmss_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int n = params->n;\n\n  uint32_t i, j;\n  unsigned char buffer[2*n];\n\n  // If leafidx is odd (last bit = 1), current path element is a right child and authpath has to go to the left.\n  // Otherwise, it is the other way around\n  if (leafidx & 1) {\n    for (j = 0; j < n; j++)\n      buffer[n+j] = leaf[j];\n    for (j = 0; j < n; j++)\n      buffer[j] = authpath[j];\n  }\n  else {\n    for (j = 0; j < n; j++)\n      buffer[j] = leaf[j];\n    for (j = 0; j < n; j++)\n      buffer[n+j] = authpath[j];\n  }\n  authpath += n;\n\n  for (i=0; i < params->h-1; i++) {\n    setTreeHeight(addr, i);\n    leafidx >>= 1;\n    setTreeIndex(addr, leafidx);\n    if (leafidx&1) {\n      hash_h(buffer+n, buffer, pub_seed, addr, n);\n      for (j = 0; j < n; j++)\n        buffer[j] = authpath[j];\n    }\n    else {\n      hash_h(buffer, buffer, pub_seed, addr, n);\n      for (j = 0; j < n; j++)\n        buffer[j+n] = authpath[j];\n    }\n    authpath += n;\n  }\n  setTreeHeight(addr, (params->h-1));\n  leafidx >>= 1;\n  setTreeIndex(addr, leafidx);\n  hash_h(root, buffer, pub_seed, addr, n);\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void validate_authpath(unsigned char *root, const unsigned char *leaf, unsigned long leafidx, const unsigned char *authpath, const xmss_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int n = params->n;\n\n  uint32_t i, j;\n  unsigned char buffer[2*n];\n\n  // If leafidx is odd (last bit = 1), current path element is a right child and authpath has to go to the left.\n  // Otherwise, it is the other way around\n  if (leafidx & 1) {\n    for (j = 0; j < n; j++)\n      buffer[n+j] = leaf[j];\n    for (j = 0; j < n; j++)\n      buffer[j] = authpath[j];\n  }\n  else {\n    for (j = 0; j < n; j++)\n      buffer[j] = leaf[j];\n    for (j = 0; j < n; j++)\n      buffer[n+j] = authpath[j];\n  }\n  authpath += n;\n\n  for (i=0; i < params->h-1; i++) {\n    setTreeHeight(addr, i);\n    leafidx >>= 1;\n    setTreeIndex(addr, leafidx);\n    if (leafidx&1) {\n      hash_h(buffer+n, buffer, pub_seed, addr, n);\n      for (j = 0; j < n; j++)\n        buffer[j] = authpath[j];\n    }\n    else {\n      hash_h(buffer, buffer, pub_seed, addr, n);\n      for (j = 0; j < n; j++)\n        buffer[j+n] = authpath[j];\n    }\n    authpath += n;\n  }\n  setTreeHeight(addr, (params->h-1));\n  leafidx >>= 1;\n  setTreeIndex(addr, leafidx);\n  hash_h(root, buffer, pub_seed, addr, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "l_tree",
          "args": [
            "pkhash",
            "wots_pk",
            "&(params->xmss_par)",
            "pub_seed",
            "ltree_addr"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "l_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "111-147",
          "snippet": "static void l_tree(unsigned char *leaf, unsigned char *wots_pk, const xmss_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int l = params->wots_par.len;\n  unsigned int n = params->n;\n  uint32_t i = 0;\n  uint32_t height = 0;\n  uint32_t bound;\n\n  //ADRS.setTreeHeight(0);\n  setTreeHeight(addr, height);\n  \n  while (l > 1) {\n     bound = l >> 1; //floor(l / 2);\n     for (i = 0; i < bound; i++) {\n       //ADRS.setTreeIndex(i);\n       setTreeIndex(addr, i);\n       //wots_pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n       hash_h(wots_pk+i*n, wots_pk+i*2*n, pub_seed, addr, n);\n     }\n     //if ( l % 2 == 1 ) {\n     if (l & 1) {\n       //pk[floor(l / 2) + 1] = pk[l];\n       memcpy(wots_pk+(l>>1)*n, wots_pk+(l-1)*n, n);\n       //l = ceil(l / 2);\n       l=(l>>1)+1;\n     }\n     else {\n       //l = ceil(l / 2);\n       l=(l>>1);\n     }\n     //ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     height++;\n     setTreeHeight(addr, height);\n   }\n   //return pk[0];\n   memcpy(leaf, wots_pk, n);\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void l_tree(unsigned char *leaf, unsigned char *wots_pk, const xmss_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int l = params->wots_par.len;\n  unsigned int n = params->n;\n  uint32_t i = 0;\n  uint32_t height = 0;\n  uint32_t bound;\n\n  //ADRS.setTreeHeight(0);\n  setTreeHeight(addr, height);\n  \n  while (l > 1) {\n     bound = l >> 1; //floor(l / 2);\n     for (i = 0; i < bound; i++) {\n       //ADRS.setTreeIndex(i);\n       setTreeIndex(addr, i);\n       //wots_pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n       hash_h(wots_pk+i*n, wots_pk+i*2*n, pub_seed, addr, n);\n     }\n     //if ( l % 2 == 1 ) {\n     if (l & 1) {\n       //pk[floor(l / 2) + 1] = pk[l];\n       memcpy(wots_pk+(l>>1)*n, wots_pk+(l-1)*n, n);\n       //l = ceil(l / 2);\n       l=(l>>1)+1;\n     }\n     else {\n       //l = ceil(l / 2);\n       l=(l>>1);\n     }\n     //ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     height++;\n     setTreeHeight(addr, height);\n   }\n   //return pk[0];\n   memcpy(leaf, wots_pk, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setLtreeADRS",
          "args": [
            "ltree_addr",
            "idx_leaf"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "setLtreeADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "53-55",
          "snippet": "void setLtreeADRS(uint32_t adrs[8], uint32_t ltree){\n  adrs[4] = ltree;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setLtreeADRS(uint32_t adrs[8], uint32_t ltree){\n  adrs[4] = ltree;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wots_pkFromSig",
          "args": [
            "wots_pk",
            "sig_msg",
            "root",
            "&(params->xmss_par.wots_par)",
            "pub_seed",
            "ots_addr"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "wots_pkFromSig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_wots.c",
          "lines": "158-191",
          "snippet": "int wots_pkFromSig(unsigned char *pk, const unsigned char *sig, const unsigned char *msg, const wots_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  int csum = 0;\n  uint32_t i = 0;\n  int *basew = calloc(params->len, sizeof(int));\n  if (basew == NULL)\n    return -1;\n\n  base_w(basew, params->len_1, msg, params);\n\n  for (i=0; i < params->len_1; i++) {\n    csum += params->w - 1 - basew[i];\n  }\n\n  csum = csum << (8 - ((params->len_2 * params->log_w) % 8));\n\n  int len_2_bytes = ((params->len_2 * params->log_w) + 7) / 8;\n\n  unsigned char csum_bytes[len_2_bytes];\n  to_byte(csum_bytes, csum, len_2_bytes);\n\n  int csum_basew[params->len_2];\n  base_w(csum_basew, params->len_2, csum_bytes, params);\n\n  for (i = 0; i < params->len_2; i++) {\n    basew[params->len_1 + i] = csum_basew[i];\n  }\n  for (i=0; i < params->len; i++) {\n    setChainADRS(addr, i);\n    gen_chain(pk+i*params->n, sig+i*params->n, basew[i], params->w-1-basew[i], params, pub_seed, addr);\n  }\n  free(basew);\n  return 0;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include <limits.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\n#include \"xmss_wots.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint wots_pkFromSig(unsigned char *pk, const unsigned char *sig, const unsigned char *msg, const wots_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  int csum = 0;\n  uint32_t i = 0;\n  int *basew = calloc(params->len, sizeof(int));\n  if (basew == NULL)\n    return -1;\n\n  base_w(basew, params->len_1, msg, params);\n\n  for (i=0; i < params->len_1; i++) {\n    csum += params->w - 1 - basew[i];\n  }\n\n  csum = csum << (8 - ((params->len_2 * params->log_w) % 8));\n\n  int len_2_bytes = ((params->len_2 * params->log_w) + 7) / 8;\n\n  unsigned char csum_bytes[len_2_bytes];\n  to_byte(csum_bytes, csum, len_2_bytes);\n\n  int csum_basew[params->len_2];\n  base_w(csum_basew, params->len_2, csum_bytes, params);\n\n  for (i = 0; i < params->len_2; i++) {\n    basew[params->len_1 + i] = csum_basew[i];\n  }\n  for (i=0; i < params->len; i++) {\n    setChainADRS(addr, i);\n    gen_chain(pk+i*params->n, sig+i*params->n, basew[i], params->w-1-basew[i], params, pub_seed, addr);\n  }\n  free(basew);\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setOTSADRS",
          "args": [
            "ots_addr",
            "idx_leaf"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "setOTSADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "39-41",
          "snippet": "void setOTSADRS(uint32_t adrs[8], uint32_t ots){\n  adrs[4] = ots;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setOTSADRS(uint32_t adrs[8], uint32_t ots){\n  adrs[4] = ots;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setType",
          "args": [
            "node_addr",
            "2"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "setType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "25-31",
          "snippet": "void setType(uint32_t adrs[8], uint32_t type){\n  adrs[3] = type;\n  int i;\n  for(i = 4; i < 8; i++){\n    adrs[i] = 0;\n  }\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setType(uint32_t adrs[8], uint32_t type){\n  adrs[3] = type;\n  int i;\n  for(i = 4; i < 8; i++){\n    adrs[i] = 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "node_addr",
            "ltree_addr",
            "12"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ltree_addr",
            "ots_addr",
            "12"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setTreeADRS",
          "args": [
            "ots_addr",
            "idx_tree"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "setTreeADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "20-23",
          "snippet": "void setTreeADRS(uint32_t adrs[8], uint64_t tree){\n  adrs[1] = (uint32_t) (tree >> 32);\n  adrs[2] = (uint32_t) tree;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setTreeADRS(uint32_t adrs[8], uint64_t tree){\n  adrs[1] = (uint32_t) (tree >> 32);\n  adrs[2] = (uint32_t) tree;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setLayerADRS",
          "args": [
            "ots_addr",
            "i"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "setLayerADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "16-18",
          "snippet": "void setLayerADRS(uint32_t adrs[8], uint32_t layer){\n  adrs[0] = layer;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setLayerADRS(uint32_t adrs[8], uint32_t layer){\n  adrs[0] = layer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "node_addr",
            "ltree_addr",
            "12"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ltree_addr",
            "ots_addr",
            "12"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h_msg",
          "args": [
            "msg_h",
            "sig_msg + tmp_sig_len",
            "m_len",
            "hash_key",
            "3*n",
            "n"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "h_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "82-89",
          "snippet": "int h_msg(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *key, const unsigned int keylen, const unsigned int n)\n{\n  if (keylen != 3*n){\n    // H_msg takes 3n-bit keys, but n does not match the keylength of keylen\n    return -1;\n  }  \n  return core_hash_SHA2(out, 2, key, keylen, in, inlen, n);\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint h_msg(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *key, const unsigned int keylen, const unsigned int n)\n{\n  if (keylen != 3*n){\n    // H_msg takes 3n-bit keys, but n does not match the keylength of keylen\n    return -1;\n  }  \n  return core_hash_SHA2(out, 2, key, keylen, in, inlen, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_byte",
          "args": [
            "hash_key+2*n",
            "idx",
            "n"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "to_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_commons.c",
          "lines": "19-26",
          "snippet": "void to_byte(unsigned char *out, unsigned long long in, uint32_t bytes)\n{\n  int32_t i;\n  for (i = bytes-1; i >= 0; i--) {\n    out[i] = in & 0xff;\n    in = in >> 8;\n  }\n}",
          "includes": [
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"xmss_commons.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"xmss_commons.h\"\n#include \"includes.h\"\n\nvoid to_byte(unsigned char *out, unsigned long long in, uint32_t bytes)\n{\n  int32_t i;\n  for (i = bytes-1; i >= 0; i--) {\n    out[i] = in & 0xff;\n    in = in >> 8;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hash_key+n",
            "pk",
            "n"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hash_key",
            "sig_msg",
            "n"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"verify:: idx = %llu\\n\"",
            "idx"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pub_seed",
            "pk+n",
            "n"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint xmssmt_sign_open(unsigned char *msg, unsigned long long *msglen, const unsigned char *sig_msg, unsigned long long sig_msg_len, const unsigned char *pk, const xmssmt_params *params)\n{\n  unsigned int n = params->n;\n\n  unsigned int tree_h = params->xmss_par.h;\n  unsigned int idx_len = params->index_len;\n  uint64_t idx_tree;\n  uint32_t idx_leaf;\n\n  unsigned long long i, m_len;\n  unsigned long long idx=0;\n  unsigned char wots_pk[params->xmss_par.wots_par.keysize];\n  unsigned char pkhash[n];\n  unsigned char root[n];\n  unsigned char msg_h[n];\n  unsigned char hash_key[3*n];\n\n  unsigned char pub_seed[n];\n  memcpy(pub_seed, pk+n, n);\n\n  // Init addresses\n  uint32_t ots_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t ltree_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t node_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n  // Extract index\n  for (i = 0; i < idx_len; i++) {\n    idx |= ((unsigned long long)sig_msg[i]) << (8*(idx_len - 1 - i));\n  }\n  printf(\"verify:: idx = %llu\\n\", idx);\n  sig_msg += idx_len;\n  sig_msg_len -= idx_len;\n  \n  // Generate hash key (R || root || idx)\n  memcpy(hash_key, sig_msg,n);\n  memcpy(hash_key+n, pk, n);\n  to_byte(hash_key+2*n, idx, n);\n\n  sig_msg += n;\n  sig_msg_len -= n;\n  \n\n  // hash message (recall, R is now on pole position at sig_msg\n  unsigned long long tmp_sig_len = (params->d * params->xmss_par.wots_par.keysize) + (params->h * n);\n  m_len = sig_msg_len - tmp_sig_len;\n  h_msg(msg_h, sig_msg + tmp_sig_len, m_len, hash_key, 3*n, n);\n\n  \n  //-----------------------\n  // Verify signature\n  //-----------------------\n\n  // Prepare Address\n  idx_tree = idx >> tree_h;\n  idx_leaf = (idx & ((1 << tree_h)-1));\n  setLayerADRS(ots_addr, 0);\n  setTreeADRS(ots_addr, idx_tree);\n  setType(ots_addr, 0);\n\n  memcpy(ltree_addr, ots_addr, 12);\n  setType(ltree_addr, 1);\n\n  memcpy(node_addr, ltree_addr, 12);\n  setType(node_addr, 2);\n  \n  setOTSADRS(ots_addr, idx_leaf);\n\n  // Check WOTS signature\n  wots_pkFromSig(wots_pk, sig_msg, msg_h, &(params->xmss_par.wots_par), pub_seed, ots_addr);\n\n  sig_msg += params->xmss_par.wots_par.keysize;\n  sig_msg_len -= params->xmss_par.wots_par.keysize;\n\n  // Compute Ltree\n  setLtreeADRS(ltree_addr, idx_leaf);\n  l_tree(pkhash, wots_pk, &(params->xmss_par), pub_seed, ltree_addr);\n\n  // Compute root\n  validate_authpath(root, pkhash, idx_leaf, sig_msg, &(params->xmss_par), pub_seed, node_addr);\n\n  sig_msg += tree_h*n;\n  sig_msg_len -= tree_h*n;\n\n  for (i = 1; i < params->d; i++) {\n    // Prepare Address\n    idx_leaf = (idx_tree & ((1 << tree_h)-1));\n    idx_tree = idx_tree >> tree_h;\n\n    setLayerADRS(ots_addr, i);\n    setTreeADRS(ots_addr, idx_tree);\n    setType(ots_addr, 0);\n\n    memcpy(ltree_addr, ots_addr, 12);\n    setType(ltree_addr, 1);\n\n    memcpy(node_addr, ltree_addr, 12);\n    setType(node_addr, 2);\n\n    setOTSADRS(ots_addr, idx_leaf);\n\n    // Check WOTS signature\n    wots_pkFromSig(wots_pk, sig_msg, root, &(params->xmss_par.wots_par), pub_seed, ots_addr);\n\n    sig_msg += params->xmss_par.wots_par.keysize;\n    sig_msg_len -= params->xmss_par.wots_par.keysize;\n\n    // Compute Ltree\n    setLtreeADRS(ltree_addr, idx_leaf);\n    l_tree(pkhash, wots_pk, &(params->xmss_par), pub_seed, ltree_addr);\n\n    // Compute root\n    validate_authpath(root, pkhash, idx_leaf, sig_msg, &(params->xmss_par), pub_seed, node_addr);\n\n    sig_msg += tree_h*n;\n    sig_msg_len -= tree_h*n;\n\n  }\n\n  for (i = 0; i < n; i++)\n    if (root[i] != pk[i])\n      goto fail;\n\n  *msglen = sig_msg_len;\n  for (i = 0; i < *msglen; i++)\n    msg[i] = sig_msg[i];\n\n  return 0;\n\n\nfail:\n  *msglen = sig_msg_len;\n  for (i = 0; i < *msglen; i++)\n    msg[i] = 0;\n  *msglen = -1;\n  return -1;\n}"
  },
  {
    "function_name": "xmssmt_sign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "787-965",
    "snippet": "int xmssmt_sign(unsigned char *sk, bds_state *states, unsigned char *wots_sigs, unsigned char *sig_msg, unsigned long long *sig_msg_len, const unsigned char *msg, unsigned long long msglen, const xmssmt_params *params)\n{\n  unsigned int n = params->n;\n  \n  unsigned int tree_h = params->xmss_par.h;\n  unsigned int h = params->h;\n  unsigned int k = params->xmss_par.k;\n  unsigned int idx_len = params->index_len;\n  uint64_t idx_tree;\n  uint32_t idx_leaf;\n  uint64_t i, j;\n  int needswap_upto = -1;\n  unsigned int updates;\n\n  unsigned char sk_seed[n];\n  unsigned char sk_prf[n];\n  unsigned char pub_seed[n];\n  // Init working params\n  unsigned char R[n];\n  unsigned char msg_h[n];\n  unsigned char hash_key[3*n];\n  unsigned char ots_seed[n];\n  uint32_t addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t ots_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  unsigned char idx_bytes_32[32];\n  bds_state tmp;\n\n  // Extract SK \n  unsigned long long idx = 0;\n  for (i = 0; i < idx_len; i++) {\n    idx |= ((unsigned long long)sk[i]) << 8*(idx_len - 1 - i);\n  }\n\n  memcpy(sk_seed, sk+idx_len, n);\n  memcpy(sk_prf, sk+idx_len+n, n);\n  memcpy(pub_seed, sk+idx_len+2*n, n);\n\n  // Update SK\n  for (i = 0; i < idx_len; i++) {\n    sk[i] = ((idx + 1) >> 8*(idx_len - 1 - i)) & 255;\n  }\n  // -- Secret key for this non-forward-secure version is now updated.\n  // -- A productive implementation should use a file handle instead and write the updated secret key at this point!\n\n\n  // ---------------------------------\n  // Message Hashing\n  // ---------------------------------\n\n  // Message Hash:\n  // First compute pseudorandom value\n  to_byte(idx_bytes_32, idx, 32);\n  prf(R, idx_bytes_32, sk_prf, n);\n  // Generate hash key (R || root || idx)\n  memcpy(hash_key, R, n);\n  memcpy(hash_key+n, sk+idx_len+3*n, n);\n  to_byte(hash_key+2*n, idx, n);\n  \n  // Then use it for message digest\n  h_msg(msg_h, msg, msglen, hash_key, 3*n, n);\n\n  // Start collecting signature\n  *sig_msg_len = 0;\n\n  // Copy index to signature\n  for (i = 0; i < idx_len; i++) {\n    sig_msg[i] = (idx >> 8*(idx_len - 1 - i)) & 255;\n  }\n\n  sig_msg += idx_len;\n  *sig_msg_len += idx_len;\n\n  // Copy R to signature\n  for (i = 0; i < n; i++)\n    sig_msg[i] = R[i];\n\n  sig_msg += n;\n  *sig_msg_len += n;\n\n  // ----------------------------------\n  // Now we start to \"really sign\"\n  // ----------------------------------\n\n  // Handle lowest layer separately as it is slightly different...\n\n  // Prepare Address\n  setType(ots_addr, 0);\n  idx_tree = idx >> tree_h;\n  idx_leaf = (idx & ((1 << tree_h)-1));\n  setLayerADRS(ots_addr, 0);\n  setTreeADRS(ots_addr, idx_tree);\n  setOTSADRS(ots_addr, idx_leaf);\n\n  // Compute seed for OTS key pair\n  get_seed(ots_seed, sk_seed, n, ots_addr);\n\n  // Compute WOTS signature\n  wots_sign(sig_msg, msg_h, ots_seed, &(params->xmss_par.wots_par), pub_seed, ots_addr);\n\n  sig_msg += params->xmss_par.wots_par.keysize;\n  *sig_msg_len += params->xmss_par.wots_par.keysize;\n\n  memcpy(sig_msg, states[0].auth, tree_h*n);\n  sig_msg += tree_h*n;\n  *sig_msg_len += tree_h*n;\n\n  // prepare signature of remaining layers\n  for (i = 1; i < params->d; i++) {\n    // put WOTS signature in place\n    memcpy(sig_msg, wots_sigs + (i-1)*params->xmss_par.wots_par.keysize, params->xmss_par.wots_par.keysize);\n\n    sig_msg += params->xmss_par.wots_par.keysize;\n    *sig_msg_len += params->xmss_par.wots_par.keysize;\n\n    // put AUTH nodes in place\n    memcpy(sig_msg, states[i].auth, tree_h*n);\n    sig_msg += tree_h*n;\n    *sig_msg_len += tree_h*n;\n  }\n\n  updates = (tree_h - k) >> 1;\n\n  setTreeADRS(addr, (idx_tree + 1));\n  // mandatory update for NEXT_0 (does not count towards h-k/2) if NEXT_0 exists\n  if ((1 + idx_tree) * (1 << tree_h) + idx_leaf < (1ULL << h)) {\n    bds_state_update(&states[params->d], sk_seed, &(params->xmss_par), pub_seed, addr);\n  }\n\n  for (i = 0; i < params->d; i++) {\n    // check if we're not at the end of a tree\n    if (! (((idx + 1) & ((1ULL << ((i+1)*tree_h)) - 1)) == 0)) {\n      idx_leaf = (idx >> (tree_h * i)) & ((1 << tree_h)-1);\n      idx_tree = (idx >> (tree_h * (i+1)));\n      setLayerADRS(addr, i);\n      setTreeADRS(addr, idx_tree);\n      if (i == (unsigned int) (needswap_upto + 1)) {\n        bds_round(&states[i], idx_leaf, sk_seed, &(params->xmss_par), pub_seed, addr);\n      }\n      updates = bds_treehash_update(&states[i], updates, sk_seed, &(params->xmss_par), pub_seed, addr);\n      setTreeADRS(addr, (idx_tree + 1));\n      // if a NEXT-tree exists for this level;\n      if ((1 + idx_tree) * (1 << tree_h) + idx_leaf < (1ULL << (h - tree_h * i))) {\n        if (i > 0 && updates > 0 && states[params->d + i].next_leaf < (1ULL << h)) {\n          bds_state_update(&states[params->d + i], sk_seed, &(params->xmss_par), pub_seed, addr);\n          updates--;\n        }\n      }\n    }\n    else if (idx < (1ULL << h) - 1) {\n      memcpy(&tmp, states+params->d + i, sizeof(bds_state));\n      memcpy(states+params->d + i, states + i, sizeof(bds_state));\n      memcpy(states + i, &tmp, sizeof(bds_state));\n\n      setLayerADRS(ots_addr, (i+1));\n      setTreeADRS(ots_addr, ((idx + 1) >> ((i+2) * tree_h)));\n      setOTSADRS(ots_addr, (((idx >> ((i+1) * tree_h)) + 1) & ((1 << tree_h)-1)));\n\n      get_seed(ots_seed, sk+params->index_len, n, ots_addr);\n      wots_sign(wots_sigs + i*params->xmss_par.wots_par.keysize, states[i].stack, ots_seed, &(params->xmss_par.wots_par), pub_seed, ots_addr);\n\n      states[params->d + i].stackoffset = 0;\n      states[params->d + i].next_leaf = 0;\n\n      updates--; // WOTS-signing counts as one update\n      needswap_upto = i;\n      for (j = 0; j < tree_h-k; j++) {\n        states[i].treehash[j].completed = 1;\n      }\n    }\n  }\n\n  //Whipe secret elements?\n  //zerobytes(tsk, CRYPTO_SECRETKEYBYTES);\n\n  memcpy(sig_msg, msg, msglen);\n  *sig_msg_len += msglen;\n\n  return 0;\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sig_msg",
            "msg",
            "msglen"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wots_sign",
          "args": [
            "wots_sigs + i*params->xmss_par.wots_par.keysize",
            "states[i].stack",
            "ots_seed",
            "&(params->xmss_par.wots_par)",
            "pub_seed",
            "ots_addr"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "wots_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_wots.c",
          "lines": "119-156",
          "snippet": "int wots_sign(unsigned char *sig, const unsigned char *msg, const unsigned char *sk, const wots_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  //int basew[params->len];\n  int csum = 0;\n  uint32_t i = 0;\n  int *basew = calloc(params->len, sizeof(int));\n  if (basew == NULL)\n    return -1;\n\n  base_w(basew, params->len_1, msg, params);\n\n  for (i=0; i < params->len_1; i++) {\n    csum += params->w - 1 - basew[i];\n  }\n\n  csum = csum << (8 - ((params->len_2 * params->log_w) % 8));\n\n  int len_2_bytes = ((params->len_2 * params->log_w) + 7) / 8;\n\n  unsigned char csum_bytes[len_2_bytes];\n  to_byte(csum_bytes, csum, len_2_bytes);\n\n  int csum_basew[params->len_2];\n  base_w(csum_basew, params->len_2, csum_bytes, params);\n\n  for (i = 0; i < params->len_2; i++) {\n    basew[params->len_1 + i] = csum_basew[i];\n  }\n\n  expand_seed(sig, sk, params);\n\n  for (i = 0; i < params->len; i++) {\n    setChainADRS(addr, i);\n    gen_chain(sig+i*params->n, sig+i*params->n, 0, basew[i], params, pub_seed, addr);\n  }\n  free(basew);\n  return 0;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include <limits.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\n#include \"xmss_wots.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint wots_sign(unsigned char *sig, const unsigned char *msg, const unsigned char *sk, const wots_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  //int basew[params->len];\n  int csum = 0;\n  uint32_t i = 0;\n  int *basew = calloc(params->len, sizeof(int));\n  if (basew == NULL)\n    return -1;\n\n  base_w(basew, params->len_1, msg, params);\n\n  for (i=0; i < params->len_1; i++) {\n    csum += params->w - 1 - basew[i];\n  }\n\n  csum = csum << (8 - ((params->len_2 * params->log_w) % 8));\n\n  int len_2_bytes = ((params->len_2 * params->log_w) + 7) / 8;\n\n  unsigned char csum_bytes[len_2_bytes];\n  to_byte(csum_bytes, csum, len_2_bytes);\n\n  int csum_basew[params->len_2];\n  base_w(csum_basew, params->len_2, csum_bytes, params);\n\n  for (i = 0; i < params->len_2; i++) {\n    basew[params->len_1 + i] = csum_basew[i];\n  }\n\n  expand_seed(sig, sk, params);\n\n  for (i = 0; i < params->len; i++) {\n    setChainADRS(addr, i);\n    gen_chain(sig+i*params->n, sig+i*params->n, 0, basew[i], params, pub_seed, addr);\n  }\n  free(basew);\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seed",
          "args": [
            "ots_seed",
            "sk+params->index_len",
            "n",
            "ots_addr"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "get_seed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "36-46",
          "snippet": "static void get_seed(unsigned char *seed, const unsigned char *sk_seed, int n, uint32_t addr[8])\n{\n  unsigned char bytes[32];\n  // Make sure that chain addr, hash addr, and key bit are 0!\n  setChainADRS(addr,0);\n  setHashADRS(addr,0);\n  setKeyAndMask(addr,0);\n  // Generate pseudorandom value\n  addr_to_byte(bytes, addr);\n  prf(seed, bytes, sk_seed, n);\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void get_seed(unsigned char *seed, const unsigned char *sk_seed, int n, uint32_t addr[8])\n{\n  unsigned char bytes[32];\n  // Make sure that chain addr, hash addr, and key bit are 0!\n  setChainADRS(addr,0);\n  setHashADRS(addr,0);\n  setKeyAndMask(addr,0);\n  // Generate pseudorandom value\n  addr_to_byte(bytes, addr);\n  prf(seed, bytes, sk_seed, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setOTSADRS",
          "args": [
            "ots_addr",
            "(((idx >> ((i+1) * tree_h)) + 1) & ((1 << tree_h)-1))"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "setOTSADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "39-41",
          "snippet": "void setOTSADRS(uint32_t adrs[8], uint32_t ots){\n  adrs[4] = ots;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setOTSADRS(uint32_t adrs[8], uint32_t ots){\n  adrs[4] = ots;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setTreeADRS",
          "args": [
            "ots_addr",
            "((idx + 1) >> ((i+2) * tree_h))"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "setTreeADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "20-23",
          "snippet": "void setTreeADRS(uint32_t adrs[8], uint64_t tree){\n  adrs[1] = (uint32_t) (tree >> 32);\n  adrs[2] = (uint32_t) tree;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setTreeADRS(uint32_t adrs[8], uint64_t tree){\n  adrs[1] = (uint32_t) (tree >> 32);\n  adrs[2] = (uint32_t) tree;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setLayerADRS",
          "args": [
            "ots_addr",
            "(i+1)"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "setLayerADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "16-18",
          "snippet": "void setLayerADRS(uint32_t adrs[8], uint32_t layer){\n  adrs[0] = layer;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setLayerADRS(uint32_t adrs[8], uint32_t layer){\n  adrs[0] = layer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "states + i",
            "&tmp",
            "sizeof(bds_state)"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "states+params->d + i",
            "states + i",
            "sizeof(bds_state)"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tmp",
            "states+params->d + i",
            "sizeof(bds_state)"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bds_state_update",
          "args": [
            "&states[params->d + i]",
            "sk_seed",
            "&(params->xmss_par)",
            "pub_seed",
            "addr"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "bds_state_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "383-439",
          "snippet": "static char bds_state_update(bds_state *state, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, const uint32_t addr[8]) {\n  uint32_t ltree_addr[8];\n  uint32_t node_addr[8];\n  uint32_t ots_addr[8];\n\n  int n = params->n;\n  int h = params->h;\n  int k = params->k;\n\n  int nodeh;\n  int idx = state->next_leaf;\n  if (idx == 1 << h) {\n    return 1;\n  }\n\n  // only copy layer and tree address parts\n  memcpy(ots_addr, addr, 12);\n  // type = ots\n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n  \n  setOTSADRS(ots_addr, idx);\n  setLtreeADRS(ltree_addr, idx);\n\n  gen_leaf_wots(state->stack+state->stackoffset*n, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n\n  state->stacklevels[state->stackoffset] = 0;\n  state->stackoffset++;\n  if (h - k > 0 && idx == 3) {\n    memcpy(state->treehash[0].node, state->stack+state->stackoffset*n, n);\n  }\n  while (state->stackoffset>1 && state->stacklevels[state->stackoffset-1] == state->stacklevels[state->stackoffset-2]) {\n    nodeh = state->stacklevels[state->stackoffset-1];\n    if (idx >> nodeh == 1) {\n      memcpy(state->auth + nodeh*n, state->stack+(state->stackoffset-1)*n, n);\n    }\n    else {\n      if (nodeh < h - k && idx >> nodeh == 3) {\n        memcpy(state->treehash[nodeh].node, state->stack+(state->stackoffset-1)*n, n);\n      }\n      else if (nodeh >= h - k) {\n        memcpy(state->retain + ((1 << (h - 1 - nodeh)) + nodeh - h + (((idx >> nodeh) - 3) >> 1)) * n, state->stack+(state->stackoffset-1)*n, n);\n      }\n    }\n    setTreeHeight(node_addr, state->stacklevels[state->stackoffset-1]);\n    setTreeIndex(node_addr, (idx >> (state->stacklevels[state->stackoffset-1]+1)));\n    hash_h(state->stack+(state->stackoffset-2)*n, state->stack+(state->stackoffset-2)*n, pub_seed, node_addr, n);\n\n    state->stacklevels[state->stackoffset-2]++;\n    state->stackoffset--;\n  }\n  state->next_leaf++;\n  return 0;\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic char bds_state_update(bds_state *state, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, const uint32_t addr[8]) {\n  uint32_t ltree_addr[8];\n  uint32_t node_addr[8];\n  uint32_t ots_addr[8];\n\n  int n = params->n;\n  int h = params->h;\n  int k = params->k;\n\n  int nodeh;\n  int idx = state->next_leaf;\n  if (idx == 1 << h) {\n    return 1;\n  }\n\n  // only copy layer and tree address parts\n  memcpy(ots_addr, addr, 12);\n  // type = ots\n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n  \n  setOTSADRS(ots_addr, idx);\n  setLtreeADRS(ltree_addr, idx);\n\n  gen_leaf_wots(state->stack+state->stackoffset*n, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n\n  state->stacklevels[state->stackoffset] = 0;\n  state->stackoffset++;\n  if (h - k > 0 && idx == 3) {\n    memcpy(state->treehash[0].node, state->stack+state->stackoffset*n, n);\n  }\n  while (state->stackoffset>1 && state->stacklevels[state->stackoffset-1] == state->stacklevels[state->stackoffset-2]) {\n    nodeh = state->stacklevels[state->stackoffset-1];\n    if (idx >> nodeh == 1) {\n      memcpy(state->auth + nodeh*n, state->stack+(state->stackoffset-1)*n, n);\n    }\n    else {\n      if (nodeh < h - k && idx >> nodeh == 3) {\n        memcpy(state->treehash[nodeh].node, state->stack+(state->stackoffset-1)*n, n);\n      }\n      else if (nodeh >= h - k) {\n        memcpy(state->retain + ((1 << (h - 1 - nodeh)) + nodeh - h + (((idx >> nodeh) - 3) >> 1)) * n, state->stack+(state->stackoffset-1)*n, n);\n      }\n    }\n    setTreeHeight(node_addr, state->stacklevels[state->stackoffset-1]);\n    setTreeIndex(node_addr, (idx >> (state->stacklevels[state->stackoffset-1]+1)));\n    hash_h(state->stack+(state->stackoffset-2)*n, state->stack+(state->stackoffset-2)*n, pub_seed, node_addr, n);\n\n    state->stacklevels[state->stackoffset-2]++;\n    state->stackoffset--;\n  }\n  state->next_leaf++;\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bds_treehash_update",
          "args": [
            "&states[i]",
            "updates",
            "sk_seed",
            "&(params->xmss_par)",
            "pub_seed",
            "addr"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "bds_treehash_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "345-377",
          "snippet": "static char bds_treehash_update(bds_state *state, unsigned int updates, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, const uint32_t addr[8]) {\n  uint32_t i, j;\n  unsigned int level, l_min, low;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n  unsigned int used = 0;\n\n  for (j = 0; j < updates; j++) {\n    l_min = h;\n    level = h - k;\n    for (i = 0; i < h - k; i++) {\n      if (state->treehash[i].completed) {\n        low = h;\n      }\n      else if (state->treehash[i].stackusage == 0) {\n        low = i;\n      }\n      else {\n        low = treehash_minheight_on_stack(state, params, &(state->treehash[i]));\n      }\n      if (low < l_min) {\n        level = i;\n        l_min = low;\n      }\n    }\n    if (level == h - k) {\n      break;\n    }\n    treehash_update(&(state->treehash[level]), state, sk_seed, params, pub_seed, addr);\n    used++;\n  }\n  return updates - used;\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic char bds_treehash_update(bds_state *state, unsigned int updates, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, const uint32_t addr[8]) {\n  uint32_t i, j;\n  unsigned int level, l_min, low;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n  unsigned int used = 0;\n\n  for (j = 0; j < updates; j++) {\n    l_min = h;\n    level = h - k;\n    for (i = 0; i < h - k; i++) {\n      if (state->treehash[i].completed) {\n        low = h;\n      }\n      else if (state->treehash[i].stackusage == 0) {\n        low = i;\n      }\n      else {\n        low = treehash_minheight_on_stack(state, params, &(state->treehash[i]));\n      }\n      if (low < l_min) {\n        level = i;\n        l_min = low;\n      }\n    }\n    if (level == h - k) {\n      break;\n    }\n    treehash_update(&(state->treehash[level]), state, sk_seed, params, pub_seed, addr);\n    used++;\n  }\n  return updates - used;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bds_round",
          "args": [
            "&states[i]",
            "idx_leaf",
            "sk_seed",
            "&(params->xmss_par)",
            "pub_seed",
            "addr"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "bds_round",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "446-515",
          "snippet": "static void bds_round(bds_state *state, const unsigned long leaf_idx, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int i;\n  unsigned int n = params->n;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n\n  unsigned int tau = h;\n  unsigned int startidx;\n  unsigned int offset, rowidx;\n  unsigned char buf[2 * n];\n\n  uint32_t ots_addr[8];\n  uint32_t ltree_addr[8];\n  uint32_t  node_addr[8];\n  // only copy layer and tree address parts\n  memcpy(ots_addr, addr, 12);\n  // type = ots\n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n\n  for (i = 0; i < h; i++) {\n    if (! ((leaf_idx >> i) & 1)) {\n      tau = i;\n      break;\n    }\n  }\n\n  if (tau > 0) {\n    memcpy(buf,     state->auth + (tau-1) * n, n);\n    // we need to do this before refreshing state->keep to prevent overwriting\n    memcpy(buf + n, state->keep + ((tau-1) >> 1) * n, n);\n  }\n  if (!((leaf_idx >> (tau + 1)) & 1) && (tau < h - 1)) {\n    memcpy(state->keep + (tau >> 1)*n, state->auth + tau*n, n);\n  }\n  if (tau == 0) {\n    setLtreeADRS(ltree_addr, leaf_idx);\n    setOTSADRS(ots_addr, leaf_idx);\n    gen_leaf_wots(state->auth, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n  }\n  else {\n    setTreeHeight(node_addr, (tau-1));\n    setTreeIndex(node_addr, leaf_idx >> tau);\n    hash_h(state->auth + tau * n, buf, pub_seed, node_addr, n);\n    for (i = 0; i < tau; i++) {\n      if (i < h - k) {\n        memcpy(state->auth + i * n, state->treehash[i].node, n);\n      }\n      else {\n        offset = (1 << (h - 1 - i)) + i - h;\n        rowidx = ((leaf_idx >> i) - 1) >> 1;\n        memcpy(state->auth + i * n, state->retain + (offset + rowidx) * n, n);\n      }\n    }\n\n    for (i = 0; i < ((tau < h - k) ? tau : (h - k)); i++) {\n      startidx = leaf_idx + 1 + 3 * (1 << i);\n      if (startidx < 1U << h) {\n        state->treehash[i].h = i;\n        state->treehash[i].next_idx = startidx;\n        state->treehash[i].completed = 0;\n        state->treehash[i].stackusage = 0;\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void bds_round(bds_state *state, const unsigned long leaf_idx, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int i;\n  unsigned int n = params->n;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n\n  unsigned int tau = h;\n  unsigned int startidx;\n  unsigned int offset, rowidx;\n  unsigned char buf[2 * n];\n\n  uint32_t ots_addr[8];\n  uint32_t ltree_addr[8];\n  uint32_t  node_addr[8];\n  // only copy layer and tree address parts\n  memcpy(ots_addr, addr, 12);\n  // type = ots\n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n\n  for (i = 0; i < h; i++) {\n    if (! ((leaf_idx >> i) & 1)) {\n      tau = i;\n      break;\n    }\n  }\n\n  if (tau > 0) {\n    memcpy(buf,     state->auth + (tau-1) * n, n);\n    // we need to do this before refreshing state->keep to prevent overwriting\n    memcpy(buf + n, state->keep + ((tau-1) >> 1) * n, n);\n  }\n  if (!((leaf_idx >> (tau + 1)) & 1) && (tau < h - 1)) {\n    memcpy(state->keep + (tau >> 1)*n, state->auth + tau*n, n);\n  }\n  if (tau == 0) {\n    setLtreeADRS(ltree_addr, leaf_idx);\n    setOTSADRS(ots_addr, leaf_idx);\n    gen_leaf_wots(state->auth, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n  }\n  else {\n    setTreeHeight(node_addr, (tau-1));\n    setTreeIndex(node_addr, leaf_idx >> tau);\n    hash_h(state->auth + tau * n, buf, pub_seed, node_addr, n);\n    for (i = 0; i < tau; i++) {\n      if (i < h - k) {\n        memcpy(state->auth + i * n, state->treehash[i].node, n);\n      }\n      else {\n        offset = (1 << (h - 1 - i)) + i - h;\n        rowidx = ((leaf_idx >> i) - 1) >> 1;\n        memcpy(state->auth + i * n, state->retain + (offset + rowidx) * n, n);\n      }\n    }\n\n    for (i = 0; i < ((tau < h - k) ? tau : (h - k)); i++) {\n      startidx = leaf_idx + 1 + 3 * (1 << i);\n      if (startidx < 1U << h) {\n        state->treehash[i].h = i;\n        state->treehash[i].next_idx = startidx;\n        state->treehash[i].completed = 0;\n        state->treehash[i].stackusage = 0;\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sig_msg",
            "states[i].auth",
            "tree_h*n"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sig_msg",
            "wots_sigs + (i-1)*params->xmss_par.wots_par.keysize",
            "params->xmss_par.wots_par.keysize"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sig_msg",
            "states[0].auth",
            "tree_h*n"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setType",
          "args": [
            "ots_addr",
            "0"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "setType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "25-31",
          "snippet": "void setType(uint32_t adrs[8], uint32_t type){\n  adrs[3] = type;\n  int i;\n  for(i = 4; i < 8; i++){\n    adrs[i] = 0;\n  }\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setType(uint32_t adrs[8], uint32_t type){\n  adrs[3] = type;\n  int i;\n  for(i = 4; i < 8; i++){\n    adrs[i] = 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "h_msg",
          "args": [
            "msg_h",
            "msg",
            "msglen",
            "hash_key",
            "3*n",
            "n"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "h_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "82-89",
          "snippet": "int h_msg(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *key, const unsigned int keylen, const unsigned int n)\n{\n  if (keylen != 3*n){\n    // H_msg takes 3n-bit keys, but n does not match the keylength of keylen\n    return -1;\n  }  \n  return core_hash_SHA2(out, 2, key, keylen, in, inlen, n);\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint h_msg(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *key, const unsigned int keylen, const unsigned int n)\n{\n  if (keylen != 3*n){\n    // H_msg takes 3n-bit keys, but n does not match the keylength of keylen\n    return -1;\n  }  \n  return core_hash_SHA2(out, 2, key, keylen, in, inlen, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_byte",
          "args": [
            "hash_key+2*n",
            "idx",
            "n"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "to_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_commons.c",
          "lines": "19-26",
          "snippet": "void to_byte(unsigned char *out, unsigned long long in, uint32_t bytes)\n{\n  int32_t i;\n  for (i = bytes-1; i >= 0; i--) {\n    out[i] = in & 0xff;\n    in = in >> 8;\n  }\n}",
          "includes": [
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"xmss_commons.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"xmss_commons.h\"\n#include \"includes.h\"\n\nvoid to_byte(unsigned char *out, unsigned long long in, uint32_t bytes)\n{\n  int32_t i;\n  for (i = bytes-1; i >= 0; i--) {\n    out[i] = in & 0xff;\n    in = in >> 8;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hash_key+n",
            "sk+idx_len+3*n",
            "n"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hash_key",
            "R",
            "n"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prf",
          "args": [
            "R",
            "idx_bytes_32",
            "sk_prf",
            "n"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "prf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "74-77",
          "snippet": "int prf(unsigned char *out, const unsigned char *in, const unsigned char *key, unsigned int keylen)\n{ \n  return core_hash_SHA2(out, 3, key, keylen, in, 32, keylen);\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint prf(unsigned char *out, const unsigned char *in, const unsigned char *key, unsigned int keylen)\n{ \n  return core_hash_SHA2(out, 3, key, keylen, in, 32, keylen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pub_seed",
            "sk+idx_len+2*n",
            "n"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sk_prf",
            "sk+idx_len+n",
            "n"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sk_seed",
            "sk+idx_len",
            "n"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint xmssmt_sign(unsigned char *sk, bds_state *states, unsigned char *wots_sigs, unsigned char *sig_msg, unsigned long long *sig_msg_len, const unsigned char *msg, unsigned long long msglen, const xmssmt_params *params)\n{\n  unsigned int n = params->n;\n  \n  unsigned int tree_h = params->xmss_par.h;\n  unsigned int h = params->h;\n  unsigned int k = params->xmss_par.k;\n  unsigned int idx_len = params->index_len;\n  uint64_t idx_tree;\n  uint32_t idx_leaf;\n  uint64_t i, j;\n  int needswap_upto = -1;\n  unsigned int updates;\n\n  unsigned char sk_seed[n];\n  unsigned char sk_prf[n];\n  unsigned char pub_seed[n];\n  // Init working params\n  unsigned char R[n];\n  unsigned char msg_h[n];\n  unsigned char hash_key[3*n];\n  unsigned char ots_seed[n];\n  uint32_t addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t ots_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  unsigned char idx_bytes_32[32];\n  bds_state tmp;\n\n  // Extract SK \n  unsigned long long idx = 0;\n  for (i = 0; i < idx_len; i++) {\n    idx |= ((unsigned long long)sk[i]) << 8*(idx_len - 1 - i);\n  }\n\n  memcpy(sk_seed, sk+idx_len, n);\n  memcpy(sk_prf, sk+idx_len+n, n);\n  memcpy(pub_seed, sk+idx_len+2*n, n);\n\n  // Update SK\n  for (i = 0; i < idx_len; i++) {\n    sk[i] = ((idx + 1) >> 8*(idx_len - 1 - i)) & 255;\n  }\n  // -- Secret key for this non-forward-secure version is now updated.\n  // -- A productive implementation should use a file handle instead and write the updated secret key at this point!\n\n\n  // ---------------------------------\n  // Message Hashing\n  // ---------------------------------\n\n  // Message Hash:\n  // First compute pseudorandom value\n  to_byte(idx_bytes_32, idx, 32);\n  prf(R, idx_bytes_32, sk_prf, n);\n  // Generate hash key (R || root || idx)\n  memcpy(hash_key, R, n);\n  memcpy(hash_key+n, sk+idx_len+3*n, n);\n  to_byte(hash_key+2*n, idx, n);\n  \n  // Then use it for message digest\n  h_msg(msg_h, msg, msglen, hash_key, 3*n, n);\n\n  // Start collecting signature\n  *sig_msg_len = 0;\n\n  // Copy index to signature\n  for (i = 0; i < idx_len; i++) {\n    sig_msg[i] = (idx >> 8*(idx_len - 1 - i)) & 255;\n  }\n\n  sig_msg += idx_len;\n  *sig_msg_len += idx_len;\n\n  // Copy R to signature\n  for (i = 0; i < n; i++)\n    sig_msg[i] = R[i];\n\n  sig_msg += n;\n  *sig_msg_len += n;\n\n  // ----------------------------------\n  // Now we start to \"really sign\"\n  // ----------------------------------\n\n  // Handle lowest layer separately as it is slightly different...\n\n  // Prepare Address\n  setType(ots_addr, 0);\n  idx_tree = idx >> tree_h;\n  idx_leaf = (idx & ((1 << tree_h)-1));\n  setLayerADRS(ots_addr, 0);\n  setTreeADRS(ots_addr, idx_tree);\n  setOTSADRS(ots_addr, idx_leaf);\n\n  // Compute seed for OTS key pair\n  get_seed(ots_seed, sk_seed, n, ots_addr);\n\n  // Compute WOTS signature\n  wots_sign(sig_msg, msg_h, ots_seed, &(params->xmss_par.wots_par), pub_seed, ots_addr);\n\n  sig_msg += params->xmss_par.wots_par.keysize;\n  *sig_msg_len += params->xmss_par.wots_par.keysize;\n\n  memcpy(sig_msg, states[0].auth, tree_h*n);\n  sig_msg += tree_h*n;\n  *sig_msg_len += tree_h*n;\n\n  // prepare signature of remaining layers\n  for (i = 1; i < params->d; i++) {\n    // put WOTS signature in place\n    memcpy(sig_msg, wots_sigs + (i-1)*params->xmss_par.wots_par.keysize, params->xmss_par.wots_par.keysize);\n\n    sig_msg += params->xmss_par.wots_par.keysize;\n    *sig_msg_len += params->xmss_par.wots_par.keysize;\n\n    // put AUTH nodes in place\n    memcpy(sig_msg, states[i].auth, tree_h*n);\n    sig_msg += tree_h*n;\n    *sig_msg_len += tree_h*n;\n  }\n\n  updates = (tree_h - k) >> 1;\n\n  setTreeADRS(addr, (idx_tree + 1));\n  // mandatory update for NEXT_0 (does not count towards h-k/2) if NEXT_0 exists\n  if ((1 + idx_tree) * (1 << tree_h) + idx_leaf < (1ULL << h)) {\n    bds_state_update(&states[params->d], sk_seed, &(params->xmss_par), pub_seed, addr);\n  }\n\n  for (i = 0; i < params->d; i++) {\n    // check if we're not at the end of a tree\n    if (! (((idx + 1) & ((1ULL << ((i+1)*tree_h)) - 1)) == 0)) {\n      idx_leaf = (idx >> (tree_h * i)) & ((1 << tree_h)-1);\n      idx_tree = (idx >> (tree_h * (i+1)));\n      setLayerADRS(addr, i);\n      setTreeADRS(addr, idx_tree);\n      if (i == (unsigned int) (needswap_upto + 1)) {\n        bds_round(&states[i], idx_leaf, sk_seed, &(params->xmss_par), pub_seed, addr);\n      }\n      updates = bds_treehash_update(&states[i], updates, sk_seed, &(params->xmss_par), pub_seed, addr);\n      setTreeADRS(addr, (idx_tree + 1));\n      // if a NEXT-tree exists for this level;\n      if ((1 + idx_tree) * (1 << tree_h) + idx_leaf < (1ULL << (h - tree_h * i))) {\n        if (i > 0 && updates > 0 && states[params->d + i].next_leaf < (1ULL << h)) {\n          bds_state_update(&states[params->d + i], sk_seed, &(params->xmss_par), pub_seed, addr);\n          updates--;\n        }\n      }\n    }\n    else if (idx < (1ULL << h) - 1) {\n      memcpy(&tmp, states+params->d + i, sizeof(bds_state));\n      memcpy(states+params->d + i, states + i, sizeof(bds_state));\n      memcpy(states + i, &tmp, sizeof(bds_state));\n\n      setLayerADRS(ots_addr, (i+1));\n      setTreeADRS(ots_addr, ((idx + 1) >> ((i+2) * tree_h)));\n      setOTSADRS(ots_addr, (((idx >> ((i+1) * tree_h)) + 1) & ((1 << tree_h)-1)));\n\n      get_seed(ots_seed, sk+params->index_len, n, ots_addr);\n      wots_sign(wots_sigs + i*params->xmss_par.wots_par.keysize, states[i].stack, ots_seed, &(params->xmss_par.wots_par), pub_seed, ots_addr);\n\n      states[params->d + i].stackoffset = 0;\n      states[params->d + i].next_leaf = 0;\n\n      updates--; // WOTS-signing counts as one update\n      needswap_upto = i;\n      for (j = 0; j < tree_h-k; j++) {\n        states[i].treehash[j].completed = 1;\n      }\n    }\n  }\n\n  //Whipe secret elements?\n  //zerobytes(tsk, CRYPTO_SECRETKEYBYTES);\n\n  memcpy(sig_msg, msg, msglen);\n  *sig_msg_len += msglen;\n\n  return 0;\n}"
  },
  {
    "function_name": "xmssmt_keypair",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "750-778",
    "snippet": "int xmssmt_keypair(unsigned char *pk, unsigned char *sk, bds_state *states, unsigned char *wots_sigs, xmssmt_params *params)\n{\n  unsigned int n = params->n;\n  unsigned int i;\n  unsigned char ots_seed[params->n];\n  // Set idx = 0\n  for (i = 0; i < params->index_len; i++) {\n    sk[i] = 0;\n  }\n  // Init SK_SEED (n byte), SK_PRF (n byte), and PUB_SEED (n byte)\n  randombytes(sk+params->index_len, 3*n);\n  // Copy PUB_SEED to public key\n  memcpy(pk+n, sk+params->index_len+2*n, n);\n\n  // Set address to point on the single tree on layer d-1\n  uint32_t addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  setLayerADRS(addr, (params->d-1));\n  // Set up state and compute wots signatures for all but topmost tree root\n  for (i = 0; i < params->d - 1; i++) {\n    // Compute seed for OTS key pair\n    treehash_setup(pk, params->xmss_par.h, 0, states + i, sk+params->index_len, &(params->xmss_par), pk+n, addr);\n    setLayerADRS(addr, (i+1));\n    get_seed(ots_seed, sk+params->index_len, n, addr);\n    wots_sign(wots_sigs + i*params->xmss_par.wots_par.keysize, pk, ots_seed, &(params->xmss_par.wots_par), pk+n, addr);\n  }\n  treehash_setup(pk, params->xmss_par.h, 0, states + i, sk+params->index_len, &(params->xmss_par), pk+n, addr);\n  memcpy(sk+params->index_len+3*n, pk, n);\n  return 0;\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sk+params->index_len+3*n",
            "pk",
            "n"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "treehash_setup",
          "args": [
            "pk",
            "params->xmss_par.h",
            "0",
            "states + i",
            "sk+params->index_len",
            "&(params->xmss_par)",
            "pk+n",
            "addr"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "treehash_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "178-247",
          "snippet": "static void treehash_setup(unsigned char *node, int height, int index, bds_state *state, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, const uint32_t addr[8])\n{\n  unsigned int idx = index;\n  unsigned int n = params->n;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n  // use three different addresses because at this point we use all three formats in parallel\n  uint32_t ots_addr[8];\n  uint32_t ltree_addr[8];\n  uint32_t  node_addr[8];\n  // only copy layer and tree address parts\n  memcpy(ots_addr, addr, 12);\n  // type = ots\n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n\n  uint32_t lastnode, i;\n  unsigned char stack[(height+1)*n];\n  unsigned int stacklevels[height+1];\n  unsigned int stackoffset=0;\n  unsigned int nodeh;\n\n  lastnode = idx+(1<<height);\n\n  for (i = 0; i < h-k; i++) {\n    state->treehash[i].h = i;\n    state->treehash[i].completed = 1;\n    state->treehash[i].stackusage = 0;\n  }\n\n  i = 0;\n  for (; idx < lastnode; idx++) {\n    setLtreeADRS(ltree_addr, idx);\n    setOTSADRS(ots_addr, idx);\n    gen_leaf_wots(stack+stackoffset*n, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n    stacklevels[stackoffset] = 0;\n    stackoffset++;\n    if (h - k > 0 && i == 3) {\n      memcpy(state->treehash[0].node, stack+stackoffset*n, n);\n    }\n    while (stackoffset>1 && stacklevels[stackoffset-1] == stacklevels[stackoffset-2])\n    {\n      nodeh = stacklevels[stackoffset-1];\n      if (i >> nodeh == 1) {\n        memcpy(state->auth + nodeh*n, stack+(stackoffset-1)*n, n);\n      }\n      else {\n        if (nodeh < h - k && i >> nodeh == 3) {\n          memcpy(state->treehash[nodeh].node, stack+(stackoffset-1)*n, n);\n        }\n        else if (nodeh >= h - k) {\n          memcpy(state->retain + ((1 << (h - 1 - nodeh)) + nodeh - h + (((i >> nodeh) - 3) >> 1)) * n, stack+(stackoffset-1)*n, n);\n        }\n      }\n      setTreeHeight(node_addr, stacklevels[stackoffset-1]);\n      setTreeIndex(node_addr, (idx >> (stacklevels[stackoffset-1]+1)));\n      hash_h(stack+(stackoffset-2)*n, stack+(stackoffset-2)*n, pub_seed,\n          node_addr, n);\n      stacklevels[stackoffset-2]++;\n      stackoffset--;\n    }\n    i++;\n  }\n\n  for (i = 0; i < n; i++)\n    node[i] = stack[i];\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void treehash_setup(unsigned char *node, int height, int index, bds_state *state, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, const uint32_t addr[8])\n{\n  unsigned int idx = index;\n  unsigned int n = params->n;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n  // use three different addresses because at this point we use all three formats in parallel\n  uint32_t ots_addr[8];\n  uint32_t ltree_addr[8];\n  uint32_t  node_addr[8];\n  // only copy layer and tree address parts\n  memcpy(ots_addr, addr, 12);\n  // type = ots\n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n\n  uint32_t lastnode, i;\n  unsigned char stack[(height+1)*n];\n  unsigned int stacklevels[height+1];\n  unsigned int stackoffset=0;\n  unsigned int nodeh;\n\n  lastnode = idx+(1<<height);\n\n  for (i = 0; i < h-k; i++) {\n    state->treehash[i].h = i;\n    state->treehash[i].completed = 1;\n    state->treehash[i].stackusage = 0;\n  }\n\n  i = 0;\n  for (; idx < lastnode; idx++) {\n    setLtreeADRS(ltree_addr, idx);\n    setOTSADRS(ots_addr, idx);\n    gen_leaf_wots(stack+stackoffset*n, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n    stacklevels[stackoffset] = 0;\n    stackoffset++;\n    if (h - k > 0 && i == 3) {\n      memcpy(state->treehash[0].node, stack+stackoffset*n, n);\n    }\n    while (stackoffset>1 && stacklevels[stackoffset-1] == stacklevels[stackoffset-2])\n    {\n      nodeh = stacklevels[stackoffset-1];\n      if (i >> nodeh == 1) {\n        memcpy(state->auth + nodeh*n, stack+(stackoffset-1)*n, n);\n      }\n      else {\n        if (nodeh < h - k && i >> nodeh == 3) {\n          memcpy(state->treehash[nodeh].node, stack+(stackoffset-1)*n, n);\n        }\n        else if (nodeh >= h - k) {\n          memcpy(state->retain + ((1 << (h - 1 - nodeh)) + nodeh - h + (((i >> nodeh) - 3) >> 1)) * n, stack+(stackoffset-1)*n, n);\n        }\n      }\n      setTreeHeight(node_addr, stacklevels[stackoffset-1]);\n      setTreeIndex(node_addr, (idx >> (stacklevels[stackoffset-1]+1)));\n      hash_h(stack+(stackoffset-2)*n, stack+(stackoffset-2)*n, pub_seed,\n          node_addr, n);\n      stacklevels[stackoffset-2]++;\n      stackoffset--;\n    }\n    i++;\n  }\n\n  for (i = 0; i < n; i++)\n    node[i] = stack[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "wots_sign",
          "args": [
            "wots_sigs + i*params->xmss_par.wots_par.keysize",
            "pk",
            "ots_seed",
            "&(params->xmss_par.wots_par)",
            "pk+n",
            "addr"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "wots_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_wots.c",
          "lines": "119-156",
          "snippet": "int wots_sign(unsigned char *sig, const unsigned char *msg, const unsigned char *sk, const wots_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  //int basew[params->len];\n  int csum = 0;\n  uint32_t i = 0;\n  int *basew = calloc(params->len, sizeof(int));\n  if (basew == NULL)\n    return -1;\n\n  base_w(basew, params->len_1, msg, params);\n\n  for (i=0; i < params->len_1; i++) {\n    csum += params->w - 1 - basew[i];\n  }\n\n  csum = csum << (8 - ((params->len_2 * params->log_w) % 8));\n\n  int len_2_bytes = ((params->len_2 * params->log_w) + 7) / 8;\n\n  unsigned char csum_bytes[len_2_bytes];\n  to_byte(csum_bytes, csum, len_2_bytes);\n\n  int csum_basew[params->len_2];\n  base_w(csum_basew, params->len_2, csum_bytes, params);\n\n  for (i = 0; i < params->len_2; i++) {\n    basew[params->len_1 + i] = csum_basew[i];\n  }\n\n  expand_seed(sig, sk, params);\n\n  for (i = 0; i < params->len; i++) {\n    setChainADRS(addr, i);\n    gen_chain(sig+i*params->n, sig+i*params->n, 0, basew[i], params, pub_seed, addr);\n  }\n  free(basew);\n  return 0;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include <limits.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\n#include \"xmss_wots.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint wots_sign(unsigned char *sig, const unsigned char *msg, const unsigned char *sk, const wots_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  //int basew[params->len];\n  int csum = 0;\n  uint32_t i = 0;\n  int *basew = calloc(params->len, sizeof(int));\n  if (basew == NULL)\n    return -1;\n\n  base_w(basew, params->len_1, msg, params);\n\n  for (i=0; i < params->len_1; i++) {\n    csum += params->w - 1 - basew[i];\n  }\n\n  csum = csum << (8 - ((params->len_2 * params->log_w) % 8));\n\n  int len_2_bytes = ((params->len_2 * params->log_w) + 7) / 8;\n\n  unsigned char csum_bytes[len_2_bytes];\n  to_byte(csum_bytes, csum, len_2_bytes);\n\n  int csum_basew[params->len_2];\n  base_w(csum_basew, params->len_2, csum_bytes, params);\n\n  for (i = 0; i < params->len_2; i++) {\n    basew[params->len_1 + i] = csum_basew[i];\n  }\n\n  expand_seed(sig, sk, params);\n\n  for (i = 0; i < params->len; i++) {\n    setChainADRS(addr, i);\n    gen_chain(sig+i*params->n, sig+i*params->n, 0, basew[i], params, pub_seed, addr);\n  }\n  free(basew);\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seed",
          "args": [
            "ots_seed",
            "sk+params->index_len",
            "n",
            "addr"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "get_seed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "36-46",
          "snippet": "static void get_seed(unsigned char *seed, const unsigned char *sk_seed, int n, uint32_t addr[8])\n{\n  unsigned char bytes[32];\n  // Make sure that chain addr, hash addr, and key bit are 0!\n  setChainADRS(addr,0);\n  setHashADRS(addr,0);\n  setKeyAndMask(addr,0);\n  // Generate pseudorandom value\n  addr_to_byte(bytes, addr);\n  prf(seed, bytes, sk_seed, n);\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void get_seed(unsigned char *seed, const unsigned char *sk_seed, int n, uint32_t addr[8])\n{\n  unsigned char bytes[32];\n  // Make sure that chain addr, hash addr, and key bit are 0!\n  setChainADRS(addr,0);\n  setHashADRS(addr,0);\n  setKeyAndMask(addr,0);\n  // Generate pseudorandom value\n  addr_to_byte(bytes, addr);\n  prf(seed, bytes, sk_seed, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setLayerADRS",
          "args": [
            "addr",
            "(i+1)"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "setLayerADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "16-18",
          "snippet": "void setLayerADRS(uint32_t adrs[8], uint32_t layer){\n  adrs[0] = layer;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setLayerADRS(uint32_t adrs[8], uint32_t layer){\n  adrs[0] = layer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pk+n",
            "sk+params->index_len+2*n",
            "n"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "randombytes",
          "args": [
            "sk+params->index_len",
            "3*n"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint xmssmt_keypair(unsigned char *pk, unsigned char *sk, bds_state *states, unsigned char *wots_sigs, xmssmt_params *params)\n{\n  unsigned int n = params->n;\n  unsigned int i;\n  unsigned char ots_seed[params->n];\n  // Set idx = 0\n  for (i = 0; i < params->index_len; i++) {\n    sk[i] = 0;\n  }\n  // Init SK_SEED (n byte), SK_PRF (n byte), and PUB_SEED (n byte)\n  randombytes(sk+params->index_len, 3*n);\n  // Copy PUB_SEED to public key\n  memcpy(pk+n, sk+params->index_len+2*n, n);\n\n  // Set address to point on the single tree on layer d-1\n  uint32_t addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  setLayerADRS(addr, (params->d-1));\n  // Set up state and compute wots signatures for all but topmost tree root\n  for (i = 0; i < params->d - 1; i++) {\n    // Compute seed for OTS key pair\n    treehash_setup(pk, params->xmss_par.h, 0, states + i, sk+params->index_len, &(params->xmss_par), pk+n, addr);\n    setLayerADRS(addr, (i+1));\n    get_seed(ots_seed, sk+params->index_len, n, addr);\n    wots_sign(wots_sigs + i*params->xmss_par.wots_par.keysize, pk, ots_seed, &(params->xmss_par.wots_par), pk+n, addr);\n  }\n  treehash_setup(pk, params->xmss_par.h, 0, states + i, sk+params->index_len, &(params->xmss_par), pk+n, addr);\n  memcpy(sk+params->index_len+3*n, pk, n);\n  return 0;\n}"
  },
  {
    "function_name": "xmss_sign_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "663-743",
    "snippet": "int xmss_sign_open(unsigned char *msg, unsigned long long *msglen, const unsigned char *sig_msg, unsigned long long sig_msg_len, const unsigned char *pk, const xmss_params *params)\n{\n  unsigned int n = params->n;\n\n  unsigned long long i, m_len;\n  unsigned long idx=0;\n  unsigned char wots_pk[params->wots_par.keysize];\n  unsigned char pkhash[n];\n  unsigned char root[n];\n  unsigned char msg_h[n];\n  unsigned char hash_key[3*n];\n\n  unsigned char pub_seed[n];\n  memcpy(pub_seed, pk+n, n);\n\n  // Init addresses\n  uint32_t ots_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t ltree_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t node_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n  setType(ots_addr, 0);\n  setType(ltree_addr, 1);\n  setType(node_addr, 2);\n\n  // Extract index\n  idx = ((unsigned long)sig_msg[0] << 24) | ((unsigned long)sig_msg[1] << 16) | ((unsigned long)sig_msg[2] << 8) | sig_msg[3];\n  printf(\"verify:: idx = %lu\\n\", idx);\n  \n  // Generate hash key (R || root || idx)\n  memcpy(hash_key, sig_msg+4,n);\n  memcpy(hash_key+n, pk, n);\n  to_byte(hash_key+2*n, idx, n);\n  \n  sig_msg += (n+4);\n  sig_msg_len -= (n+4);\n\n  // hash message \n  unsigned long long tmp_sig_len = params->wots_par.keysize+params->h*n;\n  m_len = sig_msg_len - tmp_sig_len;\n  h_msg(msg_h, sig_msg + tmp_sig_len, m_len, hash_key, 3*n, n);\n\n  //-----------------------\n  // Verify signature\n  //-----------------------\n\n  // Prepare Address\n  setOTSADRS(ots_addr, idx);\n  // Check WOTS signature\n  wots_pkFromSig(wots_pk, sig_msg, msg_h, &(params->wots_par), pub_seed, ots_addr);\n\n  sig_msg += params->wots_par.keysize;\n  sig_msg_len -= params->wots_par.keysize;\n\n  // Compute Ltree\n  setLtreeADRS(ltree_addr, idx);\n  l_tree(pkhash, wots_pk, params, pub_seed, ltree_addr);\n\n  // Compute root\n  validate_authpath(root, pkhash, idx, sig_msg, params, pub_seed, node_addr);\n\n  sig_msg += params->h*n;\n  sig_msg_len -= params->h*n;\n\n  for (i = 0; i < n; i++)\n    if (root[i] != pk[i])\n      goto fail;\n\n  *msglen = sig_msg_len;\n  for (i = 0; i < *msglen; i++)\n    msg[i] = sig_msg[i];\n\n  return 0;\n\n\nfail:\n  *msglen = sig_msg_len;\n  for (i = 0; i < *msglen; i++)\n    msg[i] = 0;\n  *msglen = -1;\n  return -1;\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "validate_authpath",
          "args": [
            "root",
            "pkhash",
            "idx",
            "sig_msg",
            "params",
            "pub_seed",
            "node_addr"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "validate_authpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "296-339",
          "snippet": "static void validate_authpath(unsigned char *root, const unsigned char *leaf, unsigned long leafidx, const unsigned char *authpath, const xmss_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int n = params->n;\n\n  uint32_t i, j;\n  unsigned char buffer[2*n];\n\n  // If leafidx is odd (last bit = 1), current path element is a right child and authpath has to go to the left.\n  // Otherwise, it is the other way around\n  if (leafidx & 1) {\n    for (j = 0; j < n; j++)\n      buffer[n+j] = leaf[j];\n    for (j = 0; j < n; j++)\n      buffer[j] = authpath[j];\n  }\n  else {\n    for (j = 0; j < n; j++)\n      buffer[j] = leaf[j];\n    for (j = 0; j < n; j++)\n      buffer[n+j] = authpath[j];\n  }\n  authpath += n;\n\n  for (i=0; i < params->h-1; i++) {\n    setTreeHeight(addr, i);\n    leafidx >>= 1;\n    setTreeIndex(addr, leafidx);\n    if (leafidx&1) {\n      hash_h(buffer+n, buffer, pub_seed, addr, n);\n      for (j = 0; j < n; j++)\n        buffer[j] = authpath[j];\n    }\n    else {\n      hash_h(buffer, buffer, pub_seed, addr, n);\n      for (j = 0; j < n; j++)\n        buffer[j+n] = authpath[j];\n    }\n    authpath += n;\n  }\n  setTreeHeight(addr, (params->h-1));\n  leafidx >>= 1;\n  setTreeIndex(addr, leafidx);\n  hash_h(root, buffer, pub_seed, addr, n);\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void validate_authpath(unsigned char *root, const unsigned char *leaf, unsigned long leafidx, const unsigned char *authpath, const xmss_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int n = params->n;\n\n  uint32_t i, j;\n  unsigned char buffer[2*n];\n\n  // If leafidx is odd (last bit = 1), current path element is a right child and authpath has to go to the left.\n  // Otherwise, it is the other way around\n  if (leafidx & 1) {\n    for (j = 0; j < n; j++)\n      buffer[n+j] = leaf[j];\n    for (j = 0; j < n; j++)\n      buffer[j] = authpath[j];\n  }\n  else {\n    for (j = 0; j < n; j++)\n      buffer[j] = leaf[j];\n    for (j = 0; j < n; j++)\n      buffer[n+j] = authpath[j];\n  }\n  authpath += n;\n\n  for (i=0; i < params->h-1; i++) {\n    setTreeHeight(addr, i);\n    leafidx >>= 1;\n    setTreeIndex(addr, leafidx);\n    if (leafidx&1) {\n      hash_h(buffer+n, buffer, pub_seed, addr, n);\n      for (j = 0; j < n; j++)\n        buffer[j] = authpath[j];\n    }\n    else {\n      hash_h(buffer, buffer, pub_seed, addr, n);\n      for (j = 0; j < n; j++)\n        buffer[j+n] = authpath[j];\n    }\n    authpath += n;\n  }\n  setTreeHeight(addr, (params->h-1));\n  leafidx >>= 1;\n  setTreeIndex(addr, leafidx);\n  hash_h(root, buffer, pub_seed, addr, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "l_tree",
          "args": [
            "pkhash",
            "wots_pk",
            "params",
            "pub_seed",
            "ltree_addr"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "l_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "111-147",
          "snippet": "static void l_tree(unsigned char *leaf, unsigned char *wots_pk, const xmss_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int l = params->wots_par.len;\n  unsigned int n = params->n;\n  uint32_t i = 0;\n  uint32_t height = 0;\n  uint32_t bound;\n\n  //ADRS.setTreeHeight(0);\n  setTreeHeight(addr, height);\n  \n  while (l > 1) {\n     bound = l >> 1; //floor(l / 2);\n     for (i = 0; i < bound; i++) {\n       //ADRS.setTreeIndex(i);\n       setTreeIndex(addr, i);\n       //wots_pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n       hash_h(wots_pk+i*n, wots_pk+i*2*n, pub_seed, addr, n);\n     }\n     //if ( l % 2 == 1 ) {\n     if (l & 1) {\n       //pk[floor(l / 2) + 1] = pk[l];\n       memcpy(wots_pk+(l>>1)*n, wots_pk+(l-1)*n, n);\n       //l = ceil(l / 2);\n       l=(l>>1)+1;\n     }\n     else {\n       //l = ceil(l / 2);\n       l=(l>>1);\n     }\n     //ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     height++;\n     setTreeHeight(addr, height);\n   }\n   //return pk[0];\n   memcpy(leaf, wots_pk, n);\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void l_tree(unsigned char *leaf, unsigned char *wots_pk, const xmss_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int l = params->wots_par.len;\n  unsigned int n = params->n;\n  uint32_t i = 0;\n  uint32_t height = 0;\n  uint32_t bound;\n\n  //ADRS.setTreeHeight(0);\n  setTreeHeight(addr, height);\n  \n  while (l > 1) {\n     bound = l >> 1; //floor(l / 2);\n     for (i = 0; i < bound; i++) {\n       //ADRS.setTreeIndex(i);\n       setTreeIndex(addr, i);\n       //wots_pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n       hash_h(wots_pk+i*n, wots_pk+i*2*n, pub_seed, addr, n);\n     }\n     //if ( l % 2 == 1 ) {\n     if (l & 1) {\n       //pk[floor(l / 2) + 1] = pk[l];\n       memcpy(wots_pk+(l>>1)*n, wots_pk+(l-1)*n, n);\n       //l = ceil(l / 2);\n       l=(l>>1)+1;\n     }\n     else {\n       //l = ceil(l / 2);\n       l=(l>>1);\n     }\n     //ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     height++;\n     setTreeHeight(addr, height);\n   }\n   //return pk[0];\n   memcpy(leaf, wots_pk, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setLtreeADRS",
          "args": [
            "ltree_addr",
            "idx"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "setLtreeADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "53-55",
          "snippet": "void setLtreeADRS(uint32_t adrs[8], uint32_t ltree){\n  adrs[4] = ltree;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setLtreeADRS(uint32_t adrs[8], uint32_t ltree){\n  adrs[4] = ltree;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wots_pkFromSig",
          "args": [
            "wots_pk",
            "sig_msg",
            "msg_h",
            "&(params->wots_par)",
            "pub_seed",
            "ots_addr"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "wots_pkFromSig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_wots.c",
          "lines": "158-191",
          "snippet": "int wots_pkFromSig(unsigned char *pk, const unsigned char *sig, const unsigned char *msg, const wots_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  int csum = 0;\n  uint32_t i = 0;\n  int *basew = calloc(params->len, sizeof(int));\n  if (basew == NULL)\n    return -1;\n\n  base_w(basew, params->len_1, msg, params);\n\n  for (i=0; i < params->len_1; i++) {\n    csum += params->w - 1 - basew[i];\n  }\n\n  csum = csum << (8 - ((params->len_2 * params->log_w) % 8));\n\n  int len_2_bytes = ((params->len_2 * params->log_w) + 7) / 8;\n\n  unsigned char csum_bytes[len_2_bytes];\n  to_byte(csum_bytes, csum, len_2_bytes);\n\n  int csum_basew[params->len_2];\n  base_w(csum_basew, params->len_2, csum_bytes, params);\n\n  for (i = 0; i < params->len_2; i++) {\n    basew[params->len_1 + i] = csum_basew[i];\n  }\n  for (i=0; i < params->len; i++) {\n    setChainADRS(addr, i);\n    gen_chain(pk+i*params->n, sig+i*params->n, basew[i], params->w-1-basew[i], params, pub_seed, addr);\n  }\n  free(basew);\n  return 0;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include <limits.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\n#include \"xmss_wots.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint wots_pkFromSig(unsigned char *pk, const unsigned char *sig, const unsigned char *msg, const wots_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  int csum = 0;\n  uint32_t i = 0;\n  int *basew = calloc(params->len, sizeof(int));\n  if (basew == NULL)\n    return -1;\n\n  base_w(basew, params->len_1, msg, params);\n\n  for (i=0; i < params->len_1; i++) {\n    csum += params->w - 1 - basew[i];\n  }\n\n  csum = csum << (8 - ((params->len_2 * params->log_w) % 8));\n\n  int len_2_bytes = ((params->len_2 * params->log_w) + 7) / 8;\n\n  unsigned char csum_bytes[len_2_bytes];\n  to_byte(csum_bytes, csum, len_2_bytes);\n\n  int csum_basew[params->len_2];\n  base_w(csum_basew, params->len_2, csum_bytes, params);\n\n  for (i = 0; i < params->len_2; i++) {\n    basew[params->len_1 + i] = csum_basew[i];\n  }\n  for (i=0; i < params->len; i++) {\n    setChainADRS(addr, i);\n    gen_chain(pk+i*params->n, sig+i*params->n, basew[i], params->w-1-basew[i], params, pub_seed, addr);\n  }\n  free(basew);\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setOTSADRS",
          "args": [
            "ots_addr",
            "idx"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "setOTSADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "39-41",
          "snippet": "void setOTSADRS(uint32_t adrs[8], uint32_t ots){\n  adrs[4] = ots;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setOTSADRS(uint32_t adrs[8], uint32_t ots){\n  adrs[4] = ots;\n}"
        }
      },
      {
        "call_info": {
          "callee": "h_msg",
          "args": [
            "msg_h",
            "sig_msg + tmp_sig_len",
            "m_len",
            "hash_key",
            "3*n",
            "n"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "h_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "82-89",
          "snippet": "int h_msg(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *key, const unsigned int keylen, const unsigned int n)\n{\n  if (keylen != 3*n){\n    // H_msg takes 3n-bit keys, but n does not match the keylength of keylen\n    return -1;\n  }  \n  return core_hash_SHA2(out, 2, key, keylen, in, inlen, n);\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint h_msg(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *key, const unsigned int keylen, const unsigned int n)\n{\n  if (keylen != 3*n){\n    // H_msg takes 3n-bit keys, but n does not match the keylength of keylen\n    return -1;\n  }  \n  return core_hash_SHA2(out, 2, key, keylen, in, inlen, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_byte",
          "args": [
            "hash_key+2*n",
            "idx",
            "n"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "to_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_commons.c",
          "lines": "19-26",
          "snippet": "void to_byte(unsigned char *out, unsigned long long in, uint32_t bytes)\n{\n  int32_t i;\n  for (i = bytes-1; i >= 0; i--) {\n    out[i] = in & 0xff;\n    in = in >> 8;\n  }\n}",
          "includes": [
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"xmss_commons.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"xmss_commons.h\"\n#include \"includes.h\"\n\nvoid to_byte(unsigned char *out, unsigned long long in, uint32_t bytes)\n{\n  int32_t i;\n  for (i = bytes-1; i >= 0; i--) {\n    out[i] = in & 0xff;\n    in = in >> 8;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hash_key+n",
            "pk",
            "n"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hash_key",
            "sig_msg+4",
            "n"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"verify:: idx = %lu\\n\"",
            "idx"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setType",
          "args": [
            "node_addr",
            "2"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "setType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "25-31",
          "snippet": "void setType(uint32_t adrs[8], uint32_t type){\n  adrs[3] = type;\n  int i;\n  for(i = 4; i < 8; i++){\n    adrs[i] = 0;\n  }\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setType(uint32_t adrs[8], uint32_t type){\n  adrs[3] = type;\n  int i;\n  for(i = 4; i < 8; i++){\n    adrs[i] = 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pub_seed",
            "pk+n",
            "n"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint xmss_sign_open(unsigned char *msg, unsigned long long *msglen, const unsigned char *sig_msg, unsigned long long sig_msg_len, const unsigned char *pk, const xmss_params *params)\n{\n  unsigned int n = params->n;\n\n  unsigned long long i, m_len;\n  unsigned long idx=0;\n  unsigned char wots_pk[params->wots_par.keysize];\n  unsigned char pkhash[n];\n  unsigned char root[n];\n  unsigned char msg_h[n];\n  unsigned char hash_key[3*n];\n\n  unsigned char pub_seed[n];\n  memcpy(pub_seed, pk+n, n);\n\n  // Init addresses\n  uint32_t ots_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t ltree_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t node_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n  setType(ots_addr, 0);\n  setType(ltree_addr, 1);\n  setType(node_addr, 2);\n\n  // Extract index\n  idx = ((unsigned long)sig_msg[0] << 24) | ((unsigned long)sig_msg[1] << 16) | ((unsigned long)sig_msg[2] << 8) | sig_msg[3];\n  printf(\"verify:: idx = %lu\\n\", idx);\n  \n  // Generate hash key (R || root || idx)\n  memcpy(hash_key, sig_msg+4,n);\n  memcpy(hash_key+n, pk, n);\n  to_byte(hash_key+2*n, idx, n);\n  \n  sig_msg += (n+4);\n  sig_msg_len -= (n+4);\n\n  // hash message \n  unsigned long long tmp_sig_len = params->wots_par.keysize+params->h*n;\n  m_len = sig_msg_len - tmp_sig_len;\n  h_msg(msg_h, sig_msg + tmp_sig_len, m_len, hash_key, 3*n, n);\n\n  //-----------------------\n  // Verify signature\n  //-----------------------\n\n  // Prepare Address\n  setOTSADRS(ots_addr, idx);\n  // Check WOTS signature\n  wots_pkFromSig(wots_pk, sig_msg, msg_h, &(params->wots_par), pub_seed, ots_addr);\n\n  sig_msg += params->wots_par.keysize;\n  sig_msg_len -= params->wots_par.keysize;\n\n  // Compute Ltree\n  setLtreeADRS(ltree_addr, idx);\n  l_tree(pkhash, wots_pk, params, pub_seed, ltree_addr);\n\n  // Compute root\n  validate_authpath(root, pkhash, idx, sig_msg, params, pub_seed, node_addr);\n\n  sig_msg += params->h*n;\n  sig_msg_len -= params->h*n;\n\n  for (i = 0; i < n; i++)\n    if (root[i] != pk[i])\n      goto fail;\n\n  *msglen = sig_msg_len;\n  for (i = 0; i < *msglen; i++)\n    msg[i] = sig_msg[i];\n\n  return 0;\n\n\nfail:\n  *msglen = sig_msg_len;\n  for (i = 0; i < *msglen; i++)\n    msg[i] = 0;\n  *msglen = -1;\n  return -1;\n}"
  },
  {
    "function_name": "xmss_sign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "551-658",
    "snippet": "int xmss_sign(unsigned char *sk, bds_state *state, unsigned char *sig_msg, unsigned long long *sig_msg_len, const unsigned char *msg, unsigned long long msglen, const xmss_params *params)\n{\n  unsigned int h = params->h;\n  unsigned int n = params->n;\n  unsigned int k = params->k;\n  uint16_t i = 0;\n\n  // Extract SK\n  unsigned long idx = ((unsigned long)sk[0] << 24) | ((unsigned long)sk[1] << 16) | ((unsigned long)sk[2] << 8) | sk[3];\n  unsigned char sk_seed[n];\n  memcpy(sk_seed, sk+4, n);\n  unsigned char sk_prf[n];\n  memcpy(sk_prf, sk+4+n, n);\n  unsigned char pub_seed[n];\n  memcpy(pub_seed, sk+4+2*n, n);\n  \n  // index as 32 bytes string\n  unsigned char idx_bytes_32[32];\n  to_byte(idx_bytes_32, idx, 32);\n  \n  unsigned char hash_key[3*n]; \n  \n  // Update SK\n  sk[0] = ((idx + 1) >> 24) & 255;\n  sk[1] = ((idx + 1) >> 16) & 255;\n  sk[2] = ((idx + 1) >> 8) & 255;\n  sk[3] = (idx + 1) & 255;\n  // -- Secret key for this non-forward-secure version is now updated.\n  // -- A productive implementation should use a file handle instead and write the updated secret key at this point!\n\n  // Init working params\n  unsigned char R[n];\n  unsigned char msg_h[n];\n  unsigned char ots_seed[n];\n  uint32_t ots_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n  // ---------------------------------\n  // Message Hashing\n  // ---------------------------------\n\n  // Message Hash:\n  // First compute pseudorandom value\n  prf(R, idx_bytes_32, sk_prf, n);\n  // Generate hash key (R || root || idx)\n  memcpy(hash_key, R, n);\n  memcpy(hash_key+n, sk+4+3*n, n);\n  to_byte(hash_key+2*n, idx, n);\n  // Then use it for message digest\n  h_msg(msg_h, msg, msglen, hash_key, 3*n, n);\n\n  // Start collecting signature\n  *sig_msg_len = 0;\n\n  // Copy index to signature\n  sig_msg[0] = (idx >> 24) & 255;\n  sig_msg[1] = (idx >> 16) & 255;\n  sig_msg[2] = (idx >> 8) & 255;\n  sig_msg[3] = idx & 255;\n\n  sig_msg += 4;\n  *sig_msg_len += 4;\n\n  // Copy R to signature\n  for (i = 0; i < n; i++)\n    sig_msg[i] = R[i];\n\n  sig_msg += n;\n  *sig_msg_len += n;\n\n  // ----------------------------------\n  // Now we start to \"really sign\"\n  // ----------------------------------\n\n  // Prepare Address\n  setType(ots_addr, 0);\n  setOTSADRS(ots_addr, idx);\n\n  // Compute seed for OTS key pair\n  get_seed(ots_seed, sk_seed, n, ots_addr);\n\n  // Compute WOTS signature\n  wots_sign(sig_msg, msg_h, ots_seed, &(params->wots_par), pub_seed, ots_addr);\n\n  sig_msg += params->wots_par.keysize;\n  *sig_msg_len += params->wots_par.keysize;\n\n  // the auth path was already computed during the previous round\n  memcpy(sig_msg, state->auth, h*n);\n\n  if (idx < (1U << h) - 1) {\n    bds_round(state, idx, sk_seed, params, pub_seed, ots_addr);\n    bds_treehash_update(state, (h - k) >> 1, sk_seed, params, pub_seed, ots_addr);\n  }\n\n/* TODO: save key/bds state here! */\n\n  sig_msg += params->h*n;\n  *sig_msg_len += params->h*n;\n\n  //Whipe secret elements?\n  //zerobytes(tsk, CRYPTO_SECRETKEYBYTES);\n\n\n  memcpy(sig_msg, msg, msglen);\n  *sig_msg_len += msglen;\n\n  return 0;\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sig_msg",
            "msg",
            "msglen"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bds_treehash_update",
          "args": [
            "state",
            "(h - k) >> 1",
            "sk_seed",
            "params",
            "pub_seed",
            "ots_addr"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "bds_treehash_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "345-377",
          "snippet": "static char bds_treehash_update(bds_state *state, unsigned int updates, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, const uint32_t addr[8]) {\n  uint32_t i, j;\n  unsigned int level, l_min, low;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n  unsigned int used = 0;\n\n  for (j = 0; j < updates; j++) {\n    l_min = h;\n    level = h - k;\n    for (i = 0; i < h - k; i++) {\n      if (state->treehash[i].completed) {\n        low = h;\n      }\n      else if (state->treehash[i].stackusage == 0) {\n        low = i;\n      }\n      else {\n        low = treehash_minheight_on_stack(state, params, &(state->treehash[i]));\n      }\n      if (low < l_min) {\n        level = i;\n        l_min = low;\n      }\n    }\n    if (level == h - k) {\n      break;\n    }\n    treehash_update(&(state->treehash[level]), state, sk_seed, params, pub_seed, addr);\n    used++;\n  }\n  return updates - used;\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic char bds_treehash_update(bds_state *state, unsigned int updates, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, const uint32_t addr[8]) {\n  uint32_t i, j;\n  unsigned int level, l_min, low;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n  unsigned int used = 0;\n\n  for (j = 0; j < updates; j++) {\n    l_min = h;\n    level = h - k;\n    for (i = 0; i < h - k; i++) {\n      if (state->treehash[i].completed) {\n        low = h;\n      }\n      else if (state->treehash[i].stackusage == 0) {\n        low = i;\n      }\n      else {\n        low = treehash_minheight_on_stack(state, params, &(state->treehash[i]));\n      }\n      if (low < l_min) {\n        level = i;\n        l_min = low;\n      }\n    }\n    if (level == h - k) {\n      break;\n    }\n    treehash_update(&(state->treehash[level]), state, sk_seed, params, pub_seed, addr);\n    used++;\n  }\n  return updates - used;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bds_round",
          "args": [
            "state",
            "idx",
            "sk_seed",
            "params",
            "pub_seed",
            "ots_addr"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "bds_round",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "446-515",
          "snippet": "static void bds_round(bds_state *state, const unsigned long leaf_idx, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int i;\n  unsigned int n = params->n;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n\n  unsigned int tau = h;\n  unsigned int startidx;\n  unsigned int offset, rowidx;\n  unsigned char buf[2 * n];\n\n  uint32_t ots_addr[8];\n  uint32_t ltree_addr[8];\n  uint32_t  node_addr[8];\n  // only copy layer and tree address parts\n  memcpy(ots_addr, addr, 12);\n  // type = ots\n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n\n  for (i = 0; i < h; i++) {\n    if (! ((leaf_idx >> i) & 1)) {\n      tau = i;\n      break;\n    }\n  }\n\n  if (tau > 0) {\n    memcpy(buf,     state->auth + (tau-1) * n, n);\n    // we need to do this before refreshing state->keep to prevent overwriting\n    memcpy(buf + n, state->keep + ((tau-1) >> 1) * n, n);\n  }\n  if (!((leaf_idx >> (tau + 1)) & 1) && (tau < h - 1)) {\n    memcpy(state->keep + (tau >> 1)*n, state->auth + tau*n, n);\n  }\n  if (tau == 0) {\n    setLtreeADRS(ltree_addr, leaf_idx);\n    setOTSADRS(ots_addr, leaf_idx);\n    gen_leaf_wots(state->auth, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n  }\n  else {\n    setTreeHeight(node_addr, (tau-1));\n    setTreeIndex(node_addr, leaf_idx >> tau);\n    hash_h(state->auth + tau * n, buf, pub_seed, node_addr, n);\n    for (i = 0; i < tau; i++) {\n      if (i < h - k) {\n        memcpy(state->auth + i * n, state->treehash[i].node, n);\n      }\n      else {\n        offset = (1 << (h - 1 - i)) + i - h;\n        rowidx = ((leaf_idx >> i) - 1) >> 1;\n        memcpy(state->auth + i * n, state->retain + (offset + rowidx) * n, n);\n      }\n    }\n\n    for (i = 0; i < ((tau < h - k) ? tau : (h - k)); i++) {\n      startidx = leaf_idx + 1 + 3 * (1 << i);\n      if (startidx < 1U << h) {\n        state->treehash[i].h = i;\n        state->treehash[i].next_idx = startidx;\n        state->treehash[i].completed = 0;\n        state->treehash[i].stackusage = 0;\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void bds_round(bds_state *state, const unsigned long leaf_idx, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int i;\n  unsigned int n = params->n;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n\n  unsigned int tau = h;\n  unsigned int startidx;\n  unsigned int offset, rowidx;\n  unsigned char buf[2 * n];\n\n  uint32_t ots_addr[8];\n  uint32_t ltree_addr[8];\n  uint32_t  node_addr[8];\n  // only copy layer and tree address parts\n  memcpy(ots_addr, addr, 12);\n  // type = ots\n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n\n  for (i = 0; i < h; i++) {\n    if (! ((leaf_idx >> i) & 1)) {\n      tau = i;\n      break;\n    }\n  }\n\n  if (tau > 0) {\n    memcpy(buf,     state->auth + (tau-1) * n, n);\n    // we need to do this before refreshing state->keep to prevent overwriting\n    memcpy(buf + n, state->keep + ((tau-1) >> 1) * n, n);\n  }\n  if (!((leaf_idx >> (tau + 1)) & 1) && (tau < h - 1)) {\n    memcpy(state->keep + (tau >> 1)*n, state->auth + tau*n, n);\n  }\n  if (tau == 0) {\n    setLtreeADRS(ltree_addr, leaf_idx);\n    setOTSADRS(ots_addr, leaf_idx);\n    gen_leaf_wots(state->auth, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n  }\n  else {\n    setTreeHeight(node_addr, (tau-1));\n    setTreeIndex(node_addr, leaf_idx >> tau);\n    hash_h(state->auth + tau * n, buf, pub_seed, node_addr, n);\n    for (i = 0; i < tau; i++) {\n      if (i < h - k) {\n        memcpy(state->auth + i * n, state->treehash[i].node, n);\n      }\n      else {\n        offset = (1 << (h - 1 - i)) + i - h;\n        rowidx = ((leaf_idx >> i) - 1) >> 1;\n        memcpy(state->auth + i * n, state->retain + (offset + rowidx) * n, n);\n      }\n    }\n\n    for (i = 0; i < ((tau < h - k) ? tau : (h - k)); i++) {\n      startidx = leaf_idx + 1 + 3 * (1 << i);\n      if (startidx < 1U << h) {\n        state->treehash[i].h = i;\n        state->treehash[i].next_idx = startidx;\n        state->treehash[i].completed = 0;\n        state->treehash[i].stackusage = 0;\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sig_msg",
            "state->auth",
            "h*n"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wots_sign",
          "args": [
            "sig_msg",
            "msg_h",
            "ots_seed",
            "&(params->wots_par)",
            "pub_seed",
            "ots_addr"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "wots_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_wots.c",
          "lines": "119-156",
          "snippet": "int wots_sign(unsigned char *sig, const unsigned char *msg, const unsigned char *sk, const wots_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  //int basew[params->len];\n  int csum = 0;\n  uint32_t i = 0;\n  int *basew = calloc(params->len, sizeof(int));\n  if (basew == NULL)\n    return -1;\n\n  base_w(basew, params->len_1, msg, params);\n\n  for (i=0; i < params->len_1; i++) {\n    csum += params->w - 1 - basew[i];\n  }\n\n  csum = csum << (8 - ((params->len_2 * params->log_w) % 8));\n\n  int len_2_bytes = ((params->len_2 * params->log_w) + 7) / 8;\n\n  unsigned char csum_bytes[len_2_bytes];\n  to_byte(csum_bytes, csum, len_2_bytes);\n\n  int csum_basew[params->len_2];\n  base_w(csum_basew, params->len_2, csum_bytes, params);\n\n  for (i = 0; i < params->len_2; i++) {\n    basew[params->len_1 + i] = csum_basew[i];\n  }\n\n  expand_seed(sig, sk, params);\n\n  for (i = 0; i < params->len; i++) {\n    setChainADRS(addr, i);\n    gen_chain(sig+i*params->n, sig+i*params->n, 0, basew[i], params, pub_seed, addr);\n  }\n  free(basew);\n  return 0;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include <limits.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\n#include \"xmss_wots.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint wots_sign(unsigned char *sig, const unsigned char *msg, const unsigned char *sk, const wots_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  //int basew[params->len];\n  int csum = 0;\n  uint32_t i = 0;\n  int *basew = calloc(params->len, sizeof(int));\n  if (basew == NULL)\n    return -1;\n\n  base_w(basew, params->len_1, msg, params);\n\n  for (i=0; i < params->len_1; i++) {\n    csum += params->w - 1 - basew[i];\n  }\n\n  csum = csum << (8 - ((params->len_2 * params->log_w) % 8));\n\n  int len_2_bytes = ((params->len_2 * params->log_w) + 7) / 8;\n\n  unsigned char csum_bytes[len_2_bytes];\n  to_byte(csum_bytes, csum, len_2_bytes);\n\n  int csum_basew[params->len_2];\n  base_w(csum_basew, params->len_2, csum_bytes, params);\n\n  for (i = 0; i < params->len_2; i++) {\n    basew[params->len_1 + i] = csum_basew[i];\n  }\n\n  expand_seed(sig, sk, params);\n\n  for (i = 0; i < params->len; i++) {\n    setChainADRS(addr, i);\n    gen_chain(sig+i*params->n, sig+i*params->n, 0, basew[i], params, pub_seed, addr);\n  }\n  free(basew);\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seed",
          "args": [
            "ots_seed",
            "sk_seed",
            "n",
            "ots_addr"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "get_seed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "36-46",
          "snippet": "static void get_seed(unsigned char *seed, const unsigned char *sk_seed, int n, uint32_t addr[8])\n{\n  unsigned char bytes[32];\n  // Make sure that chain addr, hash addr, and key bit are 0!\n  setChainADRS(addr,0);\n  setHashADRS(addr,0);\n  setKeyAndMask(addr,0);\n  // Generate pseudorandom value\n  addr_to_byte(bytes, addr);\n  prf(seed, bytes, sk_seed, n);\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void get_seed(unsigned char *seed, const unsigned char *sk_seed, int n, uint32_t addr[8])\n{\n  unsigned char bytes[32];\n  // Make sure that chain addr, hash addr, and key bit are 0!\n  setChainADRS(addr,0);\n  setHashADRS(addr,0);\n  setKeyAndMask(addr,0);\n  // Generate pseudorandom value\n  addr_to_byte(bytes, addr);\n  prf(seed, bytes, sk_seed, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setOTSADRS",
          "args": [
            "ots_addr",
            "idx"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "setOTSADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "39-41",
          "snippet": "void setOTSADRS(uint32_t adrs[8], uint32_t ots){\n  adrs[4] = ots;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setOTSADRS(uint32_t adrs[8], uint32_t ots){\n  adrs[4] = ots;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setType",
          "args": [
            "ots_addr",
            "0"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "setType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "25-31",
          "snippet": "void setType(uint32_t adrs[8], uint32_t type){\n  adrs[3] = type;\n  int i;\n  for(i = 4; i < 8; i++){\n    adrs[i] = 0;\n  }\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setType(uint32_t adrs[8], uint32_t type){\n  adrs[3] = type;\n  int i;\n  for(i = 4; i < 8; i++){\n    adrs[i] = 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "h_msg",
          "args": [
            "msg_h",
            "msg",
            "msglen",
            "hash_key",
            "3*n",
            "n"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "h_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "82-89",
          "snippet": "int h_msg(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *key, const unsigned int keylen, const unsigned int n)\n{\n  if (keylen != 3*n){\n    // H_msg takes 3n-bit keys, but n does not match the keylength of keylen\n    return -1;\n  }  \n  return core_hash_SHA2(out, 2, key, keylen, in, inlen, n);\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint h_msg(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *key, const unsigned int keylen, const unsigned int n)\n{\n  if (keylen != 3*n){\n    // H_msg takes 3n-bit keys, but n does not match the keylength of keylen\n    return -1;\n  }  \n  return core_hash_SHA2(out, 2, key, keylen, in, inlen, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_byte",
          "args": [
            "hash_key+2*n",
            "idx",
            "n"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "to_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_commons.c",
          "lines": "19-26",
          "snippet": "void to_byte(unsigned char *out, unsigned long long in, uint32_t bytes)\n{\n  int32_t i;\n  for (i = bytes-1; i >= 0; i--) {\n    out[i] = in & 0xff;\n    in = in >> 8;\n  }\n}",
          "includes": [
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"xmss_commons.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"xmss_commons.h\"\n#include \"includes.h\"\n\nvoid to_byte(unsigned char *out, unsigned long long in, uint32_t bytes)\n{\n  int32_t i;\n  for (i = bytes-1; i >= 0; i--) {\n    out[i] = in & 0xff;\n    in = in >> 8;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hash_key+n",
            "sk+4+3*n",
            "n"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hash_key",
            "R",
            "n"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prf",
          "args": [
            "R",
            "idx_bytes_32",
            "sk_prf",
            "n"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "prf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "74-77",
          "snippet": "int prf(unsigned char *out, const unsigned char *in, const unsigned char *key, unsigned int keylen)\n{ \n  return core_hash_SHA2(out, 3, key, keylen, in, 32, keylen);\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint prf(unsigned char *out, const unsigned char *in, const unsigned char *key, unsigned int keylen)\n{ \n  return core_hash_SHA2(out, 3, key, keylen, in, 32, keylen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pub_seed",
            "sk+4+2*n",
            "n"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sk_prf",
            "sk+4+n",
            "n"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sk_seed",
            "sk+4",
            "n"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint xmss_sign(unsigned char *sk, bds_state *state, unsigned char *sig_msg, unsigned long long *sig_msg_len, const unsigned char *msg, unsigned long long msglen, const xmss_params *params)\n{\n  unsigned int h = params->h;\n  unsigned int n = params->n;\n  unsigned int k = params->k;\n  uint16_t i = 0;\n\n  // Extract SK\n  unsigned long idx = ((unsigned long)sk[0] << 24) | ((unsigned long)sk[1] << 16) | ((unsigned long)sk[2] << 8) | sk[3];\n  unsigned char sk_seed[n];\n  memcpy(sk_seed, sk+4, n);\n  unsigned char sk_prf[n];\n  memcpy(sk_prf, sk+4+n, n);\n  unsigned char pub_seed[n];\n  memcpy(pub_seed, sk+4+2*n, n);\n  \n  // index as 32 bytes string\n  unsigned char idx_bytes_32[32];\n  to_byte(idx_bytes_32, idx, 32);\n  \n  unsigned char hash_key[3*n]; \n  \n  // Update SK\n  sk[0] = ((idx + 1) >> 24) & 255;\n  sk[1] = ((idx + 1) >> 16) & 255;\n  sk[2] = ((idx + 1) >> 8) & 255;\n  sk[3] = (idx + 1) & 255;\n  // -- Secret key for this non-forward-secure version is now updated.\n  // -- A productive implementation should use a file handle instead and write the updated secret key at this point!\n\n  // Init working params\n  unsigned char R[n];\n  unsigned char msg_h[n];\n  unsigned char ots_seed[n];\n  uint32_t ots_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n  // ---------------------------------\n  // Message Hashing\n  // ---------------------------------\n\n  // Message Hash:\n  // First compute pseudorandom value\n  prf(R, idx_bytes_32, sk_prf, n);\n  // Generate hash key (R || root || idx)\n  memcpy(hash_key, R, n);\n  memcpy(hash_key+n, sk+4+3*n, n);\n  to_byte(hash_key+2*n, idx, n);\n  // Then use it for message digest\n  h_msg(msg_h, msg, msglen, hash_key, 3*n, n);\n\n  // Start collecting signature\n  *sig_msg_len = 0;\n\n  // Copy index to signature\n  sig_msg[0] = (idx >> 24) & 255;\n  sig_msg[1] = (idx >> 16) & 255;\n  sig_msg[2] = (idx >> 8) & 255;\n  sig_msg[3] = idx & 255;\n\n  sig_msg += 4;\n  *sig_msg_len += 4;\n\n  // Copy R to signature\n  for (i = 0; i < n; i++)\n    sig_msg[i] = R[i];\n\n  sig_msg += n;\n  *sig_msg_len += n;\n\n  // ----------------------------------\n  // Now we start to \"really sign\"\n  // ----------------------------------\n\n  // Prepare Address\n  setType(ots_addr, 0);\n  setOTSADRS(ots_addr, idx);\n\n  // Compute seed for OTS key pair\n  get_seed(ots_seed, sk_seed, n, ots_addr);\n\n  // Compute WOTS signature\n  wots_sign(sig_msg, msg_h, ots_seed, &(params->wots_par), pub_seed, ots_addr);\n\n  sig_msg += params->wots_par.keysize;\n  *sig_msg_len += params->wots_par.keysize;\n\n  // the auth path was already computed during the previous round\n  memcpy(sig_msg, state->auth, h*n);\n\n  if (idx < (1U << h) - 1) {\n    bds_round(state, idx, sk_seed, params, pub_seed, ots_addr);\n    bds_treehash_update(state, (h - k) >> 1, sk_seed, params, pub_seed, ots_addr);\n  }\n\n/* TODO: save key/bds state here! */\n\n  sig_msg += params->h*n;\n  *sig_msg_len += params->h*n;\n\n  //Whipe secret elements?\n  //zerobytes(tsk, CRYPTO_SECRETKEYBYTES);\n\n\n  memcpy(sig_msg, msg, msglen);\n  *sig_msg_len += msglen;\n\n  return 0;\n}"
  },
  {
    "function_name": "xmss_keypair",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "522-542",
    "snippet": "int xmss_keypair(unsigned char *pk, unsigned char *sk, bds_state *state, xmss_params *params)\n{\n  unsigned int n = params->n;\n  // Set idx = 0\n  sk[0] = 0;\n  sk[1] = 0;\n  sk[2] = 0;\n  sk[3] = 0;\n  // Init SK_SEED (n byte), SK_PRF (n byte), and PUB_SEED (n byte)\n  randombytes(sk+4, 3*n);\n  // Copy PUB_SEED to public key\n  memcpy(pk+n, sk+4+2*n, n);\n\n  uint32_t addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n  // Compute root\n  treehash_setup(pk, params->h, 0, state, sk+4, params, sk+4+2*n, addr);\n  // copy root to sk\n  memcpy(sk+4+3*n, pk, n);\n  return 0;\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sk+4+3*n",
            "pk",
            "n"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "treehash_setup",
          "args": [
            "pk",
            "params->h",
            "0",
            "state",
            "sk+4",
            "params",
            "sk+4+2*n",
            "addr"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "treehash_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "178-247",
          "snippet": "static void treehash_setup(unsigned char *node, int height, int index, bds_state *state, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, const uint32_t addr[8])\n{\n  unsigned int idx = index;\n  unsigned int n = params->n;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n  // use three different addresses because at this point we use all three formats in parallel\n  uint32_t ots_addr[8];\n  uint32_t ltree_addr[8];\n  uint32_t  node_addr[8];\n  // only copy layer and tree address parts\n  memcpy(ots_addr, addr, 12);\n  // type = ots\n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n\n  uint32_t lastnode, i;\n  unsigned char stack[(height+1)*n];\n  unsigned int stacklevels[height+1];\n  unsigned int stackoffset=0;\n  unsigned int nodeh;\n\n  lastnode = idx+(1<<height);\n\n  for (i = 0; i < h-k; i++) {\n    state->treehash[i].h = i;\n    state->treehash[i].completed = 1;\n    state->treehash[i].stackusage = 0;\n  }\n\n  i = 0;\n  for (; idx < lastnode; idx++) {\n    setLtreeADRS(ltree_addr, idx);\n    setOTSADRS(ots_addr, idx);\n    gen_leaf_wots(stack+stackoffset*n, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n    stacklevels[stackoffset] = 0;\n    stackoffset++;\n    if (h - k > 0 && i == 3) {\n      memcpy(state->treehash[0].node, stack+stackoffset*n, n);\n    }\n    while (stackoffset>1 && stacklevels[stackoffset-1] == stacklevels[stackoffset-2])\n    {\n      nodeh = stacklevels[stackoffset-1];\n      if (i >> nodeh == 1) {\n        memcpy(state->auth + nodeh*n, stack+(stackoffset-1)*n, n);\n      }\n      else {\n        if (nodeh < h - k && i >> nodeh == 3) {\n          memcpy(state->treehash[nodeh].node, stack+(stackoffset-1)*n, n);\n        }\n        else if (nodeh >= h - k) {\n          memcpy(state->retain + ((1 << (h - 1 - nodeh)) + nodeh - h + (((i >> nodeh) - 3) >> 1)) * n, stack+(stackoffset-1)*n, n);\n        }\n      }\n      setTreeHeight(node_addr, stacklevels[stackoffset-1]);\n      setTreeIndex(node_addr, (idx >> (stacklevels[stackoffset-1]+1)));\n      hash_h(stack+(stackoffset-2)*n, stack+(stackoffset-2)*n, pub_seed,\n          node_addr, n);\n      stacklevels[stackoffset-2]++;\n      stackoffset--;\n    }\n    i++;\n  }\n\n  for (i = 0; i < n; i++)\n    node[i] = stack[i];\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void treehash_setup(unsigned char *node, int height, int index, bds_state *state, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, const uint32_t addr[8])\n{\n  unsigned int idx = index;\n  unsigned int n = params->n;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n  // use three different addresses because at this point we use all three formats in parallel\n  uint32_t ots_addr[8];\n  uint32_t ltree_addr[8];\n  uint32_t  node_addr[8];\n  // only copy layer and tree address parts\n  memcpy(ots_addr, addr, 12);\n  // type = ots\n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n\n  uint32_t lastnode, i;\n  unsigned char stack[(height+1)*n];\n  unsigned int stacklevels[height+1];\n  unsigned int stackoffset=0;\n  unsigned int nodeh;\n\n  lastnode = idx+(1<<height);\n\n  for (i = 0; i < h-k; i++) {\n    state->treehash[i].h = i;\n    state->treehash[i].completed = 1;\n    state->treehash[i].stackusage = 0;\n  }\n\n  i = 0;\n  for (; idx < lastnode; idx++) {\n    setLtreeADRS(ltree_addr, idx);\n    setOTSADRS(ots_addr, idx);\n    gen_leaf_wots(stack+stackoffset*n, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n    stacklevels[stackoffset] = 0;\n    stackoffset++;\n    if (h - k > 0 && i == 3) {\n      memcpy(state->treehash[0].node, stack+stackoffset*n, n);\n    }\n    while (stackoffset>1 && stacklevels[stackoffset-1] == stacklevels[stackoffset-2])\n    {\n      nodeh = stacklevels[stackoffset-1];\n      if (i >> nodeh == 1) {\n        memcpy(state->auth + nodeh*n, stack+(stackoffset-1)*n, n);\n      }\n      else {\n        if (nodeh < h - k && i >> nodeh == 3) {\n          memcpy(state->treehash[nodeh].node, stack+(stackoffset-1)*n, n);\n        }\n        else if (nodeh >= h - k) {\n          memcpy(state->retain + ((1 << (h - 1 - nodeh)) + nodeh - h + (((i >> nodeh) - 3) >> 1)) * n, stack+(stackoffset-1)*n, n);\n        }\n      }\n      setTreeHeight(node_addr, stacklevels[stackoffset-1]);\n      setTreeIndex(node_addr, (idx >> (stacklevels[stackoffset-1]+1)));\n      hash_h(stack+(stackoffset-2)*n, stack+(stackoffset-2)*n, pub_seed,\n          node_addr, n);\n      stacklevels[stackoffset-2]++;\n      stackoffset--;\n    }\n    i++;\n  }\n\n  for (i = 0; i < n; i++)\n    node[i] = stack[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pk+n",
            "sk+4+2*n",
            "n"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "randombytes",
          "args": [
            "sk+4",
            "3*n"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint xmss_keypair(unsigned char *pk, unsigned char *sk, bds_state *state, xmss_params *params)\n{\n  unsigned int n = params->n;\n  // Set idx = 0\n  sk[0] = 0;\n  sk[1] = 0;\n  sk[2] = 0;\n  sk[3] = 0;\n  // Init SK_SEED (n byte), SK_PRF (n byte), and PUB_SEED (n byte)\n  randombytes(sk+4, 3*n);\n  // Copy PUB_SEED to public key\n  memcpy(pk+n, sk+4+2*n, n);\n\n  uint32_t addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n  // Compute root\n  treehash_setup(pk, params->h, 0, state, sk+4, params, sk+4+2*n, addr);\n  // copy root to sk\n  memcpy(sk+4+3*n, pk, n);\n  return 0;\n}"
  },
  {
    "function_name": "bds_round",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "446-515",
    "snippet": "static void bds_round(bds_state *state, const unsigned long leaf_idx, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int i;\n  unsigned int n = params->n;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n\n  unsigned int tau = h;\n  unsigned int startidx;\n  unsigned int offset, rowidx;\n  unsigned char buf[2 * n];\n\n  uint32_t ots_addr[8];\n  uint32_t ltree_addr[8];\n  uint32_t  node_addr[8];\n  // only copy layer and tree address parts\n  memcpy(ots_addr, addr, 12);\n  // type = ots\n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n\n  for (i = 0; i < h; i++) {\n    if (! ((leaf_idx >> i) & 1)) {\n      tau = i;\n      break;\n    }\n  }\n\n  if (tau > 0) {\n    memcpy(buf,     state->auth + (tau-1) * n, n);\n    // we need to do this before refreshing state->keep to prevent overwriting\n    memcpy(buf + n, state->keep + ((tau-1) >> 1) * n, n);\n  }\n  if (!((leaf_idx >> (tau + 1)) & 1) && (tau < h - 1)) {\n    memcpy(state->keep + (tau >> 1)*n, state->auth + tau*n, n);\n  }\n  if (tau == 0) {\n    setLtreeADRS(ltree_addr, leaf_idx);\n    setOTSADRS(ots_addr, leaf_idx);\n    gen_leaf_wots(state->auth, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n  }\n  else {\n    setTreeHeight(node_addr, (tau-1));\n    setTreeIndex(node_addr, leaf_idx >> tau);\n    hash_h(state->auth + tau * n, buf, pub_seed, node_addr, n);\n    for (i = 0; i < tau; i++) {\n      if (i < h - k) {\n        memcpy(state->auth + i * n, state->treehash[i].node, n);\n      }\n      else {\n        offset = (1 << (h - 1 - i)) + i - h;\n        rowidx = ((leaf_idx >> i) - 1) >> 1;\n        memcpy(state->auth + i * n, state->retain + (offset + rowidx) * n, n);\n      }\n    }\n\n    for (i = 0; i < ((tau < h - k) ? tau : (h - k)); i++) {\n      startidx = leaf_idx + 1 + 3 * (1 << i);\n      if (startidx < 1U << h) {\n        state->treehash[i].h = i;\n        state->treehash[i].next_idx = startidx;\n        state->treehash[i].completed = 0;\n        state->treehash[i].stackusage = 0;\n      }\n    }\n  }\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "state->auth + i * n",
            "state->retain + (offset + rowidx) * n",
            "n"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "state->auth + i * n",
            "state->treehash[i].node",
            "n"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_h",
          "args": [
            "state->auth + tau * n",
            "buf",
            "pub_seed",
            "node_addr",
            "n"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "hash_h",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "94-117",
          "snippet": "int hash_h(unsigned char *out, const unsigned char *in, const unsigned char *pub_seed, uint32_t addr[8], const unsigned int n)\n{\n\n  unsigned char buf[2*n];\n  unsigned char key[n];\n  unsigned char bitmask[2*n];\n  unsigned char byte_addr[32];\n  unsigned int i;\n\n  setKeyAndMask(addr, 0);\n  addr_to_byte(byte_addr, addr);\n  prf(key, byte_addr, pub_seed, n);\n  // Use MSB order\n  setKeyAndMask(addr, 1);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask, byte_addr, pub_seed, n);\n  setKeyAndMask(addr, 2);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask+n, byte_addr, pub_seed, n);\n  for (i = 0; i < 2*n; i++) {\n    buf[i] = in[i] ^ bitmask[i];\n  }\n  return core_hash_SHA2(out, 1, key, n, buf, 2*n, n);\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint hash_h(unsigned char *out, const unsigned char *in, const unsigned char *pub_seed, uint32_t addr[8], const unsigned int n)\n{\n\n  unsigned char buf[2*n];\n  unsigned char key[n];\n  unsigned char bitmask[2*n];\n  unsigned char byte_addr[32];\n  unsigned int i;\n\n  setKeyAndMask(addr, 0);\n  addr_to_byte(byte_addr, addr);\n  prf(key, byte_addr, pub_seed, n);\n  // Use MSB order\n  setKeyAndMask(addr, 1);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask, byte_addr, pub_seed, n);\n  setKeyAndMask(addr, 2);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask+n, byte_addr, pub_seed, n);\n  for (i = 0; i < 2*n; i++) {\n    buf[i] = in[i] ^ bitmask[i];\n  }\n  return core_hash_SHA2(out, 1, key, n, buf, 2*n, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setTreeIndex",
          "args": [
            "node_addr",
            "leaf_idx >> tau"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "setTreeIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "63-65",
          "snippet": "void setTreeIndex(uint32_t adrs[8], uint32_t treeIndex){\n  adrs[6] = treeIndex;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setTreeIndex(uint32_t adrs[8], uint32_t treeIndex){\n  adrs[6] = treeIndex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setTreeHeight",
          "args": [
            "node_addr",
            "(tau-1)"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "setTreeHeight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "59-61",
          "snippet": "void setTreeHeight(uint32_t adrs[8], uint32_t treeHeight){\n  adrs[5] = treeHeight;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setTreeHeight(uint32_t adrs[8], uint32_t treeHeight){\n  adrs[5] = treeHeight;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_leaf_wots",
          "args": [
            "state->auth",
            "sk_seed",
            "params",
            "pub_seed",
            "ltree_addr",
            "ots_addr"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "gen_leaf_wots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "152-161",
          "snippet": "static void gen_leaf_wots(unsigned char *leaf, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, uint32_t ltree_addr[8], uint32_t ots_addr[8])\n{\n  unsigned char seed[params->n];\n  unsigned char pk[params->wots_par.keysize];\n\n  get_seed(seed, sk_seed, params->n, ots_addr);\n  wots_pkgen(pk, seed, &(params->wots_par), pub_seed, ots_addr);\n\n  l_tree(leaf, pk, params, pub_seed, ltree_addr);\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void gen_leaf_wots(unsigned char *leaf, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, uint32_t ltree_addr[8], uint32_t ots_addr[8])\n{\n  unsigned char seed[params->n];\n  unsigned char pk[params->wots_par.keysize];\n\n  get_seed(seed, sk_seed, params->n, ots_addr);\n  wots_pkgen(pk, seed, &(params->wots_par), pub_seed, ots_addr);\n\n  l_tree(leaf, pk, params, pub_seed, ltree_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setOTSADRS",
          "args": [
            "ots_addr",
            "leaf_idx"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "setOTSADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "39-41",
          "snippet": "void setOTSADRS(uint32_t adrs[8], uint32_t ots){\n  adrs[4] = ots;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setOTSADRS(uint32_t adrs[8], uint32_t ots){\n  adrs[4] = ots;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setLtreeADRS",
          "args": [
            "ltree_addr",
            "leaf_idx"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "setLtreeADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "53-55",
          "snippet": "void setLtreeADRS(uint32_t adrs[8], uint32_t ltree){\n  adrs[4] = ltree;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setLtreeADRS(uint32_t adrs[8], uint32_t ltree){\n  adrs[4] = ltree;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "state->keep + (tau >> 1)*n",
            "state->auth + tau*n",
            "n"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + n",
            "state->keep + ((tau-1) >> 1) * n",
            "n"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "state->auth + (tau-1) * n",
            "n"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setType",
          "args": [
            "node_addr",
            "2"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "setType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "25-31",
          "snippet": "void setType(uint32_t adrs[8], uint32_t type){\n  adrs[3] = type;\n  int i;\n  for(i = 4; i < 8; i++){\n    adrs[i] = 0;\n  }\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setType(uint32_t adrs[8], uint32_t type){\n  adrs[3] = type;\n  int i;\n  for(i = 4; i < 8; i++){\n    adrs[i] = 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "node_addr",
            "addr",
            "12"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ltree_addr",
            "addr",
            "12"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ots_addr",
            "addr",
            "12"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void bds_round(bds_state *state, const unsigned long leaf_idx, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int i;\n  unsigned int n = params->n;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n\n  unsigned int tau = h;\n  unsigned int startidx;\n  unsigned int offset, rowidx;\n  unsigned char buf[2 * n];\n\n  uint32_t ots_addr[8];\n  uint32_t ltree_addr[8];\n  uint32_t  node_addr[8];\n  // only copy layer and tree address parts\n  memcpy(ots_addr, addr, 12);\n  // type = ots\n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n\n  for (i = 0; i < h; i++) {\n    if (! ((leaf_idx >> i) & 1)) {\n      tau = i;\n      break;\n    }\n  }\n\n  if (tau > 0) {\n    memcpy(buf,     state->auth + (tau-1) * n, n);\n    // we need to do this before refreshing state->keep to prevent overwriting\n    memcpy(buf + n, state->keep + ((tau-1) >> 1) * n, n);\n  }\n  if (!((leaf_idx >> (tau + 1)) & 1) && (tau < h - 1)) {\n    memcpy(state->keep + (tau >> 1)*n, state->auth + tau*n, n);\n  }\n  if (tau == 0) {\n    setLtreeADRS(ltree_addr, leaf_idx);\n    setOTSADRS(ots_addr, leaf_idx);\n    gen_leaf_wots(state->auth, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n  }\n  else {\n    setTreeHeight(node_addr, (tau-1));\n    setTreeIndex(node_addr, leaf_idx >> tau);\n    hash_h(state->auth + tau * n, buf, pub_seed, node_addr, n);\n    for (i = 0; i < tau; i++) {\n      if (i < h - k) {\n        memcpy(state->auth + i * n, state->treehash[i].node, n);\n      }\n      else {\n        offset = (1 << (h - 1 - i)) + i - h;\n        rowidx = ((leaf_idx >> i) - 1) >> 1;\n        memcpy(state->auth + i * n, state->retain + (offset + rowidx) * n, n);\n      }\n    }\n\n    for (i = 0; i < ((tau < h - k) ? tau : (h - k)); i++) {\n      startidx = leaf_idx + 1 + 3 * (1 << i);\n      if (startidx < 1U << h) {\n        state->treehash[i].h = i;\n        state->treehash[i].next_idx = startidx;\n        state->treehash[i].completed = 0;\n        state->treehash[i].stackusage = 0;\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "bds_state_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "383-439",
    "snippet": "static char bds_state_update(bds_state *state, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, const uint32_t addr[8]) {\n  uint32_t ltree_addr[8];\n  uint32_t node_addr[8];\n  uint32_t ots_addr[8];\n\n  int n = params->n;\n  int h = params->h;\n  int k = params->k;\n\n  int nodeh;\n  int idx = state->next_leaf;\n  if (idx == 1 << h) {\n    return 1;\n  }\n\n  // only copy layer and tree address parts\n  memcpy(ots_addr, addr, 12);\n  // type = ots\n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n  \n  setOTSADRS(ots_addr, idx);\n  setLtreeADRS(ltree_addr, idx);\n\n  gen_leaf_wots(state->stack+state->stackoffset*n, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n\n  state->stacklevels[state->stackoffset] = 0;\n  state->stackoffset++;\n  if (h - k > 0 && idx == 3) {\n    memcpy(state->treehash[0].node, state->stack+state->stackoffset*n, n);\n  }\n  while (state->stackoffset>1 && state->stacklevels[state->stackoffset-1] == state->stacklevels[state->stackoffset-2]) {\n    nodeh = state->stacklevels[state->stackoffset-1];\n    if (idx >> nodeh == 1) {\n      memcpy(state->auth + nodeh*n, state->stack+(state->stackoffset-1)*n, n);\n    }\n    else {\n      if (nodeh < h - k && idx >> nodeh == 3) {\n        memcpy(state->treehash[nodeh].node, state->stack+(state->stackoffset-1)*n, n);\n      }\n      else if (nodeh >= h - k) {\n        memcpy(state->retain + ((1 << (h - 1 - nodeh)) + nodeh - h + (((idx >> nodeh) - 3) >> 1)) * n, state->stack+(state->stackoffset-1)*n, n);\n      }\n    }\n    setTreeHeight(node_addr, state->stacklevels[state->stackoffset-1]);\n    setTreeIndex(node_addr, (idx >> (state->stacklevels[state->stackoffset-1]+1)));\n    hash_h(state->stack+(state->stackoffset-2)*n, state->stack+(state->stackoffset-2)*n, pub_seed, node_addr, n);\n\n    state->stacklevels[state->stackoffset-2]++;\n    state->stackoffset--;\n  }\n  state->next_leaf++;\n  return 0;\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_h",
          "args": [
            "state->stack+(state->stackoffset-2)*n",
            "state->stack+(state->stackoffset-2)*n",
            "pub_seed",
            "node_addr",
            "n"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "hash_h",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "94-117",
          "snippet": "int hash_h(unsigned char *out, const unsigned char *in, const unsigned char *pub_seed, uint32_t addr[8], const unsigned int n)\n{\n\n  unsigned char buf[2*n];\n  unsigned char key[n];\n  unsigned char bitmask[2*n];\n  unsigned char byte_addr[32];\n  unsigned int i;\n\n  setKeyAndMask(addr, 0);\n  addr_to_byte(byte_addr, addr);\n  prf(key, byte_addr, pub_seed, n);\n  // Use MSB order\n  setKeyAndMask(addr, 1);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask, byte_addr, pub_seed, n);\n  setKeyAndMask(addr, 2);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask+n, byte_addr, pub_seed, n);\n  for (i = 0; i < 2*n; i++) {\n    buf[i] = in[i] ^ bitmask[i];\n  }\n  return core_hash_SHA2(out, 1, key, n, buf, 2*n, n);\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint hash_h(unsigned char *out, const unsigned char *in, const unsigned char *pub_seed, uint32_t addr[8], const unsigned int n)\n{\n\n  unsigned char buf[2*n];\n  unsigned char key[n];\n  unsigned char bitmask[2*n];\n  unsigned char byte_addr[32];\n  unsigned int i;\n\n  setKeyAndMask(addr, 0);\n  addr_to_byte(byte_addr, addr);\n  prf(key, byte_addr, pub_seed, n);\n  // Use MSB order\n  setKeyAndMask(addr, 1);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask, byte_addr, pub_seed, n);\n  setKeyAndMask(addr, 2);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask+n, byte_addr, pub_seed, n);\n  for (i = 0; i < 2*n; i++) {\n    buf[i] = in[i] ^ bitmask[i];\n  }\n  return core_hash_SHA2(out, 1, key, n, buf, 2*n, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setTreeIndex",
          "args": [
            "node_addr",
            "(idx >> (state->stacklevels[state->stackoffset-1]+1))"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "setTreeIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "63-65",
          "snippet": "void setTreeIndex(uint32_t adrs[8], uint32_t treeIndex){\n  adrs[6] = treeIndex;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setTreeIndex(uint32_t adrs[8], uint32_t treeIndex){\n  adrs[6] = treeIndex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setTreeHeight",
          "args": [
            "node_addr",
            "state->stacklevels[state->stackoffset-1]"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "setTreeHeight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "59-61",
          "snippet": "void setTreeHeight(uint32_t adrs[8], uint32_t treeHeight){\n  adrs[5] = treeHeight;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setTreeHeight(uint32_t adrs[8], uint32_t treeHeight){\n  adrs[5] = treeHeight;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "state->retain + ((1 << (h - 1 - nodeh)) + nodeh - h + (((idx >> nodeh) - 3) >> 1)) * n",
            "state->stack+(state->stackoffset-1)*n",
            "n"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "state->treehash[nodeh].node",
            "state->stack+(state->stackoffset-1)*n",
            "n"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "state->auth + nodeh*n",
            "state->stack+(state->stackoffset-1)*n",
            "n"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "state->treehash[0].node",
            "state->stack+state->stackoffset*n",
            "n"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_leaf_wots",
          "args": [
            "state->stack+state->stackoffset*n",
            "sk_seed",
            "params",
            "pub_seed",
            "ltree_addr",
            "ots_addr"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "gen_leaf_wots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "152-161",
          "snippet": "static void gen_leaf_wots(unsigned char *leaf, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, uint32_t ltree_addr[8], uint32_t ots_addr[8])\n{\n  unsigned char seed[params->n];\n  unsigned char pk[params->wots_par.keysize];\n\n  get_seed(seed, sk_seed, params->n, ots_addr);\n  wots_pkgen(pk, seed, &(params->wots_par), pub_seed, ots_addr);\n\n  l_tree(leaf, pk, params, pub_seed, ltree_addr);\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void gen_leaf_wots(unsigned char *leaf, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, uint32_t ltree_addr[8], uint32_t ots_addr[8])\n{\n  unsigned char seed[params->n];\n  unsigned char pk[params->wots_par.keysize];\n\n  get_seed(seed, sk_seed, params->n, ots_addr);\n  wots_pkgen(pk, seed, &(params->wots_par), pub_seed, ots_addr);\n\n  l_tree(leaf, pk, params, pub_seed, ltree_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setLtreeADRS",
          "args": [
            "ltree_addr",
            "idx"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "setLtreeADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "53-55",
          "snippet": "void setLtreeADRS(uint32_t adrs[8], uint32_t ltree){\n  adrs[4] = ltree;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setLtreeADRS(uint32_t adrs[8], uint32_t ltree){\n  adrs[4] = ltree;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setOTSADRS",
          "args": [
            "ots_addr",
            "idx"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "setOTSADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "39-41",
          "snippet": "void setOTSADRS(uint32_t adrs[8], uint32_t ots){\n  adrs[4] = ots;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setOTSADRS(uint32_t adrs[8], uint32_t ots){\n  adrs[4] = ots;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setType",
          "args": [
            "node_addr",
            "2"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "setType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "25-31",
          "snippet": "void setType(uint32_t adrs[8], uint32_t type){\n  adrs[3] = type;\n  int i;\n  for(i = 4; i < 8; i++){\n    adrs[i] = 0;\n  }\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setType(uint32_t adrs[8], uint32_t type){\n  adrs[3] = type;\n  int i;\n  for(i = 4; i < 8; i++){\n    adrs[i] = 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "node_addr",
            "addr",
            "12"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ltree_addr",
            "addr",
            "12"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ots_addr",
            "addr",
            "12"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic char bds_state_update(bds_state *state, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, const uint32_t addr[8]) {\n  uint32_t ltree_addr[8];\n  uint32_t node_addr[8];\n  uint32_t ots_addr[8];\n\n  int n = params->n;\n  int h = params->h;\n  int k = params->k;\n\n  int nodeh;\n  int idx = state->next_leaf;\n  if (idx == 1 << h) {\n    return 1;\n  }\n\n  // only copy layer and tree address parts\n  memcpy(ots_addr, addr, 12);\n  // type = ots\n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n  \n  setOTSADRS(ots_addr, idx);\n  setLtreeADRS(ltree_addr, idx);\n\n  gen_leaf_wots(state->stack+state->stackoffset*n, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n\n  state->stacklevels[state->stackoffset] = 0;\n  state->stackoffset++;\n  if (h - k > 0 && idx == 3) {\n    memcpy(state->treehash[0].node, state->stack+state->stackoffset*n, n);\n  }\n  while (state->stackoffset>1 && state->stacklevels[state->stackoffset-1] == state->stacklevels[state->stackoffset-2]) {\n    nodeh = state->stacklevels[state->stackoffset-1];\n    if (idx >> nodeh == 1) {\n      memcpy(state->auth + nodeh*n, state->stack+(state->stackoffset-1)*n, n);\n    }\n    else {\n      if (nodeh < h - k && idx >> nodeh == 3) {\n        memcpy(state->treehash[nodeh].node, state->stack+(state->stackoffset-1)*n, n);\n      }\n      else if (nodeh >= h - k) {\n        memcpy(state->retain + ((1 << (h - 1 - nodeh)) + nodeh - h + (((idx >> nodeh) - 3) >> 1)) * n, state->stack+(state->stackoffset-1)*n, n);\n      }\n    }\n    setTreeHeight(node_addr, state->stacklevels[state->stackoffset-1]);\n    setTreeIndex(node_addr, (idx >> (state->stacklevels[state->stackoffset-1]+1)));\n    hash_h(state->stack+(state->stackoffset-2)*n, state->stack+(state->stackoffset-2)*n, pub_seed, node_addr, n);\n\n    state->stacklevels[state->stackoffset-2]++;\n    state->stackoffset--;\n  }\n  state->next_leaf++;\n  return 0;\n}"
  },
  {
    "function_name": "bds_treehash_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "345-377",
    "snippet": "static char bds_treehash_update(bds_state *state, unsigned int updates, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, const uint32_t addr[8]) {\n  uint32_t i, j;\n  unsigned int level, l_min, low;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n  unsigned int used = 0;\n\n  for (j = 0; j < updates; j++) {\n    l_min = h;\n    level = h - k;\n    for (i = 0; i < h - k; i++) {\n      if (state->treehash[i].completed) {\n        low = h;\n      }\n      else if (state->treehash[i].stackusage == 0) {\n        low = i;\n      }\n      else {\n        low = treehash_minheight_on_stack(state, params, &(state->treehash[i]));\n      }\n      if (low < l_min) {\n        level = i;\n        l_min = low;\n      }\n    }\n    if (level == h - k) {\n      break;\n    }\n    treehash_update(&(state->treehash[level]), state, sk_seed, params, pub_seed, addr);\n    used++;\n  }\n  return updates - used;\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "treehash_update",
          "args": [
            "&(state->treehash[level])",
            "state",
            "sk_seed",
            "params",
            "pub_seed",
            "addr"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "bds_treehash_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "345-377",
          "snippet": "static char bds_treehash_update(bds_state *state, unsigned int updates, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, const uint32_t addr[8]) {\n  uint32_t i, j;\n  unsigned int level, l_min, low;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n  unsigned int used = 0;\n\n  for (j = 0; j < updates; j++) {\n    l_min = h;\n    level = h - k;\n    for (i = 0; i < h - k; i++) {\n      if (state->treehash[i].completed) {\n        low = h;\n      }\n      else if (state->treehash[i].stackusage == 0) {\n        low = i;\n      }\n      else {\n        low = treehash_minheight_on_stack(state, params, &(state->treehash[i]));\n      }\n      if (low < l_min) {\n        level = i;\n        l_min = low;\n      }\n    }\n    if (level == h - k) {\n      break;\n    }\n    treehash_update(&(state->treehash[level]), state, sk_seed, params, pub_seed, addr);\n    used++;\n  }\n  return updates - used;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "treehash_minheight_on_stack",
          "args": [
            "state",
            "params",
            "&(state->treehash[i])"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "treehash_minheight_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "163-171",
          "snippet": "static int treehash_minheight_on_stack(bds_state* state, const xmss_params *params, const treehash_inst *treehash) {\n  unsigned int r = params->h, i;\n  for (i = 0; i < treehash->stackusage; i++) {\n    if (state->stacklevels[state->stackoffset - i - 1] < r) {\n      r = state->stacklevels[state->stackoffset - i - 1];\n    }\n  }\n  return r;\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic int treehash_minheight_on_stack(bds_state* state, const xmss_params *params, const treehash_inst *treehash) {\n  unsigned int r = params->h, i;\n  for (i = 0; i < treehash->stackusage; i++) {\n    if (state->stacklevels[state->stackoffset - i - 1] < r) {\n      r = state->stacklevels[state->stackoffset - i - 1];\n    }\n  }\n  return r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic char bds_treehash_update(bds_state *state, unsigned int updates, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, const uint32_t addr[8]) {\n  uint32_t i, j;\n  unsigned int level, l_min, low;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n  unsigned int used = 0;\n\n  for (j = 0; j < updates; j++) {\n    l_min = h;\n    level = h - k;\n    for (i = 0; i < h - k; i++) {\n      if (state->treehash[i].completed) {\n        low = h;\n      }\n      else if (state->treehash[i].stackusage == 0) {\n        low = i;\n      }\n      else {\n        low = treehash_minheight_on_stack(state, params, &(state->treehash[i]));\n      }\n      if (low < l_min) {\n        level = i;\n        l_min = low;\n      }\n    }\n    if (level == h - k) {\n      break;\n    }\n    treehash_update(&(state->treehash[level]), state, sk_seed, params, pub_seed, addr);\n    used++;\n  }\n  return updates - used;\n}"
  },
  {
    "function_name": "validate_authpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "296-339",
    "snippet": "static void validate_authpath(unsigned char *root, const unsigned char *leaf, unsigned long leafidx, const unsigned char *authpath, const xmss_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int n = params->n;\n\n  uint32_t i, j;\n  unsigned char buffer[2*n];\n\n  // If leafidx is odd (last bit = 1), current path element is a right child and authpath has to go to the left.\n  // Otherwise, it is the other way around\n  if (leafidx & 1) {\n    for (j = 0; j < n; j++)\n      buffer[n+j] = leaf[j];\n    for (j = 0; j < n; j++)\n      buffer[j] = authpath[j];\n  }\n  else {\n    for (j = 0; j < n; j++)\n      buffer[j] = leaf[j];\n    for (j = 0; j < n; j++)\n      buffer[n+j] = authpath[j];\n  }\n  authpath += n;\n\n  for (i=0; i < params->h-1; i++) {\n    setTreeHeight(addr, i);\n    leafidx >>= 1;\n    setTreeIndex(addr, leafidx);\n    if (leafidx&1) {\n      hash_h(buffer+n, buffer, pub_seed, addr, n);\n      for (j = 0; j < n; j++)\n        buffer[j] = authpath[j];\n    }\n    else {\n      hash_h(buffer, buffer, pub_seed, addr, n);\n      for (j = 0; j < n; j++)\n        buffer[j+n] = authpath[j];\n    }\n    authpath += n;\n  }\n  setTreeHeight(addr, (params->h-1));\n  leafidx >>= 1;\n  setTreeIndex(addr, leafidx);\n  hash_h(root, buffer, pub_seed, addr, n);\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_h",
          "args": [
            "root",
            "buffer",
            "pub_seed",
            "addr",
            "n"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "hash_h",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "94-117",
          "snippet": "int hash_h(unsigned char *out, const unsigned char *in, const unsigned char *pub_seed, uint32_t addr[8], const unsigned int n)\n{\n\n  unsigned char buf[2*n];\n  unsigned char key[n];\n  unsigned char bitmask[2*n];\n  unsigned char byte_addr[32];\n  unsigned int i;\n\n  setKeyAndMask(addr, 0);\n  addr_to_byte(byte_addr, addr);\n  prf(key, byte_addr, pub_seed, n);\n  // Use MSB order\n  setKeyAndMask(addr, 1);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask, byte_addr, pub_seed, n);\n  setKeyAndMask(addr, 2);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask+n, byte_addr, pub_seed, n);\n  for (i = 0; i < 2*n; i++) {\n    buf[i] = in[i] ^ bitmask[i];\n  }\n  return core_hash_SHA2(out, 1, key, n, buf, 2*n, n);\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint hash_h(unsigned char *out, const unsigned char *in, const unsigned char *pub_seed, uint32_t addr[8], const unsigned int n)\n{\n\n  unsigned char buf[2*n];\n  unsigned char key[n];\n  unsigned char bitmask[2*n];\n  unsigned char byte_addr[32];\n  unsigned int i;\n\n  setKeyAndMask(addr, 0);\n  addr_to_byte(byte_addr, addr);\n  prf(key, byte_addr, pub_seed, n);\n  // Use MSB order\n  setKeyAndMask(addr, 1);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask, byte_addr, pub_seed, n);\n  setKeyAndMask(addr, 2);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask+n, byte_addr, pub_seed, n);\n  for (i = 0; i < 2*n; i++) {\n    buf[i] = in[i] ^ bitmask[i];\n  }\n  return core_hash_SHA2(out, 1, key, n, buf, 2*n, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setTreeIndex",
          "args": [
            "addr",
            "leafidx"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "setTreeIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "63-65",
          "snippet": "void setTreeIndex(uint32_t adrs[8], uint32_t treeIndex){\n  adrs[6] = treeIndex;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setTreeIndex(uint32_t adrs[8], uint32_t treeIndex){\n  adrs[6] = treeIndex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setTreeHeight",
          "args": [
            "addr",
            "(params->h-1)"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "setTreeHeight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "59-61",
          "snippet": "void setTreeHeight(uint32_t adrs[8], uint32_t treeHeight){\n  adrs[5] = treeHeight;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setTreeHeight(uint32_t adrs[8], uint32_t treeHeight){\n  adrs[5] = treeHeight;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void validate_authpath(unsigned char *root, const unsigned char *leaf, unsigned long leafidx, const unsigned char *authpath, const xmss_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int n = params->n;\n\n  uint32_t i, j;\n  unsigned char buffer[2*n];\n\n  // If leafidx is odd (last bit = 1), current path element is a right child and authpath has to go to the left.\n  // Otherwise, it is the other way around\n  if (leafidx & 1) {\n    for (j = 0; j < n; j++)\n      buffer[n+j] = leaf[j];\n    for (j = 0; j < n; j++)\n      buffer[j] = authpath[j];\n  }\n  else {\n    for (j = 0; j < n; j++)\n      buffer[j] = leaf[j];\n    for (j = 0; j < n; j++)\n      buffer[n+j] = authpath[j];\n  }\n  authpath += n;\n\n  for (i=0; i < params->h-1; i++) {\n    setTreeHeight(addr, i);\n    leafidx >>= 1;\n    setTreeIndex(addr, leafidx);\n    if (leafidx&1) {\n      hash_h(buffer+n, buffer, pub_seed, addr, n);\n      for (j = 0; j < n; j++)\n        buffer[j] = authpath[j];\n    }\n    else {\n      hash_h(buffer, buffer, pub_seed, addr, n);\n      for (j = 0; j < n; j++)\n        buffer[j+n] = authpath[j];\n    }\n    authpath += n;\n  }\n  setTreeHeight(addr, (params->h-1));\n  leafidx >>= 1;\n  setTreeIndex(addr, leafidx);\n  hash_h(root, buffer, pub_seed, addr, n);\n}"
  },
  {
    "function_name": "treehash_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "249-291",
    "snippet": "static void treehash_update(treehash_inst *treehash, bds_state *state, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, const uint32_t addr[8]) {\n  int n = params->n;\n\n  uint32_t ots_addr[8];\n  uint32_t ltree_addr[8];\n  uint32_t  node_addr[8];\n  // only copy layer and tree address parts\n  memcpy(ots_addr, addr, 12);\n  // type = ots\n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n\n  setLtreeADRS(ltree_addr, treehash->next_idx);\n  setOTSADRS(ots_addr, treehash->next_idx);\n\n  unsigned char nodebuffer[2 * n];\n  unsigned int nodeheight = 0;\n  gen_leaf_wots(nodebuffer, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n  while (treehash->stackusage > 0 && state->stacklevels[state->stackoffset-1] == nodeheight) {\n    memcpy(nodebuffer + n, nodebuffer, n);\n    memcpy(nodebuffer, state->stack + (state->stackoffset-1)*n, n);\n    setTreeHeight(node_addr, nodeheight);\n    setTreeIndex(node_addr, (treehash->next_idx >> (nodeheight+1)));\n    hash_h(nodebuffer, nodebuffer, pub_seed, node_addr, n);\n    nodeheight++;\n    treehash->stackusage--;\n    state->stackoffset--;\n  }\n  if (nodeheight == treehash->h) { // this also implies stackusage == 0\n    memcpy(treehash->node, nodebuffer, n);\n    treehash->completed = 1;\n  }\n  else {\n    memcpy(state->stack + state->stackoffset*n, nodebuffer, n);\n    treehash->stackusage++;\n    state->stacklevels[state->stackoffset] = nodeheight;\n    state->stackoffset++;\n    treehash->next_idx++;\n  }\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "state->stack + state->stackoffset*n",
            "nodebuffer",
            "n"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "treehash->node",
            "nodebuffer",
            "n"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_h",
          "args": [
            "nodebuffer",
            "nodebuffer",
            "pub_seed",
            "node_addr",
            "n"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "hash_h",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "94-117",
          "snippet": "int hash_h(unsigned char *out, const unsigned char *in, const unsigned char *pub_seed, uint32_t addr[8], const unsigned int n)\n{\n\n  unsigned char buf[2*n];\n  unsigned char key[n];\n  unsigned char bitmask[2*n];\n  unsigned char byte_addr[32];\n  unsigned int i;\n\n  setKeyAndMask(addr, 0);\n  addr_to_byte(byte_addr, addr);\n  prf(key, byte_addr, pub_seed, n);\n  // Use MSB order\n  setKeyAndMask(addr, 1);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask, byte_addr, pub_seed, n);\n  setKeyAndMask(addr, 2);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask+n, byte_addr, pub_seed, n);\n  for (i = 0; i < 2*n; i++) {\n    buf[i] = in[i] ^ bitmask[i];\n  }\n  return core_hash_SHA2(out, 1, key, n, buf, 2*n, n);\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint hash_h(unsigned char *out, const unsigned char *in, const unsigned char *pub_seed, uint32_t addr[8], const unsigned int n)\n{\n\n  unsigned char buf[2*n];\n  unsigned char key[n];\n  unsigned char bitmask[2*n];\n  unsigned char byte_addr[32];\n  unsigned int i;\n\n  setKeyAndMask(addr, 0);\n  addr_to_byte(byte_addr, addr);\n  prf(key, byte_addr, pub_seed, n);\n  // Use MSB order\n  setKeyAndMask(addr, 1);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask, byte_addr, pub_seed, n);\n  setKeyAndMask(addr, 2);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask+n, byte_addr, pub_seed, n);\n  for (i = 0; i < 2*n; i++) {\n    buf[i] = in[i] ^ bitmask[i];\n  }\n  return core_hash_SHA2(out, 1, key, n, buf, 2*n, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setTreeIndex",
          "args": [
            "node_addr",
            "(treehash->next_idx >> (nodeheight+1))"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "setTreeIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "63-65",
          "snippet": "void setTreeIndex(uint32_t adrs[8], uint32_t treeIndex){\n  adrs[6] = treeIndex;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setTreeIndex(uint32_t adrs[8], uint32_t treeIndex){\n  adrs[6] = treeIndex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setTreeHeight",
          "args": [
            "node_addr",
            "nodeheight"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "setTreeHeight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "59-61",
          "snippet": "void setTreeHeight(uint32_t adrs[8], uint32_t treeHeight){\n  adrs[5] = treeHeight;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setTreeHeight(uint32_t adrs[8], uint32_t treeHeight){\n  adrs[5] = treeHeight;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nodebuffer",
            "state->stack + (state->stackoffset-1)*n",
            "n"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nodebuffer + n",
            "nodebuffer",
            "n"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_leaf_wots",
          "args": [
            "nodebuffer",
            "sk_seed",
            "params",
            "pub_seed",
            "ltree_addr",
            "ots_addr"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "gen_leaf_wots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "152-161",
          "snippet": "static void gen_leaf_wots(unsigned char *leaf, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, uint32_t ltree_addr[8], uint32_t ots_addr[8])\n{\n  unsigned char seed[params->n];\n  unsigned char pk[params->wots_par.keysize];\n\n  get_seed(seed, sk_seed, params->n, ots_addr);\n  wots_pkgen(pk, seed, &(params->wots_par), pub_seed, ots_addr);\n\n  l_tree(leaf, pk, params, pub_seed, ltree_addr);\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void gen_leaf_wots(unsigned char *leaf, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, uint32_t ltree_addr[8], uint32_t ots_addr[8])\n{\n  unsigned char seed[params->n];\n  unsigned char pk[params->wots_par.keysize];\n\n  get_seed(seed, sk_seed, params->n, ots_addr);\n  wots_pkgen(pk, seed, &(params->wots_par), pub_seed, ots_addr);\n\n  l_tree(leaf, pk, params, pub_seed, ltree_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setOTSADRS",
          "args": [
            "ots_addr",
            "treehash->next_idx"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "setOTSADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "39-41",
          "snippet": "void setOTSADRS(uint32_t adrs[8], uint32_t ots){\n  adrs[4] = ots;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setOTSADRS(uint32_t adrs[8], uint32_t ots){\n  adrs[4] = ots;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setLtreeADRS",
          "args": [
            "ltree_addr",
            "treehash->next_idx"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "setLtreeADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "53-55",
          "snippet": "void setLtreeADRS(uint32_t adrs[8], uint32_t ltree){\n  adrs[4] = ltree;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setLtreeADRS(uint32_t adrs[8], uint32_t ltree){\n  adrs[4] = ltree;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setType",
          "args": [
            "node_addr",
            "2"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "setType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "25-31",
          "snippet": "void setType(uint32_t adrs[8], uint32_t type){\n  adrs[3] = type;\n  int i;\n  for(i = 4; i < 8; i++){\n    adrs[i] = 0;\n  }\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setType(uint32_t adrs[8], uint32_t type){\n  adrs[3] = type;\n  int i;\n  for(i = 4; i < 8; i++){\n    adrs[i] = 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "node_addr",
            "addr",
            "12"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ltree_addr",
            "addr",
            "12"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ots_addr",
            "addr",
            "12"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void treehash_update(treehash_inst *treehash, bds_state *state, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, const uint32_t addr[8]) {\n  int n = params->n;\n\n  uint32_t ots_addr[8];\n  uint32_t ltree_addr[8];\n  uint32_t  node_addr[8];\n  // only copy layer and tree address parts\n  memcpy(ots_addr, addr, 12);\n  // type = ots\n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n\n  setLtreeADRS(ltree_addr, treehash->next_idx);\n  setOTSADRS(ots_addr, treehash->next_idx);\n\n  unsigned char nodebuffer[2 * n];\n  unsigned int nodeheight = 0;\n  gen_leaf_wots(nodebuffer, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n  while (treehash->stackusage > 0 && state->stacklevels[state->stackoffset-1] == nodeheight) {\n    memcpy(nodebuffer + n, nodebuffer, n);\n    memcpy(nodebuffer, state->stack + (state->stackoffset-1)*n, n);\n    setTreeHeight(node_addr, nodeheight);\n    setTreeIndex(node_addr, (treehash->next_idx >> (nodeheight+1)));\n    hash_h(nodebuffer, nodebuffer, pub_seed, node_addr, n);\n    nodeheight++;\n    treehash->stackusage--;\n    state->stackoffset--;\n  }\n  if (nodeheight == treehash->h) { // this also implies stackusage == 0\n    memcpy(treehash->node, nodebuffer, n);\n    treehash->completed = 1;\n  }\n  else {\n    memcpy(state->stack + state->stackoffset*n, nodebuffer, n);\n    treehash->stackusage++;\n    state->stacklevels[state->stackoffset] = nodeheight;\n    state->stackoffset++;\n    treehash->next_idx++;\n  }\n}"
  },
  {
    "function_name": "treehash_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "178-247",
    "snippet": "static void treehash_setup(unsigned char *node, int height, int index, bds_state *state, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, const uint32_t addr[8])\n{\n  unsigned int idx = index;\n  unsigned int n = params->n;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n  // use three different addresses because at this point we use all three formats in parallel\n  uint32_t ots_addr[8];\n  uint32_t ltree_addr[8];\n  uint32_t  node_addr[8];\n  // only copy layer and tree address parts\n  memcpy(ots_addr, addr, 12);\n  // type = ots\n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n\n  uint32_t lastnode, i;\n  unsigned char stack[(height+1)*n];\n  unsigned int stacklevels[height+1];\n  unsigned int stackoffset=0;\n  unsigned int nodeh;\n\n  lastnode = idx+(1<<height);\n\n  for (i = 0; i < h-k; i++) {\n    state->treehash[i].h = i;\n    state->treehash[i].completed = 1;\n    state->treehash[i].stackusage = 0;\n  }\n\n  i = 0;\n  for (; idx < lastnode; idx++) {\n    setLtreeADRS(ltree_addr, idx);\n    setOTSADRS(ots_addr, idx);\n    gen_leaf_wots(stack+stackoffset*n, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n    stacklevels[stackoffset] = 0;\n    stackoffset++;\n    if (h - k > 0 && i == 3) {\n      memcpy(state->treehash[0].node, stack+stackoffset*n, n);\n    }\n    while (stackoffset>1 && stacklevels[stackoffset-1] == stacklevels[stackoffset-2])\n    {\n      nodeh = stacklevels[stackoffset-1];\n      if (i >> nodeh == 1) {\n        memcpy(state->auth + nodeh*n, stack+(stackoffset-1)*n, n);\n      }\n      else {\n        if (nodeh < h - k && i >> nodeh == 3) {\n          memcpy(state->treehash[nodeh].node, stack+(stackoffset-1)*n, n);\n        }\n        else if (nodeh >= h - k) {\n          memcpy(state->retain + ((1 << (h - 1 - nodeh)) + nodeh - h + (((i >> nodeh) - 3) >> 1)) * n, stack+(stackoffset-1)*n, n);\n        }\n      }\n      setTreeHeight(node_addr, stacklevels[stackoffset-1]);\n      setTreeIndex(node_addr, (idx >> (stacklevels[stackoffset-1]+1)));\n      hash_h(stack+(stackoffset-2)*n, stack+(stackoffset-2)*n, pub_seed,\n          node_addr, n);\n      stacklevels[stackoffset-2]++;\n      stackoffset--;\n    }\n    i++;\n  }\n\n  for (i = 0; i < n; i++)\n    node[i] = stack[i];\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_h",
          "args": [
            "stack+(stackoffset-2)*n",
            "stack+(stackoffset-2)*n",
            "pub_seed",
            "node_addr",
            "n"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "hash_h",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "94-117",
          "snippet": "int hash_h(unsigned char *out, const unsigned char *in, const unsigned char *pub_seed, uint32_t addr[8], const unsigned int n)\n{\n\n  unsigned char buf[2*n];\n  unsigned char key[n];\n  unsigned char bitmask[2*n];\n  unsigned char byte_addr[32];\n  unsigned int i;\n\n  setKeyAndMask(addr, 0);\n  addr_to_byte(byte_addr, addr);\n  prf(key, byte_addr, pub_seed, n);\n  // Use MSB order\n  setKeyAndMask(addr, 1);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask, byte_addr, pub_seed, n);\n  setKeyAndMask(addr, 2);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask+n, byte_addr, pub_seed, n);\n  for (i = 0; i < 2*n; i++) {\n    buf[i] = in[i] ^ bitmask[i];\n  }\n  return core_hash_SHA2(out, 1, key, n, buf, 2*n, n);\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint hash_h(unsigned char *out, const unsigned char *in, const unsigned char *pub_seed, uint32_t addr[8], const unsigned int n)\n{\n\n  unsigned char buf[2*n];\n  unsigned char key[n];\n  unsigned char bitmask[2*n];\n  unsigned char byte_addr[32];\n  unsigned int i;\n\n  setKeyAndMask(addr, 0);\n  addr_to_byte(byte_addr, addr);\n  prf(key, byte_addr, pub_seed, n);\n  // Use MSB order\n  setKeyAndMask(addr, 1);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask, byte_addr, pub_seed, n);\n  setKeyAndMask(addr, 2);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask+n, byte_addr, pub_seed, n);\n  for (i = 0; i < 2*n; i++) {\n    buf[i] = in[i] ^ bitmask[i];\n  }\n  return core_hash_SHA2(out, 1, key, n, buf, 2*n, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setTreeIndex",
          "args": [
            "node_addr",
            "(idx >> (stacklevels[stackoffset-1]+1))"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "setTreeIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "63-65",
          "snippet": "void setTreeIndex(uint32_t adrs[8], uint32_t treeIndex){\n  adrs[6] = treeIndex;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setTreeIndex(uint32_t adrs[8], uint32_t treeIndex){\n  adrs[6] = treeIndex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setTreeHeight",
          "args": [
            "node_addr",
            "stacklevels[stackoffset-1]"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "setTreeHeight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "59-61",
          "snippet": "void setTreeHeight(uint32_t adrs[8], uint32_t treeHeight){\n  adrs[5] = treeHeight;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setTreeHeight(uint32_t adrs[8], uint32_t treeHeight){\n  adrs[5] = treeHeight;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "state->retain + ((1 << (h - 1 - nodeh)) + nodeh - h + (((i >> nodeh) - 3) >> 1)) * n",
            "stack+(stackoffset-1)*n",
            "n"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "state->treehash[nodeh].node",
            "stack+(stackoffset-1)*n",
            "n"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "state->auth + nodeh*n",
            "stack+(stackoffset-1)*n",
            "n"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "state->treehash[0].node",
            "stack+stackoffset*n",
            "n"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_leaf_wots",
          "args": [
            "stack+stackoffset*n",
            "sk_seed",
            "params",
            "pub_seed",
            "ltree_addr",
            "ots_addr"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "gen_leaf_wots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "152-161",
          "snippet": "static void gen_leaf_wots(unsigned char *leaf, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, uint32_t ltree_addr[8], uint32_t ots_addr[8])\n{\n  unsigned char seed[params->n];\n  unsigned char pk[params->wots_par.keysize];\n\n  get_seed(seed, sk_seed, params->n, ots_addr);\n  wots_pkgen(pk, seed, &(params->wots_par), pub_seed, ots_addr);\n\n  l_tree(leaf, pk, params, pub_seed, ltree_addr);\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void gen_leaf_wots(unsigned char *leaf, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, uint32_t ltree_addr[8], uint32_t ots_addr[8])\n{\n  unsigned char seed[params->n];\n  unsigned char pk[params->wots_par.keysize];\n\n  get_seed(seed, sk_seed, params->n, ots_addr);\n  wots_pkgen(pk, seed, &(params->wots_par), pub_seed, ots_addr);\n\n  l_tree(leaf, pk, params, pub_seed, ltree_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setOTSADRS",
          "args": [
            "ots_addr",
            "idx"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "setOTSADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "39-41",
          "snippet": "void setOTSADRS(uint32_t adrs[8], uint32_t ots){\n  adrs[4] = ots;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setOTSADRS(uint32_t adrs[8], uint32_t ots){\n  adrs[4] = ots;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setLtreeADRS",
          "args": [
            "ltree_addr",
            "idx"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "setLtreeADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "53-55",
          "snippet": "void setLtreeADRS(uint32_t adrs[8], uint32_t ltree){\n  adrs[4] = ltree;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setLtreeADRS(uint32_t adrs[8], uint32_t ltree){\n  adrs[4] = ltree;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setType",
          "args": [
            "node_addr",
            "2"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "setType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "25-31",
          "snippet": "void setType(uint32_t adrs[8], uint32_t type){\n  adrs[3] = type;\n  int i;\n  for(i = 4; i < 8; i++){\n    adrs[i] = 0;\n  }\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setType(uint32_t adrs[8], uint32_t type){\n  adrs[3] = type;\n  int i;\n  for(i = 4; i < 8; i++){\n    adrs[i] = 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "node_addr",
            "addr",
            "12"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ltree_addr",
            "addr",
            "12"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ots_addr",
            "addr",
            "12"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void treehash_setup(unsigned char *node, int height, int index, bds_state *state, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, const uint32_t addr[8])\n{\n  unsigned int idx = index;\n  unsigned int n = params->n;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n  // use three different addresses because at this point we use all three formats in parallel\n  uint32_t ots_addr[8];\n  uint32_t ltree_addr[8];\n  uint32_t  node_addr[8];\n  // only copy layer and tree address parts\n  memcpy(ots_addr, addr, 12);\n  // type = ots\n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n\n  uint32_t lastnode, i;\n  unsigned char stack[(height+1)*n];\n  unsigned int stacklevels[height+1];\n  unsigned int stackoffset=0;\n  unsigned int nodeh;\n\n  lastnode = idx+(1<<height);\n\n  for (i = 0; i < h-k; i++) {\n    state->treehash[i].h = i;\n    state->treehash[i].completed = 1;\n    state->treehash[i].stackusage = 0;\n  }\n\n  i = 0;\n  for (; idx < lastnode; idx++) {\n    setLtreeADRS(ltree_addr, idx);\n    setOTSADRS(ots_addr, idx);\n    gen_leaf_wots(stack+stackoffset*n, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n    stacklevels[stackoffset] = 0;\n    stackoffset++;\n    if (h - k > 0 && i == 3) {\n      memcpy(state->treehash[0].node, stack+stackoffset*n, n);\n    }\n    while (stackoffset>1 && stacklevels[stackoffset-1] == stacklevels[stackoffset-2])\n    {\n      nodeh = stacklevels[stackoffset-1];\n      if (i >> nodeh == 1) {\n        memcpy(state->auth + nodeh*n, stack+(stackoffset-1)*n, n);\n      }\n      else {\n        if (nodeh < h - k && i >> nodeh == 3) {\n          memcpy(state->treehash[nodeh].node, stack+(stackoffset-1)*n, n);\n        }\n        else if (nodeh >= h - k) {\n          memcpy(state->retain + ((1 << (h - 1 - nodeh)) + nodeh - h + (((i >> nodeh) - 3) >> 1)) * n, stack+(stackoffset-1)*n, n);\n        }\n      }\n      setTreeHeight(node_addr, stacklevels[stackoffset-1]);\n      setTreeIndex(node_addr, (idx >> (stacklevels[stackoffset-1]+1)));\n      hash_h(stack+(stackoffset-2)*n, stack+(stackoffset-2)*n, pub_seed,\n          node_addr, n);\n      stacklevels[stackoffset-2]++;\n      stackoffset--;\n    }\n    i++;\n  }\n\n  for (i = 0; i < n; i++)\n    node[i] = stack[i];\n}"
  },
  {
    "function_name": "treehash_minheight_on_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "163-171",
    "snippet": "static int treehash_minheight_on_stack(bds_state* state, const xmss_params *params, const treehash_inst *treehash) {\n  unsigned int r = params->h, i;\n  for (i = 0; i < treehash->stackusage; i++) {\n    if (state->stacklevels[state->stackoffset - i - 1] < r) {\n      r = state->stacklevels[state->stackoffset - i - 1];\n    }\n  }\n  return r;\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic int treehash_minheight_on_stack(bds_state* state, const xmss_params *params, const treehash_inst *treehash) {\n  unsigned int r = params->h, i;\n  for (i = 0; i < treehash->stackusage; i++) {\n    if (state->stacklevels[state->stackoffset - i - 1] < r) {\n      r = state->stacklevels[state->stackoffset - i - 1];\n    }\n  }\n  return r;\n}"
  },
  {
    "function_name": "gen_leaf_wots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "152-161",
    "snippet": "static void gen_leaf_wots(unsigned char *leaf, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, uint32_t ltree_addr[8], uint32_t ots_addr[8])\n{\n  unsigned char seed[params->n];\n  unsigned char pk[params->wots_par.keysize];\n\n  get_seed(seed, sk_seed, params->n, ots_addr);\n  wots_pkgen(pk, seed, &(params->wots_par), pub_seed, ots_addr);\n\n  l_tree(leaf, pk, params, pub_seed, ltree_addr);\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "l_tree",
          "args": [
            "leaf",
            "pk",
            "params",
            "pub_seed",
            "ltree_addr"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "l_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "111-147",
          "snippet": "static void l_tree(unsigned char *leaf, unsigned char *wots_pk, const xmss_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int l = params->wots_par.len;\n  unsigned int n = params->n;\n  uint32_t i = 0;\n  uint32_t height = 0;\n  uint32_t bound;\n\n  //ADRS.setTreeHeight(0);\n  setTreeHeight(addr, height);\n  \n  while (l > 1) {\n     bound = l >> 1; //floor(l / 2);\n     for (i = 0; i < bound; i++) {\n       //ADRS.setTreeIndex(i);\n       setTreeIndex(addr, i);\n       //wots_pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n       hash_h(wots_pk+i*n, wots_pk+i*2*n, pub_seed, addr, n);\n     }\n     //if ( l % 2 == 1 ) {\n     if (l & 1) {\n       //pk[floor(l / 2) + 1] = pk[l];\n       memcpy(wots_pk+(l>>1)*n, wots_pk+(l-1)*n, n);\n       //l = ceil(l / 2);\n       l=(l>>1)+1;\n     }\n     else {\n       //l = ceil(l / 2);\n       l=(l>>1);\n     }\n     //ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     height++;\n     setTreeHeight(addr, height);\n   }\n   //return pk[0];\n   memcpy(leaf, wots_pk, n);\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void l_tree(unsigned char *leaf, unsigned char *wots_pk, const xmss_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int l = params->wots_par.len;\n  unsigned int n = params->n;\n  uint32_t i = 0;\n  uint32_t height = 0;\n  uint32_t bound;\n\n  //ADRS.setTreeHeight(0);\n  setTreeHeight(addr, height);\n  \n  while (l > 1) {\n     bound = l >> 1; //floor(l / 2);\n     for (i = 0; i < bound; i++) {\n       //ADRS.setTreeIndex(i);\n       setTreeIndex(addr, i);\n       //wots_pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n       hash_h(wots_pk+i*n, wots_pk+i*2*n, pub_seed, addr, n);\n     }\n     //if ( l % 2 == 1 ) {\n     if (l & 1) {\n       //pk[floor(l / 2) + 1] = pk[l];\n       memcpy(wots_pk+(l>>1)*n, wots_pk+(l-1)*n, n);\n       //l = ceil(l / 2);\n       l=(l>>1)+1;\n     }\n     else {\n       //l = ceil(l / 2);\n       l=(l>>1);\n     }\n     //ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     height++;\n     setTreeHeight(addr, height);\n   }\n   //return pk[0];\n   memcpy(leaf, wots_pk, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wots_pkgen",
          "args": [
            "pk",
            "seed",
            "&(params->wots_par)",
            "pub_seed",
            "ots_addr"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "wots_pkgen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_wots.c",
          "lines": "108-116",
          "snippet": "void wots_pkgen(unsigned char *pk, const unsigned char *sk, const wots_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  uint32_t i;\n  expand_seed(pk, sk, params);\n  for (i=0; i < params->len; i++) {\n    setChainADRS(addr, i);\n    gen_chain(pk+i*params->n, pk+i*params->n, 0, params->w-1, params, pub_seed, addr);\n  }\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include <limits.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\n#include \"xmss_wots.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid wots_pkgen(unsigned char *pk, const unsigned char *sk, const wots_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  uint32_t i;\n  expand_seed(pk, sk, params);\n  for (i=0; i < params->len; i++) {\n    setChainADRS(addr, i);\n    gen_chain(pk+i*params->n, pk+i*params->n, 0, params->w-1, params, pub_seed, addr);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seed",
          "args": [
            "seed",
            "sk_seed",
            "params->n",
            "ots_addr"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "get_seed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "36-46",
          "snippet": "static void get_seed(unsigned char *seed, const unsigned char *sk_seed, int n, uint32_t addr[8])\n{\n  unsigned char bytes[32];\n  // Make sure that chain addr, hash addr, and key bit are 0!\n  setChainADRS(addr,0);\n  setHashADRS(addr,0);\n  setKeyAndMask(addr,0);\n  // Generate pseudorandom value\n  addr_to_byte(bytes, addr);\n  prf(seed, bytes, sk_seed, n);\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void get_seed(unsigned char *seed, const unsigned char *sk_seed, int n, uint32_t addr[8])\n{\n  unsigned char bytes[32];\n  // Make sure that chain addr, hash addr, and key bit are 0!\n  setChainADRS(addr,0);\n  setHashADRS(addr,0);\n  setKeyAndMask(addr,0);\n  // Generate pseudorandom value\n  addr_to_byte(bytes, addr);\n  prf(seed, bytes, sk_seed, n);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void gen_leaf_wots(unsigned char *leaf, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, uint32_t ltree_addr[8], uint32_t ots_addr[8])\n{\n  unsigned char seed[params->n];\n  unsigned char pk[params->wots_par.keysize];\n\n  get_seed(seed, sk_seed, params->n, ots_addr);\n  wots_pkgen(pk, seed, &(params->wots_par), pub_seed, ots_addr);\n\n  l_tree(leaf, pk, params, pub_seed, ltree_addr);\n}"
  },
  {
    "function_name": "l_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "111-147",
    "snippet": "static void l_tree(unsigned char *leaf, unsigned char *wots_pk, const xmss_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int l = params->wots_par.len;\n  unsigned int n = params->n;\n  uint32_t i = 0;\n  uint32_t height = 0;\n  uint32_t bound;\n\n  //ADRS.setTreeHeight(0);\n  setTreeHeight(addr, height);\n  \n  while (l > 1) {\n     bound = l >> 1; //floor(l / 2);\n     for (i = 0; i < bound; i++) {\n       //ADRS.setTreeIndex(i);\n       setTreeIndex(addr, i);\n       //wots_pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n       hash_h(wots_pk+i*n, wots_pk+i*2*n, pub_seed, addr, n);\n     }\n     //if ( l % 2 == 1 ) {\n     if (l & 1) {\n       //pk[floor(l / 2) + 1] = pk[l];\n       memcpy(wots_pk+(l>>1)*n, wots_pk+(l-1)*n, n);\n       //l = ceil(l / 2);\n       l=(l>>1)+1;\n     }\n     else {\n       //l = ceil(l / 2);\n       l=(l>>1);\n     }\n     //ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     height++;\n     setTreeHeight(addr, height);\n   }\n   //return pk[0];\n   memcpy(leaf, wots_pk, n);\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "leaf",
            "wots_pk",
            "n"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setTreeHeight",
          "args": [
            "addr",
            "height"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "setTreeHeight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "59-61",
          "snippet": "void setTreeHeight(uint32_t adrs[8], uint32_t treeHeight){\n  adrs[5] = treeHeight;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setTreeHeight(uint32_t adrs[8], uint32_t treeHeight){\n  adrs[5] = treeHeight;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "wots_pk+(l>>1)*n",
            "wots_pk+(l-1)*n",
            "n"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_h",
          "args": [
            "wots_pk+i*n",
            "wots_pk+i*2*n",
            "pub_seed",
            "addr",
            "n"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "hash_h",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "94-117",
          "snippet": "int hash_h(unsigned char *out, const unsigned char *in, const unsigned char *pub_seed, uint32_t addr[8], const unsigned int n)\n{\n\n  unsigned char buf[2*n];\n  unsigned char key[n];\n  unsigned char bitmask[2*n];\n  unsigned char byte_addr[32];\n  unsigned int i;\n\n  setKeyAndMask(addr, 0);\n  addr_to_byte(byte_addr, addr);\n  prf(key, byte_addr, pub_seed, n);\n  // Use MSB order\n  setKeyAndMask(addr, 1);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask, byte_addr, pub_seed, n);\n  setKeyAndMask(addr, 2);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask+n, byte_addr, pub_seed, n);\n  for (i = 0; i < 2*n; i++) {\n    buf[i] = in[i] ^ bitmask[i];\n  }\n  return core_hash_SHA2(out, 1, key, n, buf, 2*n, n);\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint hash_h(unsigned char *out, const unsigned char *in, const unsigned char *pub_seed, uint32_t addr[8], const unsigned int n)\n{\n\n  unsigned char buf[2*n];\n  unsigned char key[n];\n  unsigned char bitmask[2*n];\n  unsigned char byte_addr[32];\n  unsigned int i;\n\n  setKeyAndMask(addr, 0);\n  addr_to_byte(byte_addr, addr);\n  prf(key, byte_addr, pub_seed, n);\n  // Use MSB order\n  setKeyAndMask(addr, 1);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask, byte_addr, pub_seed, n);\n  setKeyAndMask(addr, 2);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask+n, byte_addr, pub_seed, n);\n  for (i = 0; i < 2*n; i++) {\n    buf[i] = in[i] ^ bitmask[i];\n  }\n  return core_hash_SHA2(out, 1, key, n, buf, 2*n, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setTreeIndex",
          "args": [
            "addr",
            "i"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "setTreeIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "63-65",
          "snippet": "void setTreeIndex(uint32_t adrs[8], uint32_t treeIndex){\n  adrs[6] = treeIndex;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setTreeIndex(uint32_t adrs[8], uint32_t treeIndex){\n  adrs[6] = treeIndex;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void l_tree(unsigned char *leaf, unsigned char *wots_pk, const xmss_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int l = params->wots_par.len;\n  unsigned int n = params->n;\n  uint32_t i = 0;\n  uint32_t height = 0;\n  uint32_t bound;\n\n  //ADRS.setTreeHeight(0);\n  setTreeHeight(addr, height);\n  \n  while (l > 1) {\n     bound = l >> 1; //floor(l / 2);\n     for (i = 0; i < bound; i++) {\n       //ADRS.setTreeIndex(i);\n       setTreeIndex(addr, i);\n       //wots_pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n       hash_h(wots_pk+i*n, wots_pk+i*2*n, pub_seed, addr, n);\n     }\n     //if ( l % 2 == 1 ) {\n     if (l & 1) {\n       //pk[floor(l / 2) + 1] = pk[l];\n       memcpy(wots_pk+(l>>1)*n, wots_pk+(l-1)*n, n);\n       //l = ceil(l / 2);\n       l=(l>>1)+1;\n     }\n     else {\n       //l = ceil(l / 2);\n       l=(l>>1);\n     }\n     //ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     height++;\n     setTreeHeight(addr, height);\n   }\n   //return pk[0];\n   memcpy(leaf, wots_pk, n);\n}"
  },
  {
    "function_name": "xmssmt_set_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "90-106",
    "snippet": "int xmssmt_set_params(xmssmt_params *params, int n, int h, int d, int w, int k)\n{\n  if (h % d) {\n    fprintf(stderr, \"d must divide h without remainder!\\n\");\n    return 1;\n  }\n  params->h = h;\n  params->d = d;\n  params->n = n;\n  params->index_len = (h + 7) / 8;\n  xmss_params xmss_par;\n  if (xmss_set_params(&xmss_par, n, (h/d), w, k)) {\n    return 1;\n  }\n  params->xmss_par = xmss_par;\n  return 0;\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmss_set_params",
          "args": [
            "&xmss_par",
            "n",
            "(h/d)",
            "w",
            "k"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "xmss_set_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "53-66",
          "snippet": "int xmss_set_params(xmss_params *params, int n, int h, int w, int k)\n{\n  if (k >= h || k < 2 || (h - k) % 2) {\n    fprintf(stderr, \"For BDS traversal, H - K must be even, with H > K >= 2!\\n\");\n    return 1;\n  }\n  params->h = h;\n  params->n = n;\n  params->k = k;\n  wots_params wots_par;\n  wots_set_params(&wots_par, n, w);\n  params->wots_par = wots_par;\n  return 0;\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint xmss_set_params(xmss_params *params, int n, int h, int w, int k)\n{\n  if (k >= h || k < 2 || (h - k) % 2) {\n    fprintf(stderr, \"For BDS traversal, H - K must be even, with H > K >= 2!\\n\");\n    return 1;\n  }\n  params->h = h;\n  params->n = n;\n  params->k = k;\n  wots_params wots_par;\n  wots_set_params(&wots_par, n, w);\n  params->wots_par = wots_par;\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"d must divide h without remainder!\\n\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint xmssmt_set_params(xmssmt_params *params, int n, int h, int d, int w, int k)\n{\n  if (h % d) {\n    fprintf(stderr, \"d must divide h without remainder!\\n\");\n    return 1;\n  }\n  params->h = h;\n  params->d = d;\n  params->n = n;\n  params->index_len = (h + 7) / 8;\n  xmss_params xmss_par;\n  if (xmss_set_params(&xmss_par, n, (h/d), w, k)) {\n    return 1;\n  }\n  params->xmss_par = xmss_par;\n  return 0;\n}"
  },
  {
    "function_name": "xmss_set_bds_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "72-82",
    "snippet": "void xmss_set_bds_state(bds_state *state, unsigned char *stack, int stackoffset, unsigned char *stacklevels, unsigned char *auth, unsigned char *keep, treehash_inst *treehash, unsigned char *retain, int next_leaf)\n{\n  state->stack = stack;\n  state->stackoffset = stackoffset;\n  state->stacklevels = stacklevels;\n  state->auth = auth;\n  state->keep = keep;\n  state->treehash = treehash;\n  state->retain = retain;\n  state->next_leaf = next_leaf;\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid xmss_set_bds_state(bds_state *state, unsigned char *stack, int stackoffset, unsigned char *stacklevels, unsigned char *auth, unsigned char *keep, treehash_inst *treehash, unsigned char *retain, int next_leaf)\n{\n  state->stack = stack;\n  state->stackoffset = stackoffset;\n  state->stacklevels = stacklevels;\n  state->auth = auth;\n  state->keep = keep;\n  state->treehash = treehash;\n  state->retain = retain;\n  state->next_leaf = next_leaf;\n}"
  },
  {
    "function_name": "xmss_set_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "53-66",
    "snippet": "int xmss_set_params(xmss_params *params, int n, int h, int w, int k)\n{\n  if (k >= h || k < 2 || (h - k) % 2) {\n    fprintf(stderr, \"For BDS traversal, H - K must be even, with H > K >= 2!\\n\");\n    return 1;\n  }\n  params->h = h;\n  params->n = n;\n  params->k = k;\n  wots_params wots_par;\n  wots_set_params(&wots_par, n, w);\n  params->wots_par = wots_par;\n  return 0;\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wots_set_params",
          "args": [
            "&wots_par",
            "n",
            "w"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "wots_set_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_wots.c",
          "lines": "37-47",
          "snippet": "void\nwots_set_params(wots_params *params, int n, int w)\n{\n  params->n = n;\n  params->w = w;\n  params->log_w = wots_log2(params->w);\n  params->len_1 = (CHAR_BIT * n) / params->log_w;\n  params->len_2 = (wots_log2(params->len_1 * (w - 1)) / params->log_w) + 1;\n  params->len = params->len_1 + params->len_2;\n  params->keysize = params->len * params->n;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include <limits.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\n#include \"xmss_wots.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nwots_set_params(wots_params *params, int n, int w)\n{\n  params->n = n;\n  params->w = w;\n  params->log_w = wots_log2(params->w);\n  params->len_1 = (CHAR_BIT * n) / params->log_w;\n  params->len_2 = (wots_log2(params->len_1 * (w - 1)) / params->log_w) + 1;\n  params->len = params->len_1 + params->len_2;\n  params->keysize = params->len * params->n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"For BDS traversal, H - K must be even, with H > K >= 2!\\n\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint xmss_set_params(xmss_params *params, int n, int h, int w, int k)\n{\n  if (k >= h || k < 2 || (h - k) % 2) {\n    fprintf(stderr, \"For BDS traversal, H - K must be even, with H > K >= 2!\\n\");\n    return 1;\n  }\n  params->h = h;\n  params->n = n;\n  params->k = k;\n  wots_params wots_par;\n  wots_set_params(&wots_par, n, w);\n  params->wots_par = wots_par;\n  return 0;\n}"
  },
  {
    "function_name": "get_seed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
    "lines": "36-46",
    "snippet": "static void get_seed(unsigned char *seed, const unsigned char *sk_seed, int n, uint32_t addr[8])\n{\n  unsigned char bytes[32];\n  // Make sure that chain addr, hash addr, and key bit are 0!\n  setChainADRS(addr,0);\n  setHashADRS(addr,0);\n  setKeyAndMask(addr,0);\n  // Generate pseudorandom value\n  addr_to_byte(bytes, addr);\n  prf(seed, bytes, sk_seed, n);\n}",
    "includes": [
      "#include \"stdio.h\"",
      "#include \"xmss_hash_address.h\"",
      "#include \"xmss_commons.h\"",
      "#include \"xmss_hash.h\"",
      "#include \"xmss_wots.h\"",
      "#include \"crypto_api.h\"",
      "#include \"xmss_fast.h\"",
      "#include <stdint.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prf",
          "args": [
            "seed",
            "bytes",
            "sk_seed",
            "n"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "prf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "74-77",
          "snippet": "int prf(unsigned char *out, const unsigned char *in, const unsigned char *key, unsigned int keylen)\n{ \n  return core_hash_SHA2(out, 3, key, keylen, in, 32, keylen);\n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nint prf(unsigned char *out, const unsigned char *in, const unsigned char *key, unsigned int keylen)\n{ \n  return core_hash_SHA2(out, 3, key, keylen, in, 32, keylen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_to_byte",
          "args": [
            "bytes",
            "addr"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "addr_to_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash.c",
          "lines": "29-39",
          "snippet": "unsigned char* addr_to_byte(unsigned char *bytes, const uint32_t addr[8]){\n#if IS_LITTLE_ENDIAN==1 \n  int i = 0;\n  for(i=0;i<8;i++)\n    to_byte(bytes+i*4, addr[i],4);\n  return bytes;  \n#else\n  memcpy(bytes, addr, 32);\n  return bytes; \n#endif   \n}",
          "includes": [
            "#include <openssl/evp.h>",
            "#include <openssl/hmac.h>",
            "#include <openssl/sha.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include \"xmss_hash.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n#include \"includes.h\"\n\nunsigned char* addr_to_byte(unsigned char *bytes, const uint32_t addr[8]){\n#if IS_LITTLE_ENDIAN==1 \n  int i = 0;\n  for(i=0;i<8;i++)\n    to_byte(bytes+i*4, addr[i],4);\n  return bytes;  \n#else\n  memcpy(bytes, addr, 32);\n  return bytes; \n#endif   \n}"
        }
      },
      {
        "call_info": {
          "callee": "setKeyAndMask",
          "args": [
            "addr",
            "0"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "setKeyAndMask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "33-35",
          "snippet": "void setKeyAndMask(uint32_t adrs[8], uint32_t keyAndMask){\n  adrs[7] = keyAndMask;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setKeyAndMask(uint32_t adrs[8], uint32_t keyAndMask){\n  adrs[7] = keyAndMask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setHashADRS",
          "args": [
            "addr",
            "0"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "setHashADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "47-49",
          "snippet": "void setHashADRS(uint32_t adrs[8], uint32_t hash){\n  adrs[6] = hash;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setHashADRS(uint32_t adrs[8], uint32_t hash){\n  adrs[6] = hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setChainADRS",
          "args": [
            "addr",
            "0"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "setChainADRS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_hash_address.c",
          "lines": "43-45",
          "snippet": "void setChainADRS(uint32_t adrs[8], uint32_t chain){\n  adrs[5] = chain;\n}",
          "includes": [
            "#include \"xmss_hash_address.h\"\t/* prototypes */",
            "#include <stdint.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_hash_address.h\"\t/* prototypes */\n#include <stdint.h>\n#include \"includes.h\"\n\nvoid setChainADRS(uint32_t adrs[8], uint32_t chain){\n  adrs[5] = chain;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void get_seed(unsigned char *seed, const unsigned char *sk_seed, int n, uint32_t addr[8])\n{\n  unsigned char bytes[32];\n  // Make sure that chain addr, hash addr, and key bit are 0!\n  setChainADRS(addr,0);\n  setHashADRS(addr,0);\n  setKeyAndMask(addr,0);\n  // Generate pseudorandom value\n  addr_to_byte(bytes, addr);\n  prf(seed, bytes, sk_seed, n);\n}"
  }
]